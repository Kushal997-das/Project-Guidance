{"version":3,"file":"TabCompletionAction.js","sourceRoot":"","sources":["../../src/providers/TabCompletionAction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport stringArgv from 'string-argv';\n\nimport { CommandLineIntegerParameter } from '../parameters/CommandLineIntegerParameter';\nimport { CommandLineStringParameter } from '../parameters/CommandLineStringParameter';\nimport {\n  CommandLineParameterKind,\n  CommandLineParameter,\n  CommandLineParameterWithArgument\n} from '../parameters/BaseClasses';\nimport { CommandLineChoiceParameter } from '../parameters/CommandLineChoiceParameter';\nimport { CommandLineAction } from './CommandLineAction';\nimport { CommandLineConstants } from '../Constants';\n\nconst DEFAULT_WORD_TO_AUTOCOMPLETE: string = '';\nconst DEFAULT_POSITION: number = 0;\n\nexport class TabCompleteAction extends CommandLineAction {\n  private _wordToCompleteParameter!: CommandLineStringParameter;\n  private _positionParameter!: CommandLineIntegerParameter;\n  private readonly _actions: Map<string, Map<string, CommandLineParameter>>;\n  private readonly _globalParameters: Map<string, CommandLineParameter>;\n\n  public constructor(\n    actions: ReadonlyArray<CommandLineAction>,\n    globalParameters: ReadonlyArray<CommandLineParameter>\n  ) {\n    super({\n      actionName: CommandLineConstants.TabCompletionActionName,\n      summary: 'Provides tab completion.',\n      documentation: 'Provides tab completion.'\n    });\n\n    this._actions = new Map<string, Map<string, CommandLineParameter>>();\n    for (const action of actions) {\n      const parameterNameToParameterInfoMap: Map<string, CommandLineParameter> = new Map<\n        string,\n        CommandLineParameter\n      >();\n      for (const parameter of action.parameters) {\n        parameterNameToParameterInfoMap.set(parameter.longName, parameter);\n        if (parameter.shortName) {\n          parameterNameToParameterInfoMap.set(parameter.shortName, parameter);\n        }\n      }\n      this._actions.set(action.actionName, parameterNameToParameterInfoMap);\n    }\n\n    this._globalParameters = new Map<string, CommandLineParameter>();\n    for (const parameter of globalParameters) {\n      this._globalParameters.set(parameter.longName, parameter);\n      if (parameter.shortName) {\n        this._globalParameters.set(parameter.shortName, parameter);\n      }\n    }\n  }\n\n  protected onDefineParameters(): void {\n    this._wordToCompleteParameter = this.defineStringParameter({\n      parameterLongName: '--word',\n      argumentName: 'WORD',\n      description: `The word to complete.`,\n      defaultValue: DEFAULT_WORD_TO_AUTOCOMPLETE\n    });\n\n    this._positionParameter = this.defineIntegerParameter({\n      parameterLongName: '--position',\n      argumentName: 'INDEX',\n      description: `The position in the word to be completed.`,\n      defaultValue: DEFAULT_POSITION\n    });\n  }\n\n  protected async onExecute(): Promise<void> {\n    const commandLine: string = this._wordToCompleteParameter.value || '';\n    const caretPosition: number = this._positionParameter.value || (commandLine && commandLine.length) || 0;\n\n    for await (const value of this.getCompletions(commandLine, caretPosition)) {\n      console.log(value);\n    }\n  }\n\n  public async *getCompletions(\n    commandLine: string,\n    caretPosition: number = commandLine.length\n  ): AsyncIterable<string> {\n    const actions: Map<string, Map<string, CommandLineParameter>> = this._actions;\n\n    if (!commandLine || !caretPosition) {\n      yield* this._getAllActions();\n      return;\n    }\n\n    const tokens: string[] = Array.from(this.tokenizeCommandLine(commandLine));\n\n    // offset arguments by the number of global params in the input\n    const globalParameterOffset: number = this._getGlobalParameterOffset(tokens);\n\n    if (tokens.length < 2 + globalParameterOffset) {\n      yield* this._getAllActions();\n      return;\n    }\n\n    const lastToken: string = tokens[tokens.length - 1];\n    const secondLastToken: string = tokens[tokens.length - 2];\n\n    const completePartialWord: boolean = caretPosition === commandLine.length;\n\n    if (completePartialWord && tokens.length === 2 + globalParameterOffset) {\n      for (const actionName of actions.keys()) {\n        if (actionName.indexOf(tokens[1 + globalParameterOffset]) === 0) {\n          yield actionName;\n        }\n      }\n    } else {\n      for (const actionName of actions.keys()) {\n        if (actionName === tokens[1 + globalParameterOffset]) {\n          const parameterNameMap: Map<string, CommandLineParameter> = actions.get(actionName)!;\n\n          const parameterNames: string[] = Array.from(parameterNameMap.keys());\n\n          if (completePartialWord) {\n            for (const parameterName of parameterNames) {\n              if (parameterName === secondLastToken) {\n                const values: string[] = await this._getParameterValueCompletions(\n                  parameterNameMap.get(parameterName)!\n                );\n                if (values.length > 0) {\n                  yield* this._completeParameterValues(values, lastToken);\n                  return;\n                }\n              }\n            }\n            yield* this._completeParameterValues(parameterNames, lastToken);\n          } else {\n            for (const parameterName of parameterNames) {\n              if (parameterName === lastToken) {\n                const values: string[] = await this._getParameterValueCompletions(\n                  parameterNameMap.get(parameterName)!\n                );\n                if (values.length > 0) {\n                  yield* values;\n                  return;\n                }\n              }\n            }\n            for (const parameterName of parameterNames) {\n              if (\n                parameterName === lastToken &&\n                parameterNameMap.get(parameterName)!.kind !== CommandLineParameterKind.Flag\n              ) {\n                // The parameter is expecting a value, so don't suggest parameter names again\n                return;\n              }\n            }\n\n            yield* parameterNames;\n          }\n\n          break;\n        }\n      }\n    }\n  }\n\n  private *_getAllActions(): IterableIterator<string> {\n    yield* this._actions.keys();\n    yield* this._globalParameters.keys();\n  }\n\n  public tokenizeCommandLine(commandLine: string): string[] {\n    return stringArgv(commandLine);\n  }\n\n  private async _getParameterValueCompletions(parameter: CommandLineParameter): Promise<string[]> {\n    let choiceParameterValues: string[] = [];\n    if (parameter.kind === CommandLineParameterKind.Choice) {\n      choiceParameterValues = (parameter as CommandLineChoiceParameter).alternatives as string[];\n    } else if (parameter.kind !== CommandLineParameterKind.Flag) {\n      let parameterWithArgumentOrChoices:\n        | CommandLineParameterWithArgument\n        | CommandLineChoiceParameter\n        | undefined = undefined;\n      if (parameter instanceof CommandLineParameterWithArgument) {\n        parameterWithArgumentOrChoices = parameter as CommandLineParameterWithArgument;\n      } else if (parameter instanceof CommandLineChoiceParameter) {\n        parameterWithArgumentOrChoices = parameter as CommandLineChoiceParameter;\n      }\n      if (parameterWithArgumentOrChoices && parameterWithArgumentOrChoices.completions) {\n        choiceParameterValues = await parameterWithArgumentOrChoices.completions();\n      }\n    }\n\n    return choiceParameterValues;\n  }\n\n  private _getGlobalParameterOffset(tokens: string[]): number {\n    const globalParameters: Map<string, CommandLineParameter> = this._globalParameters;\n    let count: number = 0;\n\n    outer: for (let i: number = 1; i < tokens.length; i++) {\n      for (const globalParameter of globalParameters.values()) {\n        if (tokens[i] !== globalParameter.longName && tokens[i] !== globalParameter.shortName) {\n          break outer;\n        }\n      }\n      count++;\n    }\n\n    return count;\n  }\n\n  private *_completeParameterValues(\n    choiceParameterValues: string[],\n    lastToken: string\n  ): IterableIterator<string> {\n    for (const choiceParameterValue of choiceParameterValues) {\n      if (choiceParameterValue.indexOf(lastToken) === 0) {\n        yield choiceParameterValue;\n      }\n    }\n  }\n}\n"]}