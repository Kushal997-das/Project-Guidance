{"version":3,"file":"Import.js","sourceRoot":"","sources":["../src/Import.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\nimport importLazy = require('import-lazy');\nimport * as Resolve from 'resolve';\nimport nodeModule = require('module');\n\nimport { PackageJsonLookup } from './PackageJsonLookup';\nimport { FileSystem } from './FileSystem';\nimport { IPackageJson } from './IPackageJson';\n\n/**\n * Common options shared by {@link IImportResolveModuleOptions} and {@link IImportResolvePackageOptions}\n * @public\n */\nexport interface IImportResolveOptions {\n  /**\n   * The path from which {@link IImportResolveModuleOptions.modulePath} or\n   * {@link IImportResolvePackageOptions.packageName} should be resolved.\n   */\n  baseFolderPath: string;\n\n  /**\n   * If true, if the package name matches a Node.js system module, then the return\n   * value will be the package name without any path.\n   *\n   * @remarks\n   * This will take precedence over an installed NPM package of the same name.\n   *\n   * Example:\n   * ```ts\n   * // Returns the string \"fs\" indicating the Node.js system module\n   * Import.resolveModulePath({\n   *   resolvePath: \"fs\",\n   *   basePath: process.cwd()\n   * })\n   * ```\n   */\n  includeSystemModules?: boolean;\n\n  /**\n   * If true, then resolvePath is allowed to refer to the package.json of the active project.\n   *\n   * @remarks\n   * This will take precedence over any installed dependency with the same name.\n   * Note that this requires an additional PackageJsonLookup calculation.\n   *\n   * Example:\n   * ```ts\n   * // Returns an absolute path to the current package\n   * Import.resolveModulePath({\n   *   resolvePath: \"current-project\",\n   *   basePath: process.cwd(),\n   *   allowSelfReference: true\n   * })\n   * ```\n   */\n  allowSelfReference?: boolean;\n}\n\n/**\n * Options for {@link Import.resolveModule}\n * @public\n */\nexport interface IImportResolveModuleOptions extends IImportResolveOptions {\n  /**\n   * The module identifier to resolve. For example \"\\@rushstack/node-core-library\" or\n   * \"\\@rushstack/node-core-library/lib/index.js\"\n   */\n  modulePath: string;\n}\n\n/**\n * Options for {@link Import.resolvePackage}\n * @public\n */\nexport interface IImportResolvePackageOptions extends IImportResolveOptions {\n  /**\n   * The package name to resolve. For example \"\\@rushstack/node-core-library\"\n   */\n  packageName: string;\n}\n\ninterface IPackageDescriptor {\n  packageRootPath: string;\n  packageName: string;\n}\n\n/**\n * Helpers for resolving and importing Node.js modules.\n * @public\n */\nexport class Import {\n  private static __builtInModules: Set<string> | undefined;\n  private static get _builtInModules(): Set<string> {\n    if (!Import.__builtInModules) {\n      Import.__builtInModules = new Set<string>(nodeModule.builtinModules);\n    }\n\n    return Import.__builtInModules;\n  }\n\n  /**\n   * Provides a way to improve process startup times by lazy-loading imported modules.\n   *\n   * @remarks\n   * This is a more structured wrapper for the {@link https://www.npmjs.com/package/import-lazy|import-lazy}\n   * package.  It enables you to replace an import like this:\n   *\n   * ```ts\n   * import * as example from 'example'; // <-- 100ms load time\n   *\n   * if (condition) {\n   *   example.doSomething();\n   * }\n   * ```\n   *\n   * ...with a pattern like this:\n   *\n   * ```ts\n   * const example: typeof import('example') = Import.lazy('example', require);\n   *\n   * if (condition) {\n   *   example.doSomething(); // <-- 100ms load time occurs here, only if needed\n   * }\n   * ```\n   *\n   * The implementation relies on JavaScript's `Proxy` feature to intercept access to object members.  Thus\n   * it will only work correctly with certain types of module exports.  If a particular export isn't well behaved,\n   * you may need to find (or introduce) some other module in your dependency graph to apply the optimization to.\n   *\n   * Usage guidelines:\n   *\n   * - Always specify types using `typeof` as shown above.\n   *\n   * - Never apply lazy-loading in a way that would convert the module's type to `any`. Losing type safety\n   *   seriously impacts the maintainability of the code base.\n   *\n   * - In cases where the non-runtime types are needed, import them separately using the `Types` suffix:\n   *\n   * ```ts\n   * const example: typeof import('example') = Import.lazy('example', require);\n   * import type * as exampleTypes from 'example';\n   * ```\n   *\n   * - If the imported module confusingly has the same name as its export, then use the Module suffix:\n   *\n   * ```ts\n   * const exampleModule: typeof import('../../logic/Example') = Import.lazy(\n   *   '../../logic/Example', require);\n   * import type * as exampleTypes from '../../logic/Example';\n   * ```\n   *\n   * - If the exports cause a lot of awkwardness (e.g. too many expressions need to have `exampleModule.` inserted\n   *   into them), or if some exports cannot be proxied (e.g. `Import.lazy('example', require)` returns a function\n   *   signature), then do not lazy-load that module.  Instead, apply lazy-loading to some other module which is\n   *   better behaved.\n   *\n   * - It's recommended to sort imports in a standard ordering:\n   *\n   * ```ts\n   * // 1. external imports\n   * import * as path from 'path';\n   * import { Import, JsonFile, JsonObject } from '@rushstack/node-core-library';\n   *\n   * // 2. local imports\n   * import { LocalFile } from './path/LocalFile';\n   *\n   * // 3. lazy-imports (which are technically variables, not imports)\n   * const semver: typeof import('semver') = Import.lazy('semver', require);\n   * ```\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public static lazy(moduleName: string, require: (id: string) => unknown): any {\n    const importLazyLocal: (moduleName: string) => unknown = importLazy(require);\n    return importLazyLocal(moduleName);\n  }\n\n  /**\n   * This resolves a module path using similar logic as the Node.js `require.resolve()` API,\n   * but supporting extra features such as specifying the base folder.\n   *\n   * @remarks\n   * A module path is a text string that might appear in a statement such as\n   * `import { X } from \"____\";` or `const x = require(\"___\");`.  The implementation is based\n   * on the popular `resolve` NPM package.\n   *\n   * Suppose `example` is an NPM package whose entry point is `lib/index.js`:\n   * ```ts\n   * // Returns \"/path/to/project/node_modules/example/lib/index.js\"\n   * Import.resolveModule({ modulePath: 'example' });\n   *\n   * // Returns \"/path/to/project/node_modules/example/lib/other.js\"\n   * Import.resolveModule({ modulePath: 'example/lib/other' });\n   * ```\n   * If you need to determine the containing package folder\n   * (`/path/to/project/node_modules/example`), use {@link Import.resolvePackage} instead.\n   *\n   * @returns the absolute path of the resolved module.\n   * If {@link IImportResolveOptions.includeSystemModules} is specified\n   * and a system module is found, then its name is returned without any file path.\n   */\n  public static resolveModule(options: IImportResolveModuleOptions): string {\n    const { modulePath } = options;\n\n    if (path.isAbsolute(modulePath)) {\n      return modulePath;\n    }\n\n    const normalizedRootPath: string = FileSystem.getRealPath(options.baseFolderPath);\n\n    if (modulePath.startsWith('.')) {\n      // This looks like a conventional relative path\n      return path.resolve(normalizedRootPath, modulePath);\n    }\n\n    if (options.includeSystemModules === true && Import._builtInModules.has(modulePath)) {\n      return modulePath;\n    }\n\n    if (options.allowSelfReference === true) {\n      const ownPackage: IPackageDescriptor | undefined = Import._getPackageName(options.baseFolderPath);\n      if (ownPackage && modulePath.startsWith(ownPackage.packageName)) {\n        const packagePath: string = modulePath.substr(ownPackage.packageName.length + 1);\n        return path.resolve(ownPackage.packageRootPath, packagePath);\n      }\n    }\n\n    try {\n      return Resolve.sync(\n        // Append a slash to the package name to ensure `resolve.sync` doesn't attempt to return a system package\n        options.includeSystemModules !== true && modulePath.indexOf('/') === -1\n          ? `${modulePath}/`\n          : modulePath,\n        {\n          basedir: normalizedRootPath,\n          preserveSymlinks: false\n        }\n      );\n    } catch (e) {\n      throw new Error(`Cannot find module \"${modulePath}\" from \"${options.baseFolderPath}\".`);\n    }\n  }\n\n  /**\n   * Performs module resolution to determine the folder where a package is installed.\n   *\n   * @remarks\n   * Suppose `example` is an NPM package whose entry point is `lib/index.js`:\n   * ```ts\n   * // Returns \"/path/to/project/node_modules/example\"\n   * Import.resolvePackage({ packageName: 'example' });\n   * ```\n   *\n   * If you need to resolve a module path, use {@link Import.resolveModule} instead:\n   * ```ts\n   * // Returns \"/path/to/project/node_modules/example/lib/index.js\"\n   * Import.resolveModule({ modulePath: 'example' });\n   * ```\n   *\n   * @returns the absolute path of the package folder.\n   * If {@link IImportResolveOptions.includeSystemModules} is specified\n   * and a system module is found, then its name is returned without any file path.\n   */\n  public static resolvePackage(options: IImportResolvePackageOptions): string {\n    const { packageName } = options;\n\n    if (options.includeSystemModules && Import._builtInModules.has(packageName)) {\n      return packageName;\n    }\n\n    const normalizedRootPath: string = FileSystem.getRealPath(options.baseFolderPath);\n\n    if (options.allowSelfReference) {\n      const ownPackage: IPackageDescriptor | undefined = Import._getPackageName(options.baseFolderPath);\n      if (ownPackage && ownPackage.packageName === packageName) {\n        return ownPackage.packageRootPath;\n      }\n    }\n\n    try {\n      const resolvedPath: string = Resolve.sync(packageName, {\n        basedir: normalizedRootPath,\n        preserveSymlinks: false,\n        packageFilter: (pkg: { main: string }): { main: string } => {\n          // Hardwire \"main\" to point to a file that is guaranteed to exist.\n          // This helps resolve packages such as @types/node that have no entry point.\n          // And then we can use path.dirname() below to locate the package folder,\n          // even if the real entry point was in an subfolder with arbitrary nesting.\n          pkg.main = 'package.json';\n          return pkg;\n        }\n      });\n\n      const packagePath: string = path.dirname(resolvedPath);\n      const packageJson: IPackageJson = PackageJsonLookup.instance.loadPackageJson(\n        path.join(packagePath, 'package.json')\n      );\n      if (packageJson.name === packageName) {\n        return packagePath;\n      } else {\n        throw new Error();\n      }\n    } catch (e) {\n      throw new Error(`Cannot find package \"${packageName}\" from \"${options.baseFolderPath}\".`);\n    }\n  }\n\n  private static _getPackageName(rootPath: string): IPackageDescriptor | undefined {\n    const packageJsonPath: string | undefined =\n      PackageJsonLookup.instance.tryGetPackageJsonFilePathFor(rootPath);\n    if (packageJsonPath) {\n      const packageJson: IPackageJson = PackageJsonLookup.instance.loadPackageJson(packageJsonPath);\n      return {\n        packageRootPath: path.dirname(packageJsonPath),\n        packageName: packageJson.name\n      };\n    } else {\n      return undefined;\n    }\n  }\n}\n"]}