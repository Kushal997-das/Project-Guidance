{"version":3,"file":"Path.js","sourceRoot":"","sources":["../src/Path.ts"],"names":[],"mappings":";AAAA,4FAA4F;AAC5F,2DAA2D;;;;;;;;;;;;;;;;;;;;;;AAE3D,2CAA6B;AAiB7B;;;;;GAKG;AACH,MAAa,IAAI;IASf;;;;;;;;;OASG;IACI,MAAM,CAAC,OAAO,CAAC,SAAiB,EAAE,gBAAwB;QAC/D,6EAA6E;QAC7E,uEAAuE;QACvE,sFAAsF;QACtF,MAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;QACxE,OAAO,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IACpD,CAAC;IAED;;;;;;;;OAQG;IACI,MAAM,CAAC,cAAc,CAAC,SAAiB,EAAE,gBAAwB;QACtE,MAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,SAAS,EAAE,gBAAgB,CAAC,CAAC;QACxE,OAAO,YAAY,KAAK,EAAE,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;IAC3E,CAAC;IAED;;;;;;OAMG;IACI,MAAM,CAAC,OAAO,CAAC,KAAa,EAAE,KAAa;QAChD,OAAO,IAAI,CAAC,QAAQ,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,EAAE,CAAC;IAC5C,CAAC;IAED;;;;;;;OAOG;IACI,MAAM,CAAC,eAAe,CAAC,OAAoC;QAChE,sCAAsC;QACtC,MAAM,YAAY,GAAW,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,aAAa,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;QACtF,MAAM,cAAc,GAAY,YAAY,KAAK,EAAE,IAAI,IAAI,CAAC,kBAAkB,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAElG,IAAI,cAAc,EAAE;YAClB,qEAAqE;YACrE,OAAO,IAAI,GAAG,IAAI,CAAC,gBAAgB,CAAC,IAAI,CAAC,QAAQ,CAAC,OAAO,CAAC,UAAU,EAAE,OAAO,CAAC,aAAa,CAAC,CAAC,CAAC;SAC/F;QAED,MAAM,YAAY,GAAW,IAAI,CAAC,OAAO,CAAC,OAAO,CAAC,aAAa,CAAC,CAAC;QACjE,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,gBAAgB,CAAC,SAAiB;QAC9C,OAAO,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;IACvC,CAAC;IAED;;;;;OAKG;IACI,MAAM,CAAC,oBAAoB,CAAC,SAAiB;QAClD,OAAO,SAAS,CAAC,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,CAAC;IACxC,CAAC;IAED;;;;;;;;;;;;;;;;;OAiBG;IACI,MAAM,CAAC,kBAAkB,CAAC,SAAiB;QAChD,IAAI,IAAI,CAAC,UAAU,CAAC,SAAS,CAAC,EAAE;YAC9B,OAAO,KAAK,CAAC;SACd;QACD,uBAAuB;QACvB,IAAI,IAAI,CAAC,uBAAuB,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE;YAChD,OAAO,KAAK,CAAC;SACd;QACD,OAAO,IAAI,CAAC;IACd,CAAC;;AAzHH,oBA0HC;AAzHC,qEAAqE;AACrE,mCAAmC;AACpB,uBAAkB,GAAW,YAAY,CAAC;AAEzD,yDAAyD;AACzD,oBAAoB;AACL,4BAAuB,GAAW,0BAA0B,CAAC","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as path from 'path';\n\n/**\n * Options for {@link Path.formatConcisely}.\n * @public\n */\nexport interface IPathFormatConciselyOptions {\n  /**\n   * The path to be converted.\n   */\n  pathToConvert: string;\n  /**\n   * The base path to use when converting `pathToConvert` to a relative path.\n   */\n  baseFolder: string;\n}\n\n/**\n * Common operations for manipulating file and directory paths.\n * @remarks\n * This API is intended to eventually be a complete replacement for the NodeJS \"path\" API.\n * @public\n */\nexport class Path {\n  // Matches a relative path consisting entirely of periods and slashes\n  // Example: \".\", \"..\", \"../..\", etc\n  private static _relativePathRegex: RegExp = /^[.\\/\\\\]+$/;\n\n  // Matches a relative path segment that traverses upwards\n  // Example: \"a/../b\"\n  private static _upwardPathSegmentRegex: RegExp = /([\\/\\\\]|^)\\.\\.([\\/\\\\]|$)/;\n\n  /**\n   * Returns true if \"childPath\" is located inside the \"parentFolderPath\" folder\n   * or one of its child folders.  Note that \"parentFolderPath\" is not considered to be\n   * under itself.  The \"childPath\" can refer to any type of file system object.\n   *\n   * @remarks\n   * The indicated file/folder objects are not required to actually exist on disk.\n   * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\n   * If the paths are relative, they will first be resolved using path.resolve().\n   */\n  public static isUnder(childPath: string, parentFolderPath: string): boolean {\n    // If childPath is under parentPath, then relativePath will be something like\n    // \"../..\" or \"..\\\\..\", which consists entirely of periods and slashes.\n    // (Note that something like \"....t\" is actually a valid filename, but \"....\" is not.)\n    const relativePath: string = path.relative(childPath, parentFolderPath);\n    return Path._relativePathRegex.test(relativePath);\n  }\n\n  /**\n   * Returns true if \"childPath\" is equal to \"parentFolderPath\", or if it is inside that folder\n   * or one of its children.  The \"childPath\" can refer to any type of file system object.\n   *\n   * @remarks\n   * The indicated file/folder objects are not required to actually exist on disk.\n   * For example, \"parentFolderPath\" is interpreted as a folder name even if it refers to a file.\n   * If the paths are relative, they will first be resolved using path.resolve().\n   */\n  public static isUnderOrEqual(childPath: string, parentFolderPath: string): boolean {\n    const relativePath: string = path.relative(childPath, parentFolderPath);\n    return relativePath === '' || Path._relativePathRegex.test(relativePath);\n  }\n\n  /**\n   * Returns true if `path1` and `path2` refer to the same underlying path.\n   *\n   * @remarks\n   *\n   * The comparison is performed using `path.relative()`.\n   */\n  public static isEqual(path1: string, path2: string): boolean {\n    return path.relative(path1, path2) === '';\n  }\n\n  /**\n   * Formats a path to look nice for reporting purposes.\n   * @remarks\n   * If `pathToConvert` is under the `baseFolder`, then it will be converted to a relative with the `./` prefix.\n   * Otherwise, it will be converted to an absolute path.\n   *\n   * Backslashes will be converted to slashes, unless the path starts with an OS-specific string like `C:\\`.\n   */\n  public static formatConcisely(options: IPathFormatConciselyOptions): string {\n    // Same logic as Path.isUnderOrEqual()\n    const relativePath: string = path.relative(options.pathToConvert, options.baseFolder);\n    const isUnderOrEqual: boolean = relativePath === '' || Path._relativePathRegex.test(relativePath);\n\n    if (isUnderOrEqual) {\n      // Note that isUnderOrEqual()'s relativePath is the reverse direction\n      return './' + Path.convertToSlashes(path.relative(options.baseFolder, options.pathToConvert));\n    }\n\n    const absolutePath: string = path.resolve(options.pathToConvert);\n    return absolutePath;\n  }\n\n  /**\n   * Replaces Windows-style backslashes with POSIX-style slashes.\n   *\n   * @remarks\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n   */\n  public static convertToSlashes(inputPath: string): string {\n    return inputPath.replace(/\\\\/g, '/');\n  }\n\n  /**\n   * Replaces POSIX-style slashes with Windows-style backslashes\n   *\n   * @remarks\n   * POSIX is a registered trademark of the Institute of Electrical and Electronic Engineers, Inc.\n   */\n  public static convertToBackslashes(inputPath: string): string {\n    return inputPath.replace(/\\//g, '\\\\');\n  }\n\n  /**\n   * Returns true if the specified path is a relative path and does not use `..` to walk upwards.\n   *\n   * @example\n   * ```ts\n   * // These evaluate to true\n   * isDownwardRelative('folder');\n   * isDownwardRelative('file');\n   * isDownwardRelative('folder/');\n   * isDownwardRelative('./folder/');\n   * isDownwardRelative('./folder/file');\n   *\n   * // These evaluate to false\n   * isDownwardRelative('../folder');\n   * isDownwardRelative('folder/../file');\n   * isDownwardRelative('/folder/file');\n   * ```\n   */\n  public static isDownwardRelative(inputPath: string): boolean {\n    if (path.isAbsolute(inputPath)) {\n      return false;\n    }\n    // Does it contain \"..\"\n    if (Path._upwardPathSegmentRegex.test(inputPath)) {\n      return false;\n    }\n    return true;\n  }\n}\n"]}