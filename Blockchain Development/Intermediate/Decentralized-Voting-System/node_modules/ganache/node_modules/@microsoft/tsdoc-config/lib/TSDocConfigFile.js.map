{"version":3,"file":"TSDocConfigFile.js","sourceRoot":"","sources":["../src/TSDocConfigFile.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n  TSDocTagDefinition,\r\n  TSDocTagSyntaxKind,\r\n  TSDocConfiguration,\r\n  ParserMessageLog,\r\n  TSDocMessageId,\r\n  ParserMessage,\r\n  TextRange,\r\n  IParserMessageParameters,\r\n  ITSDocTagDefinitionParameters,\r\n} from '@microsoft/tsdoc';\r\nimport * as fs from 'fs';\r\nimport * as resolve from 'resolve';\r\nimport * as path from 'path';\r\nimport Ajv from 'ajv';\r\nimport * as jju from 'jju';\r\n\r\nconst ajv: Ajv.Ajv = new Ajv({ verbose: true });\r\n\r\nfunction initializeSchemaValidator(): Ajv.ValidateFunction {\r\n  const jsonSchemaPath: string = resolve.sync('@microsoft/tsdoc/schemas/tsdoc.schema.json', { basedir: __dirname });\r\n  const jsonSchemaContent: string = fs.readFileSync(jsonSchemaPath).toString();\r\n  const jsonSchema: object = jju.parse(jsonSchemaContent, { mode: 'cjson' });\r\n  return ajv.compile(jsonSchema);\r\n}\r\n\r\n// Warning: AJV has a fairly strange API.  Each time this function is called, the function  object's\r\n// properties get overwritten with the results of the latest validation.  Thus we need to be careful\r\n// to read the properties before a subsequent call may occur.\r\nconst tsdocSchemaValidator: Ajv.ValidateFunction = initializeSchemaValidator();\r\n\r\ninterface ITagConfigJson {\r\n  tagName: string;\r\n  syntaxKind: 'inline' | 'block' | 'modifier';\r\n  allowMultiple?: boolean;\r\n}\r\n\r\ninterface IConfigJson {\r\n  $schema: string;\r\n  extends?: string[];\r\n  noStandardTags?: boolean;\r\n  tagDefinitions?: ITagConfigJson[];\r\n  supportForTags?: { [tagName: string]: boolean };\r\n}\r\n\r\n/**\r\n * Represents an individual `tsdoc.json` file.\r\n *\r\n * @public\r\n */\r\nexport class TSDocConfigFile {\r\n  public static readonly FILENAME: string = 'tsdoc.json';\r\n  public static readonly CURRENT_SCHEMA_URL: string =\r\n    'https://developer.microsoft.com/json-schemas/tsdoc/v0/tsdoc.schema.json';\r\n\r\n  /**\r\n   * A queryable log that reports warnings and error messages that occurred during parsing.\r\n   */\r\n  public readonly log: ParserMessageLog;\r\n\r\n  private readonly _extendsFiles: TSDocConfigFile[];\r\n  private _filePath: string;\r\n  private _fileNotFound: boolean;\r\n  private _fileMTime: number;\r\n  private _hasErrors: boolean;\r\n  private _tsdocSchema: string;\r\n  private readonly _extendsPaths: string[];\r\n  private _noStandardTags: boolean | undefined;\r\n  private readonly _tagDefinitions: TSDocTagDefinition[];\r\n  private readonly _tagDefinitionNames: Set<string>;\r\n  private readonly _supportForTags: Map<string, boolean>;\r\n\r\n  private constructor() {\r\n    this.log = new ParserMessageLog();\r\n\r\n    this._extendsFiles = [];\r\n    this._filePath = '';\r\n    this._fileNotFound = false;\r\n    this._hasErrors = false;\r\n    this._fileMTime = 0;\r\n    this._tsdocSchema = '';\r\n    this._extendsPaths = [];\r\n    this._noStandardTags = undefined;\r\n    this._tagDefinitions = [];\r\n    this._tagDefinitionNames = new Set();\r\n    this._supportForTags = new Map();\r\n  }\r\n\r\n  /**\r\n   * Other config files that this file extends from.\r\n   */\r\n  public get extendsFiles(): ReadonlyArray<TSDocConfigFile> {\r\n    return this._extendsFiles;\r\n  }\r\n\r\n  /**\r\n   * The full path of the file that was attempted to load, or an empty string if the configuration was\r\n   * loaded from a source that is not a file.\r\n   */\r\n  public get filePath(): string {\r\n    return this._filePath;\r\n  }\r\n\r\n  /**\r\n   * If true, then the TSDocConfigFile object contains an empty state, because the `tsdoc.json` file\r\n   * was not found by the loader.\r\n   *\r\n   * @remarks\r\n   * A missing \"tsdoc.json\" file is not considered an error.  It simply means that the defaults will be used.\r\n   */\r\n  public get fileNotFound(): boolean {\r\n    return this._fileNotFound;\r\n  }\r\n\r\n  /**\r\n   * If true, then at least one error was encountered while loading this file or one of its \"extends\" files.\r\n   *\r\n   * @remarks\r\n   * You can use {@link TSDocConfigFile.getErrorSummary} to report these errors.\r\n   *\r\n   * The individual messages can be retrieved from the {@link TSDocConfigFile.log} property of each `TSDocConfigFile`\r\n   * object (including the {@link TSDocConfigFile.extendsFiles} tree).\r\n   */\r\n  public get hasErrors(): boolean {\r\n    return this._hasErrors;\r\n  }\r\n\r\n  /**\r\n   * The `$schema` field from the `tsdoc.json` file.\r\n   */\r\n  public get tsdocSchema(): string {\r\n    return this._tsdocSchema;\r\n  }\r\n\r\n  /**\r\n   * The `extends` field from the `tsdoc.json` file.  For the parsed file contents,\r\n   * use the `extendsFiles` property instead.\r\n   */\r\n  public get extendsPaths(): ReadonlyArray<string> {\r\n    return this._extendsPaths;\r\n  }\r\n\r\n  /**\r\n   * By default, the config file loader will predefine all of the standardized TSDoc tags.  To disable this and\r\n   * start with a completely empty configuration, set `noStandardTags` to true.\r\n   *\r\n   * @remarks\r\n   * If a config file uses `\"extends\"` to include settings from base config files, then its setting will\r\n   * override any settings from the base config files.  If `\"noStandardTags\"` is not specified, then this\r\n   * property will be `undefined`.  The config files are applied in the order they are processed (a depth-first\r\n   * traversal of the `\"extends\"` references), and files processed later can override earlier files.\r\n   * If no config file specifies `noStandardTags` then the default value is `false`.\r\n   */\r\n  public get noStandardTags(): boolean | undefined {\r\n    return this._noStandardTags;\r\n  }\r\n\r\n  public set noStandardTags(value: boolean | undefined) {\r\n    this._noStandardTags = value;\r\n  }\r\n\r\n  public get tagDefinitions(): ReadonlyArray<TSDocTagDefinition> {\r\n    return this._tagDefinitions;\r\n  }\r\n\r\n  public get supportForTags(): ReadonlyMap<string, boolean> {\r\n    return this._supportForTags;\r\n  }\r\n\r\n  /**\r\n   * Removes all items from the `tagDefinitions` array.\r\n   */\r\n  public clearTagDefinitions(): void {\r\n    this._tagDefinitions.length = 0;\r\n    this._tagDefinitionNames.clear();\r\n  }\r\n\r\n  /**\r\n   * Adds a new item to the `tagDefinitions` array.\r\n   */\r\n  public addTagDefinition(parameters: ITSDocTagDefinitionParameters): void {\r\n    // This validates the tag name\r\n    const tagDefinition: TSDocTagDefinition = new TSDocTagDefinition(parameters);\r\n\r\n    if (this._tagDefinitionNames.has(tagDefinition.tagNameWithUpperCase)) {\r\n      throw new Error(`A tag definition was already added with the tag name \"${parameters.tagName}\"`);\r\n    }\r\n    this._tagDefinitionNames.add(tagDefinition.tagName);\r\n\r\n    this._tagDefinitions.push(tagDefinition);\r\n  }\r\n\r\n  // Similar to addTagDefinition() but reports errors using _reportError()\r\n  private _addTagDefinitionForLoad(parameters: ITSDocTagDefinitionParameters): void {\r\n    let tagDefinition: TSDocTagDefinition;\r\n    try {\r\n      // This validates the tag name\r\n      tagDefinition = new TSDocTagDefinition(parameters);\r\n    } catch (error) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileInvalidTagName,\r\n        messageText: error.message,\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n\r\n    if (this._tagDefinitionNames.has(tagDefinition.tagNameWithUpperCase)) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileDuplicateTagName,\r\n        messageText: `The \"tagDefinitions\" field specifies more than one tag with the name \"${parameters.tagName}\"`,\r\n        textRange: TextRange.empty,\r\n      });\r\n    }\r\n    this._tagDefinitionNames.add(tagDefinition.tagNameWithUpperCase);\r\n\r\n    this._tagDefinitions.push(tagDefinition);\r\n  }\r\n\r\n  /**\r\n   * Removes all entries from the \"supportForTags\" map.\r\n   */\r\n  public clearSupportForTags(): void {\r\n    this._supportForTags.clear();\r\n  }\r\n\r\n  /**\r\n   * Sets an entry in the \"supportForTags\" map.\r\n   */\r\n  public setSupportForTag(tagName: string, supported: boolean): void {\r\n    TSDocTagDefinition.validateTSDocTagName(tagName);\r\n    this._supportForTags.set(tagName, supported);\r\n  }\r\n\r\n  /**\r\n   * This can be used for cache eviction.  It returns true if the modification timestamp has changed for\r\n   * any of the files that were read when loading this `TSDocConfigFile`, which indicates that the file should be\r\n   * reloaded.  It does not consider cases where `TSDocConfigFile.fileNotFound` was `true`.\r\n   *\r\n   * @remarks\r\n   * This can be used for cache eviction.  An example eviction strategy might be like this:\r\n   *\r\n   * - call `checkForModifiedFiles()` once per second, and reload the configuration if it returns true\r\n   *\r\n   * - otherwise, reload the configuration when it is more than 10 seconds old (to handle less common cases such\r\n   *   as creation of a missing file, or creation of a file at an earlier location in the search path).\r\n   */\r\n  public checkForModifiedFiles(): boolean {\r\n    if (this._checkForModifiedFile()) {\r\n      return true;\r\n    }\r\n    for (const extendsFile of this.extendsFiles) {\r\n      if (extendsFile.checkForModifiedFiles()) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Checks the last modification time for `TSDocConfigFile.filePath` and returns `true` if it has changed\r\n   * since the file was loaded.  If the file is missing, this returns `false`.  If the timestamp cannot be read,\r\n   * then this returns `true`.\r\n   */\r\n  private _checkForModifiedFile(): boolean {\r\n    if (this._fileNotFound || !this._filePath) {\r\n      return false;\r\n    }\r\n\r\n    try {\r\n      const mtimeMs: number = fs.statSync(this._filePath).mtimeMs;\r\n      return mtimeMs !== this._fileMTime;\r\n    } catch (error) {\r\n      return true;\r\n    }\r\n  }\r\n\r\n  private _reportError(parserMessageParameters: IParserMessageParameters): void {\r\n    this.log.addMessage(new ParserMessage(parserMessageParameters));\r\n    this._hasErrors = true;\r\n  }\r\n\r\n  private _loadJsonObject(configJson: IConfigJson): void {\r\n    if (configJson.$schema !== TSDocConfigFile.CURRENT_SCHEMA_URL) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileUnsupportedSchema,\r\n        messageText: `Unsupported JSON \"$schema\" value; expecting \"${TSDocConfigFile.CURRENT_SCHEMA_URL}\"`,\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n\r\n    const success: boolean = tsdocSchemaValidator(configJson) as boolean;\r\n\r\n    if (!success) {\r\n      const description: string = ajv.errorsText(tsdocSchemaValidator.errors);\r\n\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileSchemaError,\r\n        messageText: 'Error loading config file: ' + description,\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this._tsdocSchema = configJson.$schema;\r\n    if (configJson.extends) {\r\n      this._extendsPaths.push(...configJson.extends);\r\n    }\r\n\r\n    this.noStandardTags = configJson.noStandardTags;\r\n\r\n    for (const jsonTagDefinition of configJson.tagDefinitions || []) {\r\n      let syntaxKind: TSDocTagSyntaxKind;\r\n      switch (jsonTagDefinition.syntaxKind) {\r\n        case 'inline':\r\n          syntaxKind = TSDocTagSyntaxKind.InlineTag;\r\n          break;\r\n        case 'block':\r\n          syntaxKind = TSDocTagSyntaxKind.BlockTag;\r\n          break;\r\n        case 'modifier':\r\n          syntaxKind = TSDocTagSyntaxKind.ModifierTag;\r\n          break;\r\n        default:\r\n          // The JSON schema should have caught this error\r\n          throw new Error('Unexpected tag kind');\r\n      }\r\n\r\n      this._addTagDefinitionForLoad({\r\n        tagName: jsonTagDefinition.tagName,\r\n        syntaxKind: syntaxKind,\r\n        allowMultiple: jsonTagDefinition.allowMultiple,\r\n      });\r\n    }\r\n\r\n    if (configJson.supportForTags) {\r\n      for (const tagName of Object.keys(configJson.supportForTags)) {\r\n        const supported: boolean = configJson.supportForTags[tagName];\r\n\r\n        this._supportForTags.set(tagName, supported);\r\n      }\r\n    }\r\n  }\r\n\r\n  private _loadWithExtends(\r\n    configFilePath: string,\r\n    referencingConfigFile: TSDocConfigFile | undefined,\r\n    alreadyVisitedPaths: Set<string>\r\n  ): void {\r\n    // In case an exception is thrown, start by assuming that the file was not found; we'll revise\r\n    // this later upon success\r\n    this._fileNotFound = true;\r\n\r\n    if (!configFilePath) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileNotFound,\r\n        messageText: 'File not found',\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this._filePath = path.resolve(configFilePath);\r\n\r\n    if (!fs.existsSync(this._filePath)) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileNotFound,\r\n        messageText: 'File not found',\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n\r\n    const configJsonContent: string = fs.readFileSync(this._filePath).toString();\r\n    this._fileMTime = fs.statSync(this._filePath).mtimeMs;\r\n\r\n    this._fileNotFound = false;\r\n\r\n    const hashKey: string = fs.realpathSync(this._filePath);\r\n    if (referencingConfigFile && alreadyVisitedPaths.has(hashKey)) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigFileCyclicExtends,\r\n        messageText: `Circular reference encountered for \"extends\" field of \"${referencingConfigFile.filePath}\"`,\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n    alreadyVisitedPaths.add(hashKey);\r\n\r\n    let configJson: IConfigJson;\r\n    try {\r\n      configJson = jju.parse(configJsonContent, { mode: 'cjson' });\r\n    } catch (e) {\r\n      this._reportError({\r\n        messageId: TSDocMessageId.ConfigInvalidJson,\r\n        messageText: 'Error parsing JSON input: ' + e.message,\r\n        textRange: TextRange.empty,\r\n      });\r\n      return;\r\n    }\r\n\r\n    this._loadJsonObject(configJson);\r\n\r\n    const configFileFolder: string = path.dirname(this.filePath);\r\n\r\n    for (const extendsField of this.extendsPaths) {\r\n      let resolvedExtendsPath: string;\r\n      try {\r\n        resolvedExtendsPath = resolve.sync(extendsField, { basedir: configFileFolder });\r\n      } catch (e) {\r\n        this._reportError({\r\n          messageId: TSDocMessageId.ConfigFileUnresolvedExtends,\r\n          messageText: `Unable to resolve \"extends\" reference to \"${extendsField}\": ` + e.message,\r\n          textRange: TextRange.empty,\r\n        });\r\n\r\n        return;\r\n      }\r\n\r\n      const baseConfigFile: TSDocConfigFile = new TSDocConfigFile();\r\n\r\n      baseConfigFile._loadWithExtends(resolvedExtendsPath, this, alreadyVisitedPaths);\r\n\r\n      if (baseConfigFile.fileNotFound) {\r\n        this._reportError({\r\n          messageId: TSDocMessageId.ConfigFileUnresolvedExtends,\r\n          messageText: `Unable to resolve \"extends\" reference to \"${extendsField}\"`,\r\n          textRange: TextRange.empty,\r\n        });\r\n      }\r\n\r\n      this._extendsFiles.push(baseConfigFile);\r\n\r\n      if (baseConfigFile.hasErrors) {\r\n        this._hasErrors = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For the given folder, look for the relevant tsdoc.json file (if any), and return its path.\r\n   *\r\n   * @param folderPath - the path to a folder where the search should start\r\n   * @returns the (possibly relative) path to tsdoc.json, or an empty string if not found\r\n   */\r\n  public static findConfigPathForFolder(folderPath: string): string {\r\n    if (folderPath) {\r\n      let foundFolder: string = folderPath;\r\n      for (;;) {\r\n        const tsconfigJsonPath: string = path.join(foundFolder, 'tsconfig.json');\r\n        if (fs.existsSync(tsconfigJsonPath)) {\r\n          // Stop when we reach a folder containing tsconfig.json\r\n          return path.join(foundFolder, TSDocConfigFile.FILENAME);\r\n        }\r\n        const packageJsonPath: string = path.join(foundFolder, 'package.json');\r\n        if (fs.existsSync(packageJsonPath)) {\r\n          // Stop when we reach a folder containing package.json; this avoids crawling out of the current package\r\n          return path.join(foundFolder, TSDocConfigFile.FILENAME);\r\n        }\r\n\r\n        const previousFolder: string = foundFolder;\r\n        foundFolder = path.dirname(foundFolder);\r\n\r\n        if (!foundFolder || foundFolder === previousFolder) {\r\n          // Give up if we reach the filesystem root directory\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return '';\r\n  }\r\n\r\n  /**\r\n   * Calls `TSDocConfigFile.findConfigPathForFolder()` to find the relevant tsdoc.json config file, if one exists.\r\n   * Then calls `TSDocConfigFile.findConfigPathForFolder()` to return the loaded result.\r\n   *\r\n   * @remarks\r\n   * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check\r\n   * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},\r\n   * or {@link TSDocConfigFile.getErrorSummary}.\r\n   *\r\n   * @param folderPath - the path to a folder where the search should start\r\n   */\r\n  public static loadForFolder(folderPath: string): TSDocConfigFile {\r\n    const rootConfigPath: string = TSDocConfigFile.findConfigPathForFolder(folderPath);\r\n    return TSDocConfigFile.loadFile(rootConfigPath);\r\n  }\r\n\r\n  /**\r\n   * Loads the specified tsdoc.json and any base files that it refers to using the \"extends\" option.\r\n   *\r\n   * @remarks\r\n   * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check\r\n   * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},\r\n   * or {@link TSDocConfigFile.getErrorSummary}.\r\n   *\r\n   * @param tsdocJsonFilePath - the path to the tsdoc.json config file\r\n   */\r\n  public static loadFile(tsdocJsonFilePath: string): TSDocConfigFile {\r\n    const configFile: TSDocConfigFile = new TSDocConfigFile();\r\n    const alreadyVisitedPaths: Set<string> = new Set<string>();\r\n    configFile._loadWithExtends(tsdocJsonFilePath, undefined, alreadyVisitedPaths);\r\n    return configFile;\r\n  }\r\n\r\n  /**\r\n   * Loads the object state from a JSON-serializable object as produced by {@link TSDocConfigFile.saveToObject}.\r\n   *\r\n   * @remarks\r\n   * The serialized object has the same structure as `tsdoc.json`; however the `\"extends\"` field is not allowed.\r\n   *\r\n   * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check\r\n   * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},\r\n   * or {@link TSDocConfigFile.getErrorSummary}.\r\n   */\r\n  public static loadFromObject(jsonObject: unknown): TSDocConfigFile {\r\n    const configFile: TSDocConfigFile = new TSDocConfigFile();\r\n\r\n    configFile._loadJsonObject(jsonObject as IConfigJson);\r\n\r\n    if (configFile.extendsPaths.length > 0) {\r\n      throw new Error('The \"extends\" field cannot be used with TSDocConfigFile.loadFromObject()');\r\n    }\r\n\r\n    return configFile;\r\n  }\r\n\r\n  /**\r\n   * Initializes a TSDocConfigFile object using the state from the provided `TSDocConfiguration` object.\r\n   *\r\n   * @remarks\r\n   * This API does not report loading errors by throwing exceptions.  Instead, the caller is expected to check\r\n   * for errors using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log},\r\n   * or {@link TSDocConfigFile.getErrorSummary}.\r\n   */\r\n  public static loadFromParser(configuration: TSDocConfiguration): TSDocConfigFile {\r\n    const configFile: TSDocConfigFile = new TSDocConfigFile();\r\n\r\n    // The standard tags will be mixed together with custom definitions,\r\n    // so set noStandardTags=true to avoid defining them twice.\r\n    configFile.noStandardTags = true;\r\n\r\n    for (const tagDefinition of configuration.tagDefinitions) {\r\n      configFile.addTagDefinition({\r\n        syntaxKind: tagDefinition.syntaxKind,\r\n        tagName: tagDefinition.tagName,\r\n        allowMultiple: tagDefinition.allowMultiple,\r\n      });\r\n    }\r\n\r\n    for (const tagDefinition of configuration.supportedTagDefinitions) {\r\n      configFile.setSupportForTag(tagDefinition.tagName, true);\r\n    }\r\n\r\n    return configFile;\r\n  }\r\n\r\n  /**\r\n   * Writes the config file content to a JSON file with the specified file path.\r\n   */\r\n  public saveFile(jsonFilePath: string): void {\r\n    const jsonObject: unknown = this.saveToObject();\r\n    const jsonContent: string = JSON.stringify(jsonObject, undefined, 2);\r\n    fs.writeFileSync(jsonFilePath, jsonContent);\r\n  }\r\n\r\n  /**\r\n   * Writes the object state into a JSON-serializable object.\r\n   */\r\n  public saveToObject(): unknown {\r\n    const configJson: IConfigJson = {\r\n      $schema: TSDocConfigFile.CURRENT_SCHEMA_URL,\r\n    };\r\n\r\n    if (this.noStandardTags !== undefined) {\r\n      configJson.noStandardTags = this.noStandardTags;\r\n    }\r\n\r\n    if (this.tagDefinitions.length > 0) {\r\n      configJson.tagDefinitions = [];\r\n      for (const tagDefinition of this.tagDefinitions) {\r\n        configJson.tagDefinitions.push(TSDocConfigFile._serializeTagDefinition(tagDefinition));\r\n      }\r\n    }\r\n\r\n    if (this.supportForTags.size > 0) {\r\n      configJson.supportForTags = {};\r\n      this.supportForTags.forEach((supported, tagName) => {\r\n        configJson.supportForTags![tagName] = supported;\r\n      });\r\n    }\r\n\r\n    return configJson;\r\n  }\r\n\r\n  private static _serializeTagDefinition(tagDefinition: TSDocTagDefinition): ITagConfigJson {\r\n    let syntaxKind: 'inline' | 'block' | 'modifier' | undefined;\r\n    switch (tagDefinition.syntaxKind) {\r\n      case TSDocTagSyntaxKind.InlineTag:\r\n        syntaxKind = 'inline';\r\n        break;\r\n      case TSDocTagSyntaxKind.BlockTag:\r\n        syntaxKind = 'block';\r\n        break;\r\n      case TSDocTagSyntaxKind.ModifierTag:\r\n        syntaxKind = 'modifier';\r\n        break;\r\n      default:\r\n        throw new Error('Unimplemented TSDocTagSyntaxKind');\r\n    }\r\n\r\n    const tagConfigJson: ITagConfigJson = {\r\n      tagName: tagDefinition.tagName,\r\n      syntaxKind,\r\n    };\r\n    if (tagDefinition.allowMultiple) {\r\n      tagConfigJson.allowMultiple = true;\r\n    }\r\n    return tagConfigJson;\r\n  }\r\n\r\n  /**\r\n   * Returns a report of any errors that occurred while attempting to load this file or any files\r\n   * referenced via the \"extends\" field.\r\n   *\r\n   * @remarks\r\n   * Use {@link TSDocConfigFile.hasErrors} to determine whether any errors occurred.\r\n   */\r\n  public getErrorSummary(): string {\r\n    if (!this._hasErrors) {\r\n      return 'No errors.';\r\n    }\r\n\r\n    let result: string = '';\r\n\r\n    if (this.log.messages.length > 0) {\r\n      const errorNoun: string = this.log.messages.length > 1 ? 'Errors' : 'Error';\r\n      if (this.filePath) {\r\n        result += `${errorNoun} encountered for ${this.filePath}:\\n`;\r\n      } else {\r\n        result += `${errorNoun} encountered when loading TSDoc configuration:\\n`;\r\n      }\r\n\r\n      for (const message of this.log.messages) {\r\n        result += `  ${message.text}\\n`;\r\n      }\r\n    }\r\n\r\n    for (const extendsFile of this.extendsFiles) {\r\n      if (extendsFile.hasErrors) {\r\n        if (result !== '') {\r\n          result += '\\n';\r\n        }\r\n        result += extendsFile.getErrorSummary();\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Applies the settings from this config file to a TSDoc parser configuration.\r\n   * Any `extendsFile` settings will also applied.\r\n   *\r\n   * @remarks\r\n   * Additional validation is performed during this operation.  The caller is expected to check for errors\r\n   * using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log}, or {@link TSDocConfigFile.getErrorSummary}.\r\n   */\r\n  public configureParser(configuration: TSDocConfiguration): void {\r\n    if (this._getNoStandardTagsWithExtends()) {\r\n      // Do not define standard tags\r\n      configuration.clear(true);\r\n    } else {\r\n      // Define standard tags (the default behavior)\r\n      configuration.clear(false);\r\n    }\r\n\r\n    this.updateParser(configuration);\r\n  }\r\n\r\n  /**\r\n   * This is the same as {@link configureParser}, but it preserves any previous state.\r\n   *\r\n   * @remarks\r\n   * Additional validation is performed during this operation.  The caller is expected to check for errors\r\n   * using {@link TSDocConfigFile.hasErrors}, {@link TSDocConfigFile.log}, or {@link TSDocConfigFile.getErrorSummary}.\r\n   */\r\n  public updateParser(configuration: TSDocConfiguration): void {\r\n    // First apply the base config files\r\n    for (const extendsFile of this.extendsFiles) {\r\n      extendsFile.updateParser(configuration);\r\n    }\r\n\r\n    // Then apply this one\r\n    for (const tagDefinition of this.tagDefinitions) {\r\n      configuration.addTagDefinition(tagDefinition);\r\n    }\r\n\r\n    this.supportForTags.forEach((supported: boolean, tagName: string) => {\r\n      const tagDefinition: TSDocTagDefinition | undefined = configuration.tryGetTagDefinition(tagName);\r\n      if (tagDefinition) {\r\n        // Note that setSupportForTag() automatically enables configuration.validation.reportUnsupportedTags\r\n        configuration.setSupportForTag(tagDefinition, supported);\r\n      } else {\r\n        // Note that this validation may depend partially on the preexisting state of the TSDocConfiguration\r\n        // object, so it cannot be performed during the TSConfigFile.loadFile() stage.\r\n        this._reportError({\r\n          messageId: TSDocMessageId.ConfigFileUndefinedTag,\r\n          messageText: `The \"supportForTags\" field refers to an undefined tag ${JSON.stringify(tagName)}.`,\r\n          textRange: TextRange.empty,\r\n        });\r\n      }\r\n    });\r\n  }\r\n\r\n  private _getNoStandardTagsWithExtends(): boolean {\r\n    if (this.noStandardTags !== undefined) {\r\n      return this.noStandardTags;\r\n    }\r\n\r\n    // This config file does not specify \"noStandardTags\", so consider any base files referenced using \"extends\"\r\n    let result: boolean | undefined = undefined;\r\n    for (const extendsFile of this.extendsFiles) {\r\n      const extendedValue: boolean | undefined = extendsFile._getNoStandardTagsWithExtends();\r\n      if (extendedValue !== undefined) {\r\n        result = extendedValue;\r\n      }\r\n    }\r\n\r\n    if (result === undefined) {\r\n      // If no config file specifies noStandardTags, then it defaults to false\r\n      result = false;\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"]}