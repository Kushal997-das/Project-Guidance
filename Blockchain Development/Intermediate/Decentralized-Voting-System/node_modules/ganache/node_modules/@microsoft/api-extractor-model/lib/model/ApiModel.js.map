{"version":3,"file":"ApiModel.js","sourceRoot":"","sources":["../../src/model/ApiModel.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport { DeclarationReference } from '@microsoft/tsdoc/lib-commonjs/beta/DeclarationReference';\nimport { ApiItem, ApiItemKind } from '../items/ApiItem';\nimport { ApiItemContainerMixin } from '../mixins/ApiItemContainerMixin';\nimport { ApiPackage } from './ApiPackage';\nimport { PackageName } from '@rushstack/node-core-library';\nimport { ModelReferenceResolver, IResolveDeclarationReferenceResult } from './ModelReferenceResolver';\nimport { DocDeclarationReference } from '@microsoft/tsdoc';\n\n/**\n * A serializable representation of a collection of API declarations.\n *\n * @remarks\n *\n * An `ApiModel` represents a collection of API declarations that can be serialized to disk.  It captures all the\n * important information needed to generate documentation, without any reliance on the TypeScript compiler engine.\n *\n * An `ApiModel` acts as the root of a tree of objects that all inherit from the `ApiItem` base class.\n * The tree children are determined by the {@link (ApiItemContainerMixin:interface)} mixin base class.  The model\n * contains packages.  Packages have an entry point (today, only one).  And the entry point can contain various types\n * of API declarations.  The container relationships might look like this:\n *\n * ```\n * Things that can contain other things:\n *\n * - ApiModel\n *   - ApiPackage\n *     - ApiEntryPoint\n *       - ApiClass\n *         - ApiMethod\n *         - ApiProperty\n *       - ApiEnum\n *         - ApiEnumMember\n *       - ApiInterface\n *         - ApiMethodSignature\n *         - ApiPropertySignature\n *       - ApiNamespace\n *         - (ApiClass, ApiEnum, ApiInterace, ...)\n *\n * ```\n *\n * Normally, API Extractor writes an .api.json file to disk for each project that it builds.  Then, a tool like\n * API Documenter can load the various `ApiPackage` objects into a single `ApiModel` and process them as a group.\n * This is useful because compilation generally occurs separately (e.g. because projects may reside in different\n * Git repos, or because they build with different TypeScript compiler configurations that may be incompatible),\n * whereas API Documenter cannot detect broken hyperlinks without seeing the entire documentation set.\n *\n * @public\n */\nexport class ApiModel extends ApiItemContainerMixin(ApiItem) {\n  private readonly _resolver: ModelReferenceResolver;\n\n  private _packagesByName: Map<string, ApiPackage> | undefined = undefined;\n  private _apiItemsByCanonicalReference: Map<string, ApiItem> | undefined = undefined;\n  public constructor() {\n    super({});\n\n    this._resolver = new ModelReferenceResolver(this);\n  }\n\n  public loadPackage(apiJsonFilename: string): ApiPackage {\n    const apiPackage: ApiPackage = ApiPackage.loadFromJsonFile(apiJsonFilename);\n    this.addMember(apiPackage);\n    return apiPackage;\n  }\n\n  /** @override */\n  public get kind(): ApiItemKind {\n    return ApiItemKind.Model;\n  }\n\n  /** @override */\n  public get containerKey(): string {\n    return '';\n  }\n\n  public get packages(): ReadonlyArray<ApiPackage> {\n    return this.members as ReadonlyArray<ApiPackage>;\n  }\n\n  /** @override */\n  public addMember(member: ApiPackage): void {\n    if (member.kind !== ApiItemKind.Package) {\n      throw new Error('Only items of type ApiPackage may be added to an ApiModel');\n    }\n    super.addMember(member);\n    this._packagesByName = undefined; // invalidate the cache\n    this._apiItemsByCanonicalReference = undefined; // invalidate the cache\n  }\n\n  /**\n   * Efficiently finds a package by the NPM package name.\n   *\n   * @remarks\n   *\n   * If the NPM scope is omitted in the package name, it will still be found provided that it is an unambiguous match.\n   * For example, it's often convenient to write `{@link node-core-library#JsonFile}` instead of\n   * `{@link @rushstack/node-core-library#JsonFile}`.\n   */\n  public tryGetPackageByName(packageName: string): ApiPackage | undefined {\n    // Build the lookup on demand\n    if (this._packagesByName === undefined) {\n      this._packagesByName = new Map<string, ApiPackage>();\n\n      const unscopedMap: Map<string, ApiPackage | undefined> = new Map<string, ApiPackage | undefined>();\n\n      for (const apiPackage of this.packages) {\n        if (this._packagesByName.get(apiPackage.name)) {\n          // This should not happen\n          throw new Error(`The model contains multiple packages with the name ${apiPackage.name}`);\n        }\n\n        this._packagesByName.set(apiPackage.name, apiPackage);\n\n        const unscopedName: string = PackageName.parse(apiPackage.name).unscopedName;\n\n        if (unscopedMap.has(unscopedName)) {\n          // If another package has the same unscoped name, then we won't register it\n          unscopedMap.set(unscopedName, undefined);\n        } else {\n          unscopedMap.set(unscopedName, apiPackage);\n        }\n      }\n\n      for (const [unscopedName, apiPackage] of unscopedMap) {\n        if (apiPackage) {\n          if (!this._packagesByName.has(unscopedName)) {\n            // If the unscoped name is unambiguous, then we can also use it as a lookup\n            this._packagesByName.set(unscopedName, apiPackage);\n          }\n        }\n      }\n    }\n\n    return this._packagesByName.get(packageName);\n  }\n\n  public resolveDeclarationReference(\n    declarationReference: DocDeclarationReference | DeclarationReference,\n    contextApiItem: ApiItem | undefined\n  ): IResolveDeclarationReferenceResult {\n    if (declarationReference instanceof DocDeclarationReference) {\n      return this._resolver.resolve(declarationReference, contextApiItem);\n    } else if (declarationReference instanceof DeclarationReference) {\n      // use this._apiItemsByCanonicalReference to look up ApiItem\n\n      // Build the lookup on demand\n      if (!this._apiItemsByCanonicalReference) {\n        this._apiItemsByCanonicalReference = new Map<string, ApiItem>();\n\n        for (const apiPackage of this.packages) {\n          this._initApiItemsRecursive(apiPackage, this._apiItemsByCanonicalReference);\n        }\n      }\n\n      const result: IResolveDeclarationReferenceResult = {\n        resolvedApiItem: undefined,\n        errorMessage: undefined\n      };\n\n      const apiItem: ApiItem | undefined = this._apiItemsByCanonicalReference.get(\n        declarationReference.toString()\n      );\n\n      if (!apiItem) {\n        result.errorMessage = `${declarationReference.toString()} can not be located`;\n      } else {\n        result.resolvedApiItem = apiItem;\n      }\n\n      return result;\n    } else {\n      // NOTE: The \"instanceof DeclarationReference\" test assumes a specific version of the @microsoft/tsdoc package.\n      throw new Error(\n        'The \"declarationReference\" parameter must be an instance of' +\n          ' DocDeclarationReference or DeclarationReference'\n      );\n    }\n  }\n\n  private _initApiItemsRecursive(apiItem: ApiItem, apiItemsByCanonicalReference: Map<string, ApiItem>): void {\n    if (apiItem.canonicalReference && !apiItem.canonicalReference.isEmpty) {\n      apiItemsByCanonicalReference.set(apiItem.canonicalReference.toString(), apiItem);\n    }\n\n    // Recurse container members\n    if (ApiItemContainerMixin.isBaseClassOf(apiItem)) {\n      for (const apiMember of apiItem.members) {\n        this._initApiItemsRecursive(apiMember, apiItemsByCanonicalReference);\n      }\n    }\n  }\n\n  /** @beta @override */\n  public buildCanonicalReference(): DeclarationReference {\n    return DeclarationReference.empty();\n  }\n}\n"]}