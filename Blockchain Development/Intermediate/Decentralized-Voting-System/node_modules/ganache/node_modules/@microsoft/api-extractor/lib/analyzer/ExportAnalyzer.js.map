{"version":3,"file":"ExportAnalyzer.js","sourceRoot":"","sources":["../../src/analyzer/ExportAnalyzer.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\n// See LICENSE in the project root for license information.\n\nimport * as ts from 'typescript';\nimport { InternalError } from '@rushstack/node-core-library';\n\nimport { TypeScriptHelpers } from './TypeScriptHelpers';\nimport { AstSymbol } from './AstSymbol';\nimport { AstImport, IAstImportOptions, AstImportKind } from './AstImport';\nimport { AstModule, AstModuleExportInfo } from './AstModule';\nimport { TypeScriptInternals } from './TypeScriptInternals';\nimport { SourceFileLocationFormatter } from './SourceFileLocationFormatter';\nimport { IFetchAstSymbolOptions } from './AstSymbolTable';\nimport { AstEntity } from './AstEntity';\nimport { AstNamespaceImport } from './AstNamespaceImport';\nimport { SyntaxHelpers } from './SyntaxHelpers';\n\n/**\n * Exposes the minimal APIs from AstSymbolTable that are needed by ExportAnalyzer.\n *\n * In particular, we want ExportAnalyzer to be able to call AstSymbolTable._fetchAstSymbol() even though it\n * is a very private API that should not be exposed to any other components.\n */\nexport interface IAstSymbolTable {\n  fetchAstSymbol(options: IFetchAstSymbolOptions): AstSymbol | undefined;\n\n  analyze(astEntity: AstEntity): void;\n}\n\n/**\n * Used with ExportAnalyzer.fetchAstModuleBySourceFile() to provide contextual information about how the source file\n * was imported.\n */\ninterface IAstModuleReference {\n  /**\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\n   * string `\"some-package\"`.\n   */\n  moduleSpecifier: string;\n\n  /**\n   * For example, if we are following a statement like `import { X } from 'some-package'`, this will be the\n   * symbol for `X`.\n   */\n  moduleSpecifierSymbol: ts.Symbol;\n}\n\n/**\n * The ExportAnalyzer is an internal part of AstSymbolTable that has been moved out into its own source file\n * because it is a complex and mostly self-contained algorithm.\n *\n * Its job is to build up AstModule objects by crawling import statements to discover where declarations come from.\n * This is conceptually the same as the compiler's own TypeChecker.getExportsOfModule(), except that when\n * ExportAnalyzer encounters a declaration that was imported from an external package, it remembers how it was imported\n * (i.e. the AstImport object).  Today the compiler API does not expose this information, which is crucial for\n * generating .d.ts rollups.\n */\nexport class ExportAnalyzer {\n  // Captures \"@a/b\" or \"d\" from these examples:\n  //   @a/b\n  //   @a/b/c\n  //   d\n  //   d/\n  //   d/e\n  private static _modulePathRegExp: RegExp = /^((?:@[^@\\/\\s]+\\/)?[^@\\/\\s]+)(?:.*)$/;\n\n  private readonly _program: ts.Program;\n  private readonly _typeChecker: ts.TypeChecker;\n  private readonly _bundledPackageNames: ReadonlySet<string>;\n  private readonly _astSymbolTable: IAstSymbolTable;\n\n  private readonly _astModulesByModuleSymbol: Map<ts.Symbol, AstModule> = new Map<ts.Symbol, AstModule>();\n\n  // Used with isImportableAmbientSourceFile()\n  private readonly _importableAmbientSourceFiles: Set<ts.SourceFile> = new Set<ts.SourceFile>();\n\n  private readonly _astImportsByKey: Map<string, AstImport> = new Map<string, AstImport>();\n  private readonly _astNamespaceImportByModule: Map<AstModule, AstNamespaceImport> = new Map();\n\n  public constructor(\n    program: ts.Program,\n    typeChecker: ts.TypeChecker,\n    bundledPackageNames: ReadonlySet<string>,\n    astSymbolTable: IAstSymbolTable\n  ) {\n    this._program = program;\n    this._typeChecker = typeChecker;\n    this._bundledPackageNames = bundledPackageNames;\n    this._astSymbolTable = astSymbolTable;\n  }\n\n  /**\n   * For a given source file, this analyzes all of its exports and produces an AstModule object.\n   *\n   * @param moduleReference - contextual information about the import statement that took us to this source file.\n   * or `undefined` if this source file is the initial entry point\n   */\n  public fetchAstModuleFromSourceFile(\n    sourceFile: ts.SourceFile,\n    moduleReference: IAstModuleReference | undefined\n  ): AstModule {\n    const moduleSymbol: ts.Symbol = this._getModuleSymbolFromSourceFile(sourceFile, moduleReference);\n\n    // Don't traverse into a module that we already processed before:\n    // The compiler allows m1 to have \"export * from 'm2'\" and \"export * from 'm3'\",\n    // even if m2 and m3 both have \"export * from 'm4'\".\n    let astModule: AstModule | undefined = this._astModulesByModuleSymbol.get(moduleSymbol);\n    if (!astModule) {\n      // (If moduleReference === undefined, then this is the entry point of the local project being analyzed.)\n      let externalModulePath: string | undefined = undefined;\n      if (moduleReference !== undefined) {\n        // Match:       \"@microsoft/sp-lodash-subset\" or \"lodash/has\"\n        // but ignore:  \"../folder/LocalFile\"\n        if (this._isExternalModulePath(moduleReference.moduleSpecifier)) {\n          externalModulePath = moduleReference.moduleSpecifier;\n        }\n      }\n\n      astModule = new AstModule({ sourceFile, moduleSymbol, externalModulePath });\n\n      this._astModulesByModuleSymbol.set(moduleSymbol, astModule);\n\n      if (astModule.isExternal) {\n        // It's an external package, so do the special simplified analysis that doesn't crawl into referenced modules\n        for (const exportedSymbol of this._typeChecker.getExportsOfModule(moduleSymbol)) {\n          if (externalModulePath === undefined) {\n            throw new InternalError(\n              'Failed assertion: externalModulePath=undefined but astModule.isExternal=true'\n            );\n          }\n\n          const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(\n            exportedSymbol,\n            this._typeChecker\n          );\n\n          // Ignore virtual symbols that don't have any declarations\n          const arbitraryDeclaration: ts.Declaration | undefined =\n            TypeScriptHelpers.tryGetADeclaration(followedSymbol);\n          if (arbitraryDeclaration) {\n            const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\n              followedSymbol: followedSymbol,\n              isExternal: astModule.isExternal,\n              includeNominalAnalysis: true,\n              addIfMissing: true\n            });\n\n            if (!astSymbol) {\n              throw new Error(\n                `Unsupported export ${JSON.stringify(exportedSymbol.name)}:\\n` +\n                  SourceFileLocationFormatter.formatDeclaration(arbitraryDeclaration)\n              );\n            }\n\n            astModule.cachedExportedEntities.set(exportedSymbol.name, astSymbol);\n          }\n        }\n      } else {\n        // The module is part of the local project, so do the full analysis\n\n        if (moduleSymbol.exports) {\n          // The \"export * from 'module-name';\" declarations are all attached to a single virtual symbol\n          // whose name is InternalSymbolName.ExportStar\n          const exportStarSymbol: ts.Symbol | undefined = moduleSymbol.exports.get(\n            ts.InternalSymbolName.ExportStar\n          );\n          if (exportStarSymbol) {\n            for (const exportStarDeclaration of exportStarSymbol.getDeclarations() || []) {\n              if (ts.isExportDeclaration(exportStarDeclaration)) {\n                const starExportedModule: AstModule | undefined = this._fetchSpecifierAstModule(\n                  exportStarDeclaration,\n                  exportStarSymbol\n                );\n\n                if (starExportedModule !== undefined) {\n                  astModule.starExportedModules.add(starExportedModule);\n                }\n              } else {\n                // Ignore ExportDeclaration nodes that don't match the expected pattern\n                // TODO: Should we report a warning?\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return astModule;\n  }\n\n  /**\n   * Retrieves the symbol for the module corresponding to the ts.SourceFile that is being imported/exported.\n   *\n   * @remarks\n   * The `module` keyword can be used to declare multiple TypeScript modules inside a single source file.\n   * (This is a deprecated construct and mainly used for typings such as `@types/node`.)  In this situation,\n   * `moduleReference` helps us to fish out the correct module symbol.\n   */\n  private _getModuleSymbolFromSourceFile(\n    sourceFile: ts.SourceFile,\n    moduleReference: IAstModuleReference | undefined\n  ): ts.Symbol {\n    const moduleSymbol: ts.Symbol | undefined = TypeScriptInternals.tryGetSymbolForDeclaration(\n      sourceFile,\n      this._typeChecker\n    );\n    if (moduleSymbol !== undefined) {\n      // This is the normal case.  The SourceFile acts is a module and has a symbol.\n      return moduleSymbol;\n    }\n\n    if (moduleReference !== undefined) {\n      // But there is also an elaborate case where the source file contains one or more \"module\" declarations,\n      // and our moduleReference took us to one of those.\n\n      // eslint-disable-next-line no-bitwise\n      if ((moduleReference.moduleSpecifierSymbol.flags & ts.SymbolFlags.Alias) !== 0) {\n        // Follow the import/export declaration to one hop the exported item inside the target module\n        let followedSymbol: ts.Symbol | undefined = TypeScriptInternals.getImmediateAliasedSymbol(\n          moduleReference.moduleSpecifierSymbol,\n          this._typeChecker\n        );\n\n        if (followedSymbol === undefined) {\n          // This is a workaround for a compiler bug where getImmediateAliasedSymbol() sometimes returns undefined\n          followedSymbol = this._typeChecker.getAliasedSymbol(moduleReference.moduleSpecifierSymbol);\n        }\n\n        if (followedSymbol !== undefined && followedSymbol !== moduleReference.moduleSpecifierSymbol) {\n          // The parent of the exported symbol will be the module that we're importing from\n          const parent: ts.Symbol | undefined = TypeScriptInternals.getSymbolParent(followedSymbol);\n          if (parent !== undefined) {\n            // Make sure the thing we found is a module\n            // eslint-disable-next-line no-bitwise\n            if ((parent.flags & ts.SymbolFlags.ValueModule) !== 0) {\n              // Record that that this is an ambient module that can also be imported from\n              this._importableAmbientSourceFiles.add(sourceFile);\n              return parent;\n            }\n          }\n        }\n      }\n    }\n\n    throw new InternalError('Unable to determine module for: ' + sourceFile.fileName);\n  }\n\n  /**\n   * Implementation of {@link AstSymbolTable.fetchAstModuleExportInfo}.\n   */\n  public fetchAstModuleExportInfo(entryPointAstModule: AstModule): AstModuleExportInfo {\n    if (entryPointAstModule.isExternal) {\n      throw new Error('fetchAstModuleExportInfo() is not supported for external modules');\n    }\n\n    if (entryPointAstModule.astModuleExportInfo === undefined) {\n      const astModuleExportInfo: AstModuleExportInfo = new AstModuleExportInfo();\n\n      this._collectAllExportsRecursive(astModuleExportInfo, entryPointAstModule, new Set<AstModule>());\n\n      entryPointAstModule.astModuleExportInfo = astModuleExportInfo;\n    }\n    return entryPointAstModule.astModuleExportInfo;\n  }\n\n  /**\n   * Returns true if the module specifier refers to an external package.  Ignores packages listed in the\n   * \"bundledPackages\" setting from the api-extractor.json config file.\n   *\n   * @remarks\n   * Examples:\n   *\n   * - NO:  `./file1`\n   * - YES: `library1/path/path`\n   * - YES: `@my-scope/my-package`\n   */\n  private _isExternalModulePath(moduleSpecifier: string): boolean {\n    if (ts.isExternalModuleNameRelative(moduleSpecifier)) {\n      return false;\n    }\n\n    const match: RegExpExecArray | null = ExportAnalyzer._modulePathRegExp.exec(moduleSpecifier);\n    if (match) {\n      // Extract \"@my-scope/my-package\" from \"@my-scope/my-package/path/module\"\n      const packageName: string = match[1];\n      if (this._bundledPackageNames.has(packageName)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Returns true if when we analyzed sourceFile, we found that it contains an \"export=\" statement that allows\n   * it to behave /either/ as an ambient module /or/ as a regular importable module.  In this case,\n   * `AstSymbolTable._fetchAstSymbol()` will analyze its symbols even though `TypeScriptHelpers.isAmbient()`\n   * returns true.\n   */\n  public isImportableAmbientSourceFile(sourceFile: ts.SourceFile): boolean {\n    return this._importableAmbientSourceFiles.has(sourceFile);\n  }\n\n  private _collectAllExportsRecursive(\n    astModuleExportInfo: AstModuleExportInfo,\n    astModule: AstModule,\n    visitedAstModules: Set<AstModule>\n  ): void {\n    if (visitedAstModules.has(astModule)) {\n      return;\n    }\n    visitedAstModules.add(astModule);\n\n    if (astModule.isExternal) {\n      astModuleExportInfo.starExportedExternalModules.add(astModule);\n    } else {\n      // Fetch each of the explicit exports for this module\n      if (astModule.moduleSymbol.exports) {\n        astModule.moduleSymbol.exports.forEach((exportSymbol, exportName) => {\n          switch (exportName) {\n            case ts.InternalSymbolName.ExportStar:\n            case ts.InternalSymbolName.ExportEquals:\n              break;\n            default:\n              // Don't collect the \"export default\" symbol unless this is the entry point module\n              if (exportName !== ts.InternalSymbolName.Default || visitedAstModules.size === 1) {\n                if (!astModuleExportInfo.exportedLocalEntities.has(exportSymbol.name)) {\n                  const astEntity: AstEntity = this._getExportOfAstModule(exportSymbol.name, astModule);\n\n                  if (astEntity instanceof AstSymbol && !astEntity.isExternal) {\n                    this._astSymbolTable.analyze(astEntity);\n                  }\n\n                  if (astEntity instanceof AstNamespaceImport && !astEntity.astModule.isExternal) {\n                    this._astSymbolTable.analyze(astEntity);\n                  }\n\n                  astModuleExportInfo.exportedLocalEntities.set(exportSymbol.name, astEntity);\n                }\n              }\n              break;\n          }\n        });\n      }\n\n      for (const starExportedModule of astModule.starExportedModules) {\n        this._collectAllExportsRecursive(astModuleExportInfo, starExportedModule, visitedAstModules);\n      }\n    }\n  }\n\n  /**\n   * For a given symbol (which was encountered in the specified sourceFile), this fetches the AstEntity that it\n   * refers to.  For example, if a particular interface describes the return value of a function, this API can help\n   * us determine a TSDoc declaration reference for that symbol (if the symbol is exported).\n   */\n  public fetchReferencedAstEntity(\n    symbol: ts.Symbol,\n    referringModuleIsExternal: boolean\n  ): AstEntity | undefined {\n    // eslint-disable-next-line no-bitwise\n    if ((symbol.flags & ts.SymbolFlags.FunctionScopedVariable) !== 0) {\n      // If a symbol refers back to part of its own definition, don't follow that rabbit hole\n      // Example:\n      //\n      // function f(x: number): typeof x {\n      //    return 123;\n      // }\n      return undefined;\n    }\n\n    let current: ts.Symbol = symbol;\n\n    if (referringModuleIsExternal) {\n      current = TypeScriptHelpers.followAliases(symbol, this._typeChecker);\n    } else {\n      for (;;) {\n        // Is this symbol an import/export that we need to follow to find the real declaration?\n        for (const declaration of current.declarations || []) {\n          let matchedAstEntity: AstEntity | undefined;\n          matchedAstEntity = this._tryMatchExportDeclaration(declaration, current);\n          if (matchedAstEntity !== undefined) {\n            return matchedAstEntity;\n          }\n          matchedAstEntity = this._tryMatchImportDeclaration(declaration, current);\n          if (matchedAstEntity !== undefined) {\n            return matchedAstEntity;\n          }\n        }\n\n        // eslint-disable-next-line no-bitwise\n        if (!(current.flags & ts.SymbolFlags.Alias)) {\n          break;\n        }\n\n        const currentAlias: ts.Symbol = TypeScriptInternals.getImmediateAliasedSymbol(\n          current,\n          this._typeChecker\n        );\n        // Stop if we reach the end of the chain\n        if (!currentAlias || currentAlias === current) {\n          break;\n        }\n\n        current = currentAlias;\n      }\n    }\n\n    // Otherwise, assume it is a normal declaration\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\n      followedSymbol: current,\n      isExternal: referringModuleIsExternal,\n      includeNominalAnalysis: false,\n      addIfMissing: true\n    });\n\n    return astSymbol;\n  }\n\n  public fetchReferencedAstEntityFromImportTypeNode(\n    node: ts.ImportTypeNode,\n    referringModuleIsExternal: boolean\n  ): AstEntity | undefined {\n    const externalModulePath: string | undefined = this._tryGetExternalModulePath(node);\n\n    if (externalModulePath) {\n      let exportName: string;\n      if (node.qualifier) {\n        // Example input:\n        //   import('api-extractor-lib1-test').Lib1GenericType<number>\n        //\n        // Extracted qualifier:\n        //   Lib1GenericType\n        exportName = node.qualifier.getText().trim();\n      } else {\n        // Example input:\n        //   import('api-extractor-lib1-test')\n        //\n        // Extracted qualifier:\n        //   apiExtractorLib1Test\n\n        exportName = SyntaxHelpers.makeCamelCaseIdentifier(externalModulePath);\n      }\n\n      return this._fetchAstImport(undefined, {\n        importKind: AstImportKind.ImportType,\n        exportName: exportName,\n        modulePath: externalModulePath,\n        isTypeOnly: false\n      });\n    }\n\n    // Internal reference: AstSymbol\n    const rightMostToken: ts.Identifier | ts.ImportTypeNode = node.qualifier\n      ? node.qualifier.kind === ts.SyntaxKind.QualifiedName\n        ? node.qualifier.right\n        : node.qualifier\n      : node;\n\n    // There is no symbol property in a ImportTypeNode, obtain the associated export symbol\n    const exportSymbol: ts.Symbol | undefined = this._typeChecker.getSymbolAtLocation(rightMostToken);\n    if (!exportSymbol) {\n      throw new InternalError(\n        `Symbol not found for identifier: ${node.getText()}\\n` +\n          SourceFileLocationFormatter.formatDeclaration(node)\n      );\n    }\n\n    let followedSymbol: ts.Symbol = exportSymbol;\n    for (;;) {\n      const referencedAstEntity: AstEntity | undefined = this.fetchReferencedAstEntity(\n        followedSymbol,\n        referringModuleIsExternal\n      );\n\n      if (referencedAstEntity) {\n        return referencedAstEntity;\n      }\n\n      const followedSymbolNode: ts.Node | ts.ImportTypeNode | undefined =\n        followedSymbol.declarations && (followedSymbol.declarations[0] as ts.Node | undefined);\n\n      if (followedSymbolNode && followedSymbolNode.kind === ts.SyntaxKind.ImportType) {\n        return this.fetchReferencedAstEntityFromImportTypeNode(\n          followedSymbolNode as ts.ImportTypeNode,\n          referringModuleIsExternal\n        );\n      }\n\n      // eslint-disable-next-line no-bitwise\n      if (!(followedSymbol.flags & ts.SymbolFlags.Alias)) {\n        break;\n      }\n\n      const currentAlias: ts.Symbol = this._typeChecker.getAliasedSymbol(followedSymbol);\n      if (!currentAlias || currentAlias === followedSymbol) {\n        break;\n      }\n\n      followedSymbol = currentAlias;\n    }\n\n    const astSymbol: AstSymbol | undefined = this._astSymbolTable.fetchAstSymbol({\n      followedSymbol: followedSymbol,\n      isExternal: referringModuleIsExternal,\n      includeNominalAnalysis: false,\n      addIfMissing: true\n    });\n\n    return astSymbol;\n  }\n\n  private _tryMatchExportDeclaration(\n    declaration: ts.Declaration,\n    declarationSymbol: ts.Symbol\n  ): AstEntity | undefined {\n    const exportDeclaration: ts.ExportDeclaration | undefined =\n      TypeScriptHelpers.findFirstParent<ts.ExportDeclaration>(declaration, ts.SyntaxKind.ExportDeclaration);\n\n    if (exportDeclaration) {\n      let exportName: string | undefined = undefined;\n\n      if (declaration.kind === ts.SyntaxKind.ExportSpecifier) {\n        // EXAMPLE:\n        // \"export { A } from './file-a';\"\n        //\n        // ExportDeclaration:\n        //   ExportKeyword:  pre=[export] sep=[ ]\n        //   NamedExports:\n        //     FirstPunctuation:  pre=[{] sep=[ ]\n        //     SyntaxList:\n        //       ExportSpecifier:  <------------- declaration\n        //         Identifier:  pre=[A] sep=[ ]\n        //     CloseBraceToken:  pre=[}] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['./file-a']\n        //   SemicolonToken:  pre=[;]\n\n        // Example: \" ExportName as RenamedName\"\n        const exportSpecifier: ts.ExportSpecifier = declaration as ts.ExportSpecifier;\n        exportName = (exportSpecifier.propertyName || exportSpecifier.name).getText().trim();\n      } else if (declaration.kind === ts.SyntaxKind.NamespaceExport) {\n        // EXAMPLE:\n        // \"export * as theLib from 'the-lib';\"\n        //\n        // ExportDeclaration:\n        //   ExportKeyword:  pre=[export] sep=[ ]\n        //   NamespaceExport:\n        //     AsteriskToken:  pre=[*] sep=[ ]\n        //     AsKeyword:  pre=[as] sep=[ ]\n        //     Identifier:  pre=[theLib] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['the-lib']\n        //   SemicolonToken:  pre=[;]\n\n        // Issue tracking this feature: https://github.com/microsoft/rushstack/issues/2780\n        throw new Error(\n          `The \"export * as ___\" syntax is not supported yet; as a workaround,` +\n            ` use \"import * as ___\" with a separate \"export { ___ }\" declaration\\n` +\n            SourceFileLocationFormatter.formatDeclaration(declaration)\n        );\n      } else {\n        throw new InternalError(\n          `Unimplemented export declaration kind: ${declaration.getText()}\\n` +\n            SourceFileLocationFormatter.formatDeclaration(declaration)\n        );\n      }\n\n      // Ignore \"export { A }\" without a module specifier\n      if (exportDeclaration.moduleSpecifier) {\n        const externalModulePath: string | undefined = this._tryGetExternalModulePath(\n          exportDeclaration,\n          declarationSymbol\n        );\n\n        if (externalModulePath !== undefined) {\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.NamedImport,\n            modulePath: externalModulePath,\n            exportName: exportName,\n            isTypeOnly: false\n          });\n        }\n\n        return this._getExportOfSpecifierAstModule(exportName, exportDeclaration, declarationSymbol);\n      }\n    }\n\n    return undefined;\n  }\n\n  private _tryMatchImportDeclaration(\n    declaration: ts.Declaration,\n    declarationSymbol: ts.Symbol\n  ): AstEntity | undefined {\n    const importDeclaration: ts.ImportDeclaration | undefined =\n      TypeScriptHelpers.findFirstParent<ts.ImportDeclaration>(declaration, ts.SyntaxKind.ImportDeclaration);\n\n    if (importDeclaration) {\n      const externalModulePath: string | undefined = this._tryGetExternalModulePath(\n        importDeclaration,\n        declarationSymbol\n      );\n\n      if (declaration.kind === ts.SyntaxKind.NamespaceImport) {\n        // EXAMPLE:\n        // \"import * as theLib from 'the-lib';\"\n        //\n        // ImportDeclaration:\n        //   ImportKeyword:  pre=[import] sep=[ ]\n        //   ImportClause:\n        //     NamespaceImport:  <------------- declaration\n        //       AsteriskToken:  pre=[*] sep=[ ]\n        //       AsKeyword:  pre=[as] sep=[ ]\n        //       Identifier:  pre=[theLib] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['the-lib']\n        //   SemicolonToken:  pre=[;]\n\n        if (externalModulePath === undefined) {\n          const astModule: AstModule = this._fetchSpecifierAstModule(importDeclaration, declarationSymbol);\n          let namespaceImport: AstNamespaceImport | undefined =\n            this._astNamespaceImportByModule.get(astModule);\n          if (namespaceImport === undefined) {\n            namespaceImport = new AstNamespaceImport({\n              namespaceName: declarationSymbol.name,\n              astModule: astModule,\n              declaration: declaration\n            });\n            this._astNamespaceImportByModule.set(astModule, namespaceImport);\n          }\n          return namespaceImport;\n        }\n\n        // Here importSymbol=undefined because {@inheritDoc} and such are not going to work correctly for\n        // a package or source file.\n        return this._fetchAstImport(undefined, {\n          importKind: AstImportKind.StarImport,\n          exportName: declarationSymbol.name,\n          modulePath: externalModulePath,\n          isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\n        });\n      }\n\n      if (declaration.kind === ts.SyntaxKind.ImportSpecifier) {\n        // EXAMPLE:\n        // \"import { A, B } from 'the-lib';\"\n        //\n        // ImportDeclaration:\n        //   ImportKeyword:  pre=[import] sep=[ ]\n        //   ImportClause:\n        //     NamedImports:\n        //       FirstPunctuation:  pre=[{] sep=[ ]\n        //       SyntaxList:\n        //         ImportSpecifier:  <------------- declaration\n        //           Identifier:  pre=[A]\n        //         CommaToken:  pre=[,] sep=[ ]\n        //         ImportSpecifier:\n        //           Identifier:  pre=[B] sep=[ ]\n        //       CloseBraceToken:  pre=[}] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['the-lib']\n        //   SemicolonToken:  pre=[;]\n\n        // Example: \" ExportName as RenamedName\"\n        const importSpecifier: ts.ImportSpecifier = declaration as ts.ImportSpecifier;\n        const exportName: string = (importSpecifier.propertyName || importSpecifier.name).getText().trim();\n\n        if (externalModulePath !== undefined) {\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.NamedImport,\n            modulePath: externalModulePath,\n            exportName: exportName,\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\n          });\n        }\n\n        return this._getExportOfSpecifierAstModule(exportName, importDeclaration, declarationSymbol);\n      } else if (declaration.kind === ts.SyntaxKind.ImportClause) {\n        // EXAMPLE:\n        // \"import A, { B } from './A';\"\n        //\n        // ImportDeclaration:\n        //   ImportKeyword:  pre=[import] sep=[ ]\n        //   ImportClause:  <------------- declaration (referring to A)\n        //     Identifier:  pre=[A]\n        //     CommaToken:  pre=[,] sep=[ ]\n        //     NamedImports:\n        //       FirstPunctuation:  pre=[{] sep=[ ]\n        //       SyntaxList:\n        //         ImportSpecifier:\n        //           Identifier:  pre=[B] sep=[ ]\n        //       CloseBraceToken:  pre=[}] sep=[ ]\n        //   FromKeyword:  pre=[from] sep=[ ]\n        //   StringLiteral:  pre=['./A']\n        //   SemicolonToken:  pre=[;]\n\n        const importClause: ts.ImportClause = declaration as ts.ImportClause;\n        const exportName: string = importClause.name\n          ? importClause.name.getText().trim()\n          : ts.InternalSymbolName.Default;\n\n        if (externalModulePath !== undefined) {\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.DefaultImport,\n            modulePath: externalModulePath,\n            exportName,\n            isTypeOnly: ExportAnalyzer._getIsTypeOnly(importDeclaration)\n          });\n        }\n\n        return this._getExportOfSpecifierAstModule(\n          ts.InternalSymbolName.Default,\n          importDeclaration,\n          declarationSymbol\n        );\n      } else {\n        throw new InternalError(\n          `Unimplemented import declaration kind: ${declaration.getText()}\\n` +\n            SourceFileLocationFormatter.formatDeclaration(declaration)\n        );\n      }\n    }\n\n    if (ts.isImportEqualsDeclaration(declaration)) {\n      // EXAMPLE:\n      // import myLib = require('my-lib');\n      //\n      // ImportEqualsDeclaration:\n      //   ImportKeyword:  pre=[import] sep=[ ]\n      //   Identifier:  pre=[myLib] sep=[ ]\n      //   FirstAssignment:  pre=[=] sep=[ ]\n      //   ExternalModuleReference:\n      //     RequireKeyword:  pre=[require]\n      //     OpenParenToken:  pre=[(]\n      //     StringLiteral:  pre=['my-lib']\n      //     CloseParenToken:  pre=[)]\n      //   SemicolonToken:  pre=[;]\n      if (ts.isExternalModuleReference(declaration.moduleReference)) {\n        if (ts.isStringLiteralLike(declaration.moduleReference.expression)) {\n          const variableName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(declaration.name);\n          const externalModuleName: string = TypeScriptInternals.getTextOfIdentifierOrLiteral(\n            declaration.moduleReference.expression\n          );\n\n          return this._fetchAstImport(declarationSymbol, {\n            importKind: AstImportKind.EqualsImport,\n            modulePath: externalModuleName,\n            exportName: variableName,\n            isTypeOnly: false\n          });\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private static _getIsTypeOnly(importDeclaration: ts.ImportDeclaration): boolean {\n    if (importDeclaration.importClause) {\n      return !!importDeclaration.importClause.isTypeOnly;\n    }\n    return false;\n  }\n\n  private _getExportOfSpecifierAstModule(\n    exportName: string,\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\n    exportSymbol: ts.Symbol\n  ): AstEntity {\n    const specifierAstModule: AstModule = this._fetchSpecifierAstModule(\n      importOrExportDeclaration,\n      exportSymbol\n    );\n    const astEntity: AstEntity = this._getExportOfAstModule(exportName, specifierAstModule);\n    return astEntity;\n  }\n\n  private _getExportOfAstModule(exportName: string, astModule: AstModule): AstEntity {\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\n    const astEntity: AstEntity | undefined = this._tryGetExportOfAstModule(\n      exportName,\n      astModule,\n      visitedAstModules\n    );\n    if (astEntity === undefined) {\n      throw new InternalError(\n        `Unable to analyze the export ${JSON.stringify(exportName)} in\\n` + astModule.sourceFile.fileName\n      );\n    }\n    return astEntity;\n  }\n\n  /**\n   * Implementation of {@link AstSymbolTable.tryGetExportOfAstModule}.\n   */\n  public tryGetExportOfAstModule(exportName: string, astModule: AstModule): AstEntity | undefined {\n    const visitedAstModules: Set<AstModule> = new Set<AstModule>();\n    return this._tryGetExportOfAstModule(exportName, astModule, visitedAstModules);\n  }\n\n  private _tryGetExportOfAstModule(\n    exportName: string,\n    astModule: AstModule,\n    visitedAstModules: Set<AstModule>\n  ): AstEntity | undefined {\n    if (visitedAstModules.has(astModule)) {\n      return undefined;\n    }\n    visitedAstModules.add(astModule);\n\n    let astEntity: AstEntity | undefined = astModule.cachedExportedEntities.get(exportName);\n    if (astEntity !== undefined) {\n      return astEntity;\n    }\n\n    // Try the explicit exports\n    const escapedExportName: ts.__String = ts.escapeLeadingUnderscores(exportName);\n    if (astModule.moduleSymbol.exports) {\n      const exportSymbol: ts.Symbol | undefined = astModule.moduleSymbol.exports.get(escapedExportName);\n      if (exportSymbol) {\n        astEntity = this.fetchReferencedAstEntity(exportSymbol, astModule.isExternal);\n\n        if (astEntity !== undefined) {\n          astModule.cachedExportedEntities.set(exportName, astEntity); // cache for next time\n          return astEntity;\n        }\n      }\n    }\n\n    // Try each of the star imports\n    for (const starExportedModule of astModule.starExportedModules) {\n      astEntity = this._tryGetExportOfAstModule(exportName, starExportedModule, visitedAstModules);\n\n      if (astEntity !== undefined) {\n        if (starExportedModule.externalModulePath !== undefined) {\n          // This entity was obtained from an external module, so return an AstImport instead\n          const astSymbol: AstSymbol = astEntity as AstSymbol;\n          return this._fetchAstImport(astSymbol.followedSymbol, {\n            importKind: AstImportKind.NamedImport,\n            modulePath: starExportedModule.externalModulePath,\n            exportName: exportName,\n            isTypeOnly: false\n          });\n        }\n\n        return astEntity;\n      }\n    }\n\n    return undefined;\n  }\n\n  private _tryGetExternalModulePath(\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration | ts.ImportTypeNode,\n    exportSymbol?: ts.Symbol\n  ): string | undefined {\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\n    const moduleSpecifier: string | undefined =\n      TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\n    if (!moduleSpecifier) {\n      throw new InternalError(\n        'Unable to parse module specifier\\n' +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    // Match:       \"@microsoft/sp-lodash-subset\" or \"lodash/has\"\n    // but ignore:  \"../folder/LocalFile\"\n    if (this._isExternalModulePath(moduleSpecifier)) {\n      return moduleSpecifier;\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Given an ImportDeclaration of the form `export { X } from \"___\";`, this interprets the module specifier (`\"___\"`)\n   * and fetches the corresponding AstModule object.\n   */\n  private _fetchSpecifierAstModule(\n    importOrExportDeclaration: ts.ImportDeclaration | ts.ExportDeclaration,\n    exportSymbol: ts.Symbol\n  ): AstModule {\n    // The name of the module, which could be like \"./SomeLocalFile' or like 'external-package/entry/point'\n    const moduleSpecifier: string | undefined =\n      TypeScriptHelpers.getModuleSpecifier(importOrExportDeclaration);\n    if (!moduleSpecifier) {\n      throw new InternalError(\n        'Unable to parse module specifier\\n' +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    const resolvedModule: ts.ResolvedModuleFull | undefined = TypeScriptInternals.getResolvedModule(\n      importOrExportDeclaration.getSourceFile(),\n      moduleSpecifier\n    );\n\n    if (resolvedModule === undefined) {\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\n      // found in export declarations for this source file\n      //\n      // Encountered in https://github.com/microsoft/rushstack/issues/1914\n      throw new InternalError(\n        `getResolvedModule() could not resolve module name ${JSON.stringify(moduleSpecifier)}\\n` +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    // Map the filename back to the corresponding SourceFile. This circuitous approach is needed because\n    // we have no way to access the compiler's internal resolveExternalModuleName() function\n    const moduleSourceFile: ts.SourceFile | undefined = this._program.getSourceFile(\n      resolvedModule.resolvedFileName\n    );\n    if (!moduleSourceFile) {\n      // This should not happen, since getResolvedModule() specifically looks up names that the compiler\n      // found in export declarations for this source file\n      throw new InternalError(\n        `getSourceFile() failed to locate ${JSON.stringify(resolvedModule.resolvedFileName)}\\n` +\n          SourceFileLocationFormatter.formatDeclaration(importOrExportDeclaration)\n      );\n    }\n\n    const moduleReference: IAstModuleReference = {\n      moduleSpecifier: moduleSpecifier,\n      moduleSpecifierSymbol: exportSymbol\n    };\n    const specifierAstModule: AstModule = this.fetchAstModuleFromSourceFile(\n      moduleSourceFile,\n      moduleReference\n    );\n\n    return specifierAstModule;\n  }\n\n  private _fetchAstImport(importSymbol: ts.Symbol | undefined, options: IAstImportOptions): AstImport {\n    const key: string = AstImport.getKey(options);\n\n    let astImport: AstImport | undefined = this._astImportsByKey.get(key);\n\n    if (!astImport) {\n      astImport = new AstImport(options);\n      this._astImportsByKey.set(key, astImport);\n\n      if (importSymbol) {\n        const followedSymbol: ts.Symbol = TypeScriptHelpers.followAliases(importSymbol, this._typeChecker);\n\n        astImport.astSymbol = this._astSymbolTable.fetchAstSymbol({\n          followedSymbol: followedSymbol,\n          isExternal: true,\n          includeNominalAnalysis: false,\n          addIfMissing: true\n        });\n      }\n    } else {\n      // If we encounter at least one import that does not use the type-only form,\n      // then the .d.ts rollup will NOT use \"import type\".\n      if (!options.isTypeOnly) {\n        astImport.isTypeOnlyEverywhere = false;\n      }\n    }\n\n    return astImport;\n  }\n}\n"]}