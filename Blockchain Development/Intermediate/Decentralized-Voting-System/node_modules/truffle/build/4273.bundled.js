#!/usr/bin/env node

exports.id = 4273;
exports.ids = [4273];
exports.modules = {

/***/ 18957:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emptyWorkflowCompileResult = exports.promoteCompileResult = void 0;
function promoteCompileResult(result) {
    const { compilations } = result;
    const contracts = compilations.flatMap(compilation => compilation.contracts);
    return { compilations, contracts };
}
exports.promoteCompileResult = promoteCompileResult;
function emptyWorkflowCompileResult() {
    return { compilations: [], contracts: [] };
}
exports.emptyWorkflowCompileResult = emptyWorkflowCompileResult;
//# sourceMappingURL=compilations.js.map

/***/ }),

/***/ 62575:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompileError = void 0;
const colors_1 = __importDefault(__webpack_require__(83196));
const error_1 = __importDefault(__webpack_require__(73321));
class CompileError extends error_1.default {
    constructor(message) {
        // Note we trim() because solc likes to add extra whitespace.
        var fancy_message = message.trim() + "\n\n" + colors_1.default.red("Compilation failed. See above.");
        var normal_message = message.trim();
        super(normal_message);
        this.message = fancy_message; //?? I don't understand this, I just found it here
    }
}
exports.CompileError = CompileError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 29833:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Compilations = exports.Errors = exports.Sources = exports.Shims = void 0;
exports.Shims = __importStar(__webpack_require__(53304));
exports.Sources = __importStar(__webpack_require__(2543));
exports.Errors = __importStar(__webpack_require__(62575));
exports.Compilations = __importStar(__webpack_require__(18957));
__exportStar(__webpack_require__(40963), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99164:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forBytecode = exports.forContract = exports.forContracts = void 0;
function forContracts(contracts) {
    // convert to list
    return Object.values(contracts).map(forContract);
}
exports.forContracts = forContracts;
function forContract(contract) {
    const { contractName, contract_name, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;
    return {
        contractName: contract_name || contractName,
        sourcePath,
        source,
        sourceMap,
        deployedSourceMap,
        legacyAST,
        ast,
        abi,
        metadata,
        bytecode: bytecode ? forBytecode(bytecode) : undefined,
        deployedBytecode: deployedBytecode
            ? forBytecode(deployedBytecode)
            : undefined,
        compiler,
        devdoc,
        userdoc,
        immutableReferences,
        generatedSources,
        deployedGeneratedSources,
        db
    };
}
exports.forContract = forContract;
function forBytecode(bytecode) {
    if (typeof bytecode === "object") {
        return bytecode;
    }
    const linkReferences = [];
    const bytes = bytecode
        .slice(2) // remove 0x prefix
        .replace(/__[^_]+_*/g, (linkReference, characterOffset) => {
        const match = linkReference.match(/__([^_]+)_*/);
        if (match === null) {
            //this can't actually happen, but strictNullChecks requires it
            throw new Error("Could not extract link reference name");
        }
        const name = match[1];
        const characterLength = linkReference.length;
        const offset = characterOffset / 2;
        const length = characterLength / 2;
        linkReferences.push({
            offsets: [offset],
            name,
            length
        });
        return "0".repeat(characterLength);
    });
    return { bytes, linkReferences };
}
exports.forBytecode = forBytecode;
//# sourceMappingURL=LegacyToNew.js.map

/***/ }),

/***/ 26624:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forBytecode = exports.forContract = void 0;
function forContract(contract) {
    const { contractName, sourcePath, source, sourceMap, deployedSourceMap, legacyAST, ast, abi, metadata, bytecode, deployedBytecode, compiler, devdoc, userdoc, immutableReferences, generatedSources, deployedGeneratedSources, db } = contract;
    return {
        contract_name: contractName,
        sourcePath,
        source,
        sourceMap,
        deployedSourceMap,
        legacyAST,
        ast,
        abi,
        metadata,
        bytecode: forBytecode(bytecode),
        deployedBytecode: forBytecode(deployedBytecode),
        unlinked_binary: forBytecode(bytecode),
        compiler,
        devdoc,
        userdoc,
        immutableReferences,
        generatedSources,
        deployedGeneratedSources,
        db
    };
}
exports.forContract = forContract;
function forBytecode(bytecode) {
    if (!bytecode) {
        return bytecode;
    }
    if (typeof bytecode === "string") {
        return bytecode;
    }
    let { bytes, linkReferences } = bytecode;
    linkReferences = linkReferences || [];
    // inline link references - start by flattening the offsets
    const flattenedLinkReferences = linkReferences
        // map each link ref to array of link refs with only one offset
        .map(({ offsets, length, name }) => offsets.map(offset => ({ offset, length, name })))
        // flatten
        .reduce((a, b) => [...a, ...b], []);
    // then overwite bytes with link reference
    bytes = flattenedLinkReferences.reduce((bytes, { offset, name, length }) => {
        // length is a byte offset
        const characterLength = length * 2;
        let linkId = `__${name.slice(0, characterLength - 2)}`;
        while (linkId.length < characterLength) {
            linkId += "_";
        }
        const start = offset * 2;
        return `${bytes.substring(0, start)}${linkId}${bytes.substring(start + characterLength)}`;
    }, bytes);
    return `0x${bytes}`;
}
exports.forBytecode = forBytecode;
//# sourceMappingURL=NewToLegacy.js.map

/***/ }),

/***/ 53304:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewToLegacy = exports.LegacyToNew = void 0;
exports.LegacyToNew = __importStar(__webpack_require__(99164));
exports.NewToLegacy = __importStar(__webpack_require__(26624));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 2543:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collectSources = void 0;
const path = __importStar(__webpack_require__(71017));
/**
 * Collects sources, targets into collections with OS-independent paths,
 * along with a reverse mapping to the original path (for post-processing)
 *
 * @param originalSources - { [originalSourcePath]: contents }
 * @param originalTargets - originalSourcePath[]
 * @param baseDirectory - a directory to remove as a prefix
 * @param replacement - what to replace it with
 * @return { sources, targets, originalSourcePaths }
 */
function collectSources(originalSources, originalTargets = [], baseDirectory = "", replacement = "/") {
    const mappedResults = Object.entries(originalSources)
        .filter(([originalSourcePath, _]) => !path.isAbsolute(originalSourcePath) ||
        originalSourcePath.startsWith(baseDirectory))
        .map(([originalSourcePath, contents]) => ({
        originalSourcePath,
        contents,
        sourcePath: getPortableSourcePath(replaceRootDirectory(originalSourcePath, baseDirectory, replacement))
    }))
        .map(({ originalSourcePath, sourcePath, contents }) => ({
        sources: {
            [sourcePath]: contents
        },
        // include transformed form as target if original is a target
        targets: originalTargets.includes(originalSourcePath) ? [sourcePath] : [],
        originalSourcePaths: {
            [sourcePath]: originalSourcePath
        }
    }));
    const defaultAccumulator = {
        sources: {},
        targets: [],
        originalSourcePaths: {}
    };
    return mappedResults.reduce((accumulator, result) => ({
        sources: Object.assign({}, accumulator.sources, result.sources),
        targets: [...accumulator.targets, ...result.targets],
        originalSourcePaths: Object.assign({}, accumulator.originalSourcePaths, result.originalSourcePaths)
    }), defaultAccumulator);
}
exports.collectSources = collectSources;
/**
 * @param sourcePath - string
 * @return string - operating system independent path
 * @private
 */
function getPortableSourcePath(sourcePath) {
    let replacement = sourcePath;
    //on Windows, replace backslashes with forward slashes
    if (path.sep === "\\") {
        replacement = sourcePath.replace(/\\/g, "/");
    }
    // Turn G:/.../ into /G/.../ for Windows
    if (replacement.length >= 2 && replacement[1] === ":") {
        replacement = "/" + replacement;
        replacement = replacement.replace(":", "");
    }
    return replacement;
}
function replaceRootDirectory(sourcePath, rootDirectory, replacement) {
    //make sure root directory ends in a separator
    if (!rootDirectory.endsWith(path.sep)) {
        rootDirectory = rootDirectory + path.sep;
    }
    return sourcePath.startsWith(rootDirectory)
        ? replacement + sourcePath.slice(rootDirectory.length) //remove prefix
        : sourcePath;
}
//# sourceMappingURL=sources.js.map

/***/ }),

/***/ 40963:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 63505:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compileWithPragmaAnalysis = void 0;
const compilerSupplier_1 = __webpack_require__(47922);
const config_1 = __importDefault(__webpack_require__(20553));
const semver_1 = __importDefault(__webpack_require__(81249));
const profiler_1 = __webpack_require__(22860);
const run_1 = __webpack_require__(71193);
const reportSources_1 = __webpack_require__(77897);
const os_1 = __importDefault(__webpack_require__(22037));
const cloneDeep_1 = __importDefault(__webpack_require__(50361));
const getSemverExpression = source => {
    const result = source.match(/pragma solidity(.*);/);
    return result && result[1] ? result[1].trim() : undefined;
};
const getSemverExpressions = sources => {
    return sources
        .map(source => getSemverExpression(source))
        .filter(expression => expression);
};
const validateSemverExpressions = semverExpressions => {
    for (const expression of semverExpressions) {
        if (semver_1.default.validRange(expression) === null) {
            const message = `Invalid semver expression (${expression}) found in ` +
                `one of your contract's imports.`;
            throw new Error(message);
        }
    }
};
// takes an array of versions and an array of semver expressions
// returns a version of the compiler or undefined if none can be found
const findNewestSatisfyingVersion = ({ solcReleases, semverExpressions }) => {
    // releases are ordered from newest to oldest
    return solcReleases.find(version => {
        return semverExpressions.every(expression => semver_1.default.satisfies(version, expression));
    });
};
const throwCompilerVersionNotFound = ({ path, semverExpressions }) => {
    const message = `Could not find a single version of the Solidity compiler that ` +
        `satisfies the following semver expressions obtained from your source ` +
        `files' pragma statements: ${semverExpressions.join(" - ")}. ` +
        `${os_1.default.EOL}Please check the pragma statements for ${path} and its imports.`;
    throw new Error(message);
};
const compileWithPragmaAnalysis = ({ paths, options }) => __awaiter(void 0, void 0, void 0, function* () {
    //don't compile if there's yul
    const yulPath = paths.find(path => path.endsWith(".yul"));
    if (yulPath !== undefined) {
        throw new Error(`Paths to compile includes Yul source ${yulPath}.  ` +
            `Pragma analysis is not supported when compiling Yul.`);
    }
    const filteredPaths = paths.filter(path => path.endsWith(".sol") || path.endsWith(".json"));
    if (filteredPaths.length === 0) {
        return { compilations: [] };
    }
    // construct supplier options for fetching list of solc versions;
    // enforce no Docker because listing Docker versions is slow (Docker Hub API
    // paginates responses, with >500 pages at time of writing)
    const supplierOptions = {
        events: options.events,
        solcConfig: Object.assign(Object.assign({}, options.compilers.solc), { docker: false })
    };
    const compilerSupplier = new compilerSupplier_1.CompilerSupplier(supplierOptions);
    const { releases } = yield compilerSupplier.list();
    // collect sources by the version of the Solidity compiler that they require
    const versionsAndSources = {};
    for (const path of filteredPaths) {
        const source = (yield options.resolver.resolve(path)).body;
        const parserVersion = findNewestSatisfyingVersion({
            solcReleases: releases,
            semverExpressions: [getSemverExpression(source)]
        });
        if (!parserVersion) {
            const m = `Could not find a valid pragma expression in ${path}. To use the ` +
                `"pragma" compiler setting your contracts must contain a pragma ` +
                `expression.`;
            throw new Error(m);
        }
        // allSources is of the format { [filename]: string }
        const { allSources } = yield profiler_1.Profiler.requiredSourcesForSingleFile(options.with({
            path,
            base_path: options.contracts_directory,
            resolver: options.resolver,
            compiler: {
                name: "solc",
                version: parserVersion
            },
            compilers: {
                solc: {
                    version: parserVersion
                }
            }
        }));
        // get an array of all the semver expressions in the sources
        const semverExpressions = yield getSemverExpressions(Object.values(allSources));
        // this really just validates the expressions from the contracts' imports
        // as it has already determined the parser version for each contract
        validateSemverExpressions(semverExpressions);
        const newestSatisfyingVersion = findNewestSatisfyingVersion({
            solcReleases: releases,
            semverExpressions
        });
        if (!newestSatisfyingVersion) {
            throwCompilerVersionNotFound({
                path,
                semverExpressions
            });
        }
        versionsAndSources[newestSatisfyingVersion] = Object.assign(Object.assign({}, versionsAndSources[newestSatisfyingVersion]), allSources);
    }
    (0, reportSources_1.reportSources)({ paths: filteredPaths, options });
    const compilations = [];
    for (const compilerVersion in versionsAndSources) {
        const compilationOptions = {
            compilers: (0, cloneDeep_1.default)(options.compilers)
        };
        compilationOptions.compilers.solc.version = compilerVersion;
        const config = config_1.default.default().with(compilationOptions);
        const compilation = yield (0, run_1.run)(versionsAndSources[compilerVersion], config);
        if (compilation && Object.keys(compilation.contracts).length > 0) {
            compilations.push(compilation);
        }
    }
    return { compilations };
});
exports.compileWithPragmaAnalysis = compileWithPragmaAnalysis;
//# sourceMappingURL=compileWithPragmaAnalysis.js.map

/***/ }),

/***/ 46405:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cache = void 0;
const config_1 = __importDefault(__webpack_require__(20553));
const path_1 = __importDefault(__webpack_require__(71017));
const fs_1 = __importDefault(__webpack_require__(57147));
// @ts-ignore
const fsPromises = __importStar(__webpack_require__(73292));
const fileNotFoundMessage = "no such file or directory";
class Cache {
    constructor() {
        const compilersDir = path_1.default.resolve(config_1.default.getTruffleDataDirectory(), "compilers");
        const compilerCachePath = path_1.default.resolve(compilersDir, "node_modules"); // because babel binds to require & does weird things
        if (!fs_1.default.existsSync(compilersDir))
            fs_1.default.mkdirSync(compilersDir);
        if (!fs_1.default.existsSync(compilerCachePath))
            fs_1.default.mkdirSync(compilerCachePath); // for 5.0.8 users
        this.compilerCachePath = compilerCachePath;
        this.memoizedCompilers = new Map();
    }
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield fsPromises.readdir(this.compilerCachePath);
        });
    }
    add(code, fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = this.resolve(fileName);
            yield fsPromises.writeFile(filePath, code);
            this.memoizedCompilers.set(filePath, code);
        });
    }
    has(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = this.resolve(fileName);
            try {
                yield fsPromises.stat(filePath);
                return true;
            }
            catch (error) {
                // only throw if the error is due to something other than it not existing
                if (!error.message.includes(fileNotFoundMessage)) {
                    throw error;
                }
                return false;
            }
        });
    }
    loadFile(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const filePath = this.resolve(fileName);
            if (this.memoizedCompilers.has(filePath)) {
                return this.memoizedCompilers.get(filePath);
            }
            try {
                const compiler = (yield fsPromises.readFile(filePath)).toString();
                this.memoizedCompilers.set(filePath, compiler);
                return compiler;
            }
            catch (error) {
                if (!error.message.includes(fileNotFoundMessage)) {
                    throw error;
                }
                else {
                    throw new Error("The specified file could not be found.");
                }
            }
        });
    }
    resolve(fileName) {
        return path_1.default.resolve(this.compilerCachePath, fileName);
    }
}
exports.Cache = Cache;
//# sourceMappingURL=Cache.js.map

/***/ }),

/***/ 40329:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FailedRequestError = exports.CompilerFetchingError = exports.NoVersionError = void 0;
class NoVersionError extends Error {
    constructor(input) {
        const message = `Could not find a compiler version matching ${input}. ` +
            `Please ensure you are specifying a valid version, constraint or ` +
            `build in the truffle config. Run \`truffle compile --list\` to ` +
            `see available versions.`;
        super(message);
    }
}
exports.NoVersionError = NoVersionError;
class CompilerFetchingError extends Error {
    constructor(compilerRoots) {
        const message = `Failed to fetch the Solidity compiler from the following locations: ` +
            `${compilerRoots}. Are you connected to the internet?\n\n`;
        super(message);
    }
}
exports.CompilerFetchingError = CompilerFetchingError;
class FailedRequestError extends Error {
    constructor(input, error) {
        const message = `Failed to complete request to: ${input}. Are you connected to ` +
            `the internet?\n\n` +
            error;
        super(message);
    }
}
exports.FailedRequestError = FailedRequestError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 47922:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StrategyCannotListVersionsError = exports.BadInputError = exports.CompilerSupplier = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const fs_1 = __importDefault(__webpack_require__(57147));
const semver_1 = __importDefault(__webpack_require__(81249));
const loadingStrategies_1 = __webpack_require__(41514);
const defaultSolcVersion = "0.5.16";
class CompilerSupplier {
    constructor({ events, solcConfig }) {
        const { version, docker, compilerRoots, dockerTagsUrl, spawn } = solcConfig;
        this.version = version ? version : defaultSolcVersion;
        this.docker = docker;
        this.strategyOptions = {};
        if (version)
            this.strategyOptions.version = this.version;
        if (dockerTagsUrl)
            this.strategyOptions.dockerTagsUrl = dockerTagsUrl;
        if (compilerRoots)
            this.strategyOptions.compilerRoots = compilerRoots;
        if (events)
            this.strategyOptions.events = events;
        if (spawn)
            this.strategyOptions.spawn = spawn;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const userSpecification = this.version;
            let strategy;
            const useDocker = this.docker;
            const useNative = userSpecification === "native";
            const useSpecifiedLocal = userSpecification &&
                (fs_1.default.existsSync(userSpecification) || path_1.default.isAbsolute(userSpecification));
            const isValidVersionRange = semver_1.default.validRange(userSpecification);
            if (useDocker) {
                strategy = new loadingStrategies_1.Docker(this.strategyOptions);
            }
            else if (useNative) {
                strategy = new loadingStrategies_1.Native();
            }
            else if (useSpecifiedLocal) {
                strategy = new loadingStrategies_1.Local();
            }
            else if (isValidVersionRange) {
                strategy = new loadingStrategies_1.VersionRange(this.strategyOptions);
            }
            if (strategy) {
                const solc = yield strategy.load(userSpecification);
                return { solc };
            }
            else {
                throw new BadInputError(userSpecification);
            }
        });
    }
    /**
     * This function lists known solc versions, possibly asynchronously to
     * account for APIs with paginated data (namely, Docker Hub)
     *
     * @return Promise<{
     *           prereleases: AsyncIterable<string>;
     *           releases: AsyncIterable<string>;
     *           latestRelease: string;
     *         }>
     */
    list() {
        return __awaiter(this, void 0, void 0, function* () {
            const userSpecification = this.version;
            let strategy;
            const useDocker = this.docker;
            const useNative = userSpecification === "native";
            const useSpecifiedLocal = userSpecification &&
                (fs_1.default.existsSync(userSpecification) || path_1.default.isAbsolute(userSpecification));
            const isValidVersionRange = semver_1.default.validRange(userSpecification) || userSpecification === "pragma";
            if (useDocker) {
                strategy = new loadingStrategies_1.Docker(this.strategyOptions);
            }
            else if (useNative) {
                strategy = new loadingStrategies_1.Native();
            }
            else if (useSpecifiedLocal) {
                strategy = new loadingStrategies_1.Local();
            }
            else if (isValidVersionRange) {
                strategy = new loadingStrategies_1.VersionRange(this.strategyOptions);
            }
            if (!strategy) {
                throw new BadInputError(userSpecification);
            }
            if ("list" in strategy) {
                return yield strategy.list();
            }
            throw new StrategyCannotListVersionsError(strategy.constructor.name);
        });
    }
    static getDefaultVersion() {
        return defaultSolcVersion;
    }
}
exports.CompilerSupplier = CompilerSupplier;
class BadInputError extends Error {
    constructor(input) {
        const message = `Could not find a compiler version matching ${input}. ` +
            `compilers.solc.version option must be a string specifying:\n` +
            `   - a path to a locally installed solcjs\n` +
            `   - a solc version or range (ex: '0.4.22' or '^0.5.0')\n` +
            `   - a docker image name (ex: 'stable')\n` +
            `   - 'native' to use natively installed solc\n`;
        super(message);
    }
}
exports.BadInputError = BadInputError;
class StrategyCannotListVersionsError extends Error {
    constructor(strategyName) {
        super(`Cannot list versions for strategy ${strategyName}`);
    }
}
exports.StrategyCannotListVersionsError = StrategyCannotListVersionsError;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 48352:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoStringError = exports.NoDockerError = exports.Docker = void 0;
// must polyfill AbortController to use axios >=0.20.0, <=0.27.2 on node <= v14.x
__webpack_require__(19492);
const axios_1 = __importDefault(__webpack_require__(43306));
const axios_retry_1 = __importDefault(__webpack_require__(42817));
// @ts-ignore
const fs_1 = __importDefault(__webpack_require__(57147));
const child_process_1 = __webpack_require__(32081);
const semver_1 = __importDefault(__webpack_require__(81249));
const Cache_1 = __webpack_require__(46405);
const normalizeSolcVersion_1 = __webpack_require__(69738);
const errors_1 = __webpack_require__(40329);
const iter_tools_1 = __webpack_require__(84248);
class Docker {
    constructor(options) {
        const defaultConfig = {
            dockerTagsUrl: "https://registry.hub.docker.com/v2/repositories/ethereum/solc/tags/"
        };
        this.config = Object.assign({}, defaultConfig, options);
        this.cache = new Cache_1.Cache();
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            // Set a sensible limit for maxBuffer
            // See https://github.com/nodejs/node/pull/23027
            let maxBuffer = 1024 * 1024 * 100;
            if (this.config.spawn && this.config.spawn.maxBuffer) {
                maxBuffer = this.config.spawn.maxBuffer;
            }
            const versionString = yield this.validateAndGetSolcVersion();
            const command = "docker run --platform=linux/amd64 --rm -i ethereum/solc:" +
                this.config.version +
                " --standard-json";
            try {
                return {
                    compile: options => String((0, child_process_1.execSync)(command, { input: options, maxBuffer })),
                    version: () => versionString
                };
            }
            catch (error) {
                if (error.message === "No matching version found") {
                    throw new errors_1.NoVersionError(versionString);
                }
                throw error;
            }
        });
    }
    /**
     * Fetch list of solc versions available as Docker images.
     *
     * This returns a promise for an object with three fields:
     *   { latestRelease, releases, prereleases }
     * NOTE that `releases` and `prereleases` in this object are both
     * AsyncIterableIterators (thus, use only `for await (const ...)` to consume)
     */
    list() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const allTags = this.streamAllDockerTags();
            // split stream of all tags into separate releases and prereleases streams
            const isRelease = name => !!semver_1.default.valid(name);
            const isPrerelease = name => name.match(/nightly/);
            const [allTagsA, allTagsB] = (0, iter_tools_1.asyncFork)(allTags);
            // construct prereleases stream
            const prereleases = (0, iter_tools_1.asyncFilter)(isPrerelease, allTagsB);
            // construct releases stream and immediately fork so as to allow consuming
            // the first value in the stream safely
            const [releases, forkedReleases] = (0, iter_tools_1.asyncFork)((0, iter_tools_1.asyncFilter)(isRelease, allTagsA));
            // grab the latest release from the forked releases stream;
            // coerce semver to remove possible `-alpine` suffix used by this repo
            const latestRelease = (_a = semver_1.default.coerce(yield (0, iter_tools_1.asyncFirst)(forkedReleases))) === null || _a === void 0 ? void 0 : _a.version;
            return {
                prereleases,
                releases,
                latestRelease
            };
        });
    }
    /*
     * Private methods
     */
    downloadDockerImage(image) {
        if (!semver_1.default.valid(image)) {
            const message = `The image version you have provided is not valid.\n` +
                `Please ensure that ${image} is a valid docker image name.`;
            throw new Error(message);
        }
        this.config.events.emit("compile:downloadDockerImage:start");
        try {
            (0, child_process_1.execSync)(`docker pull ethereum/solc:${image}`);
            this.config.events.emit("compile:downloadDockerImage:succeed");
        }
        catch (error) {
            this.config.events.emit("compile:downloadDockerImage:fail", { error });
        }
    }
    validateAndGetSolcVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            const image = this.config.version;
            const fileName = image + ".version";
            // Skip validation if they've validated for this image before.
            if (yield this.cache.has(fileName)) {
                const cachePath = this.cache.resolve(fileName);
                return fs_1.default.readFileSync(cachePath, "utf-8");
            }
            // Image specified
            if (!image)
                throw new NoStringError(image);
            // Docker exists locally
            try {
                (0, child_process_1.execSync)("docker -v");
            }
            catch (error) {
                throw new NoDockerError();
            }
            // Image exists locally
            try {
                (0, child_process_1.execSync)("docker inspect --type=image ethereum/solc:" + image);
            }
            catch (error) {
                console.log(`${image} does not exist locally.\n`);
                this.downloadDockerImage(image);
            }
            // Get version & cache.
            const version = (0, child_process_1.execSync)("docker run --platform=linux/amd64 ethereum/solc:" + image + " --version");
            const normalized = (0, normalizeSolcVersion_1.normalizeSolcVersion)(version);
            yield this.cache.add(normalized, fileName);
            return normalized;
        });
    }
    streamAllDockerTags() {
        // build http client to account for rate limit problems
        // use axiosRetry to instate exponential backoff when requests come back
        // with expected 429
        const client = axios_1.default.create();
        (0, axios_retry_1.default)(client, {
            retries: 5,
            retryDelay: axios_retry_1.default.exponentialDelay,
            shouldResetTimeout: true,
            retryCondition: error => {
                const tooManyRequests = !!(error &&
                    error.response &&
                    error.response.status === 429);
                return (axios_retry_1.default.isNetworkOrIdempotentRequestError(error) || tooManyRequests);
            }
        });
        const { dockerTagsUrl } = this.config;
        let nextUrl = dockerTagsUrl;
        return (function () {
            return __asyncGenerator(this, arguments, function* () {
                do {
                    try {
                        const { data: { 
                        // page of results
                        results, 
                        // next page url
                        next } } = yield __await(client.get(nextUrl, { maxRedirects: 50 }));
                        for (const { name } of results) {
                            yield yield __await(name);
                        }
                        nextUrl = next;
                    }
                    catch (error) {
                        throw new errors_1.FailedRequestError(dockerTagsUrl, error);
                    }
                } while (nextUrl);
            });
        })();
    }
}
exports.Docker = Docker;
class NoDockerError extends Error {
    constructor() {
        super("You are trying to run dockerized solc, but docker is not installed.");
    }
}
exports.NoDockerError = NoDockerError;
class NoStringError extends Error {
    constructor(input) {
        const message = "`compilers.solc.version` option must be a string specifying:\n" +
            "   - a path to a locally installed solcjs\n" +
            "   - a solc version or range (ex: '0.4.22' or '^0.5.0')\n" +
            "   - a docker image name (ex: 'stable')\n" +
            "   - 'native' to use natively installed solc\n" +
            "Received: " +
            input +
            " instead.";
        super(message);
    }
}
exports.NoStringError = NoStringError;
//# sourceMappingURL=Docker.js.map

/***/ }),

/***/ 8831:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoPathError = exports.Local = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const original_require_1 = __importDefault(__webpack_require__(44516));
const wrapper_1 = __importDefault(__webpack_require__(11433));
const observeListeners_1 = __webpack_require__(60207);
class Local {
    load(localPath) {
        const listeners = (0, observeListeners_1.observeListeners)();
        try {
            const compilerPath = path_1.default.isAbsolute(localPath)
                ? localPath
                : path_1.default.resolve(process.cwd(), localPath);
            let soljson;
            try {
                soljson = (0, original_require_1.default)(compilerPath);
            }
            catch (error) {
                throw new NoPathError(localPath, error);
            }
            //HACK: if it has a compile function, assume it's already wrapped
            return soljson.compile ? soljson : (0, wrapper_1.default)(soljson);
        }
        finally {
            listeners.cleanup();
        }
    }
}
exports.Local = Local;
class NoPathError extends Error {
    constructor(input, error) {
        const message = `Could not find compiler at: ${input}\n\n` + error;
        super(message);
    }
}
exports.NoPathError = NoPathError;
//# sourceMappingURL=Local.js.map

/***/ }),

/***/ 39517:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoNativeError = exports.Native = void 0;
const { execSync } = __webpack_require__(32081);
const { normalizeSolcVersion } = __webpack_require__(69738);
const { NoVersionError } = __webpack_require__(40329);
class Native {
    load() {
        const versionString = this.validateAndGetSolcVersion();
        const command = "solc --standard-json";
        const maxBuffer = 1024 * 1024 * 50;
        try {
            return {
                compile: options => String(execSync(command, { input: options, maxBuffer })),
                version: () => versionString
            };
        }
        catch (error) {
            if (error.message === "No matching version found") {
                throw new NoVersionError(versionString);
            }
            throw error;
        }
    }
    validateAndGetSolcVersion() {
        let version;
        try {
            version = execSync("solc --version");
        }
        catch (error) {
            throw new NoNativeError(error);
        }
        return normalizeSolcVersion(version);
    }
}
exports.Native = Native;
class NoNativeError extends Error {
    constructor(error) {
        super("Could not execute local solc binary: " + error);
    }
}
exports.NoNativeError = NoNativeError;
//# sourceMappingURL=Native.js.map

/***/ }),

/***/ 780:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoUrlError = exports.VersionRange = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("compile:compilerSupplier");
const require_from_string_1 = __importDefault(__webpack_require__(46029));
// must polyfill AbortController to use axios >=0.20.0, <=0.27.2 on node <= v14.x
__webpack_require__(19492);
const axios_1 = __importDefault(__webpack_require__(43306));
const semver_1 = __importDefault(__webpack_require__(81249));
const wrapper_1 = __importDefault(__webpack_require__(11433));
const Cache_1 = __webpack_require__(46405);
const observeListeners_1 = __webpack_require__(60207);
const errors_1 = __webpack_require__(40329);
class VersionRange {
    constructor(options) {
        const defaultConfig = {
            compilerRoots: [
                // this order of url root preference was recommended by Cameel from the
                // Solidity team here -- https://github.com/trufflesuite/truffle/pull/5008
                "https://binaries.soliditylang.org/emscripten-wasm32/",
                "https://binaries.soliditylang.org/emscripten-asmjs/",
                "https://solc-bin.ethereum.org/bin/",
                "https://ethereum.github.io/solc-bin/bin/",
                "https://relay.trufflesuite.com/solc/emscripten-wasm32/",
                "https://relay.trufflesuite.com/solc/emscripten-asmjs/"
            ]
        };
        this.config = Object.assign({}, defaultConfig, options);
        this.cache = new Cache_1.Cache();
    }
    load(versionRange) {
        return __awaiter(this, void 0, void 0, function* () {
            const rangeIsSingleVersion = semver_1.default.valid(versionRange);
            if (rangeIsSingleVersion && (yield this.versionIsCached(versionRange))) {
                return yield this.getCachedSolcByVersionRange(versionRange);
            }
            try {
                return yield this.getSolcFromCacheOrUrl(versionRange);
            }
            catch (error) {
                if (error.message.includes("Failed to complete request")) {
                    return yield this.getSatisfyingVersionFromCache(versionRange);
                }
                throw error;
            }
        });
    }
    list(index = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (index >= this.config.compilerRoots.length) {
                throw new Error(`Failed to fetch the list of Solidity compilers from the following ` +
                    `sources: ${this.config.compilerRoots}. Make sure you are connected ` +
                    `to the internet.`);
            }
            let data;
            try {
                const attemptNumber = index + 1;
                data = yield this.getSolcVersionsForSource(this.config.compilerRoots[index], attemptNumber);
            }
            catch (error) {
                if (error.message.includes("Failed to fetch compiler list at")) {
                    return yield this.list(index + 1);
                }
                throw error;
            }
            const { latestRelease } = data;
            const prereleases = data.builds
                .filter(build => build["prerelease"])
                .map(build => build["longVersion"]);
            // ensure releases are listed in descending order
            const releases = semver_1.default.rsort(Object.keys(data.releases));
            return {
                prereleases,
                releases,
                latestRelease
            };
        });
    }
    compilerFromString(code) {
        const listeners = (0, observeListeners_1.observeListeners)();
        try {
            const soljson = (0, require_from_string_1.default)(code);
            return (0, wrapper_1.default)(soljson);
        }
        finally {
            listeners.cleanup();
        }
    }
    findNewestValidVersion(version, allVersions) {
        return semver_1.default.maxSatisfying(Object.keys(allVersions.releases || {}), version);
    }
    getCachedSolcByFileName(fileName) {
        return __awaiter(this, void 0, void 0, function* () {
            const listeners = (0, observeListeners_1.observeListeners)();
            try {
                const soljson = yield this.cache.loadFile(fileName);
                debug("soljson %o", soljson);
                return this.compilerFromString(soljson);
            }
            finally {
                listeners.cleanup();
            }
        });
    }
    // Range can also be a single version specification like "0.5.0"
    getCachedSolcByVersionRange(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedCompilerFileNames = yield this.cache.list();
            const validVersions = cachedCompilerFileNames.filter(fileName => {
                const match = fileName.match(/v\d+\.\d+\.\d+.*/);
                if (match)
                    return semver_1.default.satisfies(match[0], version);
            });
            const multipleValidVersions = validVersions.length > 1;
            const compilerFileName = multipleValidVersions
                ? this.getMostRecentVersionOfCompiler(validVersions)
                : validVersions[0];
            return yield this.getCachedSolcByFileName(compilerFileName);
        });
    }
    getCachedSolcFileName(commit) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedCompilerFileNames = yield this.cache.list();
            return cachedCompilerFileNames.find(fileName => {
                return fileName.includes(commit);
            });
        });
    }
    getMostRecentVersionOfCompiler(versions) {
        return versions.reduce((mostRecentVersionFileName, fileName) => {
            const match = fileName.match(/v\d+\.\d+\.\d+.*/);
            const mostRecentVersionMatch = mostRecentVersionFileName.match(/v\d+\.\d+\.\d+.*/);
            return semver_1.default.gtr(match[0], mostRecentVersionMatch[0])
                ? fileName
                : mostRecentVersionFileName;
        }, "-v0.0.0+commit");
    }
    getSatisfyingVersionFromCache(versionRange) {
        return __awaiter(this, void 0, void 0, function* () {
            if (yield this.versionIsCached(versionRange)) {
                return yield this.getCachedSolcByVersionRange(versionRange);
            }
            throw new errors_1.NoVersionError(versionRange);
        });
    }
    getAndCacheSolcByUrl(fileName, index) {
        return __awaiter(this, void 0, void 0, function* () {
            const { events, compilerRoots } = this.config;
            const url = `${compilerRoots[index].replace(/\/+$/, "")}/${fileName}`;
            events.emit("downloadCompiler:start", {
                attemptNumber: index + 1
            });
            let response;
            try {
                response = yield axios_1.default.get(url, { maxRedirects: 50 });
            }
            catch (error) {
                events.emit("downloadCompiler:fail");
                throw error;
            }
            events.emit("downloadCompiler:succeed");
            try {
                yield this.cache.add(response.data, fileName);
            }
            catch (error) {
                if (error.message.includes("EACCES: permission denied")) {
                    const warningMessage = "There was an error attempting to save the compiler to disk. " +
                        "The current user likely does not have sufficient permissions to " +
                        "write to disk in Truffle's compiler cache directory. See the error" +
                        `printed below for more information about this directory.\n${error}`;
                    console.warn(warningMessage);
                }
            }
            return this.compilerFromString(response.data);
        });
    }
    getSolcFromCacheOrUrl(versionConstraint, index = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            // go through all sources (compilerRoots) trying to locate a
            // suitable version of the Solidity compiler
            const { compilerRoots, events } = this.config;
            if (!compilerRoots || compilerRoots.length === 0) {
                events.emit("fetchSolcList:fail");
                throw new NoUrlError();
            }
            if (index >= compilerRoots.length) {
                throw new errors_1.CompilerFetchingError(compilerRoots);
            }
            let allVersionsForSource, versionToUse;
            try {
                const attemptNumber = index + 1;
                allVersionsForSource = yield this.getSolcVersionsForSource(compilerRoots[index], attemptNumber);
                const isVersionRange = !semver_1.default.valid(versionConstraint);
                versionToUse = isVersionRange
                    ? this.findNewestValidVersion(versionConstraint, allVersionsForSource)
                    : versionConstraint;
                if (versionToUse === null) {
                    throw new Error("No valid version found for source.");
                }
                const fileName = this.getSolcVersionFileName(versionToUse, allVersionsForSource);
                if (!fileName)
                    throw new errors_1.NoVersionError(versionToUse);
                if (yield this.cache.has(fileName)) {
                    return yield this.getCachedSolcByFileName(fileName);
                }
                return yield this.getAndCacheSolcByUrl(fileName, index);
            }
            catch (error) {
                const attemptNumber = index + 1;
                return yield this.getSolcFromCacheOrUrl(versionConstraint, attemptNumber);
            }
        });
    }
    getSolcVersionsForSource(urlRoot, attemptNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const { events } = this.config;
            events.emit("fetchSolcList:start", { attemptNumber });
            // trim trailing slashes from compilerRoot
            const url = `${urlRoot.replace(/\/+$/, "")}/list.json`;
            try {
                const response = yield axios_1.default.get(url, { maxRedirects: 50 });
                events.emit("fetchSolcList:succeed");
                return response.data;
            }
            catch (error) {
                events.emit("fetchSolcList:fail");
                throw new Error(`Failed to fetch compiler list at ${url}`);
            }
        });
    }
    getSolcVersionFileName(version, allVersions) {
        if (allVersions.releases[version])
            return allVersions.releases[version];
        const isPrerelease = version.includes("nightly") || version.includes("commit");
        if (isPrerelease) {
            for (let build of allVersions.builds) {
                const exists = build["prerelease"] === version ||
                    build["build"] === version ||
                    build["longVersion"] === version;
                if (exists)
                    return build["path"];
            }
        }
        const versionToUse = this.findNewestValidVersion(version, allVersions);
        if (versionToUse)
            return allVersions.releases[versionToUse];
        return null;
    }
    versionIsCached(version) {
        return __awaiter(this, void 0, void 0, function* () {
            const cachedCompilerFileNames = yield this.cache.list();
            const cachedVersions = cachedCompilerFileNames
                .map(fileName => {
                const match = fileName.match(/v\d+\.\d+\.\d+.*/);
                if (match)
                    return match[0];
            })
                .filter((version) => !!version);
            return cachedVersions.find(cachedVersion => semver_1.default.satisfies(cachedVersion, version));
        });
    }
}
exports.VersionRange = VersionRange;
class NoUrlError extends Error {
    constructor() {
        super("compiler root URL missing");
    }
}
exports.NoUrlError = NoUrlError;
//# sourceMappingURL=VersionRange.js.map

/***/ }),

/***/ 41514:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VersionRange = exports.Native = exports.Local = exports.Docker = void 0;
var Docker_1 = __webpack_require__(48352);
Object.defineProperty(exports, "Docker", ({ enumerable: true, get: function () { return Docker_1.Docker; } }));
var Local_1 = __webpack_require__(8831);
Object.defineProperty(exports, "Local", ({ enumerable: true, get: function () { return Local_1.Local; } }));
var Native_1 = __webpack_require__(39517);
Object.defineProperty(exports, "Native", ({ enumerable: true, get: function () { return Native_1.Native; } }));
var VersionRange_1 = __webpack_require__(780);
Object.defineProperty(exports, "VersionRange", ({ enumerable: true, get: function () { return VersionRange_1.VersionRange; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 69738:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSolcVersion = void 0;
/**
 * Convert a full version string (possibly with commit information, etc.) into
 * a canonical short-form semver version (x.y.z)
 */
const normalizeSolcVersion = (input) => {
    const version = String(input);
    return version.split(":")[1].trim();
};
exports.normalizeSolcVersion = normalizeSolcVersion;
//# sourceMappingURL=normalizeSolcVersion.js.map

/***/ }),

/***/ 60207:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.observeListeners = void 0;
const observeListeners = () => {
    const listeners = new ObservedListeners();
    return listeners;
};
exports.observeListeners = observeListeners;
class ObservedListeners {
    constructor() {
        this.listeners = {
            uncaughtException: new Set(process.listeners("uncaughtException")),
            unhandledRejection: new Set(process.listeners("unhandledRejection")),
        };
    }
    /**
     * Cleans up error listeners left by soljson
     */
    cleanup() {
        for (const eventName in this.listeners) {
            const marked = this.listeners[eventName];
            for (const listener of process.listeners(eventName)) {
                if (!marked.has(listener)) {
                    process.removeListener(eventName, listener);
                }
            }
        }
    }
}
//# sourceMappingURL=observeListeners.js.map

/***/ }),

/***/ 32739:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.rangeContainsAtLeast = exports.resolveToRange = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const semver_1 = __importDefault(__webpack_require__(81249));
const loadingStrategies_1 = __webpack_require__(41514);
const index_1 = __webpack_require__(47922);
/**
 * takes a version string which may be native or local, and resolves
 * it to one which is (presumably) either a version or a version range
 */
function resolveToRange(version) {
    if (!version) {
        return index_1.CompilerSupplier.getDefaultVersion();
    }
    //if version was native or local, must determine what version that
    //actually corresponds to
    if (version === "native") {
        return new loadingStrategies_1.Native().load().version();
    }
    else if (fs_extra_1.default.existsSync(version) && path_1.default.isAbsolute(version)) {
        return new loadingStrategies_1.Local().load(version).version();
    }
    return version;
}
exports.resolveToRange = resolveToRange;
/**
 * parameter range may be either an individual version or a range
 */
function rangeContainsAtLeast(range, comparisonVersion) {
    //the following line works with prereleases
    const individualAtLeast = !!(semver_1.default.valid(range, { loose: true }) &&
        semver_1.default.gte(range, comparisonVersion, {
            includePrerelease: true,
            loose: true
        }));
    //the following line doesn't, despite the flag, but does work with version ranges
    const rangeAtLeast = !!((semver_1.default.validRange(range, { loose: true }) &&
        !semver_1.default.gtr(comparisonVersion, range, {
            includePrerelease: true,
            loose: true
        })) //intersects will throw if given undefined so must ward against
    );
    return individualAtLeast || rangeAtLeast;
}
exports.rangeContainsAtLeast = rangeContainsAtLeast;
//# sourceMappingURL=rangeUtils.js.map

/***/ }),

/***/ 4273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Compile = exports.RangeUtils = exports.Parser = exports.run = exports.shouldIncludePath = exports.LoadingStrategies = exports.Cache = exports.Profiler = exports.compileWithPragmaAnalysis = exports.Shims = exports.CompilerSupplier = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("compile");
const contract_sources_1 = __importDefault(__webpack_require__(23542));
const config_1 = __importDefault(__webpack_require__(20553));
const profiler_1 = __webpack_require__(22860);
const compilerSupplier_1 = __webpack_require__(47922);
const run_1 = __webpack_require__(71193);
const normalizeOptions_1 = __webpack_require__(94764);
const compileWithPragmaAnalysis_1 = __webpack_require__(63505);
const reportSources_1 = __webpack_require__(77897);
const compile_common_1 = __webpack_require__(29833);
const partition_1 = __importDefault(__webpack_require__(43174));
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const expect = __webpack_require__(14096);
var compilerSupplier_2 = __webpack_require__(47922);
Object.defineProperty(exports, "CompilerSupplier", ({ enumerable: true, get: function () { return compilerSupplier_2.CompilerSupplier; } }));
exports.Shims = __importStar(__webpack_require__(31043));
var compileWithPragmaAnalysis_2 = __webpack_require__(63505);
Object.defineProperty(exports, "compileWithPragmaAnalysis", ({ enumerable: true, get: function () { return compileWithPragmaAnalysis_2.compileWithPragmaAnalysis; } }));
var profiler_2 = __webpack_require__(22860);
Object.defineProperty(exports, "Profiler", ({ enumerable: true, get: function () { return profiler_2.Profiler; } }));
var Cache_1 = __webpack_require__(46405);
Object.defineProperty(exports, "Cache", ({ enumerable: true, get: function () { return Cache_1.Cache; } }));
exports.LoadingStrategies = __importStar(__webpack_require__(41514));
var shouldIncludePath_1 = __webpack_require__(94642);
Object.defineProperty(exports, "shouldIncludePath", ({ enumerable: true, get: function () { return shouldIncludePath_1.shouldIncludePath; } }));
var run_2 = __webpack_require__(71193);
Object.defineProperty(exports, "run", ({ enumerable: true, get: function () { return run_2.run; } }));
var parser_1 = __webpack_require__(60747);
Object.defineProperty(exports, "Parser", ({ enumerable: true, get: function () { return parser_1.Parser; } }));
exports.RangeUtils = __importStar(__webpack_require__(32739));
function compileYulPaths(yulPaths, options) {
    return __awaiter(this, void 0, void 0, function* () {
        let yulCompilations = [];
        for (const path of yulPaths) {
            const yulOptions = options.with({ compilationTargets: [path] });
            //load up Yul sources, since they weren't loaded up earlier
            //(we'll just use FS for this rather than going through the resolver,
            //for simplicity, since there are no imports to worry about)
            const yulSource = fs_extra_1.default.readFileSync(path, { encoding: "utf8" });
            debug("Compiling Yul");
            const compilation = yield (0, run_1.run)({ [path]: yulSource }, yulOptions, {
                language: "Yul"
            });
            debug("Yul compiled successfully");
            if (compilation && compilation.contracts.length > 0) {
                yulCompilations.push(compilation);
            }
        }
        if (yulPaths.length > 0 && !options.quiet) {
            //replacement for individual Yul warnings
            options.logger.log("> Warning: Yul is still experimental. Avoid using it in live deployments.");
        }
        return yulCompilations;
    });
}
exports.Compile = {
    // this takes an object with keys being the name and values being source
    // material as well as an options object
    // NOTE: this function does *not* transform the source path prefix to
    // "project:/" before passing to the compiler!
    sources({ sources, options }) {
        return __awaiter(this, void 0, void 0, function* () {
            options = config_1.default.default().merge(options);
            options = (0, normalizeOptions_1.normalizeOptions)(options);
            //note: "solidity" here includes JSON as well!
            const [yulNames, solidityNames] = (0, partition_1.default)(Object.keys(sources), name => name.endsWith(".yul"));
            const soliditySources = Object.assign({}, ...solidityNames.map(name => ({ [name]: sources[name] })));
            let solidityCompilations = [];
            let yulCompilations = [];
            if (solidityNames.length > 0) {
                debug("Compiling Solidity (specified sources)");
                const compilation = yield (0, run_1.run)(soliditySources, options, {
                    noTransform: true
                });
                debug("Compiled Solidity");
                if (compilation && compilation.contracts.length > 0) {
                    solidityCompilations.push(compilation);
                }
            }
            for (const name of yulNames) {
                debug("Compiling Yul (specified sources)");
                const compilation = yield (0, run_1.run)({ [name]: sources[name] }, options, {
                    language: "Yul",
                    noTransform: true
                });
                debug("Compiled Yul");
                if (compilation !== null) {
                    yulCompilations.push(compilation);
                }
            }
            const compilations = [...solidityCompilations, ...yulCompilations];
            return compile_common_1.Compilations.promoteCompileResult({ compilations });
        });
    },
    all(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const paths = [
                ...new Set([
                    ...(yield (0, contract_sources_1.default)(options.contracts_directory)),
                    ...(options.files || [])
                ])
            ];
            return yield exports.Compile.sourcesWithDependencies({
                paths,
                options
            });
        });
    },
    necessary(options) {
        return __awaiter(this, void 0, void 0, function* () {
            options.logger = options.logger || console;
            const paths = yield profiler_1.Profiler.updated(options);
            return yield exports.Compile.sourcesWithDependencies({
                paths,
                options
            });
        });
    },
    sourcesWithDependencies({ paths, options }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (options.compilers.solc.version === "pragma") {
                return this.sourcesWithPragmaAnalysis({ paths, options });
            }
            options.logger = options.logger || console;
            options.contracts_directory = options.contracts_directory || process.cwd();
            debug("paths: %O", paths);
            expect.options(options, [
                "working_directory",
                "contracts_directory",
                "resolver"
            ]);
            options = config_1.default.default().merge(options);
            options = (0, normalizeOptions_1.normalizeOptions)(options);
            const supplier = new compilerSupplier_1.CompilerSupplier({
                events: options.events,
                solcConfig: options.compilers.solc
            });
            const { solc } = yield supplier.load();
            //note: solidityPaths here still includes JSON as well!
            const [yulPaths, solidityPaths] = (0, partition_1.default)(paths, path => path.endsWith(".yul"));
            debug("invoking profiler");
            //only invoke profiler on Solidity, not Yul
            const { allSources, compilationTargets } = yield profiler_1.Profiler.requiredSources(options.with({
                paths: solidityPaths,
                base_path: options.contracts_directory,
                resolver: options.resolver,
                compiler: {
                    name: "solc",
                    version: solc.version()
                }
            }), solc);
            debug("compilationTargets: %O", compilationTargets);
            // we can exit if there are no Solidity/Yul files to compile since
            // it indicates that we only have Vyper-related JSON
            const solidityTargets = compilationTargets.filter(fileName => fileName.endsWith(".sol"));
            if (solidityTargets.length === 0 && yulPaths.length === 0) {
                return compile_common_1.Compilations.emptyWorkflowCompileResult();
            }
            (0, reportSources_1.reportSources)({ paths: [...compilationTargets, ...yulPaths], options });
            let solidityCompilations = [];
            // only call run if there are sources to run on!
            if (Object.keys(allSources).length > 0) {
                const solidityOptions = options.with({ compilationTargets });
                debug("Compiling Solidity");
                const compilation = yield (0, run_1.run)(allSources, solidityOptions, { solc });
                debug("Solidity compiled successfully");
                if (compilation && compilation.contracts.length > 0) {
                    solidityCompilations.push(compilation);
                }
            }
            const yulCompilations = yield compileYulPaths(yulPaths, options);
            const compilations = [...solidityCompilations, ...yulCompilations];
            return compile_common_1.Compilations.promoteCompileResult({ compilations });
        });
    },
    sourcesWithPragmaAnalysis({ paths, options }) {
        return __awaiter(this, void 0, void 0, function* () {
            const compilationResult = yield (0, compileWithPragmaAnalysis_1.compileWithPragmaAnalysis)({
                paths,
                options
            });
            return compile_common_1.Compilations.promoteCompileResult(compilationResult);
        });
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94764:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeOptions = void 0;
const expect = __webpack_require__(14096);
const normalizeOptions = (options) => {
    if (options.logger === undefined)
        options.logger = console;
    expect.options(options, ["contracts_directory", "compilers"]);
    expect.options(options.compilers, ["solc"]);
    options.compilers.solc.settings.evmVersion =
        options.compilers.solc.settings.evmVersion ||
            options.compilers.solc.evmVersion;
    options.compilers.solc.settings.optimizer =
        options.compilers.solc.settings.optimizer ||
            options.compilers.solc.optimizer ||
            {};
    // Grandfather in old solc config
    if (options.solc) {
        options.compilers.solc.settings.evmVersion = options.solc.evmVersion;
        options.compilers.solc.settings.optimizer = options.solc.optimizer;
    }
    // Certain situations result in `{}` as a value for compilationTargets
    // Previous implementations treated any value lacking `.length` as equivalent
    // to `[]`
    // (This also happens when run() is called from sources(), so
    // compilationTargets is not passed)
    if (!options.compilationTargets || !options.compilationTargets.length) {
        options.compilationTargets = [];
    }
    return options;
};
exports.normalizeOptions = normalizeOptions;
//# sourceMappingURL=normalizeOptions.js.map

/***/ }),

/***/ 60747:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("compile:parser");
// Warning issued by a pre-release compiler version, ignored by this component.
const preReleaseCompilerWarning = "This is a pre-release compiler version, please do not use it in production.";
exports.Parser = {
    // This needs to be fast! It is fast (as of this writing). Keep it fast!
    parseImports(body, solc) {
        // WARNING: Kind of a hack (an expedient one).
        // So we don't have to maintain a separate parser, we'll get all the imports
        // in a file by sending the file to solc and evaluating the error messages
        // to see what import statements couldn't be resolved. To prevent full-on
        // compilation when a file has no import statements, we inject an import
        // statement right on the end; just to ensure it will error and we can parse
        // the imports speedily without doing extra work.
        // Inject failing import.
        const failingImportFileName = "__Truffle__NotFound.sol";
        body = `${body}\n\nimport '${failingImportFileName}';\n`;
        const solcStandardInput = {
            language: "Solidity",
            sources: {
                "ParsedContract.sol": {
                    content: body
                }
            },
            settings: {
                outputSelection: {
                    "ParsedContract.sol": {
                        "*": [] // We don't need any output.
                    }
                }
            }
        };
        // By compiling only with ParsedContract.sol as the source, solc.compile returns file import errors for each import path.
        let output = solc.compile(JSON.stringify(solcStandardInput));
        output = JSON.parse(output);
        // Filter out the "pre-release compiler" warning, if present.
        const errors = output.errors.filter(({ message }) => !message.includes(preReleaseCompilerWarning));
        debug("errors: %O", errors);
        // Filter out our forced import, then get the import paths of the rest.
        const imports = errors
            .map(({ formattedMessage, message }) => {
            // Multiline import check which works for solcjs and solc
            // solcjs: ^ (Relevant source part starts here and spans across multiple lines)
            // solc: Spanning multiple lines.
            if (formattedMessage.includes("multiple lines")) {
                // Parse the import filename from the error message, this does not include the full path to the import
                const matches = message.match(/Source[^'"]?.*?("|')([^'"]+)("|')/);
                if (matches) {
                    // Extract the full path by matching against body with the import filename
                    const fullPathRegex = new RegExp(`("|')(.*${matches[2]})("|')`);
                    const importMatches = body.match(fullPathRegex);
                    if (importMatches)
                        return importMatches[2];
                }
            }
            else {
                const matches = formattedMessage.match(/import[^'"]?.*("|')([^'"]+)("|')/);
                // Return the item between the quotes.
                if (matches)
                    return matches[2];
            }
        })
            .filter(match => match !== undefined && match !== failingImportFileName);
        return imports;
    }
};
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ 19492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// must polyfill AbortController to use axios >=0.20.0, <=0.27.2 on node <= v14.x
const node_abort_controller_1 = __webpack_require__(53357);
// we're using the "dom" lib in this package, so these types are already
// defined, but their implementations are nonexistent when running under node <=
// v15.x, so we polyfill them here anyway
if (typeof global.AbortController === "undefined") {
    global.AbortController = node_abort_controller_1.AbortController;
    global.AbortSignal = node_abort_controller_1.AbortSignal;
}
//# sourceMappingURL=polyfill.js.map

/***/ }),

/***/ 22860:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Profiler = void 0;
// Compares .sol files to their .sol.js counterparts,
// determines which .sol files have been updated.
const profiler_1 = __webpack_require__(76273);
const loadParser_1 = __webpack_require__(94532);
const shouldIncludePath_1 = __webpack_require__(94642);
exports.Profiler = {
    updated: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const profiler = new profiler_1.Profiler({});
        return yield profiler.updated(options);
    }),
    // Returns the minimal set of sources to pass to solc as compilations targets,
    // as well as the complete set of sources so solc can resolve the comp targets' imports.
    requiredSources: (options, solc) => __awaiter(void 0, void 0, void 0, function* () {
        // get parser
        const parseImports = yield (0, loadParser_1.loadParser)(options, solc);
        // generate profiler
        const profiler = new profiler_1.Profiler({
            parseImports,
            shouldIncludePath: shouldIncludePath_1.shouldIncludePath
        });
        // invoke profiler
        return yield profiler.requiredSources(options);
    }),
    requiredSourcesForSingleFile: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const parseImports = yield (0, loadParser_1.loadParser)(options);
        const profiler = new profiler_1.Profiler({
            parseImports,
            shouldIncludePath: shouldIncludePath_1.shouldIncludePath
        });
        return profiler.requiredSourcesForSingleFile(options);
    })
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 94532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.loadParser = void 0;
const compilerSupplier_1 = __webpack_require__(47922);
const parser_1 = __webpack_require__(60747);
const semver_1 = __importDefault(__webpack_require__(81249));
/**
 * Loads solc and wrap it to parse imports rather than performing a full
 * compilation. Returns the wrapped form.
 *
 * This function optionally accepts an `parser` param, whose only possible
 * value is `"solcjs"`. Passing this option indicates that the imports-parser
 * should use a wrapped soljson module instead of whatever normal compiler
 * the user would use. NOTE that as a result, this function may download solc
 * up to twice: first time as usual, to get the specific version, then a second
 * time to get the solcjs of that version.
 */
function loadParser({ events, compilers: { solc: solcConfig } }, providedSolc) {
    return __awaiter(this, void 0, void 0, function* () {
        if (providedSolc && solcConfig.parser === undefined) {
            return makeParseImports(providedSolc);
        }
        const { parser } = solcConfig;
        const supplier = new compilerSupplier_1.CompilerSupplier({ events, solcConfig });
        const { solc } = yield supplier.load();
        // if no parser is specified, just use the normal solc
        if (!parser) {
            return makeParseImports(solc);
        }
        // otherwise, there's only one choice...
        if (parser !== "solcjs") {
            throw new Error(`Unsupported parser "${parser}" found in truffle-config.js`);
        }
        // determine normal solc version and then load that version as solcjs
        const result = semver_1.default.coerce(solc.version());
        if (!result) {
            throw new Error(`Could not determine version from ${solc.version}.`);
        }
        const parserSupplier = new compilerSupplier_1.CompilerSupplier({
            events,
            solcConfig: Object.assign(Object.assign({}, solcConfig), { version: result.version, docker: false })
        });
        const { solc: parserSolc } = yield parserSupplier.load();
        return makeParseImports(parserSolc);
    });
}
exports.loadParser = loadParser;
function makeParseImports(parser) {
    const parseImports = (body) => {
        try {
            return parser_1.Parser.parseImports(body, parser);
        }
        catch (err) {
            if (err.message.includes("requires different compiler version")) {
                const contractSolcPragma = err.message.match(/pragma solidity[^;]*/gm);
                // if there's a match provide the helpful error, otherwise return solc's error output
                if (contractSolcPragma) {
                    const contractSolcVer = contractSolcPragma[0];
                    const configSolcVer = semver_1.default.valid(parser.version());
                    err.message = err.message.concat(`\n\nError: Truffle is currently using solc ${configSolcVer}, but one or more of your contracts specify "${contractSolcVer}".\nPlease update your truffle config or pragma statement(s).\n(See https://trufflesuite.com/docs/truffle/reference/configuration#compiler-configuration for information on\nconfiguring Truffle to use a specific solc compiler version.)\n`);
                }
                else {
                    err.message =
                        `Parsing error: ${err.message}.\nThe error occurred ` +
                            `while parsing the following source material: ${body}.`;
                }
            }
            throw err;
        }
    };
    return parseImports;
}
//# sourceMappingURL=loadParser.js.map

/***/ }),

/***/ 94642:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shouldIncludePath = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
function shouldIncludePath(filePath) {
    const validExtensions = [".sol", ".json"];
    return validExtensions.some(extension => path_1.default.extname(filePath) === extension);
}
exports.shouldIncludePath = shouldIncludePath;
//# sourceMappingURL=shouldIncludePath.js.map

/***/ }),

/***/ 77897:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.reportSources = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const reportSources = ({ paths, options }) => {
    if (options.quiet !== true && options.events) {
        if (!Array.isArray(paths)) {
            paths = Object.keys(paths);
        }
        const blacklistRegex = /^truffle\//;
        const sources = paths
            .sort()
            .map(contract => {
            if (path_1.default.isAbsolute(contract)) {
                contract =
                    "." + path_1.default.sep + path_1.default.relative(options.working_directory, contract);
            }
            if (contract.match(blacklistRegex) || contract.endsWith(".json")) {
                return;
            }
            return contract;
        })
            .filter(contract => contract);
        options.events.emit("compile:sourcesToCompile", {
            sourceFileNames: sources
        });
    }
};
exports.reportSources = reportSources;
//# sourceMappingURL=reportSources.js.map

/***/ }),

/***/ 71193:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.run = void 0;
const shims_1 = __webpack_require__(31043);
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("compile:run");
const OS = __webpack_require__(22037);
const semver_1 = __importDefault(__webpack_require__(81249));
const compilerSupplier_1 = __webpack_require__(47922);
const Common = __importStar(__webpack_require__(29833));
// this function returns a Compilation - legacy/index.js and ./index.js
// both check to make sure rawSources exist before calling this method
// however, there is a check here that returns null if no sources exist
function run(rawSources, options, internalOptions = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Object.keys(rawSources).length === 0) {
            return null;
        }
        const { language = "Solidity", // could also be "Yul"
        noTransform = false, // turns off project root transform
        solc // passing this skips compilerSupplier.load()
         } = internalOptions;
        // Ensure sources have operating system independent paths
        // i.e., convert backslashes to forward slashes; things like C: are left intact.
        // we also strip the project root (to avoid it appearing in metadata)
        // and replace it with "project:/" (unless noTransform is set)
        const { sources, targets, originalSourcePaths } = Common.Sources.collectSources(rawSources, options.compilationTargets, noTransform ? "" : options.working_directory, noTransform ? "" : "project:/");
        // construct solc compiler input
        const compilerInput = prepareCompilerInput({
            sources,
            targets,
            language,
            settings: options.compilers.solc.settings,
            modelCheckerSettings: options.compilers.solc.modelCheckerSettings
        });
        // perform compilation
        const { compilerOutput, solcVersion } = yield invokeCompiler({
            compilerInput,
            solc,
            options
        });
        debug("compilerOutput: %O", compilerOutput);
        // handle warnings as errors if options.strict
        // log if not options.quiet
        const { infos, warnings, errors } = detectErrors({
            compilerOutput,
            options,
            solcVersion
        });
        if (infos.length > 0) {
            options.events.emit("compile:infos", { infos });
        }
        if (warnings.length > 0) {
            options.events.emit("compile:warnings", { warnings });
        }
        if (errors.length > 0) {
            if (!options.quiet) {
                options.logger.log("");
            }
            throw new Common.Errors.CompileError(errors);
        }
        const outputSources = processAllSources({
            sources,
            compilerOutput,
            originalSourcePaths,
            language
        });
        const sourceIndexes = outputSources
            ? outputSources.map(source => source.sourcePath)
            : [];
        return {
            sourceIndexes,
            contracts: processContracts({
                sources,
                compilerOutput,
                solcVersion,
                originalSourcePaths
            }),
            sources: outputSources,
            compiler: {
                name: "solc",
                version: solcVersion
            }
        };
    });
}
exports.run = run;
function orderABI({ abi, contractName, ast }) {
    if (!abi) {
        return []; //Yul doesn't return ABIs, but we require something
    }
    if (!ast || !ast.nodes) {
        return abi;
    }
    // AST can have multiple contract definitions, make sure we have the
    // one that matches our contract
    const contractDefinition = ast.nodes.find(({ nodeType, name }) => nodeType === "ContractDefinition" && name === contractName);
    if (!contractDefinition || !contractDefinition.nodes) {
        return abi;
    }
    // Find all function definitions
    const orderedFunctionNames = contractDefinition.nodes
        .filter(({ nodeType }) => nodeType === "FunctionDefinition")
        .map(({ name: functionName }) => functionName);
    // Put function names in a hash with their order, lowest first, for speed.
    const functionIndexes = orderedFunctionNames
        .map((functionName, index) => ({ [functionName]: index }))
        .reduce((a, b) => Object.assign({}, a, b), {});
    // Construct new ABI with functions at the end in source order
    return [
        ...abi.filter(({ name }) => functionIndexes[name] === undefined),
        // followed by the functions in the source order
        ...abi
            .filter(({ name }) => functionIndexes[name] !== undefined)
            .sort(({ name: a }, { name: b }) => functionIndexes[a] - functionIndexes[b])
    ];
}
function prepareCompilerInput({ sources, targets, language, settings, modelCheckerSettings }) {
    return {
        language,
        sources: prepareSources({ sources }),
        settings: Object.assign(Object.assign({}, settings), { 
            // Specify compilation targets. Each target uses defaultSelectors,
            // defaulting to single target `*` if targets are unspecified
            outputSelection: prepareOutputSelection({ targets }) }),
        modelCheckerSettings
    };
}
/**
 * Convert sources into solc compiler input format
 * @param sources - { [sourcePath]: string }
 * @return { [sourcePath]: { content: string } }
 */
function prepareSources({ sources }) {
    return Object.entries(sources)
        .map(([sourcePath, content]) => ({ [sourcePath]: { content } }))
        .reduce((a, b) => Object.assign({}, a, b), {});
}
/**
 * If targets are specified, specify output selectors for each individually.
 * Otherwise, just use "*" selector
 * @param targets - sourcePath[] | undefined
 */
function prepareOutputSelection({ targets = [] }) {
    const defaultSelectors = {
        "": ["legacyAST", "ast"],
        "*": [
            "abi",
            "ast",
            "metadata",
            "evm.bytecode.object",
            "evm.bytecode.linkReferences",
            "evm.bytecode.sourceMap",
            "evm.bytecode.generatedSources",
            "evm.deployedBytecode.object",
            "evm.deployedBytecode.linkReferences",
            "evm.deployedBytecode.sourceMap",
            "evm.deployedBytecode.immutableReferences",
            "evm.deployedBytecode.generatedSources",
            "userdoc",
            "devdoc"
        ]
    };
    if (!targets.length) {
        return {
            "*": defaultSelectors
        };
    }
    return targets
        .map(target => ({ [target]: defaultSelectors }))
        .reduce((a, b) => Object.assign({}, a, b), {});
}
/**
 * Load solc and perform compilation
 */
function invokeCompiler({ compilerInput, options, solc }) {
    return __awaiter(this, void 0, void 0, function* () {
        const supplierOptions = {
            parser: options.parser,
            events: options.events,
            solcConfig: options.compilers.solc
        };
        if (!solc) {
            const supplier = new compilerSupplier_1.CompilerSupplier(supplierOptions);
            ({ solc } = yield supplier.load());
        }
        const solcVersion = solc.version();
        // perform compilation
        const inputString = JSON.stringify(compilerInput);
        const outputString = solc.compile(inputString);
        const compilerOutput = JSON.parse(outputString);
        return {
            compilerOutput,
            solcVersion
        };
    });
}
function detectErrors({ compilerOutput, options, solcVersion }) {
    const outputErrors = compilerOutput.errors || [];
    const rawErrors = outputErrors.filter(({ severity }) => options.strict
        ? severity !== "info" //strict mode: warnings are errors too
        : severity === "error" //nonstrict mode: only errors are errors
    );
    const rawWarnings = options.strict
        ? [] // in strict mode these get classified as errors, not warnings
        : outputErrors.filter(({ severity, message }) => severity === "warning" &&
            message !==
                "Yul is still experimental. Please use the output with care." //filter out Yul warning
        );
    const rawInfos = outputErrors.filter(({ severity }) => severity === "info");
    // extract messages
    let errors = rawErrors
        .map(({ formattedMessage }) => formattedMessage.replace(/: File import callback not supported/g, //remove this confusing message suffix
    ""))
        .join();
    const warnings = rawWarnings.map(({ formattedMessage }) => formattedMessage);
    const infos = rawInfos.map(({ formattedMessage }) => formattedMessage);
    if (errors.includes("requires different compiler version")) {
        const contractSolcVer = errors.match(/pragma solidity[^;]*/gm)[0];
        const configSolcVer = options.compilers.solc.version || semver_1.default.valid(solcVersion);
        errors = errors.concat([
            OS.EOL,
            `Error: Truffle is currently using solc ${configSolcVer}, `,
            `but one or more of your contracts specify "${contractSolcVer}".`,
            OS.EOL,
            `Please update your truffle config or pragma statement(s).`,
            OS.EOL,
            `(See https://trufflesuite.com/docs/truffle/reference/configuration#compiler-configuration `,
            `for information on`,
            OS.EOL,
            `configuring Truffle to use a specific solc compiler version.)`
        ].join(""));
    }
    return { warnings, errors, infos };
}
/**
 * aggregate source information based on compiled output;
 * this can include sources that do not define any contracts
 */
function processAllSources({ sources, compilerOutput, originalSourcePaths, language }) {
    if (!compilerOutput.sources) {
        const entries = Object.entries(sources);
        if (entries.length === 1) {
            //special case for handling old Yul versions
            const [sourcePath, contents] = entries[0];
            return [
                {
                    sourcePath: originalSourcePaths[sourcePath],
                    contents,
                    language
                }
            ];
        }
        else {
            return [];
        }
    }
    let outputSources = [];
    for (const [sourcePath, { id, ast, legacyAST }] of Object.entries(compilerOutput.sources)) {
        outputSources[id] = {
            sourcePath: originalSourcePaths[sourcePath],
            contents: sources[sourcePath],
            ast,
            legacyAST,
            language
        };
    }
    //HACK: special case for handling a Yul compilation bug that causes
    //the ID to be returned as 1 rather than 0
    if (language === "Yul" &&
        outputSources.length === 2 &&
        outputSources[0] === undefined) {
        return [outputSources[1]];
    }
    return outputSources;
}
/**
 * Converts compiler-output contracts into @truffle/compile-solidity's return format
 * Uses compiler contract output plus other information.
 */
function processContracts({ compilerOutput, sources, originalSourcePaths, solcVersion }) {
    let { contracts } = compilerOutput;
    if (!contracts)
        return [];
    //HACK: versions of Solidity prior to 0.4.20 are confused by our "project:/"
    //prefix (or, more generally, by paths containing colons)
    //and put contracts in a weird form as a result.  we detect
    //this case and repair it.
    contracts = repairOldContracts(contracts);
    return (Object.entries(contracts)
        // map to [[{ source, contractName, contract }]]
        .map(([sourcePath, sourceContracts]) => {
        return Object.entries(sourceContracts).map(([contractName, contract]) => ({
            contractName,
            contract,
            source: {
                //some versions of Yul don't have sources in output
                ast: ((compilerOutput.sources || {})[sourcePath] || {}).ast,
                legacyAST: ((compilerOutput.sources || {})[sourcePath] || {})
                    .legacyAST,
                contents: sources[sourcePath],
                sourcePath
            }
        }));
    })
        // and flatten
        .reduce((a, b) => [...a, ...b], [])
        // All source will have a key, but only the compiled source will have
        // the evm output.
        .filter(({ contract: { evm } }) => Object.keys(evm).length > 0)
        // convert to output format
        .map(({ contractName, contract: { evm: { bytecode: { sourceMap, linkReferences, generatedSources, object: bytecode }, deployedBytecode: deployedBytecodeInfo //destructured below
     }, abi, metadata, devdoc, userdoc }, source: { ast, legacyAST, sourcePath: transformedSourcePath, contents: source } }) => {
        return {
            contractName,
            abi: orderABI({ abi, contractName, ast }),
            metadata,
            devdoc,
            userdoc,
            sourcePath: originalSourcePaths[transformedSourcePath],
            source,
            sourceMap,
            deployedSourceMap: (deployedBytecodeInfo || {}).sourceMap,
            ast,
            legacyAST,
            bytecode: (0, shims_1.zeroLinkReferences)({
                bytes: bytecode,
                linkReferences: (0, shims_1.formatLinkReferences)(linkReferences)
            }),
            deployedBytecode: (0, shims_1.zeroLinkReferences)({
                bytes: (deployedBytecodeInfo || {}).object,
                linkReferences: (0, shims_1.formatLinkReferences)((deployedBytecodeInfo || {}).linkReferences)
            }),
            immutableReferences: (deployedBytecodeInfo || {})
                .immutableReferences,
            //ideally immutable references would be part of the deployedBytecode object,
            //but compatibility makes that impossible
            generatedSources,
            deployedGeneratedSources: (deployedBytecodeInfo || {})
                .generatedSources,
            compiler: {
                name: "solc",
                version: solcVersion
            }
        };
    }));
}
function repairOldContracts(contracts) {
    const contractNames = Object.values(contracts)
        .map(source => Object.keys(source))
        .flat();
    if (contractNames.some(name => name.includes(":"))) {
        //if any of the "contract names" contains a colon... hack invoked!
        //(notionally we could always apply this hack but let's skip it most of the
        //time please :P )
        let repairedContracts = {};
        for (const [sourcePrefix, sourceContracts] of Object.entries(contracts)) {
            for (const [mixedPath, contract] of Object.entries(sourceContracts)) {
                let sourcePath, contractName;
                const lastColonIndex = mixedPath.lastIndexOf(":");
                if (lastColonIndex === -1) {
                    //if there is none
                    sourcePath = sourcePrefix;
                    contractName = mixedPath;
                }
                else {
                    contractName = mixedPath.slice(lastColonIndex + 1); //take the part after the final colon
                    sourcePath = sourcePrefix + ":" + mixedPath.slice(0, lastColonIndex); //the part before the final colon
                }
                if (!repairedContracts[sourcePath]) {
                    repairedContracts[sourcePath] = {};
                }
                repairedContracts[sourcePath][contractName] = contract;
            }
        }
        debug("repaired contracts: %O", repairedContracts);
        return repairedContracts;
    }
    else {
        //otherwise just return contracts as-is rather than processing
        return contracts;
    }
}
//# sourceMappingURL=run.js.map

/***/ }),

/***/ 31043:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.zeroLinkReferences = exports.formatLinkReferences = void 0;
/**
 * Converts solc's link references format into the @truffle/compile-common
 * link references format.
 */
const formatLinkReferences = (
/**
 * @dev type matches solc's Compiler output JSON
 */
linkReferences) => {
    if (!linkReferences) {
        return [];
    }
    // convert to flat list
    const libraryLinkReferences = Object.values(linkReferences)
        .map(fileLinks => Object.entries(fileLinks).map(([name, links]) => ({
        name,
        links
    })))
        .reduce((a, b) => [...a, ...b], []);
    // convert to { offsets, length, name } format
    return libraryLinkReferences.map(({ name, links }) => ({
        offsets: links.map(({ start }) => start),
        length: links[0].length,
        name
    }));
};
exports.formatLinkReferences = formatLinkReferences;
/**
 * This function converts contract bytecodes' bytes strings from solc's native
 * format into the @truffle/compile-common internal format.
 *
 * solc produces bytecodes where the bytes corresponding to link references are
 * not necessarily zero, but Truffle's format requires that these bytes MUST be
 * zero.
 *
 * To be forgiving to the full range of possible input, this function accepts
 * `undefined` as value for `bytes`, e.g., for `abstract contract`s.
 *
 * This function produces a spec-compliant Common.Bytecode object or undefined.
 */
const zeroLinkReferences = (options) => {
    const { linkReferences, bytes: inputBytes } = options;
    if (inputBytes === undefined) {
        return {
            bytes: "",
            linkReferences: []
        };
    }
    // inline link references - start by flattening the offsets
    const flattenedLinkReferences = linkReferences
        // map each link ref to array of link refs with only one offset
        .map(({ offsets, length, name }) => offsets.map(offset => ({ offset, length, name })))
        // flatten
        .reduce((a, b) => [...a, ...b], []);
    // then overwite bytes with zeroes
    const outputBytes = flattenedLinkReferences.reduce((bytes, { offset, length }) => {
        // length is a byte offset
        const characterLength = length * 2;
        const start = offset * 2;
        const zeroes = "0".repeat(characterLength);
        return `${bytes.substring(0, start)}${zeroes}${bytes.substring(start + characterLength)}`;
    }, inputBytes);
    return { linkReferences, bytes: outputBytes };
};
exports.zeroLinkReferences = zeroLinkReferences;
//# sourceMappingURL=shims.js.map

/***/ }),

/***/ 23542:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract-sources");
const path = __webpack_require__(71017);
const glob = __webpack_require__(12884);
const { promisify } = __webpack_require__(73837);

const DEFAULT_PATTERN = "**/*.{sol,vy,v.py,vyper.py,json,yul}";

module.exports = async pattern => {
  // pattern is either a directory (contracts directory), or an absolute path
  // with a glob expression
  if (!glob.hasMagic(pattern)) {
    pattern = path.join(pattern, DEFAULT_PATTERN);
  }

  const globOptions = {
    follow: true, // follow symlinks
    dot: true //check hidden files and directories
  };

  return await promisify(glob)(pattern, globOptions);
};


/***/ }),

/***/ 14096:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.one = exports.options = exports.has = void 0;
/**
 * Asserts at runtime that `options` contains `key`
 */
function has(options, key) {
    // @ts-ignore to get around the fact that we know nothing about O
    if (options[key] == null) {
        throw new Error(`Expected parameter '${key}' not passed to function.`);
    }
}
exports.has = has;
/**
 * Asserts at runtime that `options` contains all `expectedKeys`
 */
function options(options, expectedKeys) {
    for (const key of expectedKeys) {
        has(options, key);
    }
}
exports.options = options;
/**
 * Asserts at runtime that `options` contains at least one of `expectedKeys`
 *
 * Post-condition: this narrows type of `options` to include _exactly one_ of
 * `expectedKeys`, even though at runtime this accepts more than one key.
 */
function one(options, expectedKeys) {
    const found = expectedKeys.some(key => {
        try {
            has(options, key);
            return true;
        }
        catch (error) {
            if (!error.message.includes(`Expected parameter '${key}' not passed to function.`)) {
                throw error;
            }
            return false;
        }
    });
    // If this doesn't work in all cases, perhaps we should
    // create an expect.onlyOne() function.
    if (!found) {
        throw new Error(`Expected one of the following parameters, but found none: ${expectedKeys.join(", ")}`);
    }
}
exports.one = one;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 24375:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.convertToAbsolutePaths = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler:convertToAbsolutePaths");
const path_1 = __importDefault(__webpack_require__(71017));
const isExplicitlyRelative_1 = __webpack_require__(91484);
function convertToAbsolutePaths(paths, base) {
    return paths
        .map(p => {
        // If it's anabsolute paths, leave it alone.
        if (path_1.default.isAbsolute(p))
            return p;
        // If it's not explicitly relative, then leave it alone (i.e., it's a module).
        if (!(0, isExplicitlyRelative_1.isExplicitlyRelative)(p))
            return p;
        // Path must be explicitly releative, therefore make it absolute.
        return path_1.default.resolve(path_1.default.join(base, p));
    })
        .sort();
}
exports.convertToAbsolutePaths = convertToAbsolutePaths;
//# sourceMappingURL=convertToAbsolutePaths.js.map

/***/ }),

/***/ 37766:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getImports = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler:getImports");
const path_1 = __importDefault(__webpack_require__(71017));
function getImports({ source: { filePath, body, source }, shouldIncludePath, parseImports }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!shouldIncludePath(filePath) || !parseImports)
            return [];
        debug("filePath: %s", filePath);
        const imports = yield parseImports(body);
        debug("imports: %O", imports);
        // Convert relative dependencies of modules back into module paths.
        // note: the check for what's a relative dependency has been removed from
        // here, that's now the responsibility of the individual resolverSource to check
        return (yield Promise.all(imports.map(dependencyPath => source.resolveDependencyPath(filePath, dependencyPath)))).filter(sourcePath => sourcePath) //filter out Vyper failures
            .map(sourcePath => sourcePath.replace(/\//g, path_1.default.sep)); //make sure to use
        //backslash on Windows (for same reason as in requiredSources.ts)
    });
}
exports.getImports = getImports;
//# sourceMappingURL=getImports.js.map

/***/ }),

/***/ 76273:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Profiler = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler");
const findContracts = __webpack_require__(23542);
const expect = __webpack_require__(14096);
const updated_1 = __webpack_require__(38230);
const requiredSources_1 = __webpack_require__(95472);
const convertToAbsolutePaths_1 = __webpack_require__(24375);
class Profiler {
    constructor(config) {
        this.config = config;
    }
    updated(options) {
        return __awaiter(this, void 0, void 0, function* () {
            expect.options(options, [
                "contracts_directory",
                "contracts_build_directory"
            ]);
            const { contracts_directory: contractsDirectory, contracts_build_directory: contractsBuildDirectory } = options;
            const paths = options.files
                ? options.files
                : yield findContracts(contractsDirectory);
            return yield (0, updated_1.updated)({ paths, contractsBuildDirectory });
        });
    }
    requiredSources(options) {
        return __awaiter(this, void 0, void 0, function* () {
            expect.options(options, [
                "paths",
                "base_path",
                "resolver",
                "contracts_directory"
            ]);
            const { resolver, paths, base_path: basePath, contracts_directory: contractsDirectory, compiler // { name, version }
             } = options;
            debug("paths: %O", paths);
            const resolve = ({ filePath, importedFrom }) => __awaiter(this, void 0, void 0, function* () {
                //we want to allow resolution failure here.  so, if a source can't
                //be resolved, it will show up as a compile error rather than a Truffle
                //error.
                try {
                    return yield resolver.resolve(filePath, importedFrom, { compiler });
                }
                catch (error) {
                    //resolver doesn't throw structured errors at the moment,
                    //so we'll check the messag to see whether this is an expected error
                    //(kind of a HACK)
                    if (error.message.startsWith("Could not find ")) {
                        return undefined;
                    }
                    else {
                        //rethrow unexpected errors
                        throw error;
                    }
                }
            });
            const updatedPaths = (0, convertToAbsolutePaths_1.convertToAbsolutePaths)(paths, basePath);
            const allPaths = (0, convertToAbsolutePaths_1.convertToAbsolutePaths)(yield findContracts(contractsDirectory), basePath);
            debug("invoking requiredSources");
            return yield (0, requiredSources_1.requiredSources)({
                resolve,
                parseImports: this.config.parseImports,
                shouldIncludePath: this.config.shouldIncludePath,
                updatedPaths,
                allPaths
            });
        });
    }
    requiredSourcesForSingleFile(options) {
        return __awaiter(this, void 0, void 0, function* () {
            expect.options(options, ["path", "base_path", "resolver"]);
            const { resolver, path, base_path: basePath, compiler // { name, version }
             } = options;
            const resolve = ({ filePath, importedFrom }) => resolver.resolve(filePath, importedFrom, { compiler });
            const allPaths = (0, convertToAbsolutePaths_1.convertToAbsolutePaths)([path], basePath);
            const updatedPaths = allPaths;
            return yield (0, requiredSources_1.requiredSources)({
                resolve,
                parseImports: this.config.parseImports,
                shouldIncludePath: this.config.shouldIncludePath,
                updatedPaths,
                allPaths
            });
        });
    }
}
exports.Profiler = Profiler;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91484:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isExplicitlyRelative = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler:isExplicitlyRelative");
function isExplicitlyRelative(importPath) {
    return importPath.startsWith("./") || importPath.startsWith("../");
}
exports.isExplicitlyRelative = isExplicitlyRelative;
//# sourceMappingURL=isExplicitlyRelative.js.map

/***/ }),

/***/ 95472:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.requiredSources = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler:requiredSources");
const path_1 = __importDefault(__webpack_require__(71017));
const resolveAllSources_1 = __webpack_require__(69692);
function requiredSources({ allPaths, updatedPaths, resolve, shouldIncludePath, parseImports }) {
    return __awaiter(this, void 0, void 0, function* () {
        const allSources = {};
        const compilationTargets = [];
        debug("allPaths: %O", allPaths);
        debug("updatedPaths: %O", updatedPaths);
        //before anything else: on Windows, make sure all paths are in native form
        //(with backslashes) rather than slashes.  otherwise, resolution of relative
        //paths can cause aliasing; you can end up with one source with slashes (as
        //given) and one with backslashes (due to relative import resolution).
        allPaths = allPaths.map(sourcePath => sourcePath.replace(/\//g, path_1.default.sep));
        updatedPaths = updatedPaths.map(sourcePath => sourcePath.replace(/\//g, path_1.default.sep));
        // Solidity test files might have been injected. Include them in the known set.
        updatedPaths.forEach(_path => {
            if (!allPaths.includes(_path)) {
                allPaths.push(_path);
            }
        });
        //exit out quickly if we've been asked to compile nothing
        if (!updatedPaths.length) {
            return {
                allSources: {},
                compilationTargets: []
            };
        }
        const resolved = yield (0, resolveAllSources_1.resolveAllSources)({
            resolve,
            parseImports,
            shouldIncludePath,
            paths: allPaths
        });
        //exit out semi-quickly if we've been asked to compile everything
        if (listsEqual(updatedPaths, allPaths)) {
            for (const file of Object.keys(resolved)) {
                if (shouldIncludePath(file)) {
                    allSources[file] = resolved[file].body;
                }
            }
            return {
                allSources,
                compilationTargets: Object.keys(allSources)
            };
        }
        // Seed compilationTargets with known updates
        for (const update of updatedPaths) {
            if (shouldIncludePath(update)) {
                compilationTargets.push(update);
            }
        }
        debug("entering main loop");
        // While there are updated files in the queue, we take each one
        // and search the entire file corpus to find any sources that import it.
        // Those sources are added to list of compilation targets as well as
        // the update queue because their own ancestors need to be discovered.
        while (updatedPaths.length > 0) {
            const currentUpdate = updatedPaths.shift();
            const files = allPaths.slice();
            // While files: dequeue and inspect their imports
            while (files.length > 0) {
                const currentFile = files.shift();
                // Ignore targets already selected.
                if (compilationTargets.includes(currentFile)) {
                    continue;
                }
                debug("currentFile: %s", currentFile);
                const imports = resolved[currentFile].imports;
                debug("imports.length: %d", imports.length);
                // If file imports a compilation target, add it
                // to list of updates and compilation targets
                if (imports.includes(currentUpdate)) {
                    updatedPaths.push(currentFile);
                    compilationTargets.push(currentFile);
                }
            }
        }
        debug("compilationTargets: %O", compilationTargets);
        //now: crawl the tree downward from the compilation targets
        //to get all the sources we need
        const filesToProcess = compilationTargets.slice(); //clone
        const required = [];
        while (filesToProcess.length > 0) {
            debug("filesToProcess: %O", filesToProcess);
            const file = filesToProcess.shift();
            debug("file: %s", file);
            if (resolved[file]) {
                required.push(file);
                for (const importPath of resolved[file].imports) {
                    debug("importPath: %s", importPath);
                    if (!required.includes(importPath)) { //don't go into a loop!
                        filesToProcess.push(importPath);
                    }
                }
            }
        }
        debug("required: %O", required);
        // Generate dictionary of all required sources, including external packages
        for (const file of required) {
            if (shouldIncludePath(file)) {
                allSources[file] = resolved[file].body;
            }
        }
        return {
            allSources,
            compilationTargets
        };
    });
}
exports.requiredSources = requiredSources;
function listsEqual(listA, listB) {
    const a = listA.sort();
    const b = listB.sort();
    return JSON.stringify(a) === JSON.stringify(b);
}
//# sourceMappingURL=requiredSources.js.map

/***/ }),

/***/ 69692:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAllSources = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler:resolveAllSources");
const getImports_1 = __webpack_require__(37766);
// Resolves sources in several async passes. For each resolved set it detects unknown
// imports from external packages and adds them to the set of files to resolve.
function resolveAllSources({ resolve, paths, shouldIncludePath, parseImports }) {
    return __awaiter(this, void 0, void 0, function* () {
        const mapping = {};
        const allPaths = paths.slice();
        debug("resolveAllSources called");
        // Begin generateMapping
        function generateMapping() {
            return __awaiter(this, void 0, void 0, function* () {
                const promises = [];
                // Dequeue all the known paths, generating resolver promises,
                // We'll add paths if we discover external package imports.
                while (allPaths.length) {
                    let filePath;
                    let importedFrom = null;
                    const candidate = allPaths.shift();
                    // Some paths will have been extracted as imports from a file
                    // and have information about their parent location we need to track.
                    if (typeof candidate === "object") {
                        filePath = candidate.filePath;
                        importedFrom = candidate.importedFrom;
                    }
                    else {
                        filePath = candidate;
                    }
                    promises.push(resolve({ filePath, importedFrom }));
                }
                // Resolve everything known and add it to the map, then inspect each file's
                // imports and add those to the list of paths to resolve if we don't have it.
                const results = yield Promise.all(promises);
                // Queue unknown imports for the next resolver cycle
                while (results.length) {
                    const source = results.shift();
                    if (!source || mapping[source.filePath]) {
                        //skip ones that couldn't be resolved, or are already recorded
                        continue;
                    }
                    const imports = shouldIncludePath(source.filePath)
                        ? yield (0, getImports_1.getImports)({ source, parseImports, shouldIncludePath })
                        : [];
                    debug("imports: %O", imports);
                    // Generate the sources mapping
                    mapping[source.filePath] = Object.assign(Object.assign({}, source), { imports });
                    // Detect unknown external packages / add them to the list of files to resolve
                    // Keep track of location of this import because we need to report that.
                    for (const item of imports) {
                        if (!mapping[item]) {
                            allPaths.push({ filePath: item, importedFrom: source.filePath });
                        }
                    }
                }
            });
        }
        // End generateMapping
        while (allPaths.length) {
            yield generateMapping();
        }
        return mapping;
    });
}
exports.resolveAllSources = resolveAllSources;
//# sourceMappingURL=resolveAllSources.js.map

/***/ }),

/***/ 38230:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.updated = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("profiler:updated");
const path = __importStar(__webpack_require__(71017));
const fs = __importStar(__webpack_require__(57147));
function updated({ paths, contractsBuildDirectory, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const sourceFilesArtifacts = readAndParseArtifactFiles(paths, contractsBuildDirectory);
        const sourceFilesArtifactsUpdatedTimes = minimumUpdatedTimePerSource(sourceFilesArtifacts);
        return findUpdatedFiles(sourceFilesArtifacts, sourceFilesArtifactsUpdatedTimes);
    });
}
exports.updated = updated;
function readAndParseArtifactFiles(paths, contracts_build_directory) {
    const sourceFilesArtifacts = {};
    // Get all the source files and create an object out of them.
    paths.forEach((sourceFile) => {
        sourceFilesArtifacts[sourceFile] = [];
    });
    // Get all the artifact files, and read them, parsing them as JSON
    let buildFiles;
    try {
        buildFiles = fs.readdirSync(contracts_build_directory);
    }
    catch (error) {
        // The build directory may not always exist.
        if (error.message.includes("ENOENT: no such file or directory")) {
            // Ignore it.
            buildFiles = [];
        }
        else {
            throw error;
        }
    }
    buildFiles = buildFiles.filter((file) => path.extname(file) === ".json");
    const jsonData = buildFiles.map((file) => {
        const body = fs.readFileSync(path.join(contracts_build_directory, file), "utf8");
        return { file, body };
    });
    for (let i = 0; i < jsonData.length; i++) {
        try {
            const data = JSON.parse(jsonData[i].body);
            // In case there are artifacts from other source locations.
            if (sourceFilesArtifacts[data.sourcePath] == null) {
                sourceFilesArtifacts[data.sourcePath] = [];
            }
            sourceFilesArtifacts[data.sourcePath].push(data);
        }
        catch (error) {
            // JSON.parse throws SyntaxError objects
            if (error instanceof SyntaxError) {
                throw new Error("Problem parsing artifact: " + jsonData[i].file);
            }
            else {
                throw error;
            }
        }
    }
    return sourceFilesArtifacts;
}
function findUpdatedFiles(sourceFilesArtifacts, sourceFilesArtifactsUpdatedTimes) {
    // Stat all the source files, getting there updated times, and comparing them to
    // the artifact updated times.
    const sourceFiles = Object.keys(sourceFilesArtifacts);
    let sourceFileStats;
    sourceFileStats = sourceFiles.map((file) => {
        try {
            return fs.statSync(file);
        }
        catch (error) {
            // Ignore it. This means the source file was removed
            // but the artifact file possibly exists. Return null
            // to signfy that we should ignore it.
            return null;
        }
    });
    return sourceFiles
        .map((sourceFile, index) => {
        const sourceFileStat = sourceFileStats[index];
        // Ignore updating artifacts if source file has been removed.
        if (sourceFileStat == null)
            return;
        const artifactsUpdatedTime = sourceFilesArtifactsUpdatedTimes[sourceFile] || 0;
        const sourceFileUpdatedTime = (sourceFileStat.mtime || sourceFileStat.ctime).getTime();
        if (sourceFileUpdatedTime > artifactsUpdatedTime)
            return sourceFile;
    })
        .filter((file) => file);
}
function minimumUpdatedTimePerSource(sourceFilesArtifacts) {
    let sourceFilesArtifactsUpdatedTimes = {};
    // Get the minimum updated time for all of a source file's artifacts
    // (note: one source file might have multiple artifacts).
    for (const sourceFile of Object.keys(sourceFilesArtifacts)) {
        const artifacts = sourceFilesArtifacts[sourceFile];
        sourceFilesArtifactsUpdatedTimes[sourceFile] = artifacts.reduce((minimum, current) => {
            const updatedAt = new Date(current.updatedAt).getTime();
            if (updatedAt < minimum) {
                return updatedAt;
            }
            return minimum;
        }, Number.MAX_SAFE_INTEGER);
        // Empty array?
        if (sourceFilesArtifactsUpdatedTimes[sourceFile] === Number.MAX_SAFE_INTEGER) {
            sourceFilesArtifactsUpdatedTimes[sourceFile] = 0;
        }
    }
    return sourceFilesArtifactsUpdatedTimes;
}
//# sourceMappingURL=updated.js.map

/***/ })

};
;
//# sourceMappingURL=4273.bundled.js.map