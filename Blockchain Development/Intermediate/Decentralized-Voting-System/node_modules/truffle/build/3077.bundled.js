#!/usr/bin/env node

exports.id = 3077;
exports.ids = [3077];
exports.modules = {

/***/ 26291:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 26291;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 29463:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const contract_schema_1 = __importDefault(__webpack_require__(67078));
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const path_1 = __importDefault(__webpack_require__(71017));
const os_1 = __importDefault(__webpack_require__(22037));
const utils_1 = __webpack_require__(42061);
const debug = __webpack_require__(15158)("artifactor");
class Artifactor {
    constructor(destination) {
        this.destination = destination;
    }
    save(artifactObject) {
        return __awaiter(this, void 0, void 0, function* () {
            const normalizedNewArtifact = contract_schema_1.default.normalize(artifactObject);
            const contractName = normalizedNewArtifact.contractName;
            if (!contractName)
                throw new Error("You must specify a contract name.");
            const outputPath = path_1.default.join(this.destination, `${contractName}.json`);
            try {
                const existingArtifact = fs_extra_1.default.readFileSync(outputPath, "utf8"); // check if artifact already exists
                const existingArtifactObject = JSON.parse(existingArtifact); // parse existing artifact
                const normalizedExistingArtifact = contract_schema_1.default.normalize(existingArtifactObject);
                const completeArtifact = (0, utils_1.finalizeArtifact)(normalizedExistingArtifact, normalizedNewArtifact);
                (0, utils_1.writeArtifact)(completeArtifact, outputPath);
            }
            catch (e) {
                // if artifact doesn't already exist, write new file
                if (e.code === "ENOENT")
                    return (0, utils_1.writeArtifact)(normalizedNewArtifact, outputPath);
                else if (e instanceof SyntaxError)
                    throw e; // catches improperly formatted artifact json
                throw e; // catch all other errors
            }
        });
    }
    saveAll(artifactObjects) {
        return __awaiter(this, void 0, void 0, function* () {
            let newArtifactObjects = {};
            if (Array.isArray(artifactObjects)) {
                const tmpArtifactArray = artifactObjects;
                tmpArtifactArray.forEach(artifactObj => {
                    const contractName = artifactObj.contract_name || artifactObj.contractName;
                    if (newArtifactObjects[contractName]) {
                        console.warn(`${os_1.default.EOL}> Duplicate contract names found for ${contractName}.${os_1.default.EOL}` +
                            `> This can cause errors and unknown behavior. Please rename one of your contracts.`);
                    }
                    newArtifactObjects[contractName] = artifactObj;
                });
            }
            else {
                newArtifactObjects = artifactObjects;
            }
            try {
                fs_extra_1.default.statSync(this.destination); // check if destination exists
            }
            catch (e) {
                if (e.code === "ENOENT")
                    // if destination doesn't exist, throw error
                    throw new Error(`Destination "${this.destination}" doesn't exist!`);
                throw e; // throw on all other errors
            }
            Object.keys(newArtifactObjects).forEach(contractName => {
                let artifactObject = newArtifactObjects[contractName];
                this.save(artifactObject);
            });
        });
    }
}
module.exports = Artifactor;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 42061:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.finalizeArtifact = exports.writeArtifact = void 0;
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const merge_1 = __importDefault(__webpack_require__(82492));
const assign_1 = __importDefault(__webpack_require__(28583));
function writeArtifact(completeArtifact, outputPath) {
    completeArtifact.updatedAt = new Date().toISOString();
    fs_extra_1.default.writeFileSync(outputPath, JSON.stringify(completeArtifact, null, 2), "utf8");
}
exports.writeArtifact = writeArtifact;
function finalizeArtifact(normalizedExistingArtifact, normalizedNewArtifact) {
    const knownNetworks = (0, merge_1.default)({}, normalizedExistingArtifact.networks, normalizedNewArtifact.networks);
    const completeArtifact = (0, assign_1.default)({}, normalizedExistingArtifact, normalizedNewArtifact, { networks: knownNetworks });
    return completeArtifact;
}
exports.finalizeArtifact = finalizeArtifact;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 86317:
/***/ ((module) => {

"use strict";

const Blockchain = {
    getBlockByNumber(blockNumber, provider, callback) {
        const params = [blockNumber, true];
        provider.send({
            jsonrpc: "2.0",
            method: "eth_getBlockByNumber",
            params,
            id: Date.now()
        }, callback);
    },
    getBlockByHash(blockHash, provider, callback) {
        const params = [blockHash, true];
        provider.send({
            jsonrpc: "2.0",
            method: "eth_getBlockByHash",
            params,
            id: Date.now()
        }, callback);
    },
    parse(uri) {
        const parsed = {};
        if (uri.indexOf("blockchain://") !== 0)
            return parsed;
        const cleanUri = uri.replace("blockchain://", "");
        const pieces = cleanUri.split("/block/");
        parsed.genesis_hash = `0x${pieces[0]}`;
        parsed.block_hash = `0x${pieces[1]}`;
        return parsed;
    },
    asURI(provider) {
        return new Promise((resolve, reject) => {
            let genesis, latest;
            this.getBlockByNumber("0x0", provider, (err, { result }) => {
                if (err)
                    return reject(err);
                genesis = result;
                this.getBlockByNumber("latest", provider, (err, { result }) => {
                    if (err)
                        return reject(err);
                    latest = result;
                    const url = `blockchain://${genesis.hash.replace("0x", "")}/block/${latest.hash.replace("0x", "")}`;
                    resolve(url);
                });
            });
        });
    },
    matches(uri, provider) {
        return new Promise((resolve, reject) => {
            const parsedUri = this.parse(uri);
            const expectedGenesis = parsedUri.genesis_hash;
            const expectedBlock = parsedUri.block_hash;
            this.getBlockByNumber("0x0", provider, (err, { result }) => {
                if (err)
                    return reject(err);
                const block = result;
                if (block.hash !== expectedGenesis)
                    return resolve(false);
                this.getBlockByHash(expectedBlock, provider, (err, { result }) => {
                    // Treat an error as if the block didn't exist. This is because
                    // some clients respond differently.
                    const block = result;
                    if (err || block == null) {
                        return resolve(false);
                    }
                    resolve(true);
                });
            });
        });
    }
};
module.exports = Blockchain;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 67078:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var pkgVersion = (__webpack_require__(23373)/* .version */ .i8);
var Ajv = __webpack_require__(65096);
var util = __webpack_require__(73837);

var contractObjectSchema = __webpack_require__(85351);
var networkObjectSchema = __webpack_require__(53245);
var abiSchema = __webpack_require__(900);

/**
 * Property definitions for Contract Objects
 *
 * Describes canonical output properties as sourced from some "dirty" input
 * object. Describes normalization process to account for deprecated and/or
 * nonstandard keys and values.
 *
 * Maps (key -> property) where:
 *  - `key` is the top-level output key matching up with those in the schema
 *  - `property` is an object with optional values:
 *      - `sources`: list of sources (see below); default `key`
 *      - `transform`: function(value) -> transformed value; default x -> x
 *
 * Each source represents a means to select a value from dirty object.
 * Allows:
 *  - dot-separated (`.`) string, corresponding to path to value in dirty
 *    object
 *  - function(dirtyObj) -> (cleanValue | undefined)
 *
 * The optional `transform` parameter standardizes value regardless of source,
 * for purposes of ensuring data type and/or string schemas.
 */

// helper that ensures abi's do not contain function signatures
const sanitizedValue = dirtyValueArray => {
  let sanitizedValueArray = [];
  dirtyValueArray.forEach(item => {
    let sanitizedItem = Object.assign({}, item);
    delete sanitizedItem.signature;
    sanitizedValueArray.push(sanitizedItem);
  });
  return sanitizedValueArray;
};

// filter `signature` property from an event
const sanitizeEvent = dirtyEvent =>
  Object.entries(dirtyEvent).reduce(
    (acc, [property, value]) =>
      property === "signature"
        ? acc
        : Object.assign(acc, { [property]: value }),
    {}
  );

// sanitize aggregrate events given a `network-object.spec.json#events` object
const sanitizeAllEvents = dirtyEvents =>
  Object.entries(dirtyEvents).reduce(
    (acc, [property, event]) =>
      Object.assign(acc, { [property]: sanitizeEvent(event) }),
    {}
  );

var properties = {
  contractName: {
    sources: ["contractName", "contract_name"]
  },
  abi: {
    sources: ["abi", "interface"],
    transform: function (value) {
      if (typeof value === "string") {
        try {
          value = JSON.parse(value);
        } catch (_) {
          value = undefined;
        }
      }
      if (Array.isArray(value)) {
        return sanitizedValue(value);
      }
      return value;
    }
  },
  metadata: {
    sources: ["metadata"]
  },
  bytecode: {
    sources: ["bytecode", "binary", "unlinked_binary", "evm.bytecode.object"],
    transform: function (value) {
      if (value && value.indexOf("0x") !== 0) {
        value = "0x" + value;
      }
      return value;
    }
  },
  deployedBytecode: {
    sources: [
      "deployedBytecode",
      "runtimeBytecode",
      "evm.deployedBytecode.object"
    ],
    transform: function (value) {
      if (value && value.indexOf("0x") !== 0) {
        value = "0x" + value;
      }
      return value;
    }
  },
  immutableReferences: {},
  generatedSources: {},
  deployedGeneratedSources: {},
  sourceMap: {
    transform: function (value) {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch (_) {
          return value;
        }
      } else {
        return value;
      }
    },
    sources: ["sourceMap", "srcmap", "evm.bytecode.sourceMap"]
  },
  deployedSourceMap: {
    transform: function (value) {
      if (typeof value === "string") {
        try {
          return JSON.parse(value);
        } catch (_) {
          return value;
        }
      } else {
        return value;
      }
    },
    sources: [
      "deployedSourceMap",
      "srcmapRuntime",
      "evm.deployedBytecode.sourceMap"
    ]
  },
  source: {},
  sourcePath: {},
  ast: {},
  legacyAST: {},
  compiler: {},
  networks: {
    /**
     * Normalize a networks object. Currently this makes sure `events` are
     * always sanitized and `links` is extracted when copying from
     * a TruffleContract context object.
     *
     * @param {object} value - the target object
     * @param {object | TruffleContract} obj - the context, or source object.
     * @return {object} The normalized Network object
     */
    transform: function (value = {}, obj) {
      // Sanitize value's events for known networks
      Object.keys(value).forEach(networkId => {
        if (value[networkId].events) {
          value[networkId].events = sanitizeAllEvents(value[networkId].events);
        }
      });

      // Set and sanitize the current networks property from the
      // TruffleContract. Note: obj is a TruffleContract if it has
      // `network_id` attribute
      const networkId = obj.network_id;
      if (networkId && value.hasOwnProperty(networkId)) {
        value[networkId].links = obj.links;
        value[networkId].events = sanitizeAllEvents(obj.events);
      }

      return value;
    }
  },
  schemaVersion: {
    sources: ["schemaVersion", "schema_version"]
  },
  updatedAt: {
    sources: ["updatedAt", "updated_at"],
    transform: function (value) {
      if (typeof value === "number") {
        value = new Date(value).toISOString();
      }
      return value;
    }
  },
  networkType: {},
  devdoc: {},
  userdoc: {},
  db: {}
};

/**
 * Construct a getter for a given key, possibly applying some post-retrieve
 * transformation on the resulting value.
 *
 * @return {Function} Accepting dirty object and returning value || undefined
 */
function getter(key, transform) {
  if (transform === undefined) {
    transform = function (x) {
      return x;
    };
  }

  return function (obj) {
    try {
      return transform(obj[key]);
    } catch (_) {
      return undefined;
    }
  };
}

/**
 * Chains together a series of function(obj) -> value, passing resulting
 * returned value to next function in chain.
 *
 * Accepts any number of functions passed as arguments
 * @return {Function} Accepting initial object, returning end-of-chain value
 *
 * Assumes all intermediary values to be objects, with well-formed sequence
 * of operations.
 */
function chain() {
  var getters = Array.prototype.slice.call(arguments);
  return function (obj) {
    return getters.reduce(function (cur, get) {
      return get(cur);
    }, obj);
  };
}

// Schema module
//

var TruffleContractSchema = {
  // Return a promise to validate a contract object
  // - Resolves as validated `contractObj`
  // - Rejects with list of errors from schema validator
  validate: function (contractObj) {
    var ajv = new Ajv({ verbose: true });
    ajv.addSchema(abiSchema);
    ajv.addSchema(networkObjectSchema);
    ajv.addSchema(contractObjectSchema);
    if (ajv.validate("contract-object.spec.json", contractObj)) {
      return contractObj;
    } else {
      const message = `Schema validation failed. Errors:\n\n${ajv.errors
        .map(
          ({
            keyword,
            dataPath,
            schemaPath,
            params,
            message,
            data,
            parentSchema
          }) =>
            util.format(
              "%s (%s):\n%s\n",
              message,
              keyword,
              util.inspect(
                {
                  dataPath,
                  schemaPath,
                  params,
                  data,
                  parentSchema
                },
                { depth: 5 }
              )
            )
        )
        .join("\n")}`;
      const error = new Error(message);
      error.errors = ajv.errors;
      throw error;
    }
  },

  // accepts as argument anything that can be turned into a contract object
  // returns a contract object
  normalize: function (objDirty, options) {
    options = options || {};
    var normalized = {};

    // iterate over each property
    Object.keys(properties).forEach(function (key) {
      var property = properties[key];
      var value; // normalized value || undefined

      // either used the defined sources or assume the key will only ever be
      // listed as its canonical name (itself)
      var sources = property.sources || [key];

      // iterate over sources until value is defined or end of list met
      for (var i = 0; value === undefined && i < sources.length; i++) {
        var source = sources[i];
        // string refers to path to value in objDirty, split and chain
        // getters
        if (typeof source === "string") {
          var traversals = source.split(".").map(function (k) {
            return getter(k);
          });
          source = chain.apply(null, traversals);
        }

        // source should be a function that takes the objDirty and returns
        // value or undefined
        value = source(objDirty);
      }

      // run source-agnostic transform on value
      // (e.g. make sure bytecode begins 0x)
      if (property.transform) {
        value = property.transform(value, objDirty);
      }

      // add resulting (possibly undefined) to normalized obj
      normalized[key] = value;
    });

    // Copy x- options
    Object.keys(objDirty).forEach(function (key) {
      if (key.indexOf("x-") === 0) {
        normalized[key] = getter(key)(objDirty);
      }
    });

    // update schema version
    normalized.schemaVersion = pkgVersion;

    if (options.validate) {
      this.validate(normalized);
    }

    return normalized;
  }
};

module.exports = TruffleContractSchema;


/***/ }),

/***/ 78883:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Schema = __webpack_require__(67078);
const Contract = __webpack_require__(7974);
const truffleContractVersion = (__webpack_require__(54720)/* .version */ .i8);

const contract = (json = {}) => {
  const normalizedArtifactObject = Schema.normalize(json);

  // Note we don't use `new` here at all. This will cause the class to
  // "mutate" instead of instantiate an instance.
  return Contract.clone(normalizedArtifactObject);
};

contract.version = truffleContractVersion;

module.exports = contract;


/***/ }),

/***/ 85210:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const execute = __webpack_require__(41441);
const debug = __webpack_require__(15158)("contract:contract:bootstrap");

module.exports = fn => {
  // Add our static methods
  // Add something here about excluding send, privately defined methods
  Object.keys(fn._constructorMethods).forEach(function (key) {
    fn[key] = fn._constructorMethods[key].bind(fn);
  });

  // Add our properties.
  Object.keys(fn._properties).forEach(function (key) {
    fn.addProp(key, fn._properties[key]);
  });

  // estimateGas & request as sub-property of new
  fn["new"].estimateGas = execute.estimateDeployment.bind(fn);
  fn["new"].request = execute.requestDeployment.bind(fn);

  //add enumerations. (probably these should go in
  //constructorMethods.js, but this is easier to modify... we'll
  //redo all this in the rewrite anyway)
  if (fn._json) {
    //getters will throw otherwise!
    if (fn.ast) {
      //note this was set up earlier
      const node = locateNode(fn.contractName, fn.ast); //name also set up earlier
      if (node) {
        fn.enums = extractEnums(node);
        for (const [name, enumeration] of Object.entries(fn.enums)) {
          //enum is a reserved word :P
          if (!(name in fn)) {
            //don't overwrite anything!
            fn[name] = enumeration;
          }
        }
      }
    }
  }

  return fn;
};

function locateNode(name, ast) {
  if (ast.nodeType === "SourceUnit") {
    return ast.nodes.find(
      node => node.nodeType === "ContractDefinition" && node.name === name
    );
  } else {
    return undefined;
  }
}

function extractEnums(node) {
  return Object.assign(
    {},
    ...node.nodes
      .filter(definition => definition.nodeType === "EnumDefinition")
      .map(definition => ({
        [definition.name]: Object.assign(
          {},
          ...definition.members.map((member, index) => ({[member.name]: index}))
        )
      }))
  );
}


/***/ }),

/***/ 2629:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(36339);
const utils = __webpack_require__(13735);
const execute = __webpack_require__(41441);
const bootstrap = __webpack_require__(85210);
const debug = __webpack_require__(15158)("contract:contract:constructorMethods");
const OS = __webpack_require__(22037);

module.exports = Contract => ({
  configureNetwork({ networkType, provider } = {}) {
    // otherwise use existing value as default (at most one of these)
    networkType = networkType || this.networkType;
    provider = provider || this.currentProvider;

    // recreate interfaceadapter
    this.interfaceAdapter = createInterfaceAdapter({ networkType, provider });

    if (this.web3) {
      // update existing
      this.web3.setNetworkType(networkType);
      this.web3.setProvider(provider);
    } else {
      // create new
      this.web3 = new Web3Shim({ networkType, provider });
    }

    // save properties
    this.currentProvider = provider;
    this.networkType = networkType;
  },

  setProvider(provider) {
    if (!provider) {
      throw new Error(
        `Invalid provider passed to setProvider(); provider is ${provider}`
      );
    }

    this.configureNetwork({ provider });
  },

  new() {
    utils.checkProvider(this);

    if (!this.bytecode || this.bytecode === "0x") {
      throw new Error(
        `${this.contractName} error: contract binary not set. Can't deploy new instance.\n` +
          `This contract may be abstract, not implement an abstract parent's methods completely\n` +
          `or not invoke an inherited contract's constructor correctly\n`
      );
    }

    var constructorABI = this.abi.filter(i => i.type === "constructor")[0];

    return execute.deploy.call(this, constructorABI)(...arguments);
  },

  async at(address) {
    if (
      address == null ||
      typeof address !== "string" ||
      address.length !== 42
    ) {
      throw new Error(
        `Invalid address passed to ${this.contractName}.at(): ${address}`
      );
    }

    await this.detectNetwork();
    const onChainCode = await this.interfaceAdapter.getCode(address);
    await utils.checkCode(onChainCode, this.contractName, address);
    return new this(address);
  },

  async deployed() {
    if (this.reloadJson) {
      this.reloadJson(); //truffle test monkey-patches in this method
    }
    utils.checkProvider(this);
    await this.detectNetwork();
    utils.checkNetworkArtifactMatch(this);
    utils.checkDeployment(this);
    return new this(this.address);
  },

  defaults(class_defaults) {
    if (this.class_defaults == null) {
      this.class_defaults = {};
    }

    if (class_defaults == null) {
      class_defaults = {};
    }

    Object.keys(class_defaults).forEach(key => {
      const value = class_defaults[key];
      this.class_defaults[key] = value;
    });

    return this.class_defaults;
  },

  hasNetwork(network_id) {
    return this._json.networks[`${network_id}`] != null;
  },

  isDeployed() {
    if (this.network_id == null) {
      return false;
    }

    if (this._json.networks[this.network_id] == null) {
      return false;
    }

    return !!this.network.address;
  },

  async detectNetwork() {
    // guard interfaceAdapter!
    if (this.interfaceAdapter == null) {
      throw new Error("Provider not set or invalid");
    }
    // if artifacts already have a network_id and network configuration synced,
    // use that network and use latest block gasLimit
    if (this.network_id && this.networks[this.network_id] != null) {
      const { gasLimit } = await this.interfaceAdapter.getBlock("latest");
      return { id: this.network_id, blockLimit: gasLimit };
    }
    // since artifacts don't have a network_id synced with a network configuration,
    // poll chain for network_id and sync artifacts
    const chainNetworkID = await this.interfaceAdapter.getNetworkId();
    const { gasLimit } = await this.interfaceAdapter.getBlock("latest");
    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);
  },

  setNetwork(network_id) {
    if (!network_id) return;
    this.network_id = `${network_id}`;
  },

  setNetworkType(networkType = "ethereum") {
    this.configureNetwork({ networkType });
  },

  setWallet(wallet) {
    this.configureNetwork();

    this.web3.eth.accounts.wallet = wallet;
  },

  // Overrides the deployed address to null.
  // You must call this explicitly so you don't inadvertently do this otherwise.
  resetAddress() {
    delete this.network.address;
  },

  // accepts 4 input formats
  //  - (<name>, <address>)
  //  - (<contractType>) - must have a deployed instance with an address
  //  - (<contractInstance>)
  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })
  link(name, address) {
    switch (typeof name) {
      case "string":
        // Case: Contract.link(<libraryName>, <address>)
        if (this._json.networks[this.network_id] == null) {
          this._json.networks[this.network_id] = {
            events: {},
            links: {}
          };
        }

        this.network.links[name] = address;
        return;
      case "function":
        // Case: Contract.link(<contractType>)
        const contract = name;

        if (contract.isDeployed() === false) {
          throw new Error("Cannot link contract without an address.");
        }

        this.link(contract.contractName, contract.address);

        // Merge events so this contract knows about library's events
        Object.keys(contract.events).forEach(topic => {
          this.network.events[topic] = contract.events[topic];
        });
        return;
      case "object":
        // 2 Cases:
        //   - Contract.link({<libraryName>: <address>, ... })
        //   - Contract.link(<instance>)
        const obj = name;
        if (
          obj.constructor &&
          typeof obj.constructor.contractName === "string" &&
          obj.address
        ) {
          // obj is a Truffle contract instance
          this.link(obj.constructor.contractName, obj.address);
        } else {
          // obj is of the form { <libraryName>: <address>, ... }
          Object.keys(obj).forEach(name => this.link(name, obj[name]));
        }
        return;
      default:
        const invalidInput =
          `Input to the link method is in the incorrect` +
          ` format. Input must be one of the following:${OS.EOL}` +
          `    - a library name and address                 > ("MyLibrary", ` +
          `"0x123456789...")${OS.EOL}` +
          `    - a contract type                            > ` +
          `(MyContract)${OS.EOL}` +
          `    - a contract instance                        > ` +
          `(myContract)${OS.EOL}` +
          `    - an object with library names and addresses > ({ <libName>: ` +
          `<address>, <libName2>: <address2>, ... })${OS.EOL}`;
        throw new Error(invalidInput);
    }
  },

  // Note, this function can be called with two input types:
  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.
  // 2. network id; this will clone the contract and set a specific network id upon cloning.
  clone(json) {
    json = json || {};

    const temp = function TruffleContract() {
      this.constructor = temp;
      return Contract.apply(this, arguments);
    };

    temp.prototype = Object.create(this.prototype);

    let network_id;

    // If we have a network id passed
    if (typeof json !== "object") {
      network_id = json;
      json = this._json;
    }

    json = utils.merge({}, this._json || {}, json);

    temp._constructorMethods = this._constructorMethods;
    temp._properties = this._properties;

    temp._property_values = {};
    temp._json = json;

    bootstrap(temp);

    temp.class_defaults = temp.prototype.defaults || {};

    if (network_id) {
      temp.setNetwork(network_id);
    }

    if (this.currentProvider) {
      temp.configureNetwork({
        provider: this.currentProvider,
        networkType: this.networkType
      });
    }

    // Copy over custom key/values to the contract class
    Object.keys(json).forEach(key => {
      if (key.indexOf("x-") !== 0) return;
      temp[key] = json[key];
    });

    return temp;
  },

  addProp(key, fn) {
    const getter = () => {
      if (fn.get != null) {
        return fn.get.call(this);
      }

      return this._property_values[key] || fn.call(this);
    };

    const setter = val => {
      if (fn.set != null) {
        fn.set.call(this, val);
        return;
      }

      // If there's not a setter, then the property is immutable.
      throw new Error(`${key} property is immutable`);
    };

    const definition = {};
    definition.enumerable = false;
    definition.configurable = false;
    definition.get = getter;
    definition.set = setter;

    Object.defineProperty(this, key, definition);
  },

  toJSON() {
    return this._json;
  },

  decodeLogs: utils.decodeLogs
});


/***/ }),

/***/ 7974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
const debug = __webpack_require__(15158)("contract:contract");
let Web3 = __webpack_require__(3283);
const webUtils = __webpack_require__(18269);
const execute = __webpack_require__(41441);
const bootstrap = __webpack_require__(85210);
const constructorMethods = __webpack_require__(2629);
const properties = __webpack_require__(40920);

// For browserified version. If browserify gave us an empty version,
// look for the one provided by the user.
if (typeof Web3 === "object" && Object.keys(Web3).length === 0) {
  Web3 = global.Web3;
}

(function (module) {
  // Accepts a contract object created with web3.eth.Contract or an address.
  function Contract(contract) {
    var instance = this;
    var constructor = instance.constructor;

    // Disambiguate between .at() and .new()
    if (typeof contract === "string") {
      var web3Instance = new constructor.web3.eth.Contract(constructor.abi);
      web3Instance.options.address = contract;
      contract = web3Instance;
    }

    // Core:
    instance.methods = {};
    instance.abi = constructor.abi;
    instance.address = contract.options.address;
    instance.transactionHash = contract.transactionHash;
    instance.contract = contract;

    //for stacktracing in tests
    if (constructor.debugger) {
      instance.debugger = constructor.debugger;
    }

    // User defined methods, overloaded methods, events
    instance.abi.forEach(function (item) {
      switch (item.type) {
        case "function":
          var isConstant =
            ["pure", "view"].includes(item.stateMutability) || item.constant; // new form // deprecated case

          var signature = webUtils._jsonInterfaceMethodToString(item);

          var method = function (constant, web3Method) {
            var fn;

            constant
              ? (fn = execute.call.call(
                  constructor,
                  web3Method,
                  item,
                  instance.address
                ))
              : (fn = execute.send.call(
                  constructor,
                  web3Method,
                  item,
                  instance.address
                ));

            fn.call = execute.call.call(
              constructor,
              web3Method,
              item,
              instance.address
            );
            fn.sendTransaction = execute.send.call(
              constructor,
              web3Method,
              item,
              instance.address
            );
            fn.estimateGas = execute.estimate.call(
              constructor,
              web3Method,
              item,
              instance.address
            );
            fn.request = execute.request.call(
              constructor,
              web3Method,
              item,
              instance.address
            );

            return fn;
          };

          // Only define methods once. Any overloaded methods will have all their
          // accessors available by ABI signature available on the `methods` key below.
          if (instance[item.name] === undefined) {
            instance[item.name] = method(
              isConstant,
              contract.methods[item.name]
            );
          }

          // Overloaded methods should be invoked via the .methods property
          instance.methods[signature] = method(
            isConstant,
            contract.methods[signature]
          );
          break;

        case "event":
          instance[item.name] = execute.event.call(
            constructor,
            contract.events[item.name]
          );
          break;
      }
    });

    // instance.{sendTransaction, estimateGas, call, send}
    instance.sendTransaction = execute.send.call(
      constructor,
      null,
      null,
      instance.address
    );

    instance.estimateGas = execute.estimate.call(
      constructor,
      null,
      null,
      instance.address
    );

    // Prefer user defined `call`
    if (!instance.call) {
      instance.call = execute.call.call(
        constructor,
        null,
        null,
        instance.address
      );
    }

    // Prefer user defined `send`
    if (!instance.send) {
      instance.send = (value, txParams = {}) => {
        const packet = Object.assign({ value: value }, txParams);
        return instance.sendTransaction(packet);
      };
    }

    // Other events
    instance.allEvents = execute.allEvents.call(constructor, contract);
    instance.getPastEvents = execute.getPastEvents.call(constructor, contract);
  }

  Contract._constructorMethods = constructorMethods(Contract);

  // Getter functions are scoped to Contract object.
  Contract._properties = properties;

  bootstrap(Contract);
  module.exports = Contract;

  return Contract;
})(module || {});


/***/ }),

/***/ 40920:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const utils = __webpack_require__(13735);
const web3Utils = __webpack_require__(18269);

module.exports = {
  contract_name: {
    get: function () {
      return this.contractName;
    },
    set: function (val) {
      this.contractName = val;
    }
  },
  contractName: {
    get: function () {
      return this._json.contractName || "Contract";
    },
    set: function (val) {
      this._json.contractName = val;
    }
  },

  gasMultiplier: {
    get: function () {
      if (this._json.gasMultiplier === undefined) {
        this._json.gasMultiplier = 1.25;
      }
      return this._json.gasMultiplier;
    },
    set: function (val) {
      this._json.gasMultiplier = val;
    }
  },
  timeoutBlocks: {
    get: function () {
      return this._json.timeoutBlocks;
    },
    set: function (val) {
      this._json.timeoutBlocks = val;
    }
  },
  autoGas: {
    get: function () {
      if (this._json.autoGas === undefined) {
        this._json.autoGas = true;
      }
      return this._json.autoGas;
    },
    set: function (val) {
      this._json.autoGas = val;
    }
  },
  numberFormat: {
    get: function () {
      if (this._json.numberFormat === undefined) {
        this._json.numberFormat = "BN";
      }
      return this._json.numberFormat;
    },
    set: function (val) {
      const allowedFormats = ["BigNumber", "BN", "String", "BigInt"];

      const msg =
        `Invalid number format setting: "${val}": ` +
        `valid formats are: ${JSON.stringify(allowedFormats)}.`;

      if (!allowedFormats.includes(val)) throw new Error(msg);

      this._json.numberFormat = val;
    }
  },
  abi: {
    get: function () {
      return this._json.abi;
    },
    set: function (val) {
      this._json.abi = val;
    }
  },
  metadata: function () {
    return this._json.metadata;
  },
  network: function () {
    var network_id = this.network_id;

    if (network_id == null) {
      var error =
        this.contractName +
        " has no network id set, cannot lookup artifact data." +
        " Either set the network manually using " +
        this.contractName +
        ".setNetwork(), run " +
        this.contractName +
        ".detectNetwork(), or use new()," +
        " at() or deployed() as a thenable which will detect the network automatically.";

      throw new Error(error);
    }

    // TODO: this might be bad; setting a value on a get.
    if (this._json.networks[network_id] == null) {
      var error =
        this.contractName +
        " has no network configuration" +
        " for its current network id (" +
        network_id +
        ").";

      throw new Error(error);
    }

    var returnVal = this._json.networks[network_id];

    // Normalize output
    if (returnVal.links == null) {
      returnVal.links = {};
    }

    if (returnVal.events == null) {
      returnVal.events = {};
    }

    return returnVal;
  },
  networks: function () {
    return this._json.networks;
  },
  address: {
    get: function () {
      var address = this.network.address;

      if (address == null) {
        var error =
          "Cannot find deployed address: " +
          this.contractName +
          " not deployed or address not set.";
        throw new Error(error);
      }

      return address;
    },
    set: function (val) {
      if (val == null) {
        throw new Error("Cannot set deployed address; malformed value: " + val);
      }

      var network_id = this.network_id;

      if (network_id == null) {
        var error =
          this.contractName +
          " has no network id set, cannot lookup artifact data." +
          " Either set the network manually using " +
          this.contractName +
          ".setNetwork(), run " +
          this.contractName +
          ".detectNetwork()," +
          " or use new(), at() or deployed() as a thenable which will" +
          " detect the network automatically.";

        throw new Error(error);
      }

      // Create a network if we don't have one.
      if (this._json.networks[network_id] == null) {
        this._json.networks[network_id] = {
          events: {},
          links: {}
        };
      }

      // Finally, set the address.
      this.network.address = val;
    }
  },
  transactionHash: {
    get: function () {
      return this.network.transactionHash;
    },
    set: function (val) {
      this.network.transactionHash = val;
    }
  },
  links: function () {
    if (!this.network_id) {
      var error =
        this.contractName +
        " has no network id set, cannot lookup artifact data." +
        " Either set the network manually using " +
        this.contractName +
        ".setNetwork()," +
        " run " +
        this.contractName +
        ".detectNetwork(), or use new(), at()" +
        " or deployed() as a thenable which will detect the network automatically.";

      throw new Error(error);
    }

    if (this._json.networks[this.network_id] == null) {
      return {};
    }

    return this.network.links || {};
  },
  events: function () {
    var events;

    if (this._json.networks[this.network_id] == null) {
      events = {};
    } else {
      events = this.network.events || {};
    }

    // Merge abi events with whatever's returned.
    var abi = this.abi;

    abi.forEach(function (item) {
      if (item.type !== "event") return;

      if (item.signature) {
        events[item.signature] = item;
      } else {
        var signature = item.name + "(";

        item.inputs.forEach(function (input, index) {
          signature += input.type;

          if (index < item.inputs.length - 1) {
            signature += ",";
          }
        });

        signature += ")";

        var topic = web3Utils.keccak256(signature);

        events[topic] = item;
      }
    });

    return events;
  },
  binary: function () {
    return utils.linkBytecode(this.bytecode, this.links);
  },
  deployedBinary: function () {
    return utils.linkBytecode(this.deployedBytecode, this.links);
  },

  // deprecated; use bytecode
  unlinked_binary: {
    get: function () {
      return this.bytecode;
    },
    set: function (val) {
      this.bytecode = val;
    }
  },
  // alias for unlinked_binary; unlinked_binary will eventually be deprecated
  bytecode: {
    get: function () {
      return this._json.bytecode;
    },
    set: function (val) {
      this._json.bytecode = val;
    }
  },
  deployedBytecode: {
    get: function () {
      var code = this._json.deployedBytecode;

      if (!code) {
        return code;
      }

      if (code.indexOf("0x") !== 0) {
        code = "0x" + code;
      }

      return code;
    },
    set: function (val) {
      var code = val;

      if (val && val.indexOf("0x") !== 0) {
        code = "0x" + code;
      }

      this._json.deployedBytecode = code;
    }
  },
  sourceMap: {
    get: function () {
      return this._json.sourceMap;
    },
    set: function (val) {
      this._json.sourceMap = val;
    }
  },
  deployedSourceMap: {
    get: function () {
      return this._json.deployedSourceMap;
    },
    set: function (val) {
      this._json.deployedSourceMap = val;
    }
  },
  source: {
    get: function () {
      return this._json.source;
    },
    set: function (val) {
      this._json.source = val;
    }
  },
  sourcePath: {
    get: function () {
      return this._json.sourcePath;
    },
    set: function (val) {
      this._json.sourcePath = val;
    }
  },
  legacyAST: {
    get: function () {
      return this._json.legacyAST;
    },
    set: function (val) {
      this._json.legacyAST = val;
    }
  },
  ast: {
    get: function () {
      return this._json.ast;
    },
    set: function (val) {
      this._json.ast = val;
    }
  },
  compiler: {
    get: function () {
      return this._json.compiler;
    },
    set: function (val) {
      this._json.compiler = val;
    }
  },
  // Deprecated
  schema_version: function () {
    return this.schemaVersion;
  },
  schemaVersion: function () {
    return this._json.schemaVersion;
  },
  // deprecated
  updated_at: function () {
    return this.updatedAt;
  },
  updatedAt: function () {
    try {
      return this.network.updatedAt || this._json.updatedAt;
    } catch (e) {
      return this._json.updatedAt;
    }
  },
  userdoc: function () {
    return this._json.userdoc;
  },
  devdoc: function () {
    return this._json.devdoc;
  },
  networkType: {
    get: function () {
      return this._json.networkType || "ethereum";
    },
    set: function (_networkType) {
      this._json.networkType = _networkType;
    }
  },
  immutableReferences: {
    get: function () {
      return this._json.immutableReferences;
    },
    set: function (refs) {
      this._json.immutableReferences = refs;
    }
  },
  generatedSources: {
    get: function () {
      return this._json.generatedSources;
    },
    set: function (sources) {
      this._json.generatedSources = sources;
    }
  },
  deployedGeneratedSources: {
    get: function () {
      return this._json.deployedGeneratedSources;
    },
    set: function (sources) {
      this._json.deployedGeneratedSources = sources;
    }
  },
  db: {
    get: function () {
      return this._json.db;
    },
    set: function (db) {
      this._json.db = db;
    }
  }
};


/***/ }),

/***/ 41441:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract:execute");
const PromiEvent = __webpack_require__(20302);
const EventEmitter = __webpack_require__(82361);
const utils = __webpack_require__(13735);
const StatusError = __webpack_require__(60550);
const Reason = __webpack_require__(12630);
const handlers = __webpack_require__(99198);
const override = __webpack_require__(47009);
const reformat = __webpack_require__(90908);
const { sendTransactionManual } = __webpack_require__(95945);

const execute = {
  // -----------------------------------  Helpers --------------------------------------------------
  /**
   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.
   * Lacking an estimate, sets gas to have of latest blockLimit
   * @param  {Object} params     `sendTransaction` parameters
   * @param  {Number} blockLimit  most recent network block.blockLimit
   * @return {Number}             gas estimate
   */
  getGasEstimate: function (params, blockLimit, stacktrace = false) {
    const constructor = this;
    const interfaceAdapter = constructor.interfaceAdapter;
    const web3 = constructor.web3;

    return new Promise(function (accept, reject) {
      // Always prefer gas specified by user (if a user sets gas to 0, that is treated
      // as undefined here and we do proceed to do gas estimation)
      if (params.gas) return accept(params.gas);
      if (!constructor.autoGas) return accept();

      interfaceAdapter
        .estimateGas(params, stacktrace)
        .then(gas => {
          // there are situations where the web3 gas estimation function in interfaceAdapter
          // fails, specifically when a transaction will revert; we still want to continue
          // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a
          // default gas for that situation, equal to half of the blockLimit for the latest block
          //
          // note: this means if a transaction will revert but the user does not have stacktracing enabled,
          // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this
          if (gas === null) {
            const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));
            accept(defaultGas.toHexString());
          } else {
            const limit = utils.bigNumberify(blockLimit);
            // if we did get a numerical gas estimate from interfaceAdapter, we
            // multiply that estimate by the gasMultiplier to help ensure we
            // have enough gas for the transaction
            const bestEstimate = utils.multiplyBigNumberByDecimal(
              utils.bigNumberify(gas),
              constructor.gasMultiplier
            );
            // Check that we don't go over blockLimit
            bestEstimate.gte(limit)
              ? accept(limit.sub(1).toHexString())
              : accept(bestEstimate.toHexString());
          }
        })
        .catch(error => {
          //HACK: Frankenstein together an error in a destructive fashion!!
          debug("error: %O", error);
          const reason = Reason._extract({ error }, web3);
          error.reason = reason;
          if (reason) {
            error.message += ` -- Reason given: ${reason}.`;
          }
          reject(error);
        });
    });
  },

  /**
   * Prepares simple wrapped calls by checking network and organizing the method inputs into
   * objects web3 can consume.
   * @param  {Object} constructor   TruffleContract constructor
   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.
   * @param  {Array}  _arguments    Arguments passed to method invocation
   * @param  {Boolean}  isCall      Used when preparing a call as opposed to a tx;
   *                                  skips network checks and ignores default gas prices
   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments
   */
  prepareCall: async function (constructor, methodABI, _arguments, isCall) {
    let args = Array.prototype.slice.call(_arguments);
    let params = utils.getTxParams.call(constructor, methodABI, args, isCall);

    args = utils.convertToEthersBN(args);

    if (constructor.ens && constructor.ens.enabled) {
      const { web3 } = constructor;
      const processedValues = await utils.ens.convertENSNames({
        networkId: constructor.network_id,
        ens: constructor.ens,
        inputArgs: args,
        inputParams: params,
        methodABI,
        web3
      });
      args = processedValues.args;
      params = processedValues.params;
    }
    //isCall flag used to skip network call for read data (calls type) methods invocation
    if (isCall) {
      return { args, params };
    }
    const network = await constructor.detectNetwork();
    return { args, params, network };
  },

  /**
   * Disambiguates between transaction parameter objects and BN / BigNumber objects
   * @param  {Any}  arg
   * @return {Boolean}
   */
  hasTxParams: function (arg) {
    return utils.is_object(arg) && !utils.is_big_number(arg);
  },

  /**
   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`
   * to execute a call at.
   * @param  {Array}  args      `arguments` that were passed to method
   * @param  {Any}    lastArg    terminal argument passed to method
   * @param  {Array}  methodABI  ABI for the method; null for ABI-less calls
   * @return {Boolean}           true if final argument is `defaultBlock`
   */
  hasDefaultBlock: function (args, lastArg, methodABI) {
    const expectedArgsCount = methodABI ? methodABI.inputs.length : 0;
    const hasDefaultBlock =
      !execute.hasTxParams(lastArg) && args.length > expectedArgsCount;
    const hasDefaultBlockWithParams =
      execute.hasTxParams(lastArg) && args.length - 1 > expectedArgsCount;
    return hasDefaultBlock || hasDefaultBlockWithParams;
  },

  // -----------------------------------  Methods --------------------------------------------------

  /**
   * Executes method as .call and processes optional `defaultBlock` argument.
   * @param  {Function} fn         method
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @return {Promise}             Return value of the call.
   */
  call: function (fn, methodABI, address) {
    const constructor = this;

    return function () {
      let defaultBlock = constructor.web3.eth.defaultBlock || "latest";
      const args = Array.prototype.slice.call(arguments);
      const lastArg = args[args.length - 1];
      const promiEvent = new PromiEvent();

      // Extract defaultBlock parameter
      if (execute.hasDefaultBlock(args, lastArg, methodABI)) {
        defaultBlock = args.pop();
      }
      //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation
      const skipNetworkCheck = true;
      execute
        .prepareCall(constructor, methodABI, args, skipNetworkCheck)
        .then(async ({ args, params }) => {
          let result;

          params.to = address;

          promiEvent.eventEmitter.emit("execute:call:method", {
            fn: fn,
            args: args,
            address: address,
            abi: methodABI,
            contract: constructor
          });

          result = fn //null fn is used for instance.call()
            ? await fn(...args).call(params, defaultBlock)
            : await constructor.web3.eth.call(params, defaultBlock);
          result = reformat.numbers.call(
            constructor,
            result,
            methodABI ? methodABI.outputs : []
          );
          return promiEvent.resolve(result);
        })
        .catch(promiEvent.reject);

      return promiEvent.eventEmitter;
    };
  },

  /**
   * Executes method as .send
   * @param  {Function} fn         Method to invoke
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @param  {String}   address    Deployed address of the targeted instance
   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)
   */
  send: function (fn, methodABI, address) {
    const constructor = this;
    const web3 = constructor.web3;

    return function () {
      const promiEvent = new PromiEvent(false, constructor.debugger);

      execute
        .prepareCall(constructor, methodABI, arguments)
        .then(async ({ args, params, network }) => {
          const context = {
            contract: constructor, // Can't name this field `constructor` or `_constructor`
            promiEvent: promiEvent,
            blockLimit: network.blockLimit,
            params: params
          };

          params.to = address;
          params.data = fn ? fn(...args).encodeABI() : params.data;

          promiEvent.eventEmitter.emit("execute:send:method", {
            fn,
            args,
            address,
            abi: methodABI,
            contract: constructor
          });

          params.gas = await execute.getGasEstimate.call(
            constructor,
            params,
            network.blockLimit,
            promiEvent.debug //apply stacktracing mode if promiEvent.debug is true
          );

          execute
            .sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...
            .then(receipt => {
              if (promiEvent.debug) {
                // in this case, we need to manually invoke the handler since it
                // hasn't been set up (hack?)
                handlers.receipt(context, receipt);
              }
              //otherwise, just let the handlers handle things
            })
            .catch(override.start.bind(constructor, context));
        })
        .catch(promiEvent.reject);

      return promiEvent.eventEmitter;
    };
  },

  /**
   * Deploys an instance
   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys
   * @return {PromiEvent}             Resolves a TruffleContract instance
   */
  deploy: function (constructorABI) {
    const constructor = this;
    const web3 = constructor.web3;

    return function () {
      let deferred;
      const promiEvent = new PromiEvent(false, constructor.debugger, true);

      execute
        .prepareCall(constructor, constructorABI, arguments)
        .then(async ({ args, params, network }) => {
          const { blockLimit } = network;

          utils.checkLibraries.apply(constructor);

          // Promievent and flag that allows instance to resolve (rather than just receipt)
          const context = {
            contract: constructor,
            promiEvent,
            blockLimit,
            onlyEmitReceipt: true
          };

          const options = {
            data: constructor.binary,
            arguments: args
          };

          const contract = new web3.eth.Contract(constructor.abi);
          params.data = contract.deploy(options).encodeABI();

          params.gas = await execute.getGasEstimate.call(
            constructor,
            params,
            blockLimit,
            promiEvent.debug //apply stacktracing mode if promiEvent.debug is true
          );

          context.params = params;

          promiEvent.eventEmitter.emit("execute:deploy:method", {
            args,
            abi: constructorABI,
            contract: constructor
          });

          deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...

          try {
            const receipt = await deferred;
            if (receipt.status !== undefined && !receipt.status) {
              const reason = await Reason.get(params, web3);

              const error = new StatusError(
                params,
                context.transactionHash,
                receipt,
                reason
              );

              return context.promiEvent.reject(error);
            }

            const web3Instance = new web3.eth.Contract(
              constructor.abi,
              receipt.contractAddress
            );
            web3Instance.transactionHash = context.transactionHash;

            context.promiEvent.resolve(new constructor(web3Instance));
          } catch (web3Error) {
            // Manage web3's 50 blocks' timeout error.
            // Web3's own subscriptions go dead here.
            await override.start.call(constructor, context, web3Error);
          }
        })
        .catch(promiEvent.reject);

      return promiEvent.eventEmitter;
    };
  },

  /**
   * Begins listening for an event OR manages the event callback
   * @param  {Function} fn  Solidity event method
   * @return {Emitter}      Event emitter
   */
  event: function (fn) {
    const constructor = this;
    const decode = utils.decodeLogs;
    let currentLogID = null;

    // Someone upstream is firing duplicates :/
    function dedupe(id) {
      return id === currentLogID ? false : (currentLogID = id);
    }

    return function (params, callback) {
      if (typeof params === "function") {
        callback = params;
        params = {};
      }

      // As callback
      if (callback !== undefined) {
        const intermediary = function (err, e) {
          if (err) return callback(err);
          if (!dedupe(e.id)) return;
          callback(null, decode.call(constructor, e, true)[0]);
        };

        return constructor
          .detectNetwork()
          .then(() => fn.call(constructor.events, params, intermediary));
      }

      // As EventEmitter
      const emitter = new EventEmitter();

      constructor.detectNetwork().then(() => {
        const event = fn(params);

        event.on(
          "data",
          e =>
            dedupe(e.id) &&
            emitter.emit("data", decode.call(constructor, e, true)[0])
        );
        event.on(
          "changed",
          e =>
            dedupe(e.id) &&
            emitter.emit("changed", decode.call(constructor, e, true)[0])
        );
        event.on("error", e => emitter.emit("error", e));
      });

      return emitter;
    };
  },

  /**
   * Wraps web3 `allEvents`, with additional log decoding
   * @return {PromiEvent}  EventEmitter
   */
  allEvents: function (web3Instance) {
    const constructor = this;
    const decode = utils.decodeLogs;
    let currentLogID = null;

    // Someone upstream is firing duplicates :/
    function dedupe(id) {
      return id === currentLogID ? false : (currentLogID = id);
    }

    return function (params) {
      const emitter = new EventEmitter();

      constructor.detectNetwork().then(() => {
        const event = web3Instance.events.allEvents(params);

        event.on(
          "data",
          e =>
            dedupe(e.id) &&
            emitter.emit("data", decode.call(constructor, e, true)[0])
        );
        event.on(
          "changed",
          e =>
            dedupe(e.id) &&
            emitter.emit("changed", decode.call(constructor, e, true)[0])
        );
        event.on("error", e => emitter.emit("error", e));
      });

      return emitter;
    };
  },

  /**
   * Wraps web3 `getPastEvents`, with additional log decoding
   * @return {Promise}  Resolves array of event objects
   */
  getPastEvents: function (web3Instance) {
    const constructor = this;
    const decode = utils.decodeLogs;

    return function (event, options) {
      return web3Instance
        .getPastEvents(event, options)
        .then(events => decode.call(constructor, events, false));
    };
  },

  /**
   * Estimates gas cost of a method invocation
   * @param  {Function} fn  Method to target
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @return {Promise}
   */
  estimate: function (fn, methodABI, address) {
    const constructor = this;
    return function () {
      return execute
        .prepareCall(constructor, methodABI, arguments)
        .then(async res =>
          fn //null fn is used for instance.estimateGas()
            ? await fn(...res.args).estimateGas(res.params)
            : await constructor.web3.eth.estimateGas({
                ...res.params,
                to: address
              })
        );
    };
  },

  /**
   *
   * @param  {Function} fn  Method to target
   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.
   * @return {Promise}
   */
  request: function (fn, methodABI, address) {
    const constructor = this;
    return function () {
      return execute
        .prepareCall(constructor, methodABI, arguments)
        .then(res => {
          //clone res.params
          let tx = {};
          for (let key in res.params) {
            tx[key] = res.params[key];
          }
          //set to
          tx.to = address;
          //set data
          tx.data = fn(...res.args).encodeABI();
          return tx;
        });
    };
  },

  // This gets attached to `.new` (declared as a static_method in `contract`)
  // during bootstrapping as `estimateGas`
  estimateDeployment: function () {
    const constructor = this;

    const constructorABI = constructor.abi.filter(
      i => i.type === "constructor"
    )[0];

    return execute
      .prepareCall(constructor, constructorABI, arguments)
      .then(res => {
        const options = {
          data: constructor.binary,
          arguments: res.args
        };

        delete res.params["data"]; // Is this necessary?

        const instance = new constructor.web3.eth.Contract(
          constructor.abi,
          res.params
        );
        return instance.deploy(options).estimateGas(res.params);
      });
  },

  // This gets attached to `.new` (declared as a static_method in `contract`)
  // during bootstrapping as `request`
  requestDeployment: function () {
    const constructor = this;

    const constructorABI = constructor.abi.filter(
      i => i.type === "constructor"
    )[0];

    return execute
      .prepareCall(constructor, constructorABI, arguments)
      .then(res => {
        //clone res.params
        let tx = {};
        for (let key in res.params) {
          tx[key] = res.params[key];
        }

        const options = {
          data: constructor.binary,
          arguments: res.args
        };

        const instance = new constructor.web3.eth.Contract(
          constructor.abi,
          res.params
        );
        tx.data = instance.deploy(options).encodeABI();
        return tx;
      });
  },

  //our own custom sendTransaction function, made to mimic web3's,
  //while also being able to do things, like, say, store the transaction
  //hash even in case of failure.  it's not as powerful in some ways,
  //as it just returns an ordinary Promise rather than web3's PromiEvent,
  //but it's more suited to our purposes (we're not using that PromiEvent
  //functionality here anyway)
  //input works the same as input to web3.sendTransaction
  //(well, OK, it's lacking some things there too, but again, good enough
  //for our purposes)
  sendTransaction: async function (web3, params, promiEvent, context) {
    //if we don't need the debugger, let's not risk any errors on our part,
    //and just have web3 do everything
    if (!promiEvent || !promiEvent.debug) {
      const deferred = web3.eth.sendTransaction(params);
      handlers.setup(deferred, context);
      return deferred;
    }
    //otherwise, do things manually!
    //(and skip the PromiEvent stuff :-/ )
    return sendTransactionManual(web3, params, promiEvent);
  }
};

module.exports = execute;


/***/ }),

/***/ 99198:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract:handlers");
const StatusError = __webpack_require__(60550);
const Utils = __webpack_require__(13735);
const Reason = __webpack_require__(12630);

/*
  Handlers for events emitted by `send` / `call` etc.
 */
const handlers = {
  // ----------------------------------- Constants -------------------------------------------------

  maxConfirmations: 24, // Maximum number of confirmation web3 emits
  defaultTimeoutBlocks: 50, // Maximum number of blocks web3 will wait before abandoning tx
  timeoutMessage: "50 blocks", // Substring of web3 timeout error.
  defaultWeb3Error: "please check your gas limit", // Substring of default Web3 error

  // -----------------------------------  Helpers --------------------------------------------------

  /**
   * Parses error message and determines if we should squash web3 timeout errors at user's request.
   * @param  {Object} contract contract instance
   * @param  {Object} message  error message
   * @return {Boolean}
   */
  ignoreTimeoutError({ contract }, { message }) {
    const timedOut = message && message.includes(handlers.timeoutMessage);

    const shouldWait =
      contract &&
      contract.timeoutBlocks &&
      contract.timeoutBlocks > handlers.defaultTimeoutBlocks;

    const waitForTxPropagation =
      message && message.includes(handlers.defaultWeb3Error);

    return shouldWait && (timedOut || waitForTxPropagation);
  },

  /**
   * Attaches Truffle specific handlers to all of the events emitted by a web3 method.
   * @param {Object}       context  execution state
   * @param {PromiEvent}   emitter  promiEvent returned by a web3 method call
   */
  setup: function(emitter, context) {
    emitter.on("error", handlers.error.bind(emitter, context));
    emitter.on("transactionHash", handlers.hash.bind(emitter, context));
    // web3 block polls if the confirmation listener is enabled so we want to
    // give users a way of opting out of this behavior - it causes problems in testing
    if (!context.contract.disableConfirmationListener) {
      emitter.on("confirmation", handlers.confirmation.bind(emitter, context));
    }
    emitter.on("receipt", handlers.receipt.bind(emitter, context));
  },

  // -----------------------------------  Handlers -------------------------------------------------
  /**
   * Error event handler. Emits error unless error is block timeout and user has
   * specified we should wait longer
   * @param  {Object} context   execution state
   * @param  {Object} error     error
   */
  error: function(context, error) {
    if (!handlers.ignoreTimeoutError(context, error)) {
      context.promiEvent.eventEmitter.emit("error", error);
      this.removeListener("error", handlers.error);
    }
  },

  /**
   * Transaction hash event handler. Attaches the hash to the context object
   * so it can be attached to the contract instance after a deployment resolves.
   * @param  {Object} context   execution state
   * @param  {String} hash      transaction hash
   */
  hash: function(context, hash) {
    context.transactionHash = hash;
    context.promiEvent.eventEmitter.emit("transactionHash", hash);
    this.removeListener("transactionHash", handlers.hash);
  },

  confirmation: function(context, number, receipt) {
    context.promiEvent.eventEmitter.emit("confirmation", number, receipt);

    // Per web3: initial confirmation index is 0
    if (number === handlers.maxConfirmations + 1) {
      this.removeListener("confirmation", handlers.confirmation);
    }
  },

  /**
   * Receipt event handler. This handler decodes the event logs, re-emits the receipt,
   * and (for method calls only) resolves/rejects the promiEvent with the receipt.
   * @param  {Object} context   execution state
   * @param  {Object} receipt   transaction receipt
   */
  receipt: async function(context, receipt) {
    // keep around the raw (not decoded) logs in the raw logs field as a
    // stopgap until we can get the ABI for all events, not just the current
    // contract
    receipt.rawLogs = receipt.logs;

    // Decode logs, use as receipt.logs for ease of use.
    try {
      receipt.logs = receipt.logs
        ? Utils.decodeLogs.call(context.contract, receipt.logs)
        : [];
    } catch (error) {
      return context.promiEvent.reject(error);
    }

    // Emit receipt
    context.promiEvent.eventEmitter.emit("receipt", receipt);

    // .new(): Exit early. We need the promiEvent to resolve a contract instance.
    if (context.onlyEmitReceipt) {
      context.receipt = receipt;
      return;
    }

    // .method(): resolve/reject receipt in handler
    if (receipt.status !== undefined && !receipt.status) {
      const reason = await Reason.get(
        context.params,
        context.contract.web3,
        context.contract.interfaceAdapter
      );

      const error = new StatusError(
        context.params,
        receipt.transactionHash,
        receipt,
        reason
      );

      return context.promiEvent.reject(error);
    }

    // This object has some duplicate data but is backward compatible.
    context.promiEvent.resolve({
      tx: receipt.transactionHash,
      receipt: receipt,
      logs: receipt.logs
    });

    //HACK: adding this conditional for when the handler is invoked
    //manually during stacktracing
    if (this.removeListener) {
      this.removeListener("receipt", handlers.receipt);
    }
  }
};

module.exports = handlers;


/***/ }),

/***/ 95945:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract:manual-send");
const ethers = __webpack_require__(71712);
const Utils = __webpack_require__ (13735);
const { formatters } = __webpack_require__(84390); //used for reproducing web3's behavior

//this is less manual now, it uses ethers, whew
//(it's still more manual than using web3)
async function sendTransactionManual(web3, params, promiEvent) {
  debug("executing manually!");
  //set up ethers provider
  const ethersProvider = new ethers.providers.Web3Provider(
    web3.currentProvider
  );
  //let's clone params and set it up properly
  const { transaction, from } = setUpParameters(params, web3);
  //now: if the from address is in the wallet, web3 will sign the transaction before
  //sending, so we have to account for that
  const account = web3.eth.accounts.wallet[from];
  const ethersSigner = account
    ? new ethers.Wallet(account.privateKey, ethersProvider)
    : ethersProvider.getSigner(from);
  debug("got signer");
  let txHash, receipt, ethersResponse;
  try {
    //note: the following code won't work with ethers v5.
    //wth ethers v5, in the getSigner() case, you'll need to
    //use sendUncheckedTransaction instead of sendTransaction.
    //I don't know why.
    ethersResponse = await ethersSigner.sendTransaction(transaction);
    txHash = ethersResponse.hash;
    receipt = await ethersProvider.waitForTransaction(txHash);
    debug("no error");
  } catch (error) {
    ({ txHash, receipt } = handleError(error));
    if (!receipt) {
      receipt = await ethersProvider.waitForTransaction(txHash);
    }
  }
  debug("txHash: %s", txHash);
  receipt = translateReceipt(receipt);
  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@
  return await handleResult(receipt, transaction.to == null);
}

function handleError(error) {
  debug("error: %O", error);
  if (error.data && error.data.hash) {
    //ganache v7.x
    return { txHash: error.data.hash };
  } else if (error.data && Object.keys(error.data).length === 3) {
    //ganache v2.x
    //error.data will have 3 keys: stack, name, and the txHash
    const transactionHash = Object.keys(error.data).find(
      key => key !== "stack" && key !== "name"
    );
    return { txHash: transactionHash };
  } else if (error.transactionHash && error.receipt) {
    return {
      txHash: error.transactionHash,
      receipt: error.receipt
    };
  } else {
    throw error; //rethrow unexpected errors
  }
}

async function handleResult(receipt, isDeployment) {
  const deploymentFailedMessage = "The contract code couldn't be stored, please check your gas limit.";
  if (receipt.status) {
    if (isDeployment) {
      //in the deployment case, web3 might error even when technically successful @_@
      if ((await web3.eth.getCode(receipt.contractAddress)) === "0x") {
        throw new Error(deploymentFailedMessage);
      }
    }
    return receipt;
  } else {
    //otherwise: we have to mimic web3's errors @_@
    if (isDeployment) {
      //deployment case
      throw new Error(deploymentFailedMessage);
    }
    throw new Error(
      "Transaction has been reverted by the EVM:" +
        "\n" +
        JSON.stringify(receipt)
    );
  }
}

function setUpParameters(params, web3) {
  let transaction = Object.assign({}, params);
  transaction.from =
    transaction.from != undefined
      ? transaction.from
      : web3.eth.defaultAccount;
  //now let's have web3 check our inputs
  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn
  //...but ethers uses gasLimit instead of gas like web3
  transaction.gasLimit = transaction.gas;
  delete transaction.gas;
  //also, it insists "from" be kept separate
  const { from } = transaction;
  delete transaction.from;
  return { transaction, from }
}

//translate the receipt to web3 format by converting BigNumbers
//(note: these are *ethers* BigNumbers) to numbers
function translateReceipt(receipt) {
  return Object.assign({},
    ...Object.entries(receipt).map(([key, value]) => ({
      [key]: Utils.is_big_number(value)
        ? value.toNumber()
        : value
    }))
  );
}

module.exports = {
  sendTransactionManual
}


/***/ }),

/***/ 47009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Reason = __webpack_require__(12630);
const handlers = __webpack_require__(99198);
const utils = __webpack_require__(13735);

const override = {
  timeoutMessage: "not mined within", // Substring of timeout err fired by web3
  defaultWeb3Error: "please check your gas limit", // Substring of default Web3 error
  defaultMaxBlocks: 50, // Max # of blocks web3 will wait for a tx
  pollingInterval: 1000,

  /**
   * Attempts to extract receipt object from Web3 error message
   * @param  {Object} message       web3 error
   * @return {Object|undefined} receipt
   */
  extractReceipt(message) {
    const hasReceipt = message && message.includes("{");
    message.includes("}");

    if (hasReceipt) {
      const receiptString = "{" + message.split("{")[1].trim();
      try {
        return JSON.parse(receiptString);
      } catch (err) {
        // ignore
      }
    }
  },

  /**
   * Fired after web3 ceases to support subscriptions if user has specified
   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen
   * for new blocks and begins evaluating whether block height has reached the user
   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.
   *
   * @param  {Object} context execution state
   * @param  {Object} err     error
   */
  start: async function (context, web3Error) {
    const constructor = this;
    let currentBlock = override.defaultMaxBlocks;

    // Reject after attempting to get reason string if we shouldn't be waiting.
    if (!handlers.ignoreTimeoutError(context, web3Error)) {
      // We might have been routed here in web3 >= beta.34 by their own status check
      // error. We want to extract the receipt, emit a receipt event
      // and reject it ourselves.
      const receipt = override.extractReceipt(web3Error.message);
      if (receipt) {
        await handlers.receipt(context, receipt);
        return;
      }

      //set up gas for getting reason -- we want it to be a lot, but not infinite
      const defaultGas = utils
        .bigNumberify(Math.floor(context.blockLimit / 2))
        .toHexString();

      // This will run if there's a reason and no status field
      // e.g: revert with reason ganache --vmErrorsOnRPCResponse=true
      const reason = await Reason.get(
        { ...context.params, gas: defaultGas }, //don't be gas-limited here!
        constructor.web3,
        constructor.interfaceAdapter
      );
      if (reason) {
        web3Error.reason = reason;
        web3Error.message += ` -- Reason given: ${reason}.`;
      }

      return context.promiEvent.reject(web3Error);
    }

    // This will run every block from now until contract.timeoutBlocks
    const listener = function (pollID) {
      currentBlock++;

      if (currentBlock > constructor.timeoutBlocks) {
        clearInterval(pollID);
        return;
      }

      constructor.interfaceAdapter
        .getTransactionReceipt(context.transactionHash)
        .then(result => {
          if (!result) return;

          // make sure reporter receives tx receipt promievent
          handlers.receipt(context, result);
          result.contractAddress
            ? constructor
                .at(result.contractAddress)
                .then(context.promiEvent.resolve)
                .catch(context.promiEvent.reject)
            : constructor.promiEvent.resolve(result);
        })
        .catch(err => {
          clearInterval(pollID);
          context.promiEvent.reject(err);
        });
    };

    // Start polling
    let currentPollingBlock =
      await constructor.interfaceAdapter.getBlockNumber();

    const pollID = setInterval(async () => {
      const newBlock = await constructor.interfaceAdapter.getBlockNumber();

      if (newBlock > currentPollingBlock) {
        currentPollingBlock = newBlock;
        listener(pollID);
      }
    }, override.pollingInterval);
  }
};

module.exports = override;


/***/ }),

/***/ 20302:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract:promievent");
const DebugUtils = __webpack_require__(93293);
const Web3PromiEvent = __webpack_require__(4017);

function PromiEvent(justPromise, bugger = undefined, isDeploy = false) {
  const { resolve, reject, eventEmitter } = new Web3PromiEvent(justPromise);

  const originalStackTrace = new Error().stack;

  function rejectHijacker(e) {
    debug("hijacking!");
    debug("hash: %s", this.txHash);
    let getSolidityStackTrace;
    if (bugger && this.txHash) {
      debug("debugging time!");
      getSolidityStackTrace = async () => {
        try {
          await bugger.load(this.txHash);
          await bugger.runToEnd();
          const report = bugger.stacktrace();
          await bugger.unload();
          return DebugUtils.formatStacktrace(report, 4); //indent 4 to match node's stacktraces
        } catch (_) {
          //ignore errors
          return undefined;
        }
      };
    } else {
      getSolidityStackTrace = async () => undefined;
    }

    getSolidityStackTrace().then((solidityStackTrace) => {
      debug("e.stack: %s", e.stack);
      debug("originalStackTrace: %s", originalStackTrace);
      debug("solidityStackTrace: %s", solidityStackTrace);
      const initialLinesRegexp = isDeploy
        ? /^.*\n.*\n.*\n.*/ //first 4 lines (note . does not include \n)
        : /^.*\n.*\n.*/; //first 3 lines
      //we replace not just the first line but also the next 2 as they contain
      //useless stuff users shouldn't see; in case of deployments there's one
      //additional to remove
      try {
        let stackTrace = originalStackTrace.replace(
          initialLinesRegexp,
          e.stack.split("\n")[0]
        );
        if (solidityStackTrace) {
          //let's split the solidity stack trace into first line & rest
          let [
            _,
            solidityFirstLine,
            solidityRemaining,
          ] = solidityStackTrace.match(/^(.*?)\r?\n((.|\r|\n)*)$/);

          stackTrace = stackTrace.replace(
            /^.*/, //note that . does not include \n
            solidityRemaining //note: this does not end in \n, so no modification needed
          );
          e.hijackedMessage = e.message;
          e.message = solidityFirstLine;
        }

        e.hijackedStack = e.stack;
        e.stack = stackTrace;
      } catch (_) {
        //again, ignore errors
        //(not sure how this can happen here but I'll leave this block here)
      }
      reject(e);
    });
  }

  this.resolve = resolve;
  this.reject = rejectHijacker.bind(this);
  this.eventEmitter = eventEmitter;
  if (bugger) {
    this.debug = true;
  }
}

PromiEvent.resolve = Web3PromiEvent.resolve;

PromiEvent.prototype.setTransactionHash = function (txHash) {
  debug("setting!");
  debug("hash: %s", txHash);
  this.txHash = txHash;
};

module.exports = PromiEvent;


/***/ }),

/***/ 12630:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DebugUtils = __webpack_require__(93293);

/**
 * Methods to fetch and decode reason string from ganache when a tx errors.
 */

const reason = {
  /**
   * Extracts a reason string from `eth_call` response
   * @param  {Object}           res  response from `eth_call` to extract reason
   * @param  {Web3}             web3 a helpful friend
   * @param  {InterfaceAdapter}      interfaceAdapter a new helpful friend
   * @return {String|Undefined}      decoded reason string
   */
  _extract: function (res, web3, _interfaceAdapter) {
    //I'm not sure why interfaceAdapter is here if it's not used,
    //so I just put an underscore in front of its name for now...
    if (!res || (!res.error && !res.result)) return;

    const isObject =
      res && typeof res === "object" && res.error && res.error.data;
    const isString =
      res && typeof res === "object" && typeof res.result === "string";

    if (isObject) {
      // NOTE that Ganache >=2 returns the reason string when
      // vmErrorsOnRPCResponse === true, which this code could
      // be updated to respect (instead of computing here)
      const data = res.error.data;
      let resData;
      if (typeof data === "string") {
        resData = data; // geth, Ganache >7.0.0
      } else if ("result" in data) {
        // there is a single result (Ganache 7.0.0)
        resData = data.result;
      } else {
        // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0
        // NOTE this only works for a single failed transaction at a time.
        const hash = Object.keys(data)[0];
        const errorDetails = data[hash];
        resData = errorDetails.return /* ganache 2.0 */;
      }

      return reason._decode(resData, web3);
    } else if (isString) {
      return reason._decode(res.result, web3);
    } else {
      return undefined;
    }
  },

  _decode: function (rawData, web3) {
    const errorStringHash = "0x08c379a0";
    const panicCodeHash = "0x4e487b71";
    const selectorLength = 2 + 2 * 4; //0x then 4 bytes (0x then 8 hex digits)
    const wordLength = 2 * 32; //32 bytes (64 hex digits)
    if (!rawData) {
      return undefined;
    } else if (rawData === "0x") {
      //no revert message
      return undefined;
    } else if (rawData.startsWith(errorStringHash)) {
      try {
        return web3.eth.abi.decodeParameter(
          "string",
          rawData.slice(selectorLength)
        );
      } catch (_) {
        //no reasonable way to handle this case at present
        return undefined;
      }
    } else if (rawData.startsWith(panicCodeHash)) {
      if (rawData.length === selectorLength + wordLength) {
        const panicCode = web3.eth.abi.decodeParameter(
          "uint256",
          rawData.slice(selectorLength)
        ); //this returns a decimal string
        return `Panic: ${DebugUtils.panicString(panicCode)}`;
      } else {
        //incorrectly encoded panic...?
        return undefined;
      }
    } else {
      const bytesLength = (rawData.length - 2) / 2; //length of raw data in bytes
      if (bytesLength % 32 === 4) {
        //we can't reasonably handle custom errors here at present, sorry
        return "Custom error (could not decode)";
      } else {
        //if the length isn't 4 mod 32, just give up and return undefined.
        //the reason for this is that sometimes this function can accidentally get
        //called on a return value rather than an error (because the tx ran out of
        //gas or failed for a reason other than a revert, e.g., getting refused by
        //the user in MetaMask), meaning the eth_call rerun will *succeed*, potentially
        //resulting in a return value.  We don't want to attach an additional
        //error message in that case, so we return undefined.
        //(What if e.g. the tx is refused by the user in MetaMask, but the rerun yields
        //a revert string...?  Well, that's a problem for another time...)
        return undefined;
      }
    }
  },

  /**
   * Runs tx via `eth_call` and resolves a reason string if it exists on the response.
   * @param  {Object} web3
   * @param  {Object} interfaceAdapter
   * @return {String|Undefined}
   */
  get: function (params, web3, interfaceAdapter) {
    const packet = {
      jsonrpc: "2.0",
      method: "eth_call",
      params: [params, "latest"],
      id: new Date().getTime()
    };

    return new Promise(resolve => {
      web3.currentProvider.send(packet, (err, response) => {
        const reasonString = reason._extract(response, web3, interfaceAdapter);
        resolve(reasonString);
      });
    });
  }
};

module.exports = reason;


/***/ }),

/***/ 90908:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Utilities for reformatting web3 outputs
 */
const BigNumber = __webpack_require__(526);
const web3Utils = __webpack_require__(18269);

/**
 * Converts from string to other number format
 * @param  {String} val    number string returned by web3
 * @param  {String} format name of format to convert to
 * @return {Object|String} converted value
 */
const _convertNumber = function(val, format) {
  const badFormatMsg = `Attempting to convert to unknown number format: ${format}`;

  switch (format) {
    case "BigNumber":
      return new BigNumber(val);
    case "BN":
      return web3Utils.toBN(val);
    case "String":
      return val;
    case "BigInt":
      return BigInt(val);
    default:
      throw new Error(badFormatMsg);
  }
};

/**
 * Converts arrays of number strings to other number formats
 * @param  {String[]} arr       number string array returned by web3
 * @param  {String}   format    name of format to convert to
 * @return {Object[]|String[]}  array of converted values
 */
const _convertNumberArray = function(arr, format, depth = 0) {
  if (depth == 0) return arr.map(item => _convertNumber(item, format));
  // arr is nested
  return arr.map(item => _convertNumberArray(item, format, depth - 1));
};

/**
 * Reformats numbers in the result/result-object of a web3 call.
 * Possible forms of `result` are:
 *   - object (with index keys and optionally, named keys)
 *   - array
 *   - single primitive
 * @param  {String|Object|Array} result      web3 call result
 * @param  {Array}               abiSegment  event params OR .call outputs
 * @return {String|Object|Array} reformatted result
 */
const numbers = function(result, abiSegment) {
  const format = this.numberFormat;

  abiSegment.forEach((output, i) => {
    // output is a number type (uint || int);
    if (output.type.includes("int")) {
      // output is an array type
      if (output.type.includes("[")) {
        // larger than zero if nested array
        let depth = output.type.split("[").length - 2;

        // result is array
        if (Array.isArray(result)) {
          result = _convertNumberArray(result, format, depth);

          // result is object
        } else {
          // output has name
          if (output.name.length) {
            result[output.name] = _convertNumberArray(
              result[output.name],
              format,
              depth
            );
          }
          // output will always have an index key
          result[i] = _convertNumberArray(result[i], format, depth);
        }
        //
      } else if (typeof result === "object") {
        // output has name
        if (output.name.length) {
          result[output.name] = _convertNumber(result[output.name], format);
        }

        // output will always have an index key
        result[i] = _convertNumber(result[i], format);
      } else {
        result = _convertNumber(result, format);
      }
    }
  });
  return result;
};

module.exports = {
  numbers: numbers
};


/***/ }),

/***/ 60550:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TruffleError = __webpack_require__(73321);
const utils = __webpack_require__(13735);

const defaultGas = 90000;

class StatusError extends TruffleError {
  constructor(args, tx, receipt, reason) {
    let message;
    const gasLimit = args.gas || defaultGas;
    let reasonString = "";

    if (reason) reasonString = `Reason given: ${reason}.`;

    if (utils.bigNumberify(receipt.gasUsed).eq(utils.bigNumberify(gasLimit))) {
      message =
        "Transaction: " +
        tx +
        " exited with an error (status 0) after consuming all gas.\n" +
        "     Please check that the transaction:\n" +
        "     - satisfies all conditions set by Solidity `assert` statements.\n" +
        "     - has enough gas to execute the full transaction.\n" +
        "     - does not trigger an invalid opcode by other means (ex: accessing an array out of bounds).";
    } else {
      message =
        `Transaction: ${tx} exited with an error (status 0). ${reasonString}\n` +
        "     Please check that the transaction:\n" +
        "     - satisfies all conditions set by Solidity `require` statements.\n" +
        "     - does not trigger a Solidity `revert` statement.\n";
    }

    super(message);
    this.tx = tx;
    this.receipt = receipt;
    this.reason = reason;
  }
}

module.exports = StatusError;


/***/ }),

/***/ 50145:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract:utils:ens");
const { default: ENSJS, getEnsAddress } = __webpack_require__(26143);
const { isAddress } = __webpack_require__(18269);

module.exports = {
  convertENSNames: async function ({
    ens,
    inputArgs,
    methodABI,
    inputParams,
    web3,
    networkId
  }) {
    //note that registryAddress here is for a user-supplied registry address
    //if none is supplied this will be undefined, and we'll apply a default later
    const { registryAddress } = ens;
    let args;
    if (inputArgs.length && methodABI) {
      args = await this.convertENSArgsNames({
        inputArgs,
        methodABI,
        web3,
        registryAddress,
        networkId
      });
    } else {
      args = inputArgs;
    }
    let params;
    if (inputParams) {
      params = await this.convertENSParamsNames({
        inputParams,
        web3,
        registryAddress,
        networkId
      });
    }
    return { args, params };
  },

  getNewENSJS: function ({ provider, registryAddress, networkId }) {
    return new ENSJS({
      provider,
      ensAddress: registryAddress ?? getEnsAddress(networkId)
    });
  },

  resolveNameToAddress: async function ({
    name,
    provider,
    registryAddress,
    networkId
  }) {
    let ensjs;
    try {
      ensjs = this.getNewENSJS({
        provider,
        registryAddress,
        networkId
      });
    } catch (error) {
      const message =
        "There was a problem initializing the ENS library." +
        "Please ensure you have the address of the registry set correctly." +
        ` Truffle is currently using ${registryAddress}.`;
      throw new Error(`${message} - ${error.message}`);
    }
    return await ensjs.name(name).getAddress("ETH");
  },

  convertENSArgsNames: function ({
    inputArgs,
    methodABI,
    web3,
    registryAddress,
    networkId
  }) {
    if (methodABI.inputs.length === 0) return inputArgs;

    const convertedNames = inputArgs.map((argument, index) => {
      if (index + 1 > methodABI.inputs.length) {
        return argument;
      } else if (methodABI.inputs[index].type === "address") {
        // Check all address arguments for ENS names
        const argIsAddress = isAddress(argument);
        if (argIsAddress) return argument;
        return this.resolveNameToAddress({
          name: argument,
          provider: web3.currentProvider,
          registryAddress,
          networkId
        });
      } else {
        return argument;
      }
    });
    return Promise.all(convertedNames);
  },

  convertENSParamsNames: async function ({
    inputParams,
    web3,
    registryAddress,
    networkId
  }) {
    let outputParams = inputParams;
    if (inputParams.from && !isAddress(inputParams.from)) {
      const newFrom = await this.resolveNameToAddress({
        name: inputParams.from,
        provider: web3.currentProvider,
        networkId,
        registryAddress
      });
      outputParams = {
        ...outputParams,
        from: newFrom
      };
    }
    if (inputParams.accessList && Array.isArray(inputParams.accessList)) {
      const newAccessList = await Promise.all(
        inputParams.accessList.map(async entry => {
          if (entry && entry.address && !isAddress(entry.address)) {
            const newAddress = await this.resolveNameToAddress({
              name: entry.address,
              provider: web3.currentProvider,
              networkId,
              registryAddress
            });
            return {
              ...entry,
              address: newAddress
            };
          } else {
            return entry;
          }
        })
      );
      outputParams = {
        ...outputParams,
        accessList: newAccessList
      };
    }
    return outputParams;
  }
};


/***/ }),

/***/ 13735:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("contract:utils");
const web3Utils = __webpack_require__(18269);
const { bigNumberify } = __webpack_require__(64498);
const abi = __webpack_require__(93338);
const BlockchainUtils = __webpack_require__(86317);
const reformat = __webpack_require__(90908);
const ens = __webpack_require__(50145);

const allowedTxParams = new Set([
  "from",
  "to",
  "gas",
  "gasPrice",
  "maxFeePerGas",
  "maxPriorityFeePerGas",
  "value",
  "data",
  "nonce",
  "accessList",
  "type",
  "privateFor",
  "overwrite"
]);

const Utils = {
  is_object(val) {
    return typeof val === "object" && !Array.isArray(val);
  },

  is_big_number(val) {
    if (typeof val !== "object") return false;

    //NOTE: For some reason, contrary to the docs,
    //web3Utils.isBigNumber returns true not only for
    //bignumber.js BigNumbers, but also for ethers BigNumbers,
    //even though these are totally different things.
    return web3Utils.isBN(val) || web3Utils.isBigNumber(val);
  },

  isTxParams(val) {
    if (!Utils.is_object(val)) return false;
    if (Utils.is_big_number(val)) return false;
    return Object.keys(val).some(fieldName => allowedTxParams.has(fieldName));
  },

  decodeLogs(_logs, isSingle) {
    const constructor = this;
    const logs = Utils.toTruffleLog(_logs, isSingle);

    return logs
      .map(log => {
        const logABI = constructor.events[log.topics[0]];

        if (logABI == null) return null;

        const copy = Utils.merge({}, log);

        copy.event = logABI.name;
        copy.topics = logABI.anonymous ? copy.topics : copy.topics.slice(1);

        if (copy.data === "0x") copy.data = "";

        let logArgs;
        try {
          logArgs = abi.decodeLog(logABI.inputs, copy.data, copy.topics);
          copy.args = reformat.numbers.call(
            constructor,
            logArgs,
            logABI.inputs
          );
        } catch (_) {
          return null;
        }

        delete copy.data;
        delete copy.topics;

        return copy;
      })
      .filter(log => log != null);
  },

  toTruffleLog(events, isSingle) {
    // Transform singletons (from event listeners) to the kind of
    // object we find on the receipt
    if (isSingle && typeof isSingle === "boolean") {
      const temp = [];
      temp.push(events);
      return temp.map(log => {
        log.data = log.raw.data;
        log.topics = log.raw.topics;
        return log;
      });
    }

    // Or reformat items in the existing array
    events.forEach(event => {
      if (event.raw) {
        event.data = event.raw.data;
        event.topics = event.raw.topics;
      }
    });

    return events;
  },

  merge() {
    const merged = {};
    const args = Array.prototype.slice.call(arguments);

    for (let i = 0; i < args.length; i++) {
      const object = args[i];
      const keys = Object.keys(object);
      for (let j = 0; j < keys.length; j++) {
        const key = keys[j];
        const value = object[key];
        merged[key] = value;
      }
    }

    return merged;
  },

  linkBytecode(bytecode, links) {
    Object.keys(links).forEach(library_name => {
      const library_address = links[library_name];
      const regex = new RegExp(`__${library_name}_+`, "g");

      bytecode = bytecode.replace(regex, library_address.replace("0x", ""));
    });

    return bytecode;
  },

  // Extracts optional tx params from a list of fn arguments
  getTxParams(methodABI, args, ignoreDefaultGasPriceParams = false) {
    const constructor = this;

    const expectedArgCount = methodABI ? methodABI.inputs.length : 0;

    let txParams = {};
    const lastArg = args[args.length - 1];

    if (args.length === expectedArgCount + 1 && Utils.isTxParams(lastArg)) {
      txParams = args.pop();
    }

    let defaultParams = constructor.class_defaults;
    if (ignoreDefaultGasPriceParams) {
      //this parameter is set when making calls (as opposed to transactions)
      //gas price params can cause problems with those on some networks, so
      //we ignore any defaults, and only include them if they were explicitly
      //specified
      defaultParams = { ...constructor.class_defaults }; //clone
      delete defaultParams.gasPrice;
      delete defaultParams.maxFeePerGas;
      delete defaultParams.maxPriorityFeePerGas;
    }

    return Utils.merge(defaultParams, txParams);
  },

  // Verifies that a contracts libraries have been linked correctly.
  // Throws on error
  checkLibraries() {
    const constructor = this;
    const regex = /__[^_]+_+/g;
    let unlinkedLibraries = constructor.binary.match(regex);

    if (unlinkedLibraries !== null) {
      unlinkedLibraries = unlinkedLibraries
        .map(
          (
            name // Remove underscores
          ) => name.replace(/_/g, "")
        )
        .sort()
        .filter((name, index, arr) => {
          // Remove duplicates
          if (index + 1 >= arr.length) {
            return true;
          }

          return name !== arr[index + 1];
        })
        .join(", ");

      const error = `${constructor.contractName} contains unresolved libraries. You must deploy and link the following libraries before you can deploy a new version of ${constructor.contractName}: ${unlinkedLibraries}`;

      throw new Error(error);
    }
  },

  convertToEthersBN(original) {
    const converted = [];
    original.forEach(item => {
      // Recurse for arrays
      if (Array.isArray(item)) {
        converted.push(Utils.convertToEthersBN(item));

        // Convert Web3 BN / BigNumber
      } else if (Utils.is_big_number(item)) {
        //HACK: Since we can't rely on web3Utils.isBigNumber to tell
        //whether we have a bignumber.js BigNumber, we'll just check
        //whether it has the toFixed method
        const stringValue = item.toFixed
          ? item.toFixed() //prevents use of scientific notation
          : item.toString();
        const ethersBN = bigNumberify(stringValue);
        converted.push(ethersBN);
      } else {
        converted.push(item);
      }
    });
    return converted;
  },

  /**
   * Multiplies an ethers.js BigNumber and a number with decimal places using
   * integer math rather than using an arbitrary floating-point library like
   * `bignumber.js`.
   * @param  {BigNumber} bignum            an ethers.js BigNumber (use bigNumberify)
   * @param  {Number}    decimal           a number which has 0+ decimal places
   * @param  {Number}    [maxPrecision=5]  the max number of significant figures
   *                                       `decimal` can have. (default: 5)
   * @return {BigNumber}                   floor(bignum * decimal)
   */
  multiplyBigNumberByDecimal(bignum, decimal, maxPrecision) {
    if (typeof maxPrecision === "undefined") {
      maxPrecision = 5;
    }

    const significantFigures = Math.min(
      decimal.toString().length - 1, // length less one because `.`
      maxPrecision
    );

    const denominator = bigNumberify(10).pow(significantFigures);
    const multiplier = Math.round(decimal * denominator);
    const numerator = bigNumberify(multiplier).mul(bignum);

    return numerator.div(denominator);
  },

  // checks if given contract instance has a set provider
  checkProvider({ currentProvider, contractName }) {
    if (!currentProvider)
      throw new Error(
        `${contractName} error: Please call setProvider() first before calling new().`
      );
  },

  // verifies current network has been assigned to contract instance
  checkNetworkArtifactMatch({ networks, network_id, contractName }) {
    if (networks[network_id] == null)
      throw new Error(
        `${contractName} has not been deployed to detected network (network/artifact mismatch)`
      );
  },

  // verifies contract instance has been deployed
  checkDeployment({ isDeployed, contractName, network_id }) {
    if (!isDeployed())
      throw new Error(
        `${contractName} has not been deployed to detected network (${network_id})`
      );
  },

  // checks if provided contract address has on-chain code
  checkCode(onChainCode, contractName, address) {
    if (!onChainCode || onChainCode.replace("0x", "").replace(/0/g, "") === "")
      throw new Error(
        `Cannot create instance of ${contractName}; no code at address ${address}`
      );
  },

  // parses known contract instance networks
  async parseKnownNetworks(
    { networks, currentProvider, setNetwork, network_id },
    gasLimit
  ) {
    if (!networks && Object.keys(networks).length === 0) {
      return false;
    }
    // go through all the networks that are listed as
    // blockchain uris and see if they match
    for (const network in networks) {
      if (network.startsWith("blockchain://")) {
        const networkMatches = await BlockchainUtils.matches(
          network,
          currentProvider
        );
        if (networkMatches) {
          setNetwork(network);
          return {
            id: network_id,
            blockLimit: gasLimit
          };
        }
      }
    }
    // no match found!
    return false;
  },

  // sets a contract instance network ID
  async setInstanceNetworkID(
    TruffleContractInstance,
    chainNetworkID,
    gasLimit
  ) {
    // if chainNetworkID already present as network configuration, use it
    if (TruffleContractInstance.hasNetwork(chainNetworkID)) {
      TruffleContractInstance.setNetwork(chainNetworkID);
      return {
        id: TruffleContractInstance.network_id,
        blockLimit: gasLimit
      };
    }
    // chainNetworkID not present,
    // parse all known networks
    const matchedNetwork = await Utils.parseKnownNetworks(
      TruffleContractInstance,
      gasLimit
    );
    if (matchedNetwork) return matchedNetwork;

    // network unknown, trust the provider and use given chainNetworkID
    TruffleContractInstance.setNetwork(chainNetworkID);
    return { id: TruffleContractInstance.network_id, blockLimit: gasLimit };
  }
};

Utils.ens = ens;
Utils.bigNumberify = bigNumberify;

module.exports = Utils;


/***/ }),

/***/ 93293:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);
const debug = __webpack_require__(15158)("debug-utils");
const util = __webpack_require__(73837);
const Codec = __webpack_require__(20102);
const BN = __webpack_require__(13550);

const chromafi = __webpack_require__(10298);
const hljsDefineSolidity = __webpack_require__(96988);
hljsDefineSolidity(chromafi.hljs);
const chalk = __webpack_require__(88551);

const panicTable = {
  0x01: "Failed assertion",
  0x11: "Arithmetic overflow",
  0x12: "Division by zero",
  0x21: "Enum value out of bounds",
  0x22: "Malformed string",
  0x31: "Array underflow",
  0x32: "Index out of bounds",
  0x41: "Oversized array or out of memory",
  0x51: "Call to invalid function"
};

const verbosePanicTable = {
  0x01: "An assert() check was not satisfied.",
  0x11: "An arithmetic overflow occurred outside an unchecked { ... } block.",
  0x12: "A division by zero occurred.",
  0x21: "An integer was cast to an enum type that cannot hold it.",
  0x22: "There was an attempt to read an incorrectly-encoded string or bytestring.",
  0x31: "An empty array's pop() method was called.",
  0x32: "An array or bytestring was indexed or sliced with an out-of-bounds index.",
  0x41: "An oversized array was created, or the contract ran out of memory.",
  0x51: "An uninitialized internal function pointer was called."
};

const commandReference = {
  "o": "step over",
  "i": "step line / step into",
  "u": "step out",
  "n": "step next",
  ";": "step instruction (include number to step multiple)",
  "p": "print instruction & state (`p [mem|cal|sto]*`; see docs for more)",
  "l": "print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)",
  "h": "print this help",
  "v": "print variables and values (`v [bui|glo|con|loc]*`)",
  ":": "evaluate expression - see `v`",
  "+": "add watch expression (`+:<expr>`)",
  "-": "remove watch expression (-:<expr>)",
  "?": "list existing watch expressions and breakpoints",
  "b": "add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)",
  "B": "remove breakpoint (similar to adding, or `B all` to remove all)",
  "c": "continue until breakpoint",
  "q": "quit",
  "r": "reset",
  "t": "load new transaction",
  "T": "unload transaction",
  "s": "print stacktrace",
  "g": "turn on generated sources",
  "G": "turn off generated sources except via `;`",
  "y": "(if at end) reset & continue to final error",
  "Y": "reset & continue to previous error",
  "e": "Print recent events (`e [<number>|all]`)"
};

const shortCommandReference = {
  "o": "step over",
  "i": "step into",
  "u": "step out",
  "n": "step next",
  ";": "step instruction",
  "p": "print state",
  "l": "print context",
  "h": "print help",
  "v": "print variables",
  ":": "evaluate",
  "+": "add watch",
  "-": "remove watch",
  "?": "list watches & breakpoints",
  "b": "add breakpoint",
  "B": "remove breakpoint",
  "c": "continue",
  "q": "quit",
  "r": "reset",
  "t": "load",
  "T": "unload",
  "s": "stacktrace",
  "g": "turn on generated sources",
  "G": "turn off generated sources",
  "y": "reset & go to final error",
  "Y": "reset & go to previous error",
  "e": "print event log"
};

const truffleColors = {
  mint: chalk.hex("#3FE0C5"),
  orange: chalk.hex("#E4A663"),
  pink: chalk.hex("#E911BD"),
  purple: chalk.hex("#8731E8"),
  green: chalk.hex("#00D717"),
  red: chalk.hex("#D60000"),
  yellow: chalk.hex("#F2E941"),
  blue: chalk.hex("#25A9E0"),
  comment: chalk.hsl(30, 20, 50),
  watermelon: chalk.hex("#E86591"),
  periwinkle: chalk.hex("#7F9DD1")
};

const DEFAULT_TAB_WIDTH = 8;

const trufflePalette = {
  /* base (chromafi special, not hljs) */
  "base": chalk,
  "lineNumbers": chalk,
  "trailingSpace": chalk,
  /* classes hljs-solidity actually uses */
  "keyword": truffleColors.mint,
  "number": truffleColors.red,
  "string": truffleColors.green,
  "params": truffleColors.pink,
  "builtIn": truffleColors.watermelon,
  "built_in": truffleColors.watermelon, //just to be sure
  "literal": truffleColors.watermelon,
  "function": truffleColors.orange,
  "title": truffleColors.orange,
  "class": truffleColors.orange,
  "comment": truffleColors.comment,
  "doctag": truffleColors.comment,
  "operator": truffleColors.blue,
  "punctuation": truffleColors.purple,
  /* classes it might soon use! */
  "meta": truffleColors.pink,
  "metaString": truffleColors.green,
  "meta-string": truffleColors.green, //similar
  /* classes it doesn't currently use but notionally could */
  "type": truffleColors.orange,
  "symbol": truffleColors.orange,
  "metaKeyword": truffleColors.mint,
  "meta-keyword": truffleColors.mint, //again, to be sure
  "property": chalk, //not putting any highlighting here for now
  /* classes that don't make sense for Solidity */
  "regexp": chalk, //solidity does not have regexps
  "subst": chalk, //or string interpolation
  "name": chalk, //or s-expressions
  "builtInName": chalk, //or s-expressions, again
  "builtin-name": chalk, //just to be sure
  /* classes for config, markup, CSS, templates, diffs (not programming) */
  "section": chalk,
  "tag": chalk,
  "attr": chalk,
  "attribute": chalk,
  "variable": chalk,
  "bullet": chalk,
  "code": chalk,
  "emphasis": chalk,
  "strong": chalk,
  "formula": chalk,
  "link": chalk,
  "quote": chalk,
  "selectorAttr": chalk, //lotta redundancy follows
  "selector-attr": chalk,
  "selectorClass": chalk,
  "selector-class": chalk,
  "selectorId": chalk,
  "selector-id": chalk,
  "selectorPseudo": chalk,
  "selector-pseudo": chalk,
  "selectorTag": chalk,
  "selector-tag": chalk,
  "templateTag": chalk,
  "template-tag": chalk,
  "templateVariable": chalk,
  "template-variable": chalk,
  "addition": chalk,
  "deletion": chalk
};

var DebugUtils = {
  truffleColors, //make these externally available

  //panicCode may be either a number, BN, or decimal string
  panicString: function (panicCode, verbose = false) {
    const unknownString = "Unknown panic";
    const verboseUnknownString = "A panic occurred of unrecognized type.";
    if (BN.isBN(panicCode)) {
      try {
        panicCode = panicCode.toNumber();
      } catch (_) {
        return verbose ? verboseUnknownString : unknownString;
      }
    }
    return verbose
      ? verbosePanicTable[panicCode] || verboseUnknownString
      : panicTable[panicCode] || unknownString;
  },

  //attempts to test whether a given compilation is a real compilation,
  //i.e., was compiled all at once.
  //if it is real, it will definitely pass this test, barring a Solidity bug.
  //(anyway worst case failing it just results in a recompilation)
  //if it isn't real, but passes this test anyway... well, I'm hoping it should
  //still be usable all the same!
  isUsableCompilation: function (compilation) {
    //check #1: is the source order reliable?
    if (compilation.unreliableSourceOrder) {
      debug("unreliable source order");
      return false;
    }

    //check #2: are (user) source indices consecutive?
    //(while nonconsecutivity should not be a problem by itself, this probably
    //indicates a name collision of a sort that will be fatal for other
    //reasons)
    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)
    //to return true!  So I'm doing it this way even though it looks wrong
    //(since the real concern is empty spots, not undefined, yet this turns
    //this up anyhow)
    if (compilation.sources.includes(undefined)) {
      debug("nonconsecutive sources");
      return false;
    }

    //check #3: do generated source indices start directly after user source indices?
    //(once again, if there's a gap between them, that's not a problem by itself,
    //but it probably indicates that something bad is going on)
    const lowestInternalIndex = Math.min(
      ...compilation.contracts.map(contract => {
        //find first defined index
        let lowestConstructor = (contract.generatedSources || []).findIndex(
          x => x !== undefined
        );
        if (lowestConstructor === -1) {
          lowestConstructor = Infinity;
        }
        let lowestDeployed = (
          contract.deployedGeneratedSources || []
        ).findIndex(x => x !== undefined);
        if (lowestDeployed === -1) {
          lowestDeployed = Infinity;
        }
        return Math.min(lowestConstructor, lowestDeployed);
      })
    );
    if (lowestInternalIndex !== Infinity) {
      //Infinity would mean there were none
      if (lowestInternalIndex !== compilation.sources.length) {
        //if it's a usable compilation, these should be equal,
        //as length = 1 + last user source
        debug("gap before internal sources");
        return false;
      }
    }

    //check #4: are there any AST ID collisions?
    let astIds = new Set();

    let allIDsUnseenSoFar = node => {
      if (Array.isArray(node)) {
        return node.every(allIDsUnseenSoFar);
      } else if (node !== null && typeof node === "object") {
        if (node.id !== undefined) {
          if (astIds.has(node.id)) {
            debug("id occurred twice: %o", node.id);
            return false;
          } else {
            astIds.add(node.id);
          }
        }
        return Object.values(node).every(allIDsUnseenSoFar);
      } else {
        return true;
      }
    };

    //now: walk each Solidity AST
    //(and don't bother checking generated sources as they're
    //never Solidity)
    debug("checking Solidity ASTs for collisions");
    return compilation.sources.every(
      source =>
        !source ||
        source.language !== "Solidity" ||
        allIDsUnseenSoFar(source.ast)
    );
  },

  formatStartMessage: function (withTransaction) {
    if (withTransaction) {
      return "Gathering information about your project and the transaction...";
    } else {
      return "Gathering information about your project...";
    }
  },

  formatTransactionStartMessage: function () {
    return "Gathering information about the transaction...";
  },

  formatCommandDescription: function (commandId) {
    return (
      truffleColors.mint(`(${commandId})`) + " " + commandReference[commandId]
    );
  },

  formatPrompt: function (network, txHash) {
    return txHash !== undefined
      ? `debug(${network}:${txHash.substring(0, 10)}...)> `
      : `debug(${network})> `;
  },

  formatAffectedInstances: function (instances) {
    var hasAllSource = true;

    var lines = Object.keys(instances).map(function (address) {
      var instance = instances[address];

      if (instance.contractName) {
        return " " + address + " - " + instance.contractName;
      }

      if (!instance.source) {
        hasAllSource = false;
      }

      return " " + address + "(UNKNOWN)";
    });

    if (lines.length === 0) {
      lines.push("No affected addresses found.");
    }

    if (!hasAllSource) {
      lines.push("");
      lines.push(
        `${chalk.bold(
          "Warning:"
        )} The source code for one or more contracts could not be found.`
      );
    }

    return lines.join(OS.EOL);
  },

  formatHelp: function (lastCommand = "n") {
    var prefix = [
      "Commands:",
      truffleColors.mint("(enter)") +
        " last command entered (" +
        shortCommandReference[lastCommand] +
        ")"
    ];

    var commandSections = [
      ["o", "i", "u", "n"],
      ["c", "Y"],
      ["y"],
      [";"],
      ["g", "G"],
      ["p"],
      ["l"],
      ["s", "e"],
      ["q", "r", "t", "T"],
      ["b"],
      ["B"],
      ["+", "-"],
      ["?"],
      ["v"],
      [":", "h"]
    ].map(function (shortcuts) {
      return shortcuts.map(DebugUtils.formatCommandDescription).join(", ");
    });

    var suffix = [
      "",
      "Docs: https://trufflesuite.com/docs/truffle/how-to/debug-test/use-the-truffle-debugger/",
      ""
    ];

    var lines = prefix.concat(commandSections).concat(suffix);

    return lines.join(OS.EOL);
  },

  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {
    //note: I'm going to assume for these purposes that everything is
    //basically ASCII and I don't have to worry about astral planes or
    //grapheme clusters.  Sorry. :-/
    let line = "";
    let counter = 0;
    for (let i = 0; i < inputLine.length; i++) {
      if (inputLine[i] === "\t") {
        const remaining = tabLength - counter;
        line += " ".repeat(remaining);
        counter = 0;
      } else if (inputLine[i] === "\n") {
        line += "\n";
        counter = 0;
      } else if (inputLine[i] === "\r" && inputLine[i + 1] === "\n") {
        line += "\n";
        counter = 0;
        i++;
      } else {
        line += inputLine[i];
        counter++;
        if (counter === tabLength) {
          counter = 0;
        }
      }
    }
    return line;
  },

  formatLineNumberPrefix: function (line, number, cols) {
    const prefix = String(number).padStart(cols) + ": ";

    return prefix + line;
  },

  formatLinePointer: function (
    line,
    startCol,
    endCol,
    padding,
    tabLength = DEFAULT_TAB_WIDTH
  ) {
    const prefix = " ".repeat(padding + 2); //account for ": "

    let output = "";
    let counter = 0;
    for (let i = 0; i < line.length; i++) {
      let pointedAt = i >= startCol && i < endCol;

      let additional;
      if (line[i] === "\t") {
        const remaining = tabLength - counter;
        additional = " ".repeat(remaining);
        debug("advancing %d", remaining);
        counter = 0;
      } else {
        additional = " "; // just a space
        counter++;
        if (counter === tabLength) {
          counter = 0;
        }
      }

      if (pointedAt) {
        additional = additional.replace(/./g, "^");
      }

      output += additional;
    }

    return truffleColors.purple(prefix + output);
  },

  //NOTE: source and uncolorizedSource here have already
  //been split into lines here, they're not the raw text
  //ALSO: assuming here that colorized source has been detabbed
  //but that uncolorized source has not
  formatRangeLines: function (
    source,
    range,
    uncolorizedSource,
    contextBefore = 2,
    contextAfter = 0
  ) {
    // range is {
    //   start: { line, column },
    //   end: { line, column}
    // }
    //

    var startIndex = Math.max(range.start.line - contextBefore, 0);
    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);

    var prefixLength = (endIndex + 1 + "").length; //+1 to account for 0-index

    //note: beforeLines now includes the line itself
    var beforeLines = source
      .slice(startIndex, range.start.line + 1)
      .map((line, index) => {
        let number = startIndex + index + 1; // 1 to account for 0-index
        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);
      });
    var afterLines = source
      .slice(range.start.line + 1, endIndex + 1)
      .map((line, index) => {
        let number = range.start.line + 1 + index + 1; // 1 to account for 0-index
        return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);
      });

    var pointerStart = range.start.column;
    var pointerEnd;

    let uncolorizedLine = uncolorizedSource[range.start.line];

    // range.end is undefined in some cases
    // null/undefined check to avoid exceptions
    if (range.end && range.start.line === range.end.line) {
      // start and end are same line: pointer ends at column
      pointerEnd = range.end.column;
    } else {
      pointerEnd = uncolorizedLine.length;
    }

    var allLines = beforeLines.concat(
      [
        DebugUtils.formatLinePointer(
          //the line-pointer formatter doesn't work right with colorized
          //lines, so we pass in the uncolored version
          uncolorizedLine,
          pointerStart,
          pointerEnd,
          prefixLength
        )
      ],
      afterLines
    );

    return allLines.join(OS.EOL);
  },

  formatBreakpointLocation: function (
    breakpoint,
    here,
    currentSourceId,
    sourceNames
  ) {
    let baseMessage;
    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {
      baseMessage = here
        ? `this point in line ${breakpoint.line + 1}`
        : `a point in line ${breakpoint.line + 1}`;
      //note we always add 1 to adjust for zero-indexing
    } else {
      baseMessage = `line ${breakpoint.line + 1}`;
    }
    if (breakpoint.sourceId !== currentSourceId) {
      const sourceName = sourceNames[breakpoint.sourceId];
      return baseMessage + ` in ${sourceName}`;
    } else {
      return baseMessage;
    }
  },

  formatCurrentInstruction: function (instruction) {
    const pc = this.formatPC(instruction.pc);
    const formattedInstruction = this.formatInstruction(instruction);
    return "-> " + truffleColors.mint(formattedInstruction) + pc;
  },

  formatInstruction: function (instruction) {
    return truffleColors.mint(
      instruction.name +
        " " +
        (instruction.pushData !== undefined && instruction.pushData !== "0x"
          ? instruction.pushData
          : "") //display just "PUSH0", not "PUSH0 0x"
    );
  },

  formatPC: function (pc) {
    let hex = pc.toString(16);
    if (hex.length % 2 !== 0) {
      hex = "0" + hex; //ensure even length
    }
    return " (PC=" + pc.toString() + ", 0x" + hex + ")";
  },

  formatStack: function (stack) {
    //stack here is an array of hex words (no "0x")
    var formatted = stack.map((item, index) => {
      item = truffleColors.orange(item);
      item = "  " + item;
      if (index === stack.length - 1) {
        item += " (top)";
      } else {
        item += ` (${stack.length - index - 1} from top)`;
      }

      return item;
    });

    if (stack.length === 0) {
      formatted.unshift("  No data on stack.");
    } else {
      formatted.unshift("Stack:");
    }

    return formatted.join(OS.EOL);
  },

  formatMemory: function (memory) {
    //note memory here is an array of hex words (no "0x"),
    //not a single long hex string

    //get longest prefix needed;
    //minimum of 2 so always show at least 2 hex digits
    let maxPrefixLength = Math.max(
      2,
      ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length
    );
    if (maxPrefixLength % 2 !== 0) {
      maxPrefixLength++; //make sure to use even # of hex digits
    }

    let formatted = memory.map((word, index) => {
      let address = (index * Codec.Evm.Utils.WORD_SIZE)
        .toString(16)
        .padStart(maxPrefixLength, "0");
      return `  0x${address}:  ${truffleColors.pink(word)}`;
    });

    if (memory.length === 0) {
      formatted.unshift("  No data in memory.");
    } else {
      formatted.unshift("Memory:");
    }

    return formatted.join(OS.EOL);
  },

  formatStorage: function (storage) {
    //storage here is an object mapping hex words to hex words (no 0x)

    //first: sort the keys (slice to clone as sort is in-place)
    //note: we can use the default sort here; it will do the righ thing
    let slots = Object.keys(storage).slice().sort();

    let formatted = slots.map((slot, index) => {
      if (
        index === 0 ||
        !Codec.Conversion.toBN(slot).eq(
          Codec.Conversion.toBN(slots[index - 1]).addn(1)
        )
      ) {
        return `0x${slot}:\n` + `  ${truffleColors.blue(storage[slot])}`;
      } else {
        return `  ${truffleColors.blue(storage[slot])}`;
      }
    });

    if (slots.length === 0) {
      formatted.unshift("  No known relevant data found in storage.");
    } else {
      formatted.unshift("Storage (partial view):");
    }

    return formatted.join(OS.EOL);
  },

  formatCalldata: function (calldata) {
    //takes a Uint8Array
    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);
    let words = [];
    for (
      let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE;
      wordIndex < calldata.length;
      wordIndex += Codec.Evm.Utils.WORD_SIZE
    ) {
      words.push(
        calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE)
      );
    }
    let maxWordIndex =
      (words.length - 1) * Codec.Evm.Utils.WORD_SIZE +
      Codec.Evm.Utils.SELECTOR_SIZE;
    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);
    if (maxPrefixLength % 2 !== 0) {
      maxPrefixLength++;
    }
    let formattedSelector;
    if (selector.length > 0) {
      formattedSelector =
        "Calldata:\n" +
        `  0x${"00".padStart(maxPrefixLength, "0")}:  ` +
        truffleColors.pink(
          Codec.Conversion.toHexString(selector)
            .slice(2)
            .padStart(2 * Codec.Evm.Utils.WORD_SIZE, "  ")
        );
    } else {
      formattedSelector = "  No data in calldata.";
    }

    let formatted = words.map((word, index) => {
      let address = (
        index * Codec.Evm.Utils.WORD_SIZE +
        Codec.Evm.Utils.SELECTOR_SIZE
      )
        .toString(16)
        .padStart(maxPrefixLength, "0");
      let data = Codec.Conversion.toHexString(word)
        .slice(2)
        .padEnd(2 * Codec.Evm.Utils.WORD_SIZE);
      return `  0x${address}:  ${truffleColors.pink(data)}`;
    });

    formatted.unshift(formattedSelector);

    return formatted.join(OS.EOL);
  },

  formatValue: function (value, indent = 0, nativized = false) {
    let inspectOptions = {
      colors: true,
      depth: null,
      maxArrayLength: null,
      breakLength: 30
    };
    let valueToInspect = nativized
      ? value
      : new Codec.Export.ResultInspector(value, { noHideAddress: true });
    return util
      .inspect(valueToInspect, inspectOptions)
      .split(/\r?\n/g)
      .map((line, i) => {
        // don't indent first line
        const padding = i > 0 ? Array(indent).join(" ") : "";
        return padding + line;
      })
      .join(OS.EOL);
  },

  //note: only intended to be used for *custom* errors :)
  formatCustomError: function (decoding, indent = 0) {
    const inspectOptions = {
      colors: true,
      depth: null,
      maxArrayLength: null,
      breakLength: 30
    };
    const name = decoding.definedIn
      ? `${decoding.definedIn.typeName}.${decoding.abi.name}`
      : decoding.abi.name;
    return Codec.Export.formatFunctionLike(
      name,
      decoding.arguments,
      inspectOptions,
      { noHideAddress: true },
      false,
      indent
    );
  },

  formatStacktrace: function (stacktrace, indent = 2) {
    //get message or panic code from stacktrace
    const { message, panic, custom } = stacktrace[0];
    //we want to print inner to outer, so first, let's
    //reverse
    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first
    let lines = stacktrace.map(
      ({
        functionName,
        contractName,
        address,
        location,
        isConstructor,
        type
      }) => {
        let name;
        if (contractName && functionName) {
          name = `${contractName}.${functionName}`;
        } else if (contractName) {
          name =
            type === "external" && isConstructor
              ? `new ${contractName}`
              : contractName;
          //for internal calls, it doesn't really make sense
          //to write "new Contract"
        } else if (functionName) {
          name = functionName;
        } else {
          name = "unknown function";
        }
        let locationString;
        if (location) {
          let {
            source: { sourcePath },
            sourceRange: {
              lines: {
                start: { line, column }
              }
            }
          } = location;
          locationString = sourcePath
            ? `${sourcePath}:${line + 1}:${column + 1}` //add 1 to account for 0-indexing
            : "unknown location";
        } else {
          locationString = "unknown location";
        }
        let addressString =
          type === "external"
            ? address !== undefined
              ? ` [address ${address}]`
              : " [unknown address]"
            : "";
        return `at ${name}${addressString} (${locationString})`;
      }
    );
    let status = stacktrace[0].status;
    if (status != undefined) {
      let statusLine;
      if (message !== undefined) {
        statusLine = status
          ? `Error: Improper return (caused message: ${message})`
          : `Error: Revert (message: ${message})`;
      } else if (panic !== undefined) {
        statusLine = status
          ? `Panic: Improper return (caused ${DebugUtils.panicString(
              panic
            ).toLowerCase()} (code 0x${panic.toString(16)}))`
          : `Panic: ${DebugUtils.panicString(panic)} (code 0x${panic.toString(
              16
            )})`;
      } else if (custom !== undefined) {
        statusLine = status
          ? `Error: Improper return (caused custom error)`
          : `Error: Revert (custom error)`;
      } else {
        statusLine = status
          ? "Error: Improper return (may be an unexpected self-destruct)"
          : "Error: Revert or exceptional halt";
      }
      lines.unshift(statusLine);
    }
    let indented = lines.map((line, index) =>
      index === 0 ? line : " ".repeat(indent) + line
    );
    return indented.join(OS.EOL);
  },

  colorize: function (code, language = "Solidity") {
    const options = {
      lang: "solidity",
      colors: trufflePalette,
      //we want to turn off basically everything else, as we're
      //handling padding & numbering manually
      lineNumbers: false,
      stripIndent: false,
      codePad: 0,
      tabsToSpaces: false, //we handle this ourself and don't
      //want chromafi's padding
      lineEndPad: false
    };
    switch (language) {
      case "Solidity":
        return chromafi(code, options);
      case "Yul":
        options.lang = "yul"; //registered along with Solidity :)
        return chromafi(code, options);
      case "Vyper":
        options.lang = "python"; //HACK -- close enough for now!
        return chromafi(code, options);
      default:
        //don't highlight
        return code;
    }
  },

  //HACK
  cleanThis: function (variables, replacement) {
    return Object.assign(
      {},
      ...Object.entries(variables).map(([variable, value]) =>
        variable === "this" ? { [replacement]: value } : { [variable]: value }
      )
    );
  },

  /**
   * HACK warning!  This function modifies the debugger state
   * and should only be used in light mode, at startup, in a very specific way!
   *
   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });
   * const sources = await getTransactionSourcesBeforeStarting(bugger);
   * await bugger.startFullMode();
   *
   * Don't go switching transactions after doing this, because there's no
   * way at the moment to switch back into light mode in order to re-run
   * this function.  You do *not* want to run this in full mode.
   */
  getTransactionSourcesBeforeStarting: async function (bugger) {
    await bugger.reset();
    let sources = {};
    const { controller } = bugger.selectors;
    while (!bugger.view(controller.current.trace.finished)) {
      const source = bugger.view(controller.current.location.source);
      const { compilationId, id, internal } = source;
      //stepInto should skip internal sources, but there still might be
      //one at the end
      if (!internal && compilationId !== undefined && id !== undefined) {
        sources[compilationId] = {
          ...sources[compilationId],
          [id]: source
        };
      }
      await bugger.stepInto();
    }
    await bugger.reset();
    //flatten sources before returning
    return [].concat(...Object.values(sources).map(Object.values));
  }
};

module.exports = DebugUtils;


/***/ }),

/***/ 7702:
/***/ ((module) => {

"use strict";

const provision = (contractAbstraction, truffleConfig) => {
    if (truffleConfig.provider) {
        contractAbstraction.setProvider(truffleConfig.provider);
    }
    if (truffleConfig.network_id) {
        contractAbstraction.setNetwork(truffleConfig.network_id);
    }
    if (truffleConfig.network && truffleConfig.networks) {
        contractAbstraction.setNetworkType(truffleConfig.networks[truffleConfig.network].type);
        // this is a workaround to allow users to opt out of the block polling that
        // web3 performs when we listen for confirmations which causes problems in testing
        if (truffleConfig.networks[truffleConfig.network]) {
            const { disableConfirmationListener } = truffleConfig.networks[truffleConfig.network];
            contractAbstraction.disableConfirmationListener =
                disableConfirmationListener;
        }
    }
    contractAbstraction.ens = truffleConfig.ens;
    //HACK: use getter to get what we want and put it where we want
    contractAbstraction.ens.registryAddress = truffleConfig.ensRegistry.address;
    [
        "from",
        "gas",
        "gasPrice",
        "maxFeePerGas",
        "maxPriorityFeePerGas",
        "type"
    ].forEach(key => {
        if (truffleConfig[key]) {
            const obj = {};
            obj[key] = truffleConfig[key];
            contractAbstraction.defaults(obj);
        }
    });
    return contractAbstraction;
};
module.exports = provision;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 43563:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resolver = void 0;
const contract = __webpack_require__(78883);
const expect = __webpack_require__(14096);
const provision = __webpack_require__(7702);
const sources_1 = __webpack_require__(12493);
class Resolver {
    constructor(options, resolverOptions = { includeTruffleSources: true }) {
        expect.options(options, [
            "working_directory",
            "contracts_build_directory",
            "contracts_directory"
        ]);
        const { includeTruffleSources } = resolverOptions;
        this.options = options;
        let basicSources = [
            new sources_1.NPM(options.working_directory),
            new sources_1.GlobalNPM(),
            new sources_1.FS(options.working_directory, options.contracts_build_directory)
        ];
        if (includeTruffleSources) {
            basicSources.unshift(new sources_1.Truffle(options));
        }
        //set up abi-to-sol resolution
        this.sources = [].concat(...basicSources.map(source => [new sources_1.ABI(source), source]));
        //set up vyper resolution rules
        this.sources = [
            new sources_1.Vyper(basicSources, options.contracts_directory),
            ...this.sources //for Vyper this is redundant
        ];
    }
    // This function might be doing too much. If so, too bad (for now).
    require(import_path, search_path) {
        for (const source of this.sources) {
            const result = source.require(import_path, search_path);
            if (result) {
                const abstraction = contract(result);
                provision(abstraction, this.options);
                return abstraction;
            }
        }
        // exhausted sources and could not resolve
        throw new Error("Could not find artifacts for " + import_path + " from any sources");
    }
    resolve(importPath, importedFrom, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let body = null;
            let filePath = null;
            let source = null;
            for (source of this.sources) {
                ({ body, filePath } = yield source.resolve(importPath, importedFrom, options));
                if (body !== undefined) {
                    break;
                }
            }
            if (body === undefined) {
                let message = `Could not find ${importPath} from any sources`;
                if (importedFrom) {
                    message += "; imported from " + importedFrom;
                }
                throw new Error(message);
            }
            return {
                body,
                filePath,
                source
            };
        });
    }
}
exports.Resolver = Resolver;
//# sourceMappingURL=resolver.js.map

/***/ }),

/***/ 69136:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABI = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const abi_to_sol_1 = __webpack_require__(1324);
class ABI {
    constructor(wrappedSource) {
        this.wrappedSource = wrappedSource;
    }
    // requiring artifacts is out of scope for this ResolverSource
    // just return `null` here and let another ResolverSource handle it
    require() {
        return null;
    }
    /**
     * @dev This attempts to resolve an ABI JSON file as Solidity using the
     *      abi-to-sol utility.
     *
     *      Note the **precondition** that `compiler`, if passed, will always
     *      refer to a version of solc, since this ResolverSource is explicitly
     *      disabled for Vyper.
     */
    resolve(importPath, importedFrom = "", options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { compiler } = options;
            if (!compiler || compiler.name !== "solc") {
                //this resolver source for use by solc only!
                //vyper doesn't need it and would be quite thrown off by it
                return { filePath: undefined, body: undefined };
            }
            let filePath;
            let body;
            if (!importPath.endsWith(".json")) {
                return { filePath, body };
            }
            const resolution = yield this.wrappedSource.resolve(importPath, importedFrom, options);
            if (resolution.body === undefined) {
                return { filePath, body };
            }
            const solidityVersion = determineSolidityVersion(compiler);
            ({ filePath, body } = resolution);
            // extract basename twice to support .json and .abi.json
            const name = path_1.default.basename(path_1.default.basename(filePath, ".json"), ".abi");
            try {
                const abi = JSON.parse(body);
                const soliditySource = (0, abi_to_sol_1.generateSolidity)({
                    name,
                    abi,
                    license: "MIT",
                    solidityVersion
                });
                return {
                    filePath,
                    body: soliditySource
                };
            }
            catch (_) {
                //we use this not-quite-empty Solidity to avoid warnings
                //pragma statement introduced in 0.4.0 so can't go earlier
                //than that :)
                const emptySolidity = `
        // SPDX-License-Identifier: MIT
        pragma solidity >=0.4.0;
      `;
                return {
                    filePath,
                    body: emptySolidity
                };
            }
        });
    }
    resolveDependencyPath(importPath, dependencyPath) {
        return __awaiter(this, void 0, void 0, function* () {
            //just defer to wrapped source
            return yield this.wrappedSource.resolveDependencyPath(importPath, dependencyPath);
        });
    }
}
exports.ABI = ABI;
function determineSolidityVersion(compiler) {
    const { version } = compiler;
    // resolver.resolve's `compiler` option may include the full version string,
    // including commit and build target information. abi-to-sol only accepts a
    // short-form version range, i.e. <major>.<minor>.<patch>
    return version.split("+")[0];
}
//# sourceMappingURL=abi.js.map

/***/ }),

/***/ 3224:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FS = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const fs_1 = __importDefault(__webpack_require__(57147));
class FS {
    constructor(workingDirectory, contractsBuildDirectory) {
        this.workingDirectory = workingDirectory;
        this.contractsBuildDirectory = contractsBuildDirectory;
    }
    require(importPath, searchPath = this.contractsBuildDirectory) {
        const normalizedImportPath = path_1.default.normalize(importPath);
        const contractName = this.getContractName(normalizedImportPath, searchPath);
        // If we have an absolute path, only check the file if it's a child of the workingDirectory.
        if (path_1.default.isAbsolute(normalizedImportPath)) {
            if (normalizedImportPath.indexOf(this.workingDirectory) !== 0) {
                return null;
            }
        }
        try {
            const result = fs_1.default.readFileSync(path_1.default.join(searchPath, `${contractName}.json`), "utf8");
            return JSON.parse(result);
        }
        catch (e) {
            return null;
        }
    }
    getContractName(sourcePath, searchPath = this.contractsBuildDirectory) {
        const contractsBuildDirFiles = fs_1.default.readdirSync(searchPath);
        const filteredBuildArtifacts = contractsBuildDirFiles.filter((file) => file.match(".json") != null);
        for (const buildArtifact of filteredBuildArtifacts) {
            const artifact = JSON.parse(fs_1.default.readFileSync(path_1.default.resolve(searchPath, buildArtifact)).toString());
            if (artifact.sourcePath === sourcePath) {
                return artifact.contractName;
            }
        }
        // fallback
        return path_1.default.basename(sourcePath, ".sol");
    }
    resolve(importPath, _importedFrom) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!path_1.default.isAbsolute(importPath)) {
                //the FS resolver should only resolve absolute paths.
                //If things are being done properly, then either:
                //1. this is a top-level path so of course it's absolute; or,
                //2. the import was an explicitly relative path... which has been
                //converted to absolute by the time it's passed here.
                //The bad cases we want to disallow are:
                //3. this is an absolute path in an import (allowed here but disallowed
                //elsewhere)
                //4. this is an implicitly relative path in an import (we have to disallow
                //these, sorry, they cause problems with Solidity's import resolution)
                return { body: undefined, filePath: undefined };
            }
            try {
                const resolvedSource = fs_1.default.readFileSync(importPath, {
                    encoding: "utf8"
                });
                return { body: resolvedSource, filePath: importPath };
            }
            catch (error) {
                return { body: undefined, filePath: undefined };
            }
        });
    }
    // Here we're resolving from local files to local files, all absolute.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        const dirname = path_1.default.dirname(importPath);
        return path_1.default.resolve(path_1.default.join(dirname, dependencyPath));
    }
}
exports.FS = FS;
//# sourceMappingURL=fs.js.map

/***/ }),

/***/ 82776:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalNPM = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const fs_1 = __importDefault(__webpack_require__(57147));
const detectInstalled = __webpack_require__(9790);
const getInstalledPath = __webpack_require__(39975);
class GlobalNPM {
    require(importPath) {
        if (importPath.indexOf(".") === 0 || path_1.default.isAbsolute(importPath)) {
            return null;
        }
        const contractName = path_1.default.basename(importPath, ".sol");
        let [packageName] = importPath.split("/", 1);
        if (detectInstalled.sync(packageName)) {
            const regex = new RegExp(`/${packageName}$`);
            const globalPackagePath = getInstalledPath
                .getInstalledPathSync(packageName)
                .replace(regex, "");
            const result = this.resolveAndParse(globalPackagePath, packageName, contractName);
            // result is null if it fails to resolve
            if (result) {
                return result;
            }
        }
        return null;
    }
    resolveAndParse(basePath, packageName, contractName) {
        const packagePath = path_1.default.join(basePath, packageName);
        const subDirs = [`build${path_1.default.sep}contracts`, "build"];
        for (const subDir of subDirs) {
            const possiblePath = path_1.default.join(packagePath, subDir, `${contractName}.json`);
            try {
                const result = fs_1.default.readFileSync(possiblePath, "utf8");
                return JSON.parse(result);
            }
            catch (e) {
                continue;
            }
        }
        return null;
    }
    resolve(importPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let [packageName] = importPath.split("/", 1);
            let body;
            if (detectInstalled.sync(packageName)) {
                const regex = new RegExp(`/${packageName}$`);
                const globalPackagePath = getInstalledPath
                    .getInstalledPathSync(packageName)
                    .replace(regex, "");
                const expectedPath = path_1.default.join(globalPackagePath, importPath);
                try {
                    body = fs_1.default.readFileSync(expectedPath, { encoding: "utf8" });
                }
                catch (err) { }
            }
            // If nothing's found, body returns `undefined`
            return { body, filePath: importPath };
        });
    }
    // We're resolving package paths to other package paths, not absolute paths.
    // This will ensure the source fetcher conintues to use the correct sources for packages.
    // i.e., if some_module/contracts/MyContract.sol imported "./AnotherContract.sol",
    // we're going to resolve it to some_module/contracts/AnotherContract.sol, ensuring
    // that when this path is evaluated this source is used again.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        var dirname = path_1.default.dirname(importPath);
        return path_1.default.join(dirname, dependencyPath);
    }
}
exports.GlobalNPM = GlobalNPM;
//# sourceMappingURL=globalnpm.js.map

/***/ }),

/***/ 12493:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vyper = exports.ABI = exports.Truffle = exports.FS = exports.GlobalNPM = exports.NPM = void 0;
var npm_1 = __webpack_require__(48854);
Object.defineProperty(exports, "NPM", ({ enumerable: true, get: function () { return npm_1.NPM; } }));
var globalnpm_1 = __webpack_require__(82776);
Object.defineProperty(exports, "GlobalNPM", ({ enumerable: true, get: function () { return globalnpm_1.GlobalNPM; } }));
var fs_1 = __webpack_require__(3224);
Object.defineProperty(exports, "FS", ({ enumerable: true, get: function () { return fs_1.FS; } }));
var truffle_1 = __webpack_require__(34550);
Object.defineProperty(exports, "Truffle", ({ enumerable: true, get: function () { return truffle_1.Truffle; } }));
var abi_1 = __webpack_require__(69136);
Object.defineProperty(exports, "ABI", ({ enumerable: true, get: function () { return abi_1.ABI; } }));
var vyper_1 = __webpack_require__(4320);
Object.defineProperty(exports, "Vyper", ({ enumerable: true, get: function () { return vyper_1.Vyper; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 48854:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NPM = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const fs_1 = __importDefault(__webpack_require__(57147));
class NPM {
    constructor(workingDirectory) {
        this.workingDirectory = workingDirectory;
    }
    require(importPath, searchPath) {
        if (importPath.indexOf(".") === 0 || importPath.indexOf("/") === 0) {
            return null;
        }
        const contractName = path_1.default.basename(importPath, ".sol");
        const regex = new RegExp(`(.*)/${contractName}`);
        let packageName = "";
        const matched = regex.exec(importPath);
        if (matched) {
            packageName = matched[1];
        }
        // during testing a temp dir is passed as search path - we need to check the
        // working dir in case a built contract was not copied over to it
        for (const basePath of [searchPath, this.workingDirectory]) {
            if (!basePath) {
                continue;
            }
            const result = this.resolveAndParse(basePath, packageName, contractName);
            // result is null if it fails to resolve
            if (result) {
                return result;
            }
            continue;
        }
        return null;
    }
    resolve(import_path, _imported_from) {
        return __awaiter(this, void 0, void 0, function* () {
            // If nothing's found, body returns `undefined`
            var body;
            var modulesDir = this.workingDirectory;
            while (true) {
                var expected_path = path_1.default.join(modulesDir, "node_modules", import_path);
                try {
                    var body = fs_1.default.readFileSync(expected_path, { encoding: "utf8" });
                    break;
                }
                catch (err) { }
                // Recurse outwards until impossible
                var oldModulesDir = modulesDir;
                modulesDir = path_1.default.join(modulesDir, "..");
                if (modulesDir === oldModulesDir) {
                    break;
                }
            }
            return { body, filePath: import_path };
        });
    }
    resolveAndParse(basePath, packageName, contractName) {
        const packagePath = path_1.default.join(basePath, "node_modules", packageName);
        const subDirs = [`build${path_1.default.sep}contracts`, "build"];
        for (const subDir of subDirs) {
            const possiblePath = path_1.default.join(packagePath, subDir, `${contractName}.json`);
            try {
                const result = fs_1.default.readFileSync(possiblePath, "utf8");
                return JSON.parse(result);
            }
            catch (e) {
                continue;
            }
        }
        return null;
    }
    // We're resolving package paths to other package paths, not absolute paths.
    // This will ensure the source fetcher conintues to use the correct sources for packages.
    // i.e., if some_module/contracts/MyContract.sol imported "./AnotherContract.sol",
    // we're going to resolve it to some_module/contracts/AnotherContract.sol, ensuring
    // that when this path is evaluated this source is used again.
    resolveDependencyPath(importPath, dependencyPath) {
        if (!(dependencyPath.startsWith("./") || dependencyPath.startsWith("../"))) {
            //if it's *not* a relative path, return it unchanged
            return dependencyPath;
        }
        var dirname = path_1.default.dirname(importPath);
        return path_1.default.join(dirname, dependencyPath);
    }
}
exports.NPM = NPM;
//# sourceMappingURL=npm.js.map

/***/ }),

/***/ 50794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Deployed = void 0;
const web3Utils = __webpack_require__(18269);
const RangeUtils = __importStar(__webpack_require__(32739));
class Deployed {
    static makeSolidityDeployedAddressesLibrary(mapping, { solc: { version } }) {
        let source = "";
        source +=
            "//SPDX-License-Identifier: MIT\n" +
                "pragma solidity >= 0.4.15 < 0.9.0; \n\n library DeployedAddresses {" +
                "\n";
        for (let [name, address] of Object.entries(mapping)) {
            let body = "revert();";
            if (address) {
                address = Deployed.toChecksumAddress(address);
                body = "return payable(" + address + ");";
            }
            source +=
                "  function " +
                    name +
                    "() public pure returns (address payable) { " +
                    body +
                    " }";
            source += "\n";
        }
        source += "}";
        version = RangeUtils.resolveToRange(version);
        if (!RangeUtils.rangeContainsAtLeast(version, "0.5.0")) {
            //remove "payable"s in types if we're before 0.5.0
            source = source.replace(/address payable/g, "address");
        }
        if (!RangeUtils.rangeContainsAtLeast(version, "0.6.0")) {
            //remove "payable"s in conversions if we're before 0.6.0
            source = source.replace(/payable\((.*)\)/g, "$1");
        }
        return source;
    }
    // Pulled from ethereumjs-util, but I don't want all its dependencies at the moment.
    static toChecksumAddress(address) {
        address = address.toLowerCase().replace("0x", "");
        const hash = web3Utils.sha3(address).replace("0x", "");
        var ret = "0x";
        for (var i = 0; i < address.length; i++) {
            if (parseInt(hash[i], 16) >= 8) {
                ret += address[i].toUpperCase();
            }
            else {
                ret += address[i];
            }
        }
        return ret;
    }
}
exports.Deployed = Deployed;
//# sourceMappingURL=Deployed.js.map

/***/ }),

/***/ 34550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Truffle = void 0;
const path_1 = __importDefault(__webpack_require__(71017));
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const Deployed_1 = __webpack_require__(50794);
const contract_sources_1 = __importDefault(__webpack_require__(23542));
const contract = __webpack_require__(78883);
class Truffle {
    constructor(options) {
        this.options = options;
    }
    resolve(importPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (importPath === `truffle${path_1.default.sep}DeployedAddresses.sol`) {
                const sourceFiles = yield (0, contract_sources_1.default)(this.options.contracts_directory);
                const buildDirFiles = fs_extra_1.default.existsSync(this.options.contracts_build_directory)
                    ? fs_extra_1.default.readdirSync(this.options.contracts_build_directory)
                    : [];
                const abstractionFiles = buildDirFiles.filter(file => file.match(/^.*.json$/));
                const mapping = {};
                const blacklist = new Set(["Assert", "DeployedAddresses"]);
                // Ensure we have a mapping for source files and abstraction files
                // to prevent any compile errors in tests.
                sourceFiles.forEach((file) => {
                    // we need to account for .json and .abi.json files
                    const name = path_1.default.basename(path_1.default.basename(path_1.default.basename(file, ".sol"), ".json"), ".abi");
                    if (blacklist.has(name))
                        return;
                    mapping[name] = false;
                });
                abstractionFiles.forEach(file => {
                    const name = path_1.default.basename(file, ".json");
                    if (blacklist.has(name))
                        return;
                    mapping[name] = false;
                });
                const filesData = abstractionFiles.map(file => {
                    return fs_extra_1.default.readFileSync(path_1.default.join(this.options.contracts_build_directory, file), "utf8");
                });
                const addresses = filesData.map(data => {
                    const c = contract(JSON.parse(data));
                    c.setNetwork(this.options.network_id);
                    if (c.isDeployed())
                        return c.address;
                    return null;
                });
                addresses.forEach((address, i) => {
                    const name = path_1.default.basename(abstractionFiles[i], ".json");
                    if (blacklist.has(name))
                        return;
                    mapping[name] = address;
                });
                const addressSource = Deployed_1.Deployed.makeSolidityDeployedAddressesLibrary(mapping, this.options.compilers);
                return { body: addressSource, filePath: importPath };
            }
            // Match both Camel and Pascal casing for console.sol
            if (importPath === `truffle${path_1.default.sep}Console.sol` ||
                importPath === `truffle${path_1.default.sep}console.sol`) {
                // calculating this in webpack env breaks
                let unbundledGanacheConsoleSol;
                // @ts-ignore
                if (false) {}
                const actualImportPath = 
                // @ts-ignore
                 true
                    ? path_1.default.resolve(path_1.default.join(__dirname, `console.sol`))
                    : 0;
                const body = fs_extra_1.default.readFileSync(actualImportPath, { encoding: "utf8" });
                return {
                    body,
                    filePath: importPath
                };
            }
            const truffleLibraries = [
                "Assert",
                "AssertAddress",
                "AssertAddressArray",
                "AssertBalance",
                "AssertBool",
                "AssertBytes32",
                "AssertBytes32Array",
                "AssertGeneral",
                "AssertInt",
                "AssertIntArray",
                "AssertString",
                "AssertUint",
                "AssertUintArray",
                "SafeSend"
            ];
            for (const lib of truffleLibraries) {
                if (importPath === `truffle${path_1.default.sep}${lib}.sol`) {
                    const actualImportPath = 
                    // @ts-ignore
                     true
                        ? path_1.default.resolve(path_1.default.join(__dirname, `${lib}.sol`))
                        : 0;
                    const body = fs_extra_1.default.readFileSync(actualImportPath, { encoding: "utf8" });
                    return { body, filePath: importPath };
                }
            }
            return { body: undefined, filePath: undefined };
        });
    }
    require() {
        // return null to let another source handle this behavior
        // (will be covered by FS source)
        return null;
    }
    resolveDependencyPath(_importPath, dependencyPath) {
        return dependencyPath;
    }
}
exports.Truffle = Truffle;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 4320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Vyper = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("resolver:sources:vyper");
const path_1 = __importDefault(__webpack_require__(71017));
class Vyper {
    constructor(wrappedSources, contractsDirectory) {
        this.wrappedSources = wrappedSources;
        this.cache = {};
        this.contractsDirectory = contractsDirectory;
    }
    require() {
        //out of scope for this resolver source
        return null;
    }
    resolve(importModule, importedFrom, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const { compiler } = options;
            if (!compiler || compiler.name !== "vyper") {
                //this resolver source for use by Vyper only!
                debug("not Vyper, go away!");
                return { body: undefined, filePath: undefined };
            }
            importedFrom = importedFrom || "";
            debug("importModule: %s", importModule);
            debug("importedFrom: %s", importedFrom);
            //attempt to just resolve as if it's a file path rather than Vyper module
            //(we have to do this rather than just leaving it to the other, unwrapped,
            //resolver sources, because of resolveDependencyPath... yes, that results
            //in checking those sources twice on failure :-/ )
            for (const source of this.wrappedSources) {
                const directlyResolvedSource = yield source.resolve(importModule, importedFrom);
                if (directlyResolvedSource.body !== undefined) {
                    debug("found directly");
                    return directlyResolvedSource;
                }
            }
            //so if we've made it here, it's time for some Vyper module processing...
            debug("running Vyper import processing!");
            //only attempt this if what we have looks like a Vyper module
            if (!importModule.match(/^[\w.]+$/)) {
                debug("clearly not a Vyper module");
                return { body: undefined, filePath: undefined };
            }
            const importPath = moduleToPath(importModule); //note: no file extension yet
            debug("importPath: %s", importPath);
            const explicitlyRelative = importModule[0] === "."; //note we check importModule,
            //not importPath, to make the check simpler (can just check if begins with "."
            //rather than "./" or "../")
            debug("explicitlyRelative: %o", explicitlyRelative);
            const possiblePathsMinusExtension = [];
            //first: check in local directory
            possiblePathsMinusExtension.push(path_1.default.join(path_1.default.dirname(importedFrom), importPath));
            if (!explicitlyRelative) {
                //next: check in contracts dir, if not explicitly relative
                possiblePathsMinusExtension.push(path_1.default.join(this.contractsDirectory, importPath));
                //finally: check wherever the resolver says to check
                possiblePathsMinusExtension.push(importPath);
            }
            const possibleExtensions = [".json", ".vy"]; //Vyper only expects these two
            //note: this puts all JSON before all Vyper, which is how we want it
            //(we do not want to try Vyper from any sources until JSON from all sources
            //has been checked)
            const possiblePaths = [].concat(...possibleExtensions.map(extension => possiblePathsMinusExtension.map(path => path + extension)));
            debug("possiblePaths: %O", possiblePaths);
            for (const possiblePath of possiblePaths) {
                debug("possiblePath: %s", possiblePath);
                let resolvedSource;
                if (possiblePath in this.cache) {
                    resolvedSource = this.cache[possiblePath];
                }
                else {
                    for (const source of this.wrappedSources) {
                        debug("source: %o", source);
                        resolvedSource = yield source.resolve(possiblePath, importedFrom);
                        if (resolvedSource.body !== undefined) {
                            debug("found via this source");
                            break;
                        }
                    }
                    this.cache[possiblePath] = resolvedSource; //yes, even failures are cached!
                }
                if (resolvedSource.body !== undefined) {
                    debug("found");
                    return resolvedSource;
                }
                debug("not found");
            }
            //if not found, return nothing
            return { body: undefined, filePath: undefined };
        });
    }
    resolveDependencyPath(importPath, dependencyPath) {
        return __awaiter(this, void 0, void 0, function* () {
            //unfortunately, for this sort of source to resolve a dependency path,
            //it's going to need to do a resolve :-/
            debug("importPath: %s", importPath);
            const resolved = yield this.resolve(dependencyPath, importPath, { compiler: { name: "vyper" } } //HACK
            );
            if (resolved) {
                return resolved.filePath;
            }
            else {
                return null;
            }
        });
    }
}
exports.Vyper = Vyper;
function moduleToPath(moduleName) {
    //first: get initial dot count by matching against regular expression for
    //initial dots, then taking captured group (note: regular expression
    //will always match so don't have to worry about null here) and taking
    //length
    const initialDotCount = moduleName.match(/^(\.*)/)[1].length;
    //then: change rest of dots to slashes
    const withoutInitialDots = moduleName.slice(initialDotCount);
    const pathWithoutDots = withoutInitialDots.replace(/\./g, path_1.default.sep);
    let initialDotPath;
    //then: interpret initial dots
    switch (initialDotCount) {
        case 0:
            initialDotPath = "";
            break;
        case 1:
            initialDotPath = "./";
            break;
        default:
            initialDotPath = "../".repeat(initialDotCount - 1);
            break;
    }
    //finally: combine
    return initialDotPath + pathWithoutDots;
}
//# sourceMappingURL=vyper.js.map

/***/ }),

/***/ 23373:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"3.4.16"};

/***/ }),

/***/ 900:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$id":"abi.spec.json","$schema":"http://json-schema.org/schema#","title":"ABI","type":"array","items":{"oneOf":[{"$ref":"#/definitions/Event"},{"$ref":"#/definitions/Error"},{"$ref":"#/definitions/ConstructorFunction"},{"$ref":"#/definitions/FallbackFunction"},{"$ref":"#/definitions/ReceiveFunction"},{"$ref":"#/definitions/NormalFunction"}]},"definitions":{"Name":{"type":"string","pattern":"^$|^[a-zA-Z_\\\\$][a-zA-Z_\\\\$0-9]*$"},"Type":{"oneOf":[{"type":"string","pattern":"^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^address(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^bool(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^u?fixed(8x1|8x2|8x3|8x4|8x5|8x6|8x7|8x8|8x9|8x10|8x11|8x12|8x13|8x14|8x15|8x16|8x17|8x18|8x19|8x20|8x21|8x22|8x23|8x24|8x25|8x26|8x27|8x28|8x29|8x30|8x31|8x32|8x33|8x34|8x35|8x36|8x37|8x38|8x39|8x40|8x41|8x42|8x43|8x44|8x45|8x46|8x47|8x48|8x49|8x50|8x51|8x52|8x53|8x54|8x55|8x56|8x57|8x58|8x59|8x60|8x61|8x62|8x63|8x64|8x65|8x66|8x67|8x68|8x69|8x70|8x71|8x72|8x73|8x74|8x75|8x76|8x77|8x78|8x79|8x80|16x1|16x2|16x3|16x4|16x5|16x6|16x7|16x8|16x9|16x10|16x11|16x12|16x13|16x14|16x15|16x16|16x17|16x18|16x19|16x20|16x21|16x22|16x23|16x24|16x25|16x26|16x27|16x28|16x29|16x30|16x31|16x32|16x33|16x34|16x35|16x36|16x37|16x38|16x39|16x40|16x41|16x42|16x43|16x44|16x45|16x46|16x47|16x48|16x49|16x50|16x51|16x52|16x53|16x54|16x55|16x56|16x57|16x58|16x59|16x60|16x61|16x62|16x63|16x64|16x65|16x66|16x67|16x68|16x69|16x70|16x71|16x72|16x73|16x74|16x75|16x76|16x77|16x78|16x79|16x80|24x1|24x2|24x3|24x4|24x5|24x6|24x7|24x8|24x9|24x10|24x11|24x12|24x13|24x14|24x15|24x16|24x17|24x18|24x19|24x20|24x21|24x22|24x23|24x24|24x25|24x26|24x27|24x28|24x29|24x30|24x31|24x32|24x33|24x34|24x35|24x36|24x37|24x38|24x39|24x40|24x41|24x42|24x43|24x44|24x45|24x46|24x47|24x48|24x49|24x50|24x51|24x52|24x53|24x54|24x55|24x56|24x57|24x58|24x59|24x60|24x61|24x62|24x63|24x64|24x65|24x66|24x67|24x68|24x69|24x70|24x71|24x72|24x73|24x74|24x75|24x76|24x77|24x78|24x79|24x80|32x1|32x2|32x3|32x4|32x5|32x6|32x7|32x8|32x9|32x10|32x11|32x12|32x13|32x14|32x15|32x16|32x17|32x18|32x19|32x20|32x21|32x22|32x23|32x24|32x25|32x26|32x27|32x28|32x29|32x30|32x31|32x32|32x33|32x34|32x35|32x36|32x37|32x38|32x39|32x40|32x41|32x42|32x43|32x44|32x45|32x46|32x47|32x48|32x49|32x50|32x51|32x52|32x53|32x54|32x55|32x56|32x57|32x58|32x59|32x60|32x61|32x62|32x63|32x64|32x65|32x66|32x67|32x68|32x69|32x70|32x71|32x72|32x73|32x74|32x75|32x76|32x77|32x78|32x79|32x80|40x1|40x2|40x3|40x4|40x5|40x6|40x7|40x8|40x9|40x10|40x11|40x12|40x13|40x14|40x15|40x16|40x17|40x18|40x19|40x20|40x21|40x22|40x23|40x24|40x25|40x26|40x27|40x28|40x29|40x30|40x31|40x32|40x33|40x34|40x35|40x36|40x37|40x38|40x39|40x40|40x41|40x42|40x43|40x44|40x45|40x46|40x47|40x48|40x49|40x50|40x51|40x52|40x53|40x54|40x55|40x56|40x57|40x58|40x59|40x60|40x61|40x62|40x63|40x64|40x65|40x66|40x67|40x68|40x69|40x70|40x71|40x72|40x73|40x74|40x75|40x76|40x77|40x78|40x79|40x80|48x1|48x2|48x3|48x4|48x5|48x6|48x7|48x8|48x9|48x10|48x11|48x12|48x13|48x14|48x15|48x16|48x17|48x18|48x19|48x20|48x21|48x22|48x23|48x24|48x25|48x26|48x27|48x28|48x29|48x30|48x31|48x32|48x33|48x34|48x35|48x36|48x37|48x38|48x39|48x40|48x41|48x42|48x43|48x44|48x45|48x46|48x47|48x48|48x49|48x50|48x51|48x52|48x53|48x54|48x55|48x56|48x57|48x58|48x59|48x60|48x61|48x62|48x63|48x64|48x65|48x66|48x67|48x68|48x69|48x70|48x71|48x72|48x73|48x74|48x75|48x76|48x77|48x78|48x79|48x80|56x1|56x2|56x3|56x4|56x5|56x6|56x7|56x8|56x9|56x10|56x11|56x12|56x13|56x14|56x15|56x16|56x17|56x18|56x19|56x20|56x21|56x22|56x23|56x24|56x25|56x26|56x27|56x28|56x29|56x30|56x31|56x32|56x33|56x34|56x35|56x36|56x37|56x38|56x39|56x40|56x41|56x42|56x43|56x44|56x45|56x46|56x47|56x48|56x49|56x50|56x51|56x52|56x53|56x54|56x55|56x56|56x57|56x58|56x59|56x60|56x61|56x62|56x63|56x64|56x65|56x66|56x67|56x68|56x69|56x70|56x71|56x72|56x73|56x74|56x75|56x76|56x77|56x78|56x79|56x80|64x1|64x2|64x3|64x4|64x5|64x6|64x7|64x8|64x9|64x10|64x11|64x12|64x13|64x14|64x15|64x16|64x17|64x18|64x19|64x20|64x21|64x22|64x23|64x24|64x25|64x26|64x27|64x28|64x29|64x30|64x31|64x32|64x33|64x34|64x35|64x36|64x37|64x38|64x39|64x40|64x41|64x42|64x43|64x44|64x45|64x46|64x47|64x48|64x49|64x50|64x51|64x52|64x53|64x54|64x55|64x56|64x57|64x58|64x59|64x60|64x61|64x62|64x63|64x64|64x65|64x66|64x67|64x68|64x69|64x70|64x71|64x72|64x73|64x74|64x75|64x76|64x77|64x78|64x79|64x80|72x1|72x2|72x3|72x4|72x5|72x6|72x7|72x8|72x9|72x10|72x11|72x12|72x13|72x14|72x15|72x16|72x17|72x18|72x19|72x20|72x21|72x22|72x23|72x24|72x25|72x26|72x27|72x28|72x29|72x30|72x31|72x32|72x33|72x34|72x35|72x36|72x37|72x38|72x39|72x40|72x41|72x42|72x43|72x44|72x45|72x46|72x47|72x48|72x49|72x50|72x51|72x52|72x53|72x54|72x55|72x56|72x57|72x58|72x59|72x60|72x61|72x62|72x63|72x64|72x65|72x66|72x67|72x68|72x69|72x70|72x71|72x72|72x73|72x74|72x75|72x76|72x77|72x78|72x79|72x80|80x1|80x2|80x3|80x4|80x5|80x6|80x7|80x8|80x9|80x10|80x11|80x12|80x13|80x14|80x15|80x16|80x17|80x18|80x19|80x20|80x21|80x22|80x23|80x24|80x25|80x26|80x27|80x28|80x29|80x30|80x31|80x32|80x33|80x34|80x35|80x36|80x37|80x38|80x39|80x40|80x41|80x42|80x43|80x44|80x45|80x46|80x47|80x48|80x49|80x50|80x51|80x52|80x53|80x54|80x55|80x56|80x57|80x58|80x59|80x60|80x61|80x62|80x63|80x64|80x65|80x66|80x67|80x68|80x69|80x70|80x71|80x72|80x73|80x74|80x75|80x76|80x77|80x78|80x79|80x80|88x1|88x2|88x3|88x4|88x5|88x6|88x7|88x8|88x9|88x10|88x11|88x12|88x13|88x14|88x15|88x16|88x17|88x18|88x19|88x20|88x21|88x22|88x23|88x24|88x25|88x26|88x27|88x28|88x29|88x30|88x31|88x32|88x33|88x34|88x35|88x36|88x37|88x38|88x39|88x40|88x41|88x42|88x43|88x44|88x45|88x46|88x47|88x48|88x49|88x50|88x51|88x52|88x53|88x54|88x55|88x56|88x57|88x58|88x59|88x60|88x61|88x62|88x63|88x64|88x65|88x66|88x67|88x68|88x69|88x70|88x71|88x72|88x73|88x74|88x75|88x76|88x77|88x78|88x79|88x80|96x1|96x2|96x3|96x4|96x5|96x6|96x7|96x8|96x9|96x10|96x11|96x12|96x13|96x14|96x15|96x16|96x17|96x18|96x19|96x20|96x21|96x22|96x23|96x24|96x25|96x26|96x27|96x28|96x29|96x30|96x31|96x32|96x33|96x34|96x35|96x36|96x37|96x38|96x39|96x40|96x41|96x42|96x43|96x44|96x45|96x46|96x47|96x48|96x49|96x50|96x51|96x52|96x53|96x54|96x55|96x56|96x57|96x58|96x59|96x60|96x61|96x62|96x63|96x64|96x65|96x66|96x67|96x68|96x69|96x70|96x71|96x72|96x73|96x74|96x75|96x76|96x77|96x78|96x79|96x80|104x1|104x2|104x3|104x4|104x5|104x6|104x7|104x8|104x9|104x10|104x11|104x12|104x13|104x14|104x15|104x16|104x17|104x18|104x19|104x20|104x21|104x22|104x23|104x24|104x25|104x26|104x27|104x28|104x29|104x30|104x31|104x32|104x33|104x34|104x35|104x36|104x37|104x38|104x39|104x40|104x41|104x42|104x43|104x44|104x45|104x46|104x47|104x48|104x49|104x50|104x51|104x52|104x53|104x54|104x55|104x56|104x57|104x58|104x59|104x60|104x61|104x62|104x63|104x64|104x65|104x66|104x67|104x68|104x69|104x70|104x71|104x72|104x73|104x74|104x75|104x76|104x77|104x78|104x79|104x80|112x1|112x2|112x3|112x4|112x5|112x6|112x7|112x8|112x9|112x10|112x11|112x12|112x13|112x14|112x15|112x16|112x17|112x18|112x19|112x20|112x21|112x22|112x23|112x24|112x25|112x26|112x27|112x28|112x29|112x30|112x31|112x32|112x33|112x34|112x35|112x36|112x37|112x38|112x39|112x40|112x41|112x42|112x43|112x44|112x45|112x46|112x47|112x48|112x49|112x50|112x51|112x52|112x53|112x54|112x55|112x56|112x57|112x58|112x59|112x60|112x61|112x62|112x63|112x64|112x65|112x66|112x67|112x68|112x69|112x70|112x71|112x72|112x73|112x74|112x75|112x76|112x77|112x78|112x79|112x80|120x1|120x2|120x3|120x4|120x5|120x6|120x7|120x8|120x9|120x10|120x11|120x12|120x13|120x14|120x15|120x16|120x17|120x18|120x19|120x20|120x21|120x22|120x23|120x24|120x25|120x26|120x27|120x28|120x29|120x30|120x31|120x32|120x33|120x34|120x35|120x36|120x37|120x38|120x39|120x40|120x41|120x42|120x43|120x44|120x45|120x46|120x47|120x48|120x49|120x50|120x51|120x52|120x53|120x54|120x55|120x56|120x57|120x58|120x59|120x60|120x61|120x62|120x63|120x64|120x65|120x66|120x67|120x68|120x69|120x70|120x71|120x72|120x73|120x74|120x75|120x76|120x77|120x78|120x79|120x80|128x1|128x2|128x3|128x4|128x5|128x6|128x7|128x8|128x9|128x10|128x11|128x12|128x13|128x14|128x15|128x16|128x17|128x18|128x19|128x20|128x21|128x22|128x23|128x24|128x25|128x26|128x27|128x28|128x29|128x30|128x31|128x32|128x33|128x34|128x35|128x36|128x37|128x38|128x39|128x40|128x41|128x42|128x43|128x44|128x45|128x46|128x47|128x48|128x49|128x50|128x51|128x52|128x53|128x54|128x55|128x56|128x57|128x58|128x59|128x60|128x61|128x62|128x63|128x64|128x65|128x66|128x67|128x68|128x69|128x70|128x71|128x72|128x73|128x74|128x75|128x76|128x77|128x78|128x79|128x80|136x1|136x2|136x3|136x4|136x5|136x6|136x7|136x8|136x9|136x10|136x11|136x12|136x13|136x14|136x15|136x16|136x17|136x18|136x19|136x20|136x21|136x22|136x23|136x24|136x25|136x26|136x27|136x28|136x29|136x30|136x31|136x32|136x33|136x34|136x35|136x36|136x37|136x38|136x39|136x40|136x41|136x42|136x43|136x44|136x45|136x46|136x47|136x48|136x49|136x50|136x51|136x52|136x53|136x54|136x55|136x56|136x57|136x58|136x59|136x60|136x61|136x62|136x63|136x64|136x65|136x66|136x67|136x68|136x69|136x70|136x71|136x72|136x73|136x74|136x75|136x76|136x77|136x78|136x79|136x80|144x1|144x2|144x3|144x4|144x5|144x6|144x7|144x8|144x9|144x10|144x11|144x12|144x13|144x14|144x15|144x16|144x17|144x18|144x19|144x20|144x21|144x22|144x23|144x24|144x25|144x26|144x27|144x28|144x29|144x30|144x31|144x32|144x33|144x34|144x35|144x36|144x37|144x38|144x39|144x40|144x41|144x42|144x43|144x44|144x45|144x46|144x47|144x48|144x49|144x50|144x51|144x52|144x53|144x54|144x55|144x56|144x57|144x58|144x59|144x60|144x61|144x62|144x63|144x64|144x65|144x66|144x67|144x68|144x69|144x70|144x71|144x72|144x73|144x74|144x75|144x76|144x77|144x78|144x79|144x80|152x1|152x2|152x3|152x4|152x5|152x6|152x7|152x8|152x9|152x10|152x11|152x12|152x13|152x14|152x15|152x16|152x17|152x18|152x19|152x20|152x21|152x22|152x23|152x24|152x25|152x26|152x27|152x28|152x29|152x30|152x31|152x32|152x33|152x34|152x35|152x36|152x37|152x38|152x39|152x40|152x41|152x42|152x43|152x44|152x45|152x46|152x47|152x48|152x49|152x50|152x51|152x52|152x53|152x54|152x55|152x56|152x57|152x58|152x59|152x60|152x61|152x62|152x63|152x64|152x65|152x66|152x67|152x68|152x69|152x70|152x71|152x72|152x73|152x74|152x75|152x76|152x77|152x78|152x79|152x80|160x1|160x2|160x3|160x4|160x5|160x6|160x7|160x8|160x9|160x10|160x11|160x12|160x13|160x14|160x15|160x16|160x17|160x18|160x19|160x20|160x21|160x22|160x23|160x24|160x25|160x26|160x27|160x28|160x29|160x30|160x31|160x32|160x33|160x34|160x35|160x36|160x37|160x38|160x39|160x40|160x41|160x42|160x43|160x44|160x45|160x46|160x47|160x48|160x49|160x50|160x51|160x52|160x53|160x54|160x55|160x56|160x57|160x58|160x59|160x60|160x61|160x62|160x63|160x64|160x65|160x66|160x67|160x68|160x69|160x70|160x71|160x72|160x73|160x74|160x75|160x76|160x77|160x78|160x79|160x80|168x1|168x2|168x3|168x4|168x5|168x6|168x7|168x8|168x9|168x10|168x11|168x12|168x13|168x14|168x15|168x16|168x17|168x18|168x19|168x20|168x21|168x22|168x23|168x24|168x25|168x26|168x27|168x28|168x29|168x30|168x31|168x32|168x33|168x34|168x35|168x36|168x37|168x38|168x39|168x40|168x41|168x42|168x43|168x44|168x45|168x46|168x47|168x48|168x49|168x50|168x51|168x52|168x53|168x54|168x55|168x56|168x57|168x58|168x59|168x60|168x61|168x62|168x63|168x64|168x65|168x66|168x67|168x68|168x69|168x70|168x71|168x72|168x73|168x74|168x75|168x76|168x77|168x78|168x79|168x80|176x1|176x2|176x3|176x4|176x5|176x6|176x7|176x8|176x9|176x10|176x11|176x12|176x13|176x14|176x15|176x16|176x17|176x18|176x19|176x20|176x21|176x22|176x23|176x24|176x25|176x26|176x27|176x28|176x29|176x30|176x31|176x32|176x33|176x34|176x35|176x36|176x37|176x38|176x39|176x40|176x41|176x42|176x43|176x44|176x45|176x46|176x47|176x48|176x49|176x50|176x51|176x52|176x53|176x54|176x55|176x56|176x57|176x58|176x59|176x60|176x61|176x62|176x63|176x64|176x65|176x66|176x67|176x68|176x69|176x70|176x71|176x72|176x73|176x74|176x75|176x76|176x77|176x78|176x79|176x80|184x1|184x2|184x3|184x4|184x5|184x6|184x7|184x8|184x9|184x10|184x11|184x12|184x13|184x14|184x15|184x16|184x17|184x18|184x19|184x20|184x21|184x22|184x23|184x24|184x25|184x26|184x27|184x28|184x29|184x30|184x31|184x32|184x33|184x34|184x35|184x36|184x37|184x38|184x39|184x40|184x41|184x42|184x43|184x44|184x45|184x46|184x47|184x48|184x49|184x50|184x51|184x52|184x53|184x54|184x55|184x56|184x57|184x58|184x59|184x60|184x61|184x62|184x63|184x64|184x65|184x66|184x67|184x68|184x69|184x70|184x71|184x72|184x73|184x74|184x75|184x76|184x77|184x78|184x79|184x80|192x1|192x2|192x3|192x4|192x5|192x6|192x7|192x8|192x9|192x10|192x11|192x12|192x13|192x14|192x15|192x16|192x17|192x18|192x19|192x20|192x21|192x22|192x23|192x24|192x25|192x26|192x27|192x28|192x29|192x30|192x31|192x32|192x33|192x34|192x35|192x36|192x37|192x38|192x39|192x40|192x41|192x42|192x43|192x44|192x45|192x46|192x47|192x48|192x49|192x50|192x51|192x52|192x53|192x54|192x55|192x56|192x57|192x58|192x59|192x60|192x61|192x62|192x63|192x64|192x65|192x66|192x67|192x68|192x69|192x70|192x71|192x72|192x73|192x74|192x75|192x76|192x77|192x78|192x79|192x80|200x1|200x2|200x3|200x4|200x5|200x6|200x7|200x8|200x9|200x10|200x11|200x12|200x13|200x14|200x15|200x16|200x17|200x18|200x19|200x20|200x21|200x22|200x23|200x24|200x25|200x26|200x27|200x28|200x29|200x30|200x31|200x32|200x33|200x34|200x35|200x36|200x37|200x38|200x39|200x40|200x41|200x42|200x43|200x44|200x45|200x46|200x47|200x48|200x49|200x50|200x51|200x52|200x53|200x54|200x55|200x56|200x57|200x58|200x59|200x60|200x61|200x62|200x63|200x64|200x65|200x66|200x67|200x68|200x69|200x70|200x71|200x72|200x73|200x74|200x75|200x76|200x77|200x78|200x79|200x80|208x1|208x2|208x3|208x4|208x5|208x6|208x7|208x8|208x9|208x10|208x11|208x12|208x13|208x14|208x15|208x16|208x17|208x18|208x19|208x20|208x21|208x22|208x23|208x24|208x25|208x26|208x27|208x28|208x29|208x30|208x31|208x32|208x33|208x34|208x35|208x36|208x37|208x38|208x39|208x40|208x41|208x42|208x43|208x44|208x45|208x46|208x47|208x48|208x49|208x50|208x51|208x52|208x53|208x54|208x55|208x56|208x57|208x58|208x59|208x60|208x61|208x62|208x63|208x64|208x65|208x66|208x67|208x68|208x69|208x70|208x71|208x72|208x73|208x74|208x75|208x76|208x77|208x78|208x79|208x80|216x1|216x2|216x3|216x4|216x5|216x6|216x7|216x8|216x9|216x10|216x11|216x12|216x13|216x14|216x15|216x16|216x17|216x18|216x19|216x20|216x21|216x22|216x23|216x24|216x25|216x26|216x27|216x28|216x29|216x30|216x31|216x32|216x33|216x34|216x35|216x36|216x37|216x38|216x39|216x40|216x41|216x42|216x43|216x44|216x45|216x46|216x47|216x48|216x49|216x50|216x51|216x52|216x53|216x54|216x55|216x56|216x57|216x58|216x59|216x60|216x61|216x62|216x63|216x64|216x65|216x66|216x67|216x68|216x69|216x70|216x71|216x72|216x73|216x74|216x75|216x76|216x77|216x78|216x79|216x80|224x1|224x2|224x3|224x4|224x5|224x6|224x7|224x8|224x9|224x10|224x11|224x12|224x13|224x14|224x15|224x16|224x17|224x18|224x19|224x20|224x21|224x22|224x23|224x24|224x25|224x26|224x27|224x28|224x29|224x30|224x31|224x32|224x33|224x34|224x35|224x36|224x37|224x38|224x39|224x40|224x41|224x42|224x43|224x44|224x45|224x46|224x47|224x48|224x49|224x50|224x51|224x52|224x53|224x54|224x55|224x56|224x57|224x58|224x59|224x60|224x61|224x62|224x63|224x64|224x65|224x66|224x67|224x68|224x69|224x70|224x71|224x72|224x73|224x74|224x75|224x76|224x77|224x78|224x79|224x80|232x1|232x2|232x3|232x4|232x5|232x6|232x7|232x8|232x9|232x10|232x11|232x12|232x13|232x14|232x15|232x16|232x17|232x18|232x19|232x20|232x21|232x22|232x23|232x24|232x25|232x26|232x27|232x28|232x29|232x30|232x31|232x32|232x33|232x34|232x35|232x36|232x37|232x38|232x39|232x40|232x41|232x42|232x43|232x44|232x45|232x46|232x47|232x48|232x49|232x50|232x51|232x52|232x53|232x54|232x55|232x56|232x57|232x58|232x59|232x60|232x61|232x62|232x63|232x64|232x65|232x66|232x67|232x68|232x69|232x70|232x71|232x72|232x73|232x74|232x75|232x76|232x77|232x78|232x79|232x80|240x1|240x2|240x3|240x4|240x5|240x6|240x7|240x8|240x9|240x10|240x11|240x12|240x13|240x14|240x15|240x16|240x17|240x18|240x19|240x20|240x21|240x22|240x23|240x24|240x25|240x26|240x27|240x28|240x29|240x30|240x31|240x32|240x33|240x34|240x35|240x36|240x37|240x38|240x39|240x40|240x41|240x42|240x43|240x44|240x45|240x46|240x47|240x48|240x49|240x50|240x51|240x52|240x53|240x54|240x55|240x56|240x57|240x58|240x59|240x60|240x61|240x62|240x63|240x64|240x65|240x66|240x67|240x68|240x69|240x70|240x71|240x72|240x73|240x74|240x75|240x76|240x77|240x78|240x79|240x80|248x1|248x2|248x3|248x4|248x5|248x6|248x7|248x8|248x9|248x10|248x11|248x12|248x13|248x14|248x15|248x16|248x17|248x18|248x19|248x20|248x21|248x22|248x23|248x24|248x25|248x26|248x27|248x28|248x29|248x30|248x31|248x32|248x33|248x34|248x35|248x36|248x37|248x38|248x39|248x40|248x41|248x42|248x43|248x44|248x45|248x46|248x47|248x48|248x49|248x50|248x51|248x52|248x53|248x54|248x55|248x56|248x57|248x58|248x59|248x60|248x61|248x62|248x63|248x64|248x65|248x66|248x67|248x68|248x69|248x70|248x71|248x72|248x73|248x74|248x75|248x76|248x77|248x78|248x79|248x80|256x1|256x2|256x3|256x4|256x5|256x6|256x7|256x8|256x9|256x10|256x11|256x12|256x13|256x14|256x15|256x16|256x17|256x18|256x19|256x20|256x21|256x22|256x23|256x24|256x25|256x26|256x27|256x28|256x29|256x30|256x31|256x32|256x33|256x34|256x35|256x36|256x37|256x38|256x39|256x40|256x41|256x42|256x43|256x44|256x45|256x46|256x47|256x48|256x49|256x50|256x51|256x52|256x53|256x54|256x55|256x56|256x57|256x58|256x59|256x60|256x61|256x62|256x63|256x64|256x65|256x66|256x67|256x68|256x69|256x70|256x71|256x72|256x73|256x74|256x75|256x76|256x77|256x78|256x79|256x80)?(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^bytes(1|2|3|4|5|6|7|8|9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32)(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^bytes(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^function(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^string(\\\\[[0-9]*\\\\])*$"},{"type":"string","pattern":"^tuple(\\\\[[0-9]*\\\\])*$"}]},"StateMutability":{"type":"string","enum":["pure","view","nonpayable","payable"]},"NormalFunction":{"type":"object","properties":{"type":{"type":"string","enum":["function"],"default":"function"},"name":{"$ref":"#/definitions/Name"},"inputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"outputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"},"default":[]},"stateMutability":{"$ref":"#/definitions/StateMutability"},"constant":{"type":"boolean"},"payable":{"type":"boolean"}},"anyOf":[{"required":["name","inputs","stateMutability"]},{"required":["name","inputs","constant","payable"]}],"additionalProperties":false},"ConstructorFunction":{"type":"object","properties":{"type":{"type":"string","enum":["constructor"]},"inputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"stateMutability":{"$ref":"#/definitions/StateMutability"},"constant":{"type":"boolean"},"payable":{"type":"boolean"}},"anyOf":[{"required":["type","inputs","stateMutability"]},{"required":["type","inputs","payable"]}],"additionalProperties":false},"FallbackFunction":{"type":"object","properties":{"type":{"type":"string","enum":["fallback"]},"stateMutability":{"$ref":"#/definitions/StateMutability"},"payable":{"type":"boolean"}},"anyOf":[{"required":["type","stateMutability"]},{"required":["type","payable"]}],"additionalProperties":false},"ReceiveFunction":{"type":"object","properties":{"type":{"type":"string","enum":["receive"]},"stateMutability":{"type":"string","enum":["payable"]}},"required":["type","stateMutability"],"additionalProperties":false},"Event":{"type":"object","properties":{"type":{"type":"string","enum":["event"]},"name":{"$ref":"#/definitions/Name"},"inputs":{"type":"array","items":{"$ref":"#/definitions/EventParameter"}},"anonymous":{"type":"boolean"}},"required":["type","name","inputs","anonymous"],"additionalProperties":false},"Error":{"type":"object","properties":{"type":{"type":"string","enum":["error"]},"name":{"$ref":"#/definitions/Name"},"inputs":{"type":"array","items":{"$ref":"#/definitions/Parameter"}}},"required":["type","name","inputs"],"additionalProperties":false},"Parameter":{"type":"object","if":{"properties":{"type":{"oneOf":[{"pattern":"^tuple"}]}}},"then":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"components":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"internalType":{"type":"string"}},"required":["name","type","components"],"additionalProperties":false},"else":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"internalType":{"type":"string"}},"required":["name","type"],"additionalProperties":false}},"EventParameter":{"type":"object","if":{"properties":{"type":{"oneOf":[{"pattern":"^tuple"}]}}},"then":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"components":{"type":"array","items":{"$ref":"#/definitions/Parameter"}},"indexed":{"type":"boolean"},"internalType":{"type":"string"}},"required":["name","type","components","indexed"],"additionalProperties":false},"else":{"properties":{"name":{"$ref":"#/definitions/Name"},"type":{"$ref":"#/definitions/Type"},"indexed":{"type":"boolean"},"internalType":{"type":"string"}},"required":["name","type","indexed"],"additionalProperties":false}}}}');

/***/ }),

/***/ 85351:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$id":"contract-object.spec.json","$schema":"http://json-schema.org/schema#","title":"Contract Object","description":"Describes a contract consumable by Truffle, possibly including deployed instances on networks","type":"object","properties":{"contractName":{"$ref":"#/definitions/ContractName","description":"Name used to identify the contract","default":"Contract"},"abi":{"$ref":"abi.spec.json#","description":"Interface description returned by compiler for source"},"metadata":{"$ref":"#/definitions/Metadata"},"bytecode":{"$ref":"#/definitions/Bytecode","description":"Bytecode sent as contract-creation transaction data, with unresolved link references"},"deployedBytecode":{"$ref":"#/definitions/Bytecode","description":"On-chain deployed contract bytecode, with unresolved link references"},"sourceMap":{"$ref":"#/definitions/SourceMap","description":"Source mapping for contract-creation transaction data bytecode"},"deployedSourceMap":{"$ref":"#/definitions/SourceMap","description":"Source mapping for contract bytecode"},"source":{"$ref":"#/definitions/Source"},"sourcePath":{"$ref":"#/definitions/SourcePath"},"ast":{"$ref":"#/definitions/AST"},"legacyAST":{"$ref":"#/definitions/LegacyAST"},"compiler":{"type":"object","properties":{"name":{"type":"string"},"version":{"type":"string"}}},"networks":{"type":"object","patternProperties":{"^[a-zA-Z0-9]+$":{"$ref":"network-object.spec.json#"}},"additionalProperties":false},"schemaVersion":{"$ref":"#/definitions/SchemaVersion"},"updatedAt":{"type":"string","format":"date-time"},"networkType":{"$ref":"#/definitions/NetworkType","default":"ethereum"},"devdoc":{"$ref":"#/definitions/NatSpec"},"userdoc":{"$ref":"#/definitions/NatSpec"},"immutableReferences":{"$ref":"#/definitions/ImmutableReferences"},"generatedSources":{"$ref":"#/definitions/GeneratedSources"},"deployedGeneratedSources":{"$ref":"#/definitions/GeneratedSources"},"db":{"type":"object","patternProperties":{"^[a-zA-Z0-9]+$":{"type":"object","description":"Reference to @truffle/db canonical ID object for correlation purposes","properties":{"id":{"type":"string"}}}}}},"required":["abi"],"patternProperties":{"^x-":{"anyOf":[{"type":"string"},{"type":"boolean"},{"type":"number"},{"type":"object"},{"type":"array"}]}},"additionalProperties":false,"definitions":{"ContractName":{"type":"string","pattern":"^[a-zA-Z_][a-zA-Z0-9_]*$"},"NatSpec":{"type":"object"},"Metadata":{"type":"string"},"NetworkType":{"type":"string"},"Bytecode":{"type":"string","pattern":"^0x0?$|^0x([a-fA-F0-9]{2}|__.{38})+$"},"ImmutableReferences":{"type":"object","additionalProperties":{"type":"array","items":{"type":"object","properties":{"start":{"type":"integer","minimum":0},"length":{"type":"integer","minimum":0}},"additionalProperties":false}}},"GeneratedSources":{"type":"array","items":{"type":"object","properties":{"id":{"type":"integer","minimum":0},"language":{"type":"string"},"name":{"type":"string"},"contents":{"type":"string"},"ast":{"type":"object"}},"additionalProperties":false}},"Source":{"type":"string"},"SourceMap":{"type":"string","examples":["315:637:1:-;;;452:55;;;;;;;-1:-1:-1;;;;;485:9:1;476:19;:8;:19;;;;;;;;;;498:5;476:27;;452:55;315:637;;;;;;;"]},"SourcePath":{"type":"string"},"AST":{"type":"object"},"LegacyAST":{"type":"object"},"SchemaVersion":{"type":"string","pattern":"[0-9]+\\\\.[0-9]+\\\\.[0-9]+"}}}');

/***/ }),

/***/ 53245:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"$id":"network-object.spec.json","$schema":"http://json-schema.org/schema#","title":"Network Object","type":"object","properties":{"address":{"$ref":"#/definitions/Address"},"transactionHash":{"$ref":"#/definitions/TransactionHash"},"events":{"type":"object","patternProperties":{"^0x[a-fA-F0-9]{64}$":{"$ref":"abi.spec.json#/definitions/Event"}},"additionalProperties":false},"links":{"type":"object","patternProperties":{"^[a-zA-Z_][a-zA-Z0-9_]*$":{"$ref":"#/definitions/Address"}},"additionalProperties":false},"db":{"type":"object","patternProperties":{"^[a-zA-Z0-9]+$":{"type":"object","description":"Reference to @truffle/db canonical ID object for correlation purposes","properties":{"id":{"type":"string"}}}}}},"additionalProperties":false,"definitions":{"Address":{"type":"string","pattern":"^0x[a-fA-F0-9]{40}$"},"TransactionHash":{"type":"string","pattern":"^0x[a-fA-F0-9]{64}$"}}}');

/***/ }),

/***/ 54720:
/***/ ((module) => {

"use strict";
module.exports = {"i8":"4.6.31"};

/***/ })

};
;
//# sourceMappingURL=3077.bundled.js.map