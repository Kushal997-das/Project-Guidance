#!/usr/bin/env node

/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 3196:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 3196;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 72995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(91283),
  meta: __webpack_require__(74292)
};


/***/ }),

/***/ 74292:
/***/ ((module) => {

module.exports = {
  command: "unbox",
  description: "Download a Truffle Box, a pre-built Truffle project",
  builder: {},
  help: {
    usage: "truffle unbox [<box_name>] [destination] [--force]",
    options: [
      {
        option: "destination",
        description:
          "Path to the directory in which you would like " +
          "to unbox the project files. If destination is\n                  " +
          "  not provided, this defaults to the current directory."
      },
      {
        option: "<box_name>",
        description:
          "Name of the truffle box. If no box_name is specified, a default " +
          "truffle box will be downloaded."
      },
      {
        option: "--force",
        description:
          "Unbox project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 91283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const normalizeDestination = (destination, workingDirectory) => {
  if (!destination) {
    return workingDirectory;
  }
  const path = __webpack_require__(71017);
  if (path.isAbsolute(destination)) return destination;
  return path.join(workingDirectory, destination);
};

module.exports = async options => {
  const Config = __webpack_require__(20553);
  const { default: Box } = __webpack_require__(21579);
  const fse = __webpack_require__(55674);

  const config = Config.default().with({ logger: console });
  // we merge in the options so that options passed on the command line
  // (for example --quiet) make it to the EventManager
  config.merge(options);

  let [url, destination] = options._;

  const normalizedDestination = normalizeDestination(
    destination,
    config.working_directory
  );

  fse.ensureDirSync(normalizedDestination);

  const unboxOptions = Object.assign({}, options, { logger: config.logger });

  config.events.emit("unbox:start");

  const boxConfig = await Box.unbox(
    url,
    normalizedDestination,
    unboxOptions,
    config
  );
  await config.events.emit("unbox:succeed", { boxConfig });
};


/***/ }),

/***/ 21579:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSourcePath = void 0;
const utils_1 = __importDefault(__webpack_require__(26086));
const tmp_1 = __importDefault(__webpack_require__(36276));
const path_1 = __importDefault(__webpack_require__(71017));
const config_1 = __importDefault(__webpack_require__(20553));
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const inquirer_1 = __importDefault(__webpack_require__(96062));
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("unbox");
const defaultPath = "git@github.com:trufflesuite/truffle-init-default";
/*
 * accepts a number of different url and org/repo formats and returns the
 * format required by https://www.npmjs.com/package/download-git-repo for remote URLs
 * or absolute path to local folder if the source is local folder
 *
 * supported input formats are as follows:
 *   - org/repo[#branch]
 *   - https://github.com(/|:)<org>/<repo>[.git][#branch]
 *   - git@github.com:<org>/<repo>[#branch]
 *   - path to local folder (absolute, relative or ~/home)
 */
const normalizeSourcePath = (url = defaultPath) => {
    // Process filepath resolution
    //
    if (url.startsWith(".") || url.startsWith("/") || url.startsWith("~")) {
        debug({ in: url, out: path_1.default.normalize(url) });
        return path_1.default.resolve(path_1.default.normalize(url));
    }
    // preprocess to reduce regex complexity
    // `https` is not case sensitiv, unlike `git`
    url = url.replace(/^https/i, "https");
    // branch should not end with slash
    const invalidBranch = /\/$/;
    // process https? or git prefixed input
    //
    if (/^(https?|git)/i.test(url)) {
        // This regular expression uses named capture groups to parse input. The
        // format is (?<the-name>the-regex)
        //
        // \w, the word meta character is a member of [A-Za-z0-9_]. all letters,
        // digits and the underscore. Note \w has to be \\w to escape the backslash
        // in a string literal.
        //
        const protocolRex = new RegExp([
            // match either `htps://` or `git@`
            "(?<protocol>(https://|git@))",
            // service is 1 or many (word, dot or dash)
            "(?<service>[\\w.-]+)",
            // match either `/` or `:`
            "(/|:)",
            // org is 1 or many (word, dot or dash)
            "(?<org>[\\w.-]+)",
            "/",
            // repo is 1 or many (word, dot or dash)
            "(?<repo>[\\w.-]+)",
            // branch is 1 or many (word, dot or dash) and can be optional
            "(?<branch>#[\\w./-]+)?",
            // the input string must be consumed fully at this point to match
            "$"
        ].join(""));
        const match = url.match(protocolRex);
        if (match) {
            const { groups } = match;
            const branch = groups["branch"] || "";
            if (invalidBranch.test(branch)) {
                debug({
                    in: url,
                    error: "InvalidFormat (protocol)",
                    hint: "branch is malformed"
                });
                throw new Error("Box specified with invalid format (git/https)");
            }
            const repo = groups["repo"].replace(/\.git$/i, "");
            const result = `https://${groups["service"]}:${groups["org"]}/${repo}${branch}`;
            debug({ in: url, out: result });
            return result;
        }
        debug({
            in: url,
            error: "InvalidFormat (protocol)",
            hint: "did not match protocol"
        });
        throw new Error("Box specified with invalid format (git/https)");
    }
    // default case: process [org/] + repo + [ #branch/name/with/slashes ]
    //
    const orgRepoBranchRex = new RegExp([
        // start match at beginning
        "^",
        // org is 1 or many (word, dot or dash) followed by a slash. org can be
        // optional
        "(?<org>[\\w.-]+/)?",
        // repo is 1 or many (word, dot or dash)
        "(?<repo>[\\w.-]+)",
        // optional branch (undefined if unmatched)
        "(?<branch>#[\\w./-]+)?",
        "$"
    ].join(""));
    const match = url.match(orgRepoBranchRex);
    if (match) {
        const { groups } = match;
        // `truffle-box` is the default org
        const org = groups["org"] || "truffle-box/";
        const branch = groups["branch"] || "";
        if (invalidBranch.test(branch)) {
            debug({
                in: url,
                error: "InvalidFormat (orgRepoBranch)",
                hint: "branch is malformed"
            });
            throw new Error("Box specified with invalid format");
        }
        let repo = groups["repo"];
        // Official Truffle boxes should have a `-box` suffix
        if (org.toLowerCase().startsWith("truffle-box")) {
            repo = repo.endsWith("-box") ? repo : `${repo}-box`;
        }
        const result = `https://github.com:${org}${repo}${branch}`;
        debug({ in: url, out: result });
        return result;
    }
    // No match, it's an error!
    debug({ in: url, error: "InvalidFormat", hint: "matched nothing" });
    throw new Error("Box specified in invalid format");
};
exports.normalizeSourcePath = normalizeSourcePath;
const parseSandboxOptions = (options) => {
    if (typeof options === "string") {
        // back compatibility for when `options` used to be `name`
        return {
            name: options,
            unsafeCleanup: false,
            setGracefulCleanup: false,
            logger: console,
            force: false
        };
    }
    else if (typeof options === "object") {
        return {
            name: options.name || "default",
            unsafeCleanup: options.unsafeCleanup || false,
            setGracefulCleanup: options.setGracefulCleanup || false,
            logger: options.logger || console,
            force: options.force || false
        };
    }
};
const Box = {
    unbox: (url, destination, options = {}, config) => __awaiter(void 0, void 0, void 0, function* () {
        const { events } = config;
        let tempDirCleanup;
        const unpackBoxOptions = {
            logger: options.logger,
            force: options.force
        };
        try {
            const normalizedSourcePath = (0, exports.normalizeSourcePath)(url);
            yield Box.checkDir(options, destination);
            const tempDir = utils_1.default.setUpTempDirectory(events);
            const tempDirPath = tempDir.path;
            tempDirCleanup = tempDir.cleanupCallback;
            yield utils_1.default.downloadBox(normalizedSourcePath, tempDirPath, events);
            const boxConfig = yield utils_1.default.readBoxConfig(tempDirPath);
            yield utils_1.default.unpackBox(tempDirPath, destination, boxConfig, unpackBoxOptions);
            events.emit("unbox:cleaningTempFiles:start");
            tempDirCleanup();
            events.emit("unbox:cleaningTempFiles:succeed");
            utils_1.default.setUpBox(boxConfig, destination, events);
            return boxConfig;
        }
        catch (error) {
            if (tempDirCleanup)
                tempDirCleanup();
            events.emit("unbox:fail");
            throw error;
        }
    }),
    checkDir: (options = {}, destination) => __awaiter(void 0, void 0, void 0, function* () {
        let logger = options.logger || console;
        if (!options.force) {
            const unboxDir = fs_extra_1.default.readdirSync(destination);
            if (unboxDir.length) {
                logger.log(`This directory is non-empty...`);
                const prompt = [
                    {
                        type: "confirm",
                        name: "proceed",
                        message: `Proceed anyway?`,
                        default: true
                    }
                ];
                const answer = yield inquirer_1.default.prompt(prompt);
                if (!answer.proceed) {
                    logger.log("Unbox cancelled");
                    process.exit();
                }
            }
        }
    }),
    // options.unsafeCleanup
    //   Recursively removes the created temporary directory, even when it's not empty. default is false
    // options.setGracefulCleanup
    //   Cleanup temporary files even when an uncaught exception occurs
    sandbox: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const { name, unsafeCleanup, setGracefulCleanup, logger, force } = parseSandboxOptions(options);
        const boxPath = name.replace(/^default(?=#|$)/, defaultPath);
        //ordinarily, this line will have no effect.  however, if the name is "default",
        //possibly with a branch specification, this replaces it appropriately
        //(this is necessary in order to keep using trufflesuite/truffle-init-default
        //instead of truffle-box/etc)
        if (setGracefulCleanup)
            tmp_1.default.setGracefulCleanup();
        let config = new config_1.default();
        const tmpDir = tmp_1.default.dirSync({ unsafeCleanup });
        const unboxOptions = { logger, force };
        yield Box.unbox(boxPath, tmpDir.name, unboxOptions, config);
        return config_1.default.load(path_1.default.join(tmpDir.name, "truffle-config.js"), {});
    })
};
exports["default"] = Box;
//# sourceMappingURL=box.js.map

/***/ }),

/***/ 77220:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(55674));
function setDefaults(config = {}) {
    const hooks = config.hooks || {};
    return {
        ignore: config.ignore || [],
        commands: config.commands || {
            compile: "truffle compile",
            migrate: "truffle migrate",
            test: "truffle test"
        },
        hooks: {
            "post-unpack": hooks["post-unpack"] || ""
        }
    };
}
function read(path) {
    return fs_extra_1.default
        .readFile(path)
        .catch(() => "{}")
        .then(JSON.parse)
        .then(setDefaults);
}
module.exports = {
    read,
    setDefaults
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ 26086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const unbox_1 = __importDefault(__webpack_require__(91104));
const fs_1 = __importDefault(__webpack_require__(57147));
const config_1 = __importDefault(__webpack_require__(77220));
const tmp_1 = __importDefault(__webpack_require__(36276));
const path_1 = __importDefault(__webpack_require__(71017));
module.exports = {
    downloadBox: (source, destination, events) => __awaiter(void 0, void 0, void 0, function* () {
        events.emit("unbox:downloadingBox:start");
        yield unbox_1.default.verifySourcePath(source);
        yield unbox_1.default.fetchRepository(source, destination);
        events.emit("unbox:downloadingBox:succeed");
    }),
    readBoxConfig: (destination) => __awaiter(void 0, void 0, void 0, function* () {
        const possibleConfigs = [
            path_1.default.join(destination, "truffle-box.json"),
            path_1.default.join(destination, "truffle-init.json")
        ];
        const configPath = possibleConfigs.reduce((path, alt) => path || (fs_1.default.existsSync(alt) && alt), undefined);
        return yield config_1.default.read(configPath);
    }),
    setUpTempDirectory: (events) => {
        events.emit("unbox:preparingToDownload:start");
        const options = {
            unsafeCleanup: true
        };
        const tmpDir = tmp_1.default.dirSync(options);
        events.emit("unbox:preparingToDownload:succeed");
        return {
            path: path_1.default.join(tmpDir.name, "box"),
            cleanupCallback: tmpDir.removeCallback
        };
    },
    unpackBox: (tempDir, destination, boxConfig, unpackBoxOptions) => __awaiter(void 0, void 0, void 0, function* () {
        unbox_1.default.prepareToCopyFiles(tempDir, boxConfig);
        yield unbox_1.default.copyTempIntoDestination(tempDir, destination, unpackBoxOptions);
    }),
    setUpBox: (boxConfig, destination, events) => {
        events.emit("unbox:settingUpBox:start");
        unbox_1.default.installBoxDependencies(boxConfig, destination);
        events.emit("unbox:settingUpBox:succeed");
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91104:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const path_1 = __importDefault(__webpack_require__(71017));
const download_git_repo_1 = __importDefault(__webpack_require__(20448));
const axios_1 = __importDefault(__webpack_require__(43306));
const vcsurl_1 = __importDefault(__webpack_require__(9627));
const url_1 = __webpack_require__(57310);
const child_process_1 = __webpack_require__(32081);
const inquirer_1 = __importDefault(__webpack_require__(96062));
const util_1 = __webpack_require__(73837);
const ignore_1 = __importDefault(__webpack_require__(15151));
function verifyLocalPath(localPath) {
    const configPath = path_1.default.join(localPath, "truffle-box.json");
    fs_extra_1.default.access(configPath).catch(_e => {
        throw new Error(`Truffle Box at path ${localPath} doesn't exist.`);
    });
}
function verifyVCSURL(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // Next let's see if the expected repository exists. If it doesn't, ghdownload
        // will fail spectacularly in a way we can't catch, so we have to do it ourselves.
        const configURL = (0, url_1.parse)(`${(0, vcsurl_1.default)(url)
            .replace("github.com", "raw.githubusercontent.com")
            .replace(/#.*/, "")}/master/truffle-box.json`);
        const repoUrl = `https://${configURL.host}${configURL.path}`;
        try {
            yield axios_1.default.head(repoUrl, { maxRedirects: 50 });
        }
        catch (error) {
            if (error.response && error.response.status === 404) {
                throw new Error(`Truffle Box at URL ${url} doesn't exist. If you believe this is an error, please contact Truffle support.`);
            }
            else {
                const prefix = `Error connecting to ${repoUrl}. Please check your internet connection and try again.`;
                error.message = `${prefix}\n\n${error.message || ""}`;
                throw error;
            }
        }
    });
}
function verifySourcePath(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            return verifyLocalPath(sourcePath);
        }
        return verifyVCSURL(sourcePath);
    });
}
function gitIgnoreFilter(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const ignoreFilter = (0, ignore_1.default)();
        try {
            const gitIgnore = yield fs_extra_1.default.readFile(path_1.default.join(sourcePath, ".gitignore"), "utf8");
            ignoreFilter.add(gitIgnore.split(/\r?\n/).map(p => p.replace(/\/$/, "")));
        }
        catch (err) { }
        return ignoreFilter;
    });
}
function fetchRepository(sourcePath, dir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            const filter = yield gitIgnoreFilter(sourcePath);
            return fs_extra_1.default.copy(sourcePath, dir, {
                filter: file => sourcePath === file || !filter.ignores(path_1.default.relative(sourcePath, file))
            });
        }
        return (0, util_1.promisify)(download_git_repo_1.default)(sourcePath, dir);
    });
}
function prepareToCopyFiles(tempDir, { ignore }) {
    const needingRemoval = ignore;
    // remove box config file
    needingRemoval.push("truffle-box.json");
    needingRemoval.push("truffle-init.json");
    needingRemoval
        .map((fileName) => path_1.default.join(tempDir, fileName))
        .forEach((filePath) => fs_extra_1.default.removeSync(filePath));
}
function promptOverwrites(contentCollisions, logger = console) {
    return __awaiter(this, void 0, void 0, function* () {
        const overwriteContents = [];
        for (const file of contentCollisions) {
            logger.log(`${file} already exists in this directory...`);
            const overwriting = [
                {
                    type: "confirm",
                    name: "overwrite",
                    message: `Overwrite ${file}?`,
                    default: false
                }
            ];
            const { overwrite } = yield inquirer_1.default.prompt(overwriting);
            if (overwrite) {
                fs_extra_1.default.removeSync(file);
                overwriteContents.push(file);
            }
        }
        return overwriteContents;
    });
}
function copyTempIntoDestination(tmpDir, destination, options) {
    return __awaiter(this, void 0, void 0, function* () {
        fs_extra_1.default.ensureDirSync(destination);
        const { force, logger } = options;
        const boxContents = fs_extra_1.default.readdirSync(tmpDir);
        const destinationContents = fs_extra_1.default.readdirSync(destination);
        const newContents = boxContents.filter(filename => !destinationContents.includes(filename));
        const contentCollisions = boxContents.filter(filename => destinationContents.includes(filename));
        let shouldCopy;
        if (force) {
            shouldCopy = boxContents;
        }
        else {
            const overwriteContents = yield promptOverwrites(contentCollisions, logger);
            shouldCopy = [...newContents, ...overwriteContents];
        }
        for (const file of shouldCopy) {
            fs_extra_1.default.copySync(`${tmpDir}/${file}`, `${destination}/${file}`);
        }
    });
}
function installBoxDependencies({ hooks }, destination) {
    const postUnpack = hooks["post-unpack"];
    if (postUnpack.length === 0)
        return;
    (0, child_process_1.execSync)(postUnpack, { cwd: destination });
}
module.exports = {
    copyTempIntoDestination,
    fetchRepository,
    installBoxDependencies,
    prepareToCopyFiles,
    verifySourcePath,
    verifyVCSURL
};
//# sourceMappingURL=unbox.js.map

/***/ }),

/***/ 44516:
/***/ ((module) => {

"use strict";
module.exports = require("original-require");

/***/ }),

/***/ 39491:
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ 50852:
/***/ ((module) => {

"use strict";
module.exports = require("async_hooks");

/***/ }),

/***/ 14300:
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ 32081:
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ 22057:
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),

/***/ 6113:
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ 82361:
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ 57147:
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ 13685:
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ 95687:
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ 41808:
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ 22037:
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ 71017:
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ 85477:
/***/ ((module) => {

"use strict";
module.exports = require("punycode");

/***/ }),

/***/ 63477:
/***/ ((module) => {

"use strict";
module.exports = require("querystring");

/***/ }),

/***/ 14521:
/***/ ((module) => {

"use strict";
module.exports = require("readline");

/***/ }),

/***/ 12781:
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ 71576:
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ 24404:
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ 76224:
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),

/***/ 57310:
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ 73837:
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ 59796:
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = __webpack_module_cache__;
/******/ 	
/******/ 	// the startup function
/******/ 	__webpack_require__.x = () => {
/******/ 		// Load entry module and return exports
/******/ 		var __webpack_exports__ = __webpack_require__.O(undefined, [5158,9129,6127,5674,6674,4914,2895,4957,6062,6276,1472,6752,553], () => (__webpack_require__(72995)))
/******/ 		__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 		return __webpack_exports__;
/******/ 	};
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/amd options */
/******/ 	(() => {
/******/ 		__webpack_require__.amdO = {};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/ensure chunk */
/******/ 	(() => {
/******/ 		__webpack_require__.f = {};
/******/ 		// This file contains only the entry chunk.
/******/ 		// The chunk loading function for additional chunks
/******/ 		__webpack_require__.e = (chunkId) => {
/******/ 			return Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {
/******/ 				__webpack_require__.f[key](chunkId, promises);
/******/ 				return promises;
/******/ 			}, []));
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/get javascript chunk filename */
/******/ 	(() => {
/******/ 		// This function allow to reference async chunks and sibling chunks for the entrypoint
/******/ 		__webpack_require__.u = (chunkId) => {
/******/ 			// return url for filenames based on template
/******/ 			return "" + chunkId + ".bundled.js";
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/require chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded chunks
/******/ 		// "1" means "loaded", otherwise not loaded yet
/******/ 		var installedChunks = {
/******/ 			3462: 1
/******/ 		};
/******/ 		
/******/ 		__webpack_require__.O.require = (chunkId) => (installedChunks[chunkId]);
/******/ 		
/******/ 		var installChunk = (chunk) => {
/******/ 			var moreModules = chunk.modules, chunkIds = chunk.ids, runtime = chunk.runtime;
/******/ 			for(var moduleId in moreModules) {
/******/ 				if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 					__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 				}
/******/ 			}
/******/ 			if(runtime) runtime(__webpack_require__);
/******/ 			for(var i = 0; i < chunkIds.length; i++)
/******/ 				installedChunks[chunkIds[i]] = 1;
/******/ 			__webpack_require__.O();
/******/ 		};
/******/ 		
/******/ 		// require() chunk loading for javascript
/******/ 		__webpack_require__.f.require = (chunkId, promises) => {
/******/ 			// "1" is the signal for "already loaded"
/******/ 			if(!installedChunks[chunkId]) {
/******/ 				if(true) { // all chunks have JS
/******/ 					installChunk(require("./" + __webpack_require__.u(chunkId)));
/******/ 				} else installedChunks[chunkId] = 1;
/******/ 			}
/******/ 		};
/******/ 		
/******/ 		// no external install chunk
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/startup chunk dependencies */
/******/ 	(() => {
/******/ 		var next = __webpack_require__.x;
/******/ 		__webpack_require__.x = () => {
/******/ 			__webpack_require__.e(5158);
/******/ 			__webpack_require__.e(9129);
/******/ 			__webpack_require__.e(6127);
/******/ 			__webpack_require__.e(5674);
/******/ 			__webpack_require__.e(6674);
/******/ 			__webpack_require__.e(4914);
/******/ 			__webpack_require__.e(2895);
/******/ 			__webpack_require__.e(4957);
/******/ 			__webpack_require__.e(6062);
/******/ 			__webpack_require__.e(6276);
/******/ 			__webpack_require__.e(1472);
/******/ 			__webpack_require__.e(6752);
/******/ 			__webpack_require__.e(553);
/******/ 			return next();
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// module cache are used so entry inlining is disabled
/******/ 	// run startup
/******/ 	var __webpack_exports__ = __webpack_require__.x();
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;
//# sourceMappingURL=unbox.bundled.js.map