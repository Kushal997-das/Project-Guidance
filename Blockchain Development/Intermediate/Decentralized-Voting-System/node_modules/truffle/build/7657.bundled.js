#!/usr/bin/env node

exports.id = 7657;
exports.ids = [7657];
exports.modules = {

/***/ 46486:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var upperCase = __webpack_require__(66133)
var noCase = __webpack_require__(74431)

/**
 * Camel case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale, mergeNumbers) {
  var result = noCase(value, locale)

  // Replace periods between numeric entities with an underscore.
  if (!mergeNumbers) {
    result = result.replace(/ (?=\d)/g, '_')
  }

  // Replace spaces between words with an upper cased character.
  return result.replace(/ (.)/g, function (m, $1) {
    return upperCase($1, locale)
  })
}


/***/ }),

/***/ 82141:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


exports.BigNumber = __webpack_require__(70794).BigNumber
exports.Commented = __webpack_require__(22020)
exports.Diagnose = __webpack_require__(64694)
exports.Decoder = __webpack_require__(66774)
exports.Encoder = __webpack_require__(34666)
exports.Simple = __webpack_require__(89032)
exports.Tagged = __webpack_require__(14785)
exports.Map = __webpack_require__(33070)

exports.comment = exports.Commented.comment
exports.decodeAll = exports.Decoder.decodeAll
exports.decodeFirst = exports.Decoder.decodeFirst
exports.decodeAllSync = exports.Decoder.decodeAllSync
exports.decodeFirstSync = exports.Decoder.decodeFirstSync
exports.diagnose = exports.Diagnose.diagnose
exports.encode = exports.Encoder.encode
exports.encodeCanonical = exports.Encoder.encodeCanonical
exports.encodeOne = exports.Encoder.encodeOne
exports.encodeAsync = exports.Encoder.encodeAsync
exports.decode = exports.Decoder.decodeFirstSync

exports.leveldb = {
  decode: exports.Decoder.decodeAllSync,
  encode: exports.Encoder.encode,
  buffer: true,
  name: 'cbor'
}

exports.hasBigInt = __webpack_require__(99873).hasBigInt


/***/ }),

/***/ 22020:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(12781)
const util = __webpack_require__(73837)
const utils = __webpack_require__(99873)
const Simple = __webpack_require__(89032)
const Decoder = __webpack_require__(66774)
const constants = __webpack_require__(19066)
const bignumber = (__webpack_require__(70794).BigNumber)
const NoFilter = __webpack_require__(29911)

const MT = constants.MT
const NUMBYTES = constants.NUMBYTES
const SYMS = constants.SYMS

function plural(c) {
  if (c > 1) {
    return 's'
  } else {
    return ''
  }
}

/**
 * Generate the expanded format of RFC 7049, section 2.2.1
 *
 * @extends {stream.Transform}
 */
class Commented extends stream.Transform {
  /**
   * Create a CBOR commenter.
   *
   * @param {object} [options={}] - Stream options
   * @param {number} [options.max_depth=10] - how many times to indent
   *   the dashes
   * @param {number} [options.depth=1] - initial indentation depth
   * @param {boolean} [options.no_summary=false] - if true, omit the summary
   *   of the full bytes read at the end
   */
  constructor(options) {
    const opts = Object.assign({
      depth: 1,
      max_depth: 10,
      no_summary: false
    }, options, {
      readableObjectMode: false,
      writableObjectMode: false
    })
    const max_depth = opts.max_depth
    delete opts.max_depth
    const depth = opts.depth
    delete opts.depth
    super(opts)

    this.depth = depth
    this.max_depth = max_depth
    this.all = new NoFilter()

    opts.tags = {
      24: this._tag_24.bind(this)
    }
    this.parser = new Decoder(opts)
    this.parser.on('value', this._on_value.bind(this))
    this.parser.on('start', this._on_start.bind(this))
    this.parser.on('start-string', this._on_start_string.bind(this))
    this.parser.on('stop', this._on_stop.bind(this))
    this.parser.on('more-bytes', this._on_more.bind(this))
    this.parser.on('error', this._on_error.bind(this))
    if (!opts.no_summary) {
      this.parser.on('data', this._on_data.bind(this))
    }
    this.parser.bs.on('read', this._on_read.bind(this))
  }

  /**
   * @private
   */
  _tag_24(v) {
    const c = new Commented({depth: this.depth+1, no_summary: true})
    c.on('data', b => this.push(b))
    c.on('error', er => this.emit('error', er))
    c.end(v)
  }

  _transform(fresh, encoding, cb) {
    this.parser.write(fresh, encoding, cb)
  }

  /**
   * @private
   */
  _flush(cb) {
    // TODO: find the test that covers this, and look at the return value
    return this.parser._flush(cb)
  }

  /**
   * @callback commentCallback
   * @param {Error} [error] - if one was generated
   * @param {string} [commented] - the comment string
   */

  /**
   * @typedef CommentOptions
   * @property {number} [max_depth=10] how many times to indent the dashes
   * @property {string} [encoding='hex'] encoding of the input
   */
  /**
   * Comment on an input Buffer or string, creating a string passed to the
   * callback.  If callback not specified, a promise is returned.
   *
   * @static
   * @param {string|Buffer} input
   * @param {CommentOptions|commentCallback|string} [options] or callback
   * @param {commentCallback=} cb
   * @returns {Promise} if cb not specified
   */
  static comment(input, options, cb) {
    if (input == null) {
      throw new Error('input required')
    }
    let encoding = (typeof input === 'string') ? 'hex' : void 0
    let max_depth = 10
    switch (typeof options) {
      case 'function':
        cb = options
        break
      case 'string':
        encoding = options
        break
      case 'number':
        max_depth = options
        break
      case 'object':
        const ref1 = options.encoding
        const ref2 = options.max_depth
        encoding = (ref1 != null) ? ref1 : encoding
        max_depth = (ref2 != null) ? ref2 : max_depth
        break
      case 'undefined':
        break
      default:
        throw new Error('Unknown option type')
    }
    const bs = new NoFilter()
    const d = new Commented({
      max_depth
    })
    let p = null
    if (typeof cb === 'function') {
      d.on('end', () => {
        cb(null, bs.toString('utf8'))
      })
      d.on('error', cb)
    } else {
      p = new Promise((resolve, reject) => {
        d.on('end', () => {
          resolve(bs.toString('utf8'))
        })
        return d.on('error', reject)
      })
    }
    d.pipe(bs)
    d.end(input, encoding)
    return p
  }

  /**
   * @private
   */
  _on_error(er) {
    this.push('ERROR: ')
    this.push(er.toString())
    this.push('\n')
  }

  /**
   * @private
   */
  _on_read(buf) {
    this.all.write(buf)
    const hex = buf.toString('hex')
    this.push(new Array(this.depth + 1).join('  '))
    this.push(hex)
    let ind = (this.max_depth - this.depth) * 2
    ind -= hex.length
    if (ind < 1) {
      ind = 1
    }
    this.push(new Array(ind + 1).join(' '))
    return this.push('-- ')
  }

  /**
   * @private
   */
  _on_more(mt, len, parent_mt, pos) {
    this.depth++
    let desc = ''
    switch (mt) {
      case MT.POS_INT:
        desc = 'Positive number,'
        break
      case MT.NEG_INT:
        desc = 'Negative number,'
        break
      case MT.ARRAY:
        desc = 'Array, length'
        break
      case MT.MAP:
        desc = 'Map, count'
        break
      case MT.BYTE_STRING:
        desc = 'Bytes, length'
        break
      case MT.UTF8_STRING:
        desc = 'String, length'
        break
      case MT.SIMPLE_FLOAT:
        if (len === 1) {
          desc = 'Simple value,'
        } else {
          desc = 'Float,'
        }
        break
    }
    return this.push(desc + ' next ' + len + ' byte' + (plural(len)) + '\n')
  }

  /**
   * @private
   */
  _on_start_string(mt, tag, parent_mt, pos) {
    this.depth++
    let desc = ''
    switch (mt) {
      case MT.BYTE_STRING:
        desc = 'Bytes, length: ' + tag
        break
      case MT.UTF8_STRING:
        desc = 'String, length: ' + (tag.toString())
        break
    }
    return this.push(desc + '\n')
  }

  /**
   * @private
   */
  _on_start(mt, tag, parent_mt, pos) {
    this.depth++
    if (tag !== SYMS.BREAK) {
      switch (parent_mt) {
        case MT.ARRAY:
          this.push(`[${pos}], `)
          break
        case MT.MAP:
          if (pos % 2) {
            this.push(`{Val:${Math.floor(pos / 2)}}, `)
          } else {
            this.push(`{Key:${Math.floor(pos / 2)}}, `)
          }
          break
      }
    }
    switch (mt) {
      case MT.TAG:
        this.push(`Tag #${tag}`)
        if (tag == 24) {
          this.push(' Encoded CBOR data item')
        }
        break
      case MT.ARRAY:
        if (tag === SYMS.STREAM) {
          this.push('Array (streaming)')
        } else {
          this.push(`Array, ${tag} item${plural(tag)}`)
        }
        break
      case MT.MAP:
        if (tag === SYMS.STREAM) {
          this.push('Map (streaming)')
        } else {
          this.push(`Map, ${tag} pair${plural(tag)}`)
        }
        break
      case MT.BYTE_STRING:
        this.push('Bytes (streaming)')
        break
      case MT.UTF8_STRING:
        this.push('String (streaming)')
        break
    }
    return this.push('\n')
  }

  /**
   * @private
   */
  _on_stop(mt) {
    return this.depth--
  }

  /**
   * @private
   */
  _on_value(val, parent_mt, pos, ai) {
    if (val !== SYMS.BREAK) {
      switch (parent_mt) {
        case MT.ARRAY:
          this.push(`[${pos}], `)
          break
        case MT.MAP:
          if (pos % 2) {
            this.push(`{Val:${Math.floor(pos / 2)}}, `)
          } else {
            this.push(`{Key:${Math.floor(pos / 2)}}, `)
          }
          break
      }
    }

    if (val === SYMS.BREAK) {
      this.push('BREAK\n')
    } else if (val === SYMS.NULL) {
      this.push('null\n')
    } else if (val === SYMS.UNDEFINED) {
      this.push('undefined\n')
    } else if (typeof val === 'string') {
      this.depth--
      if (val.length > 0 ) {
        this.push(JSON.stringify(val))
        this.push('\n')
      }
    } else if (Buffer.isBuffer(val)) {
      this.depth--
      if (val.length > 0) {
        this.push(val.toString('hex'))
        this.push('\n')
      }
    } else if (val instanceof bignumber) {
      this.push(val.toString())
      this.push('\n')
    } else {
      this.push(util.inspect(val))
      this.push('\n')
    }

    switch (ai) {
      case NUMBYTES.ONE:
      case NUMBYTES.TWO:
      case NUMBYTES.FOUR:
      case NUMBYTES.EIGHT:
        this.depth--
    }
  }

  /**
   * @private
   */
  _on_data() {
    this.push('0x')
    this.push(this.all.read().toString('hex'))
    return this.push('\n')
  }
}

module.exports = Commented


/***/ }),

/***/ 19066:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

const bignumber = (__webpack_require__(70794).BigNumber)

exports.MT = {
  POS_INT: 0,
  NEG_INT: 1,
  BYTE_STRING: 2,
  UTF8_STRING: 3,
  ARRAY: 4,
  MAP: 5,
  TAG: 6,
  SIMPLE_FLOAT: 7
}

exports.TAG = {
  DATE_STRING: 0,
  DATE_EPOCH: 1,
  POS_BIGINT: 2,
  NEG_BIGINT: 3,
  DECIMAL_FRAC: 4,
  BIGFLOAT: 5,
  BASE64URL_EXPECTED: 21,
  BASE64_EXPECTED: 22,
  BASE16_EXPECTED: 23,
  CBOR: 24,
  URI: 32,
  BASE64URL: 33,
  BASE64: 34,
  REGEXP: 35,
  MIME: 36
}

exports.NUMBYTES = {
  ZERO: 0,
  ONE: 24,
  TWO: 25,
  FOUR: 26,
  EIGHT: 27,
  INDEFINITE: 31
}

exports.SIMPLE = {
  FALSE: 20,
  TRUE: 21,
  NULL: 22,
  UNDEFINED: 23
}

exports.SYMS = {
  NULL: Symbol('null'),
  UNDEFINED: Symbol('undef'),
  PARENT: Symbol('parent'),
  BREAK: Symbol('break'),
  STREAM: Symbol('stream')
}

exports.SHIFT32 = 0x100000000

exports.BI = {
  MINUS_ONE: -1,
  MAXINT32: 0xffffffff,
  MAXINT64: '0xffffffffffffffff',
  SHIFT32: exports.SHIFT32
}

const MINUS_ONE = new bignumber(-1)
exports.BN = {
  MINUS_ONE,
  NEG_MAX: MINUS_ONE.minus(
    new bignumber(Number.MAX_SAFE_INTEGER.toString(16), 16)),
  MAXINT: new bignumber('0x20000000000000'),
  MAXINT32: new bignumber(0xffffffff),
  MAXINT64: new bignumber('0xffffffffffffffff'),
  SHIFT32: new bignumber(exports.SHIFT32)
}


/***/ }),

/***/ 66774:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(12781)
const BinaryParseStream = __webpack_require__(10071)
const Tagged = __webpack_require__(14785)
const Simple = __webpack_require__(89032)
const utils = __webpack_require__(99873)
const bignumber = (__webpack_require__(70794).BigNumber)
const NoFilter = __webpack_require__(29911)
const constants = __webpack_require__(19066)
// Do not fix this if you want to support node v4
const MT = constants.MT
const NUMBYTES = constants.NUMBYTES
const SIMPLE = constants.SIMPLE
const SYMS = constants.SYMS

const BI = utils.bigIntize(constants.BI)
const BN = constants.BN
const COUNT = Symbol('count')
const PENDING_KEY = Symbol('pending_key')
const MAJOR = Symbol('major type')
const ERROR = Symbol('error')
const NOT_FOUND = Symbol('not found')

function parentArray(parent, typ, count) {
  const a = []
  a[COUNT] = count
  a[SYMS.PARENT] = parent
  a[MAJOR] = typ
  return a
}

function parentBufferStream(parent, typ) {
  const b = new NoFilter()
  b[COUNT] = -1
  b[SYMS.PARENT] = parent
  b[MAJOR] = typ
  return b
}

/**
 * @param {Buffer} v
 * @private
 */
function _tag_2(v) {
  return utils.bufferToBigInt(v)
}

/**
 * @param {BigInt} v
 * @private
 */
function _tag_3(v) {
  // avoid syntax error on old runtimes
  return BI.MINUS_ONE - utils.bufferToBigInt(v)
}

/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends {BinaryParseStream}
 */
class Decoder extends BinaryParseStream {

  /**
   * Create a parsing stream.
   *
   * @param {object} [options={}]
   * @param {number} [options.max_depth=-1] - the maximum depth to parse.
   *   Use -1 for "until you run out of memory".  Set this to a finite
   *   positive number for un-trusted inputs.  Most standard inputs won't nest
   *   more than 100 or so levels; I've tested into the millions before
   *   running out of memory.
   * @param {object} [options.tags] - mapping from tag number to function(v),
   *   where v is the decoded value that comes after the tag, and where the
   *   function returns the correctly-created value for that tag.
   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's
   *   instead of BigNumbers, when possible.  TODO: when BigInt's are
   *   more prevalent, change this to default to the value of cbor.hasBigInt.
   */
  constructor(options) {
    options = options || {}
    const tags = options.tags
    delete options.tags
    const max_depth = (options.max_depth != null) ? options.max_depth : -1
    delete options.max_depth
    const bigI = utils.hasBigInt ? (!!options.bigint) : false
    delete options.bigint
    super(options)

    this.running = true
    this.max_depth = max_depth
    this.tags = tags
    if (bigI) {
      if (this.tags == null) {
        this.tags = {}
      }
      if (this.tags[2] == null) {
        this.tags[2] = _tag_2
      }
      if (this.tags[3] == null) {
        this.tags[3] = _tag_3
      }
    }
  }

  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @static
   * @param {any} val - the value to check
   * @returns {any} the corrected value
   *
   * @example
   * myDecoder.on('data', function(val) {
   *   val = Decoder.nullcheck(val);
   *   ...
   * });
   */
  static nullcheck(val) {
    switch (val) {
      case SYMS.NULL:
        return null
      case SYMS.UNDEFINED:
        return undefined
      case NOT_FOUND:
        throw new Error('Value not found')
      default:
        return val
    }
  }

  /**
   * @typedef DecodeOptions
   * @property {string} [encoding='hex'] - The encoding of the input.
   *   Ignored if input is a Buffer.
   */

  /**
   * Decode the first CBOR item in the input, synchronously.  This will throw an
   * exception if the input is not valid CBOR.
   *
   * @static
   * @param {string|Buffer|stream.Readable} input
   * @param {DecodeOptions|string} [options] Options
   * @returns {any} - the decoded value
   */
  static decodeFirstSync(input, options) {
    options = options || { encoding: 'hex' }
    let opts = {}
    let encod
    switch (typeof options) {
      case 'string':
        encod = options
        break
      case 'object':
        opts = utils.extend({}, options)
        encod = opts.encoding
        delete opts.encoding
        break
    }
    const c = new Decoder(opts)
    const s = (input instanceof stream.Readable) ? input : new NoFilter(
      input,
      encod != null ? encod : utils.guessEncoding(input))

    // for/of doesn't work when you need to call next() with a value
    // generator created by parser will be "done" after each CBOR entity
    // parser will yield numbers of bytes that it wants
    const parser = c._parse()
    let state = parser.next()
    while (!state.done) {
      const b = s.read(state.value)
      if ((b == null) || (b.length !== state.value)) {
        throw new Error('Insufficient data')
      }
      state = parser.next(b)
    }
    const val = Decoder.nullcheck(state.value)
    if (s.length > 0) {
      const nextByte = s.read(1)
      s.unshift(nextByte)
      const er = new Error(
        'Unexpected data: 0x' + nextByte[0].toString(16))
      er.value = val
      throw er
    }
    return val
  }

  /**
   * Decode all of the CBOR items in the input into an array.  This will throw
   * an exception if the input is not valid CBOR; a zero-length input will
   * return an empty array.
   *
   * @static
   * @param {string|Buffer|stream.Readable} input
   * @param {DecodeOptions|string} [options] Options or encoding string
   * @returns {Array} - Array of all found items
   */
  static decodeAllSync(input, options) {
    options = options || { encoding: 'hex' }
    let opts = {}
    let encod
    switch (typeof options) {
      case 'string':
        encod = options
        break
      case 'object':
        opts = utils.extend({}, options)
        encod = opts.encoding
        delete opts.encoding
    }
    const c = new Decoder(opts)
    const s = (input instanceof stream.Readable) ? input : new NoFilter(
      input,
      encod != null ? encod : utils.guessEncoding(input))
    const res = []
    while (s.length > 0) {
      const parser = c._parse()
      let state = parser.next()
      while (!state.done) {
        const b = s.read(state.value)
        if ((b == null) || (b.length !== state.value)) {
          throw new Error('Insufficient data')
        }
        state = parser.next(b)
      }
      res.push(Decoder.nullcheck(state.value))
    }
    return res
  }

  /**
   * @callback decodeCallback
   * @param {Error} [error] - if one was generated
   * @param {any} [value] - the decoded value
   */

  /**
   * Decode the first CBOR item in the input.  This will error if there are more
   * bytes left over at the end, and optionally if there were no valid CBOR
   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback
   * if no data was found and the `required` option is false.
   *
   * @static
   * @param {string|Buffer} input - the input to parse
   * @param {DecodeOptions|decodeCallback|string} [options] - options
   * @param {decodeCallback} [cb] callback
   * @returns {Promise<any>} returned even if callback is specified
   */
  static decodeFirst(input, options, cb) {
    let opts = {}
    let required = false
    let encod = 'hex'
    switch (typeof options) {
      case 'function':
        cb = options
        encod = utils.guessEncoding(input)
        break
      case 'string':
        encod = options
        break
      case 'object':
        opts = utils.extend({}, options)
        encod = (opts.encoding != null) ?
          opts.encoding : utils.guessEncoding(input)
        delete opts.encoding
        required = (opts.required != null) ? opts.required : false
        delete opts.required
    }
    const c = new Decoder(opts)
    let v = NOT_FOUND
    const p = new Promise((resolve, reject) => {
      c.on('data', (val) => {
        v = Decoder.nullcheck(val)
        c.close()
      })
      c.once('error', (er) => {
        if (v !== NOT_FOUND) {
          er.value = v
        }
        v = ERROR
        c.close()
        return reject(er)
      })
      c.once('end', () => {
        switch (v) {
          case NOT_FOUND:
            if (required) {
              return reject(new Error('No CBOR found'))
            } else {
              return resolve(v)
            }
          case ERROR:
            return void 0
          default:
            return resolve(v)
        }
      })
    })

    if (typeof cb === 'function') {
      p.then(v => cb(null, v), cb)
    }
    c.end(input, encod)
    return p
  }

  /**
   * @callback decodeAllCallback
   * @param {Error} error - if one was generated
   * @param {Array} value - all of the decoded values, wrapped in an Array
   */

  /**
   * Decode all of the CBOR items in the input.  This will error if there are
   * more bytes left over at the end.
   *
   * @static
   * @param {(string|Buffer)} input - the input to parse
   * @param {(string|Object)} options - Decoding options.
   *   If string, the input encoding.
   * @param {decodeAllCallback} cb callback
   * @returns {Promise<Array>} even if callback is specified
   */
  static decodeAll(input, options, cb) {
    let opts = {}
    let encod = 'hex'
    switch (typeof options) {
      case 'function':
        cb = options
        encod = utils.guessEncoding(input)
        break
      case 'string':
        encod = options
        break
      case 'object':
        opts = utils.extend({}, options)
        encod = (opts.encoding != null) ?
          opts.encoding : utils.guessEncoding(input)
        delete opts.encoding
    }
    const c = new Decoder(opts)
    const vals = []
    c.on('data', (val) => {
      return vals.push(Decoder.nullcheck(val))
    })
    const p = new Promise((resolve, reject) => {
      c.on('error', reject)
      c.on('end', () => resolve(vals))
    })
    if (typeof cb === 'function') {
      p.then(v => cb(null, v), cb)
    }
    c.end(input, encod)
    return p
  }

  /**
   * Stop processing
   */
  close() {
    this.running = false
    this.__fresh = true
  }

  *_parse() {
    let parent = null
    let depth = 0
    let val = null
    while (true) {
      if ((this.max_depth >= 0) && (depth > this.max_depth)) {
        throw new Error('Maximum depth ' + this.max_depth + ' exceeded')
      }
      const octet = (yield 1)[0]
      if (!this.running) {
        throw new Error('Unexpected data: 0x' + (octet.toString(16)))
      }
      const mt = octet >> 5
      const ai = octet & 0x1f
      const parent_major = (parent != null) ? parent[MAJOR] : undefined
      const parent_length = (parent != null) ? parent.length : undefined
      switch (ai) {
        case NUMBYTES.ONE:
          this.emit('more-bytes', mt, 1, parent_major, parent_length)
          val = (yield 1)[0]
          break
        case NUMBYTES.TWO:
        case NUMBYTES.FOUR:
        case NUMBYTES.EIGHT:
          const numbytes = 1 << (ai - 24)
          this.emit('more-bytes', mt, numbytes, parent_major, parent_length)
          const buf = yield numbytes
          val = (mt === MT.SIMPLE_FLOAT) ? buf : utils.parseCBORint(ai, buf)
          break
        case 28:
        case 29:
        case 30:
          this.running = false
          throw new Error('Additional info not implemented: ' + ai)
        case NUMBYTES.INDEFINITE:
          switch (mt) {
            case MT.POS_INT:
            case MT.NEG_INT:
            case MT.TAG:
              throw new Error(`Invalid indefinite encoding for MT ${mt}`)
          }
          val = -1
          break
        default:
          val = ai
      }
      switch (mt) {
        case MT.POS_INT:
          // val already decoded
          break
        case MT.NEG_INT:
          if (val === Number.MAX_SAFE_INTEGER) {
            val = BN.NEG_MAX
          } else if (val instanceof bignumber) {
            val = BN.MINUS_ONE.minus(val)
          } else {
            val = -1 - val
          }
          break
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          switch (val) {
            case 0:
              this.emit('start-string', mt, val, parent_major, parent_length)
              val = (mt === MT.BYTE_STRING) ? Buffer.allocUnsafe(0) : ''
              break
            case -1:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)
              parent = parentBufferStream(parent, mt)
              depth++
              continue
            default:
              this.emit('start-string', mt, val, parent_major, parent_length)
              val = yield val
              if (mt === MT.UTF8_STRING) {
                val = utils.utf8(val)
              }
          }
          break
        case MT.ARRAY:
        case MT.MAP:
          switch (val) {
            case 0:
              val = (mt === MT.MAP) ? {} : []
              break
            case -1:
              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length)
              parent = parentArray(parent, mt, -1)
              depth++
              continue
            default:
              this.emit('start', mt, val, parent_major, parent_length)
              parent = parentArray(parent, mt, val * (mt - 3))
              depth++
              continue
          }
          break
        case MT.TAG:
          this.emit('start', mt, val, parent_major, parent_length)
          parent = parentArray(parent, mt, 1)
          parent.push(val)
          depth++
          continue
        case MT.SIMPLE_FLOAT:
          if (typeof val === 'number') {
            if ((ai === NUMBYTES.ONE) && (val < 32)) {
              throw new Error(
                `Invalid two-byte encoding of simple value ${val}`
              )
            }
            const hasParent = (parent != null)
            val = Simple.decode(
              val,
              hasParent,
              hasParent && (parent[COUNT] < 0))
          } else {
            val = utils.parseCBORfloat(val)
          }
      }
      this.emit('value', val, parent_major, parent_length, ai)
      let again = false
      while (parent != null) {
        switch (false) {
          case val !== SYMS.BREAK:
            parent[COUNT] = 1
            break
          case !Array.isArray(parent):
            parent.push(val)
            break
          case !(parent instanceof NoFilter):
            const pm = parent[MAJOR]
            if ((pm != null) && (pm !== mt)) {
              this.running = false
              throw new Error('Invalid major type in indefinite encoding')
            }
            parent.write(val)
        }
        if ((--parent[COUNT]) !== 0) {
          again = true
          break
        }
        --depth
        delete parent[COUNT]

        if (Array.isArray(parent)) {
          switch (parent[MAJOR]) {
            case MT.ARRAY:
              val = parent
              break
            case MT.MAP:
              let allstrings = true
              if ((parent.length % 2) !== 0) {
                throw new Error('Invalid map length: ' + parent.length)
              }
              for (let i = 0, len = parent.length; i < len; i += 2) {
                if (typeof parent[i] !== 'string') {
                  allstrings = false
                  break
                }
              }
              if (allstrings) {
                val = {}
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  val[parent[i]] = parent[i + 1]
                }
              } else {
                val = new Map
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  val.set(parent[i], parent[i + 1])
                }
              }
              break
            case MT.TAG:
              const t = new Tagged(parent[0], parent[1])
              val = t.convert(this.tags)
              break
          }
        } else if (parent instanceof NoFilter) {
          switch (parent[MAJOR]) {
            case MT.BYTE_STRING:
              val = parent.slice()
              break
            case MT.UTF8_STRING:
              val = parent.toString('utf-8')
              break
          }
        }
        this.emit('stop', parent[MAJOR])

        const old = parent
        parent = parent[SYMS.PARENT]
        delete old[SYMS.PARENT]
        delete old[MAJOR]
      }
      if (!again) {
        return val
      }
    }
  }
}

Decoder.NOT_FOUND = NOT_FOUND
module.exports = Decoder


/***/ }),

/***/ 64694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(12781)
const util = __webpack_require__(73837)
const Decoder = __webpack_require__(66774)
const Simple = __webpack_require__(89032)
const utils = __webpack_require__(99873)
const constants = __webpack_require__(19066)
const bignumber = (__webpack_require__(70794).BigNumber)
const NoFilter = __webpack_require__(29911)

const MT = constants.MT
const SYMS = constants.SYMS

/**
 * Output the diagnostic format from a stream of CBOR bytes.
 *
 * @extends {stream.Transform}
 */
class Diagnose extends stream.Transform {

  /**
   * Creates an instance of Diagnose.
   *
   * @param {Object} [options={}] - options for creation
   * @param {string} [options.separator='\n'] - output between detected objects
   * @param {boolean} [options.stream_errors=false] - put error info into the
   *   output stream
   * @param {number} [options.max_depth=-1] - -1 for "until you run out of
   *   memory".  Set this to a finite positive number for un-trusted inputs.
   *   Most standard inputs won't nest more than 100 or so levels; I've tested
   *   into the millions before running out of memory.
   */
  constructor(options) {
    const opts = Object.assign({
      separator: '\n',
      stream_errors: false
    }, options, {
      readableObjectMode: false,
      writableObjectMode: false
    })
    const separator = opts.separator
    delete opts.separator
    const stream_errors = opts.stream_errors
    delete opts.stream_errors
    super(opts)

    this.float_bytes = -1
    this.separator = separator
    this.stream_errors = stream_errors
    this.parser = new Decoder(opts)
    this.parser.on('more-bytes', this._on_more.bind(this))
    this.parser.on('value', this._on_value.bind(this))
    this.parser.on('start', this._on_start.bind(this))
    this.parser.on('stop', this._on_stop.bind(this))
    this.parser.on('data', this._on_data.bind(this))
    this.parser.on('error', this._on_error.bind(this))
  }

  _transform(fresh, encoding, cb) {
    return this.parser.write(fresh, encoding, cb)
  }

  _flush(cb) {
    return this.parser._flush((er) => {
      if (this.stream_errors) {
        if (er) {
          this._on_error(er)
        }
        return cb()
      } else {
        return cb(er)
      }
    })
  }

  /**
   * Convenience function to return a string in diagnostic format.
   *
   * @param {(Buffer|string)} input - the CBOR bytes to format
   * @param {string} [encoding='hex'] - the encoding of input, ignored if
   *   input is Buffer
   * @param {function(Error, string): undefined} cb - callback
   * @returns {Promise} if callback not specified
   */
  static diagnose(input, encoding, cb) {
    if (input == null) {
      throw new Error('input required')
    }
    let opts = {}
    let encod = 'hex'
    switch (typeof encoding) {
      case 'function':
        cb = encoding
        encod = utils.guessEncoding(input)
        break
      case 'object':
        opts = utils.extend({}, encoding)
        encod = (opts.encoding != null) ?
          opts.encoding : utils.guessEncoding(input)
        delete opts.encoding
        break
      default:
        encod = (encoding != null) ? encoding : 'hex'
    }
    const bs = new NoFilter()
    const d = new Diagnose(opts)
    let p = null
    if (typeof cb === 'function') {
      d.on('end', () => cb(null, bs.toString('utf8')))
      d.on('error', cb)
    } else {
      p = new Promise((resolve, reject) => {
        d.on('end', () => resolve(bs.toString('utf8')))
        return d.on('error', reject)
      })
    }
    d.pipe(bs)
    d.end(input, encod)
    return p
  }

  _on_error(er) {
    if (this.stream_errors) {
      return this.push(er.toString())
    } else {
      return this.emit('error', er)
    }
  }

  _on_more(mt, len, parent_mt, pos) {
    if (mt === MT.SIMPLE_FLOAT) {
      return this.float_bytes = {
        2: 1,
        4: 2,
        8: 3
      }[len]
    }
  }

  _fore(parent_mt, pos) {
    switch (parent_mt) {
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
      case MT.ARRAY:
        if (pos > 0) {
          return this.push(', ')
        }
        break
      case MT.MAP:
        if (pos > 0) {
          if (pos % 2) {
            return this.push(': ')
          } else {
            return this.push(', ')
          }
        }
    }
  }

  _on_value(val, parent_mt, pos) {
    if (val === SYMS.BREAK) {
      return
    }
    this._fore(parent_mt, pos)
    return this.push((() => {
      switch (false) {
        case val !== SYMS.NULL:
          return 'null'
        case val !== SYMS.UNDEFINED:
          return 'undefined'
        case typeof val !== 'string':
          return JSON.stringify(val)
        case !(this.float_bytes > 0):
          const fb = this.float_bytes
          this.float_bytes = -1
          return (util.inspect(val)) + '_' + fb
        case !Buffer.isBuffer(val):
          return 'h\'' + (val.toString('hex')) + '\''
        case !(val instanceof bignumber):
          return val.toString()
        default:
          return util.inspect(val)
      }
    })())
  }

  _on_start(mt, tag, parent_mt, pos) {
    this._fore(parent_mt, pos)
    switch (mt) {
      case MT.TAG:
        this.push(`${tag}(`)
        break
      case MT.ARRAY:
        this.push('[')
        break
      case MT.MAP:
        this.push('{')
        break
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
        this.push('(')
        break
    }
    if (tag === SYMS.STREAM) {
      return this.push('_ ')
    }
  }

  _on_stop(mt) {
    switch (mt) {
      case MT.TAG:
        return this.push(')')
      case MT.ARRAY:
        return this.push(']')
      case MT.MAP:
        return this.push('}')
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
        return this.push(')')
    }
  }

  _on_data() {
    return this.push(this.separator)
  }
}

module.exports = Diagnose


/***/ }),

/***/ 34666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(12781)
const url = __webpack_require__(57310)
const bignumber = (__webpack_require__(70794).BigNumber)
const NoFilter = __webpack_require__(29911)
const Tagged = __webpack_require__(14785)
const Simple = __webpack_require__(89032)
const utils = __webpack_require__(99873)

const constants = __webpack_require__(19066)
const MT = constants.MT
const NUMBYTES = constants.NUMBYTES
const SHIFT32 = constants.SHIFT32
const SYMS = constants.SYMS
const TAG = constants.TAG
const HALF = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.TWO
const FLOAT = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.FOUR
const DOUBLE = (constants.MT.SIMPLE_FLOAT << 5) | constants.NUMBYTES.EIGHT
const TRUE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.TRUE
const FALSE = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.FALSE
const UNDEFINED = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.UNDEFINED
const NULL = (constants.MT.SIMPLE_FLOAT << 5) | constants.SIMPLE.NULL
const BREAK = Buffer.from([0xff])

const BI = utils.bigIntize(constants.BI)
const BN = constants.BN
const BUF_NAN = Buffer.from('f97e00', 'hex')
const BUF_INF_NEG = Buffer.from('f9fc00', 'hex')
const BUF_INF_POS = Buffer.from('f97c00', 'hex')
const BUF_NEG_ZERO = Buffer.from('f98000', 'hex')
const LOOP_DETECT = Symbol('CBOR_LOOP_DETECT')

/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends {stream.Transform}
 */
class Encoder extends stream.Transform {

  /**
   * Creates an instance of Encoder.
   *
   * @param {Object} [options={}] - options for the encoder
   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,
   *   `function(Encoder)` for semantic types to be encoded.  Not needed
   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.
   * @param {boolean} [options.canonical=false] - should the output be
   *   canonicalized
   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops
   *   be detected?  This will currently modify the encoded object graph
   *   by adding a Symbol property to each object.  If this bothers you,
   *   call `removeLoopDetectors` on the encoded object when done.  Do not
   *   encode the same object twice on the same encoder, without calling
   *   `removeLoopDetectors` in between.
   * @param {("number"|"float"|"int"|"string")} [options.dateType="number"] -
   *   how should dates be encoded?  "number" means float or int, if no
   *   fractional seconds.
   * @param {any} [options.encodeUndefined=undefined] - How should an 
   *   "undefined" in the input be encoded.  By default, just encode a CBOR
   *   undefined.  If this is a buffer, use those bytes without re-encoding
   *   them.  If this is a function, the function will be called (which is
   *   a good time to throw an exception, if that's what you want), and the
   *   return value will be used according to these rules.  Anything
   *   else will be encoded as CBOR.
   * @param {boolean} [options.disallowUndefinedKeys=false] - Should "undefined"
   *   be disallowed as a key in a Map that is serialized?  If this is true,
   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that
   *   it is impossible to get a key of undefined in a normal JS object.
   * @param {boolean} [options.collapseBigIntegers=false] - Should integers
   *   that come in as BigNumber integers and ECMAscript bigint's be encoded
   *   as normal CBOR integers if they fit, discarding type information?
   */
  constructor(options) {
    const opts = Object.assign({}, options, {
      readableObjectMode: false,
      writableObjectMode: true
    })
    super(opts)

    this.canonical = opts.canonical
    this.encodeUndefined = opts.encodeUndefined
    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys
    this.dateType = (opts.dateType != null) ?
      opts.dateType.toLowerCase() : 'number'
    this.collapseBigIntegers = !!opts.collapseBigIntegers

    // new Symbol for each instance.  Note: means we can't re-use the same
    // encoder and encoded object
    if (typeof(opts.detectLoops) === 'symbol') {
      this.detectLoops = opts.detectLoops
    } else {
      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null
    }

    this.semanticTypes = {
      Array: this._pushArray,
      Date: this._pushDate,
      Buffer: this._pushBuffer,
      Map: this._pushMap,
      NoFilter: this._pushNoFilter,
      RegExp: this._pushRegexp,
      Set: this._pushSet,
      BigNumber: this._pushBigNumber,
      ArrayBuffer: this._pushUint8Array,
      Uint8ClampedArray: this._pushUint8Array,
      Uint8Array: this._pushUint8Array,
      Uint16Array: this._pushArray,
      Uint32Array: this._pushArray,
      Int8Array: this._pushArray,
      Int16Array: this._pushArray,
      Int32Array: this._pushArray,
      Float32Array: this._pushFloat32Array,
      Float64Array: this._pushFloat64Array
    }

    // tsc doesn't know about old Url
    if (url['Url']) {
      this.addSemanticType('Url', this._pushUrl)
    }
    if (url['URL']) {
      this.addSemanticType('URL', this._pushURL)
    }

    const addTypes = opts.genTypes || []
    for (let i = 0, len = addTypes.length; i < len; i += 2) {
      this.addSemanticType(addTypes[i], addTypes[i + 1])
    }
  }

  _transform(fresh, encoding, cb) {
    const ret = this.pushAny(fresh)
    // Old transformers might not return bool.  undefined !== false
    return cb((ret === false) ? new Error('Push Error') : undefined)
  }

  _flush(cb) {
    return cb()
  }

  /**
   * @callback encodeFunction
   * @param {Encoder} encoder - the encoder to serialize into.  Call "write"
   *   on the encoder as needed.
   * @return {bool} - true on success, else false
   */

  /**
   * Add an encoding function to the list of supported semantic types.  This is
   * useful for objects for which you can't add an encodeCBOR method
   *
   * @param {any} type
   * @param {any} fun
   * @returns {encodeFunction}
   */
  addSemanticType(type, fun) {
    if (typeof fun !== 'function') {
      throw new TypeError('fun must be of type function')
    }
    const typeName = (typeof type === 'string') ? type : type.name
    const old = this.semanticTypes[typeName]
    this.semanticTypes[typeName] = fun
    return old
  }

  _pushUInt8(val) {
    const b = Buffer.allocUnsafe(1)
    b.writeUInt8(val, 0)
    return this.push(b)
  }

  _pushUInt16BE(val) {
    const b = Buffer.allocUnsafe(2)
    b.writeUInt16BE(val, 0)
    return this.push(b)
  }

  _pushUInt32BE(val) {
    const b = Buffer.allocUnsafe(4)
    b.writeUInt32BE(val, 0)
    return this.push(b)
  }

  _pushFloatBE(val) {
    const b = Buffer.allocUnsafe(4)
    b.writeFloatBE(val, 0)
    return this.push(b)
  }

  _pushDoubleBE(val) {
    const b = Buffer.allocUnsafe(8)
    b.writeDoubleBE(val, 0)
    return this.push(b)
  }

  _pushNaN() {
    return this.push(BUF_NAN)
  }

  _pushInfinity(obj) {
    const half = (obj < 0) ? BUF_INF_NEG : BUF_INF_POS
    return this.push(half)
  }

  _pushFloat(obj) {
    if (this.canonical) {
      // TODO: is this enough slower to hide behind canonical?
      // It's certainly enough of a hack (see utils.parseHalf)

      // From section 3.9:
      // If a protocol allows for IEEE floats, then additional canonicalization
      // rules might need to be added.  One example rule might be to have all
      // floats start as a 64-bit float, then do a test conversion to a 32-bit
      // float; if the result is the same numeric value, use the shorter value
      // and repeat the process with a test conversion to a 16-bit float.  (This
      // rule selects 16-bit float for positive and negative Infinity as well.)

      // which seems pretty much backwards to me.
      const b2 = Buffer.allocUnsafe(2)
      if (utils.writeHalf(b2, obj)) {
        // I have convinced myself that there are no cases where writeHalf
        // will return true but `utils.parseHalf(b2) !== obj)`
        return this._pushUInt8(HALF) && this.push(b2)
      }
    }
    if (Math.fround(obj) === obj) {
      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj)
    }

    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj)
  }

  _pushInt(obj, mt, orig) {
    const m = mt << 5
    switch (false) {
      case !(obj < 24):
        return this._pushUInt8(m | obj)
      case !(obj <= 0xff):
        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj)
      case !(obj <= 0xffff):
        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj)
      case !(obj <= 0xffffffff):
        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj)
      case !(obj <= Number.MAX_SAFE_INTEGER):
        return this._pushUInt8(m | NUMBYTES.EIGHT) &&
          this._pushUInt32BE(Math.floor(obj / SHIFT32)) &&
          this._pushUInt32BE(obj % SHIFT32)
      default:
        if (mt === MT.NEG_INT) {
          return this._pushFloat(orig)
        } else {
          return this._pushFloat(obj)
        }
    }
  }

  _pushIntNum(obj) {
    if (Object.is(obj, -0)) {
      return this.push(BUF_NEG_ZERO)
    }

    if (obj < 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj)
    } else {
      return this._pushInt(obj, MT.POS_INT)
    }
  }

  _pushNumber(obj) {
    switch (false) {
      case !isNaN(obj):
        return this._pushNaN()
      case isFinite(obj):
        return this._pushInfinity(obj)
      case Math.round(obj) !== obj:
        return this._pushIntNum(obj)
      default:
        return this._pushFloat(obj)
    }
  }

  _pushString(obj) {
    const len = Buffer.byteLength(obj, 'utf8')
    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8')
  }

  _pushBoolean(obj) {
    return this._pushUInt8(obj ? TRUE : FALSE)
  }

  _pushUndefined(obj) {
    switch (typeof this.encodeUndefined) {
      case 'undefined':
        return this._pushUInt8(UNDEFINED)
      case 'function':
        return this.pushAny(this.encodeUndefined.call(this, obj))
      case 'object':
        if (Buffer.isBuffer(this.encodeUndefined)) {
          return this.push(this.encodeUndefined)
        }
    }
    return this.pushAny(this.encodeUndefined)
  }

  _pushNull(obj) {
    return this._pushUInt8(NULL)
  }

  _pushArray(gen, obj, opts) {
    opts = Object.assign({
      indefinite: false
    }, opts)
    const len = obj.length
    if (opts.indefinite) {
      if (!gen._pushUInt8((MT.ARRAY << 5) | NUMBYTES.INDEFINITE)) {
        return false
      }
    } else if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j < len; j++) {
      if (!gen.pushAny(obj[j])) {
        return false
      }
    }
    if (opts.indefinite) {
      if (!gen.push(BREAK)) {
        return false
      }
    }
    return true
  }

  _pushTag(tag) {
    return this._pushInt(tag, MT.TAG)
  }

  _pushDate(gen, obj) {
    switch (gen.dateType) {
      case 'string':
        return gen._pushTag(TAG.DATE_STRING) &&
          gen._pushString(obj.toISOString())
      case 'int':
      case 'integer':
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen._pushIntNum(Math.round(obj / 1000))
      case 'float':
        // force float
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen._pushFloat(obj / 1000)
      case 'number':
      default:
        // if we happen to have an integral number of seconds,
        // use integer.  Otherwise, use float.
        return gen._pushTag(TAG.DATE_EPOCH) &&
          gen.pushAny(obj / 1000)
    }
  }

  _pushBuffer(gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj)
  }

  _pushNoFilter(gen, obj) {
    return gen._pushBuffer(gen, obj.slice())
  }

  _pushRegexp(gen, obj) {
    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source)
  }

  _pushSet(gen, obj) {
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false
    }
    for (const x of obj) {
      if (!gen.pushAny(x)) {
        return false
      }
    }
    return true
  }

  _pushUrl(gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format())
  }

  _pushURL(gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString())
  }

  /**
   * @param {bignumber} obj
   * @private
   */
  _pushBigint(obj) {
    let m = MT.POS_INT
    let tag = TAG.POS_BIGINT

    if (obj.isNegative()) {
      obj = obj.negated().minus(1)
      m = MT.NEG_INT
      tag = TAG.NEG_BIGINT
    }

    if (this.collapseBigIntegers &&
        obj.lte(BN.MAXINT64)) {
      //  special handiling for 64bits
      if (obj.lte(BN.MAXINT32)) {
        return this._pushInt(obj.toNumber(), m)
      }
      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) &&
        this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber())
    }
    let str = obj.toString(16)
    if (str.length % 2) {
      str = '0' + str
    }
    const buf = Buffer.from(str, 'hex')
    return this._pushTag(tag) && this._pushBuffer(this, buf)
  }

  /**
   * @param {bigint} obj
   * @private
   */
  _pushJSBigint(obj) {
    let m = MT.POS_INT
    let tag = TAG.POS_BIGINT
    // BigInt doesn't have -0
    if (obj < 0) {
      obj = -obj + BI.MINUS_ONE
      m = MT.NEG_INT
      tag = TAG.NEG_BIGINT
    }

    if (this.collapseBigIntegers &&
        (obj <= BI.MAXINT64)) {
      //  special handiling for 64bits
      if (obj <= 0xffffffff) {
        return this._pushInt(Number(obj), m)
      }
      return this._pushUInt8((m << 5) | NUMBYTES.EIGHT) &&
        this._pushUInt32BE(Number(obj / BI.SHIFT32)) &&
        this._pushUInt32BE(Number(obj % BI.SHIFT32))
    }

    let str = obj.toString(16)
    if (str.length % 2) {
      str = '0' + str
    }
    const buf = Buffer.from(str, 'hex')
    return this._pushTag(tag) && this._pushBuffer(this, buf)
  }

  _pushBigNumber(gen, obj) {
    if (obj.isNaN()) {
      return gen._pushNaN()
    }
    if (!obj.isFinite()) {
      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity)
    }
    if (obj.isInteger()) {
      return gen._pushBigint(obj)
    }
    if (!(gen._pushTag(TAG.DECIMAL_FRAC) &&
      gen._pushInt(2, MT.ARRAY))) {
      return false
    }

    const dec = obj.decimalPlaces()
    const slide = obj.shiftedBy(dec)
    if (!gen._pushIntNum(-dec)) {
      return false
    }
    if (slide.abs().isLessThan(BN.MAXINT)) {
      return gen._pushIntNum(slide.toNumber())
    } else {
      return gen._pushBigint(slide)
    }
  }

  _pushMap(gen, obj, opts) {
    opts = Object.assign({
      indefinite: false
    }, opts)
    if (opts.indefinite) {
      if (!gen._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {
        return false
      }
    } else if (!gen._pushInt(obj.size, MT.MAP)) {
      return false
    }
    // memoizing the cbor only helps in certain cases, and hurts in most
    // others.  Just avoid it.
    if (gen.canonical) {
      // keep the key/value pairs together, so we don't have to do odd
      // gets with object keys later
      const entries = [...obj.entries()]
      const enc = new Encoder(this) // TODO: fix genTypes
      const bs = new NoFilter({highWaterMark:this.readableHighWaterMark})
      enc.pipe(bs)
      entries.sort(([a], [b]) => {
        // a, b are the keys
        enc.pushAny(a)
        const a_cbor = bs.read()
        enc.pushAny(b)
        const b_cbor = bs.read()
        return a_cbor.compare(b_cbor)
      })
      for (const [k, v] of entries) {
        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {
          throw new Error('Invalid Map key: undefined')
        }
        if (!(gen.pushAny(k) && gen.pushAny(v))) {
          return false
        }
      }
    } else {
      for (const [k, v] of obj) {
        if (gen.disallowUndefinedKeys && (typeof k === 'undefined')) {
          throw new Error('Invalid Map key: undefined')
        }
        if (!(gen.pushAny(k) && gen.pushAny(v))) {
          return false
        }
      }
    }
    if (opts.indefinite) {
      if (!gen.push(BREAK)) {
        return false
      }
    }
    return true
  }

  _pushUint8Array(gen, obj) {
    return gen._pushBuffer(gen, Buffer.from(obj))
  }

  _pushFloat32Array(gen, obj) {
    const len = obj.length
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j < len; j++) {
      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {
        return false
      }
    }
    return true
  }

  _pushFloat64Array(gen, obj) {
    const len = obj.length
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false
    }
    for (let j = 0; j < len; j++) {
      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {
        return false
      }
    }
    return true
  }

  /**
   * Remove all of the loop detector additions to the given object.
   *
   * @param {Object} obj - object to clean
   * @returns {bool} - true when the object was cleaned, else false
   */
  removeLoopDetectors(obj) {
    if (!this.detectLoops) {
      return false
    }
    return Encoder.removeLoopDetectors(obj, this.detectLoops)
  }

  /**
   * Remove all of the loop detector additions to the given object.
   * The static version is easier to call when you don't have a full
   * encoder instance available; it uses a good heuristic to figure
   * out the loop detector symbol.
   *
   * @param {Object} obj - object to clean
   * @param {Symbol} [detector=null] - the symbol to clean, or null
   *   to use the first detected symbol
   * @returns {bool} - true when the object was cleaned, else false
   */
  static removeLoopDetectors(obj, detector=null) {
    if ((typeof(obj) !== 'object') || !obj) {
      return false
    }
    const dl = obj[LOOP_DETECT]
    if (!dl) {
      // ironically, use loop marking to detect loops on removal as well
      return false
    }
    if (detector == null) {
      detector = dl
    } else {
      if (detector !== dl) {
        return false
      }
    }
    delete obj[LOOP_DETECT]
    if (Array.isArray(obj)) {
      for (const i of obj) {
        this.removeLoopDetectors(i, detector)
      }
    } else {
      for (const k in obj) {
        this.removeLoopDetectors(obj[k], detector)
      }
    }
    return true
  }

  _pushObject(obj, opts) {
    if (!obj) {
      return this._pushNull(obj)
    }
    opts = Object.assign({
      indefinite: false,
      skipTypes: false
    }, opts)
    if (!opts.indefinite) {
      // this will only happen the first time through for indefinite encoding
      if (this.detectLoops) {
        if (obj[LOOP_DETECT] === this.detectLoops) {
          throw new Error('Loop detected while CBOR encoding')
        } else {
          obj[LOOP_DETECT] = this.detectLoops
        }
      }
    }
    if (!opts.skipTypes) {
      const f = obj.encodeCBOR
      if (typeof f === 'function') {
        return f.call(obj, this)
      }
      const converter = this.semanticTypes[obj.constructor.name]
      if (converter) {
        return converter.call(obj, this, obj)
      }
    }
    const keys = Object.keys(obj).filter(k => typeof obj[k] !== 'function')
    const cbor_keys = {}
    if (this.canonical) {
      // note: this can't be a normal sort, because 'b' needs to sort before
      // 'aa'
      keys.sort((a, b) => {
        // Always strings, so don't bother to pass options.
        // hold on to the cbor versions, since there's no need
        // to encode more than once
        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a))
        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b))

        return a_cbor.compare(b_cbor)
      })
    }
    if (opts.indefinite) {
      if (!this._pushUInt8((MT.MAP << 5) | NUMBYTES.INDEFINITE)) {
        return false
      }
    } else if (!this._pushInt(keys.length, MT.MAP)) {
      return false
    }
    let ck
    for (let j = 0, len2 = keys.length; j < len2; j++) {
      const k = keys[j]
      if (this.canonical && ((ck = cbor_keys[k]))) {
        if (!this.push(ck)) { // already a Buffer
          return false
        }
      } else {
        if (!this._pushString(k)) {
          return false
        }
      }
      if (!this.pushAny(obj[k])) {
        return false
      }
    }
    if (opts.indefinite) {
      if (!this.push(BREAK)) {
        return false
      }
    }
    return true
  }

  /**
   * Push any supported type onto the encoded stream
   *
   * @param {any} obj
   * @returns {boolean} true on success
   */
  pushAny(obj) {
    switch (typeof obj) {
      case 'number':
        return this._pushNumber(obj)
      case 'bigint':
        return this._pushJSBigint(obj)
      case 'string':
        return this._pushString(obj)
      case 'boolean':
        return this._pushBoolean(obj)
      case 'undefined':
        return this._pushUndefined(obj)
      case 'object':
        return this._pushObject(obj)
      case 'symbol':
        switch (obj) {
          case SYMS.NULL:
            return this._pushNull(null)
          case SYMS.UNDEFINED:
            return this._pushUndefined(void 0)
          // TODO: Add pluggable support for other symbols
          default:
            throw new Error('Unknown symbol: ' + obj.toString())
        }
      default:
        throw new Error(
          'Unknown type: ' + typeof obj + ', ' +
          (!!obj.toString ? obj.toString() : ''))
    }
  }

  /* backwards-compat wrapper */
  _pushAny(obj) {
    // TODO: write deprecation warning
    return this.pushAny(obj)
  }

  _encodeAll(objs) {
    const bs = new NoFilter({ highWaterMark:this.readableHighWaterMark })
    this.pipe(bs)
    for (const o of objs) {
      this.pushAny(o)
    }
    this.end()
    return bs.read()
  }

  /**
   * Encode the given object with indefinite length.  There are apparently
   * some (IMO) broken implementations of poorly-specified protocols that
   * REQUIRE indefinite-encoding.  Add this to an object or class as the
   * `encodeCBOR` function to get indefinite encoding:
   * @example
   * const o = {
   *   a: true,
   *   encodeCBOR: cbor.Encoder.encodeIndefinite
   * }
   * const m = []
   * m.encodeCBOR = cbor.Encoder.encodeIndefinite
   * cbor.encodeOne([o, m])
   *
   * @param {Encoder} - the encoder to use
   * @param {String|Buffer|Array|Map|Object} [obj] - the object to encode.  If
   *   null, use "this" instead.
   * @param {Object} [opts=null] - Options for encoding
   * @param {boolean} [opts.chunkSize=4096] - Number of characters or bytes
   *  for each chunk, if obj is a string or Buffer
   * @returns {boolean} - true on success
   */
  static encodeIndefinite(gen, obj, opts) {
    if (obj == null) {
      if (this == null) {
        throw new Error('No object to encode')
      }
      obj = this
    }
    opts = Object.assign({
      chunkSize: 4096
    }, opts)

    let ret = true
    const objType = typeof obj
    if (objType === 'string') {
      // TODO: make sure not to split surrogate pairs at the edges of chunks,
      // since such half-surrogates cannot be legally encoded as UTF-8.
      ret = ret && gen._pushUInt8((MT.UTF8_STRING << 5) | NUMBYTES.INDEFINITE)
      let offset = 0
      while (offset < obj.length) {
        const endIndex = offset + opts.chunkSize
        ret = ret && gen._pushString(obj.slice(offset, endIndex))
        offset = endIndex
      }
      ret = ret && gen.push(BREAK)
    } else if (Buffer.isBuffer(obj)) {
      ret = ret && gen._pushUInt8((MT.BYTE_STRING << 5) | NUMBYTES.INDEFINITE)
      let offset = 0
      while (offset < obj.length) {
        const endIndex = offset + opts.chunkSize
        ret = ret && gen._pushBuffer(gen, obj.slice(offset, endIndex))
        offset = endIndex
      }
      ret = ret && gen.push(BREAK)
    } else if (Array.isArray(obj)) {
      ret = ret && gen._pushArray(gen, obj, {
        indefinite: true
      })
    } else if (obj instanceof Map) {
      ret = ret && gen._pushMap(gen, obj, {
        indefinite: true
      })
    } else {
      if (objType !== 'object') {
        throw new Error('Invalid indefinite encoding')
      }
      ret = ret && gen._pushObject(obj, {
        indefinite: true,
        skipTypes: true
      })
    }
    return ret
  }

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs - the objects to encode
   * @returns {Buffer} - the encoded objects
   */
  static encode(...objs) {
    return new Encoder()._encodeAll(objs)
  }

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} objs - the objects to encode
   * @returns {Buffer} - the encoded objects
   */
  static encodeCanonical(...objs) {
    return new Encoder({canonical: true})._encodeAll(objs)
  }

  /**
   * Encode one JavaScript object using the given options.
   *
   * @static
   * @param {any} obj - the object to encode
   * @param {Object?} options - passed to the Encoder constructor
   * @returns {Buffer} - the encoded objects
   */
  static encodeOne(obj, options) {
    return new Encoder(options)._encodeAll([obj])
  }

  /**
   * Encode one JavaScript object using the given options in a way that
   * is more resilient to objects being larger than the highWaterMark
   * number of bytes.  As with the other static encode functions, this 
   * will still use a large amount of memory.  Use a stream-based approach
   * directly if you need to process large and complicated inputs.
   *
   * @param {any} obj - the object to encode
   * @param {Object?} options - passed to the Encoder constructor
   */
  static encodeAsync(obj, options) {
    return new Promise((resolve, reject) => {
      const bufs = []
      const enc = new Encoder(options)
      enc.on('data', buf => bufs.push(buf))
      enc.on('error', reject)
      enc.on('finish', () => resolve(Buffer.concat(bufs)))
      enc.pushAny(obj)
      enc.end()
    })
  }
}

module.exports = Encoder


/***/ }),

/***/ 33070:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const encoder = __webpack_require__(34666)
const decoder = __webpack_require__(66774)
const constants = __webpack_require__(19066)
const MT = constants.MT

/**
 * Wrapper around a JavaScript Map object that allows the keys to be
 * any complex type.  The base Map object allows this, but will only
 * compare the keys by identity, not by value.  CborMap translates keys
 * to CBOR first (and base64's them to ensure by-value comparison).
 *
 * This is not a subclass of Object, because it would be tough to get
 * the semantics to be an exact match.
 *
 * @class CborMap
 * @extends {Map}
 */
class CborMap extends Map {
  /**
   * Creates an instance of CborMap.
   * @param {Iterable<any, any>} [iterable] An Array or other iterable
   *   object whose elements are key-value pairs (arrays with two elements, e.g.
   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added
   *   to the new CborMap; null values are treated as undefined.
   */
  constructor(iterable) {
    super(iterable)
  }

  /**
   * @private
   */
  static _encode(key) {
    return encoder.encodeCanonical(key).toString('base64')
  }

  /**
   * @private
   */
  static _decode(key) {
    return decoder.decodeFirstSync(key, 'base64')
  }

  /**
   * Retrieve a specified element.
   *
   * @param {any} key The key identifying the element to retrieve.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {any} The element if it exists, or <code>undefined</code>.
   */
  get(key) {
    return super.get(CborMap._encode(key))
  }

  /**
   * Adds or updates an element with a specified key and value.
   *
   * @param {any} key The key identifying the element to store.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @param {any} val The element to store
   */
  set(key, val) {
    return super.set(CborMap._encode(key), val)
  }

  /**
   * Removes the specified element.
   *
   * @param {any} key The key identifying the element to delete.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {boolean}
   */
  delete(key) {
    return super.delete(CborMap._encode(key))
  }

  /**
   * Does an element with the specified key exist?
   *
   * @param {any} key The key identifying the element to check.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {boolean}
   */
  has(key) {
    return super.has(CborMap._encode(key))
  }

  /**
   * Returns a new Iterator object that contains the keys for each element
   * in the Map object in insertion order.  The keys are decoded into their
   * original format.
   *
   * @returns {IterableIterator<any>}
   */
  *keys() {
    for (const k of super.keys()) {
      yield CborMap._decode(k)
    }
  }

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {IterableIterator}
   */
  *entries() {
    for (const kv of super.entries()) {
      yield [CborMap._decode(kv[0]), kv[1]]
    }
  }

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {IterableIterator}
   */
  [Symbol.iterator]() {
    return this.entries()
  }

  /**
   * Executes a provided function once per each key/value pair in the Map
   * object, in insertion order.
   *
   * @param {function(any, any, Map): undefined} fun Function to execute for
   *  each element, which takes a value, a key, and the Map being traversed.
   * @param {any} thisArg Value to use as this when executing callback
   */
  forEach(fun, thisArg) {
    if (typeof(fun) !== 'function') {
      throw new TypeError('Must be function')
    }
    for (const kv of super.entries()) {
      fun.call(this, kv[1], CborMap._decode(kv[0]), this)
    }
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {Object} gen The generator to push onto
   * @returns {boolean} true on success
   */
  encodeCBOR(gen) {
    if (!gen._pushInt(this.size, MT.MAP)) {
      return false
    }
    if (gen.canonical) {
      const entries = Array.from(super.entries())
        .map((kv) => [Buffer.from(kv[0], 'base64'), kv[1]])
      entries.sort((a, b) => a[0].compare(b[0]))
      for (const kv of entries) {
        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {
          return false
        }
      }
    } else {
      for (const kv of super.entries()) {
        if (!(gen.push(Buffer.from(kv[0], 'base64')) && gen.pushAny(kv[1]))) {
          return false
        }
      }
    }
    return true
  }
}

module.exports = CborMap


/***/ }),

/***/ 89032:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(73837)
const constants = __webpack_require__(19066)
const MT = constants.MT
const SIMPLE = constants.SIMPLE
const SYMS = constants.SYMS

/**
 * A CBOR Simple Value that does not map onto a known constant.
 */
class Simple {
  /**
   * Creates an instance of Simple.
   *
   * @param {number} value - the simple value's integer value
   */
  constructor(value) {
    if (typeof value !== 'number') {
      throw new Error('Invalid Simple type: ' + (typeof value))
    }
    if ((value < 0) || (value > 255) || ((value|0) !== value)) {
      throw new Error('value must be a small positive integer: ' + value)
    }
    this.value = value
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */
  toString() {
    return 'simple(' + this.value + ')'
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */
  [util.inspect.custom](depth, opts) {
    return 'simple(' + this.value + ')'
  }

  /**
   * Debug string for simple value (backward-compatibility version)
   *
   * @returns {string} simple(value)
   */
  inspect(depth, opts) {
    return 'simple(' + this.value + ')'
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {Object} gen The generator to push onto
   */
  encodeCBOR(gen) {
    return gen._pushInt(this.value, MT.SIMPLE_FLOAT)
  }

  /**
   * Is the given object a Simple?
   *
   * @param {any} obj - object to test
   * @returns {boolean} - is it Simple?
   */
  static isSimple(obj) {
    return obj instanceof Simple
  }

  /**
   * Decode from the CBOR additional information into a JavaScript value.
   * If the CBOR item has no parent, return a "safe" symbol instead of
   * `null` or `undefined`, so that the value can be passed through a
   * stream in object mode.
   *
   * @param {number} val - the CBOR additional info to convert
   * @param {boolean} [has_parent=true] - Does the CBOR item have a parent?
   * @param {boolean} [parent_indefinite=false] - Is the parent element
   *   indefinitely encoded?
   * @returns {(null|undefined|boolean|Symbol|Simple)} - the decoded value
   */
  static decode(val, has_parent=true, parent_indefinite=false) {
    switch (val) {
      case SIMPLE.FALSE:
        return false
      case SIMPLE.TRUE:
        return true
      case SIMPLE.NULL:
        if (has_parent) {
          return null
        } else {
          return SYMS.NULL
        }
      case SIMPLE.UNDEFINED:
        if (has_parent) {
          return void 0
        } else {
          return SYMS.UNDEFINED
        }
      case -1:
        if (!has_parent || !parent_indefinite) {
          throw new Error('Invalid BREAK')
        }
        return SYMS.BREAK
      default:
        return new Simple(val)
    }
  }
}

module.exports = Simple


/***/ }),

/***/ 14785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const bignumber = (__webpack_require__(70794).BigNumber)
const utils = __webpack_require__(99873)
const url = __webpack_require__(57310)

const MINUS_ONE = new bignumber(-1)
const TWO = new bignumber(2)

/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */
class Tagged {

  /**
   * Creates an instance of Tagged.
   *
   * @param {number} tag - the number of the tag
   * @param {any} value - the value inside the tag
   * @param {Error} [err] - the error that was thrown parsing the tag, or null
   */
  constructor(tag, value, err) {
    this.tag = tag
    this.value = value
    this.err = err
    if (typeof this.tag !== 'number') {
      throw new Error('Invalid tag type (' + (typeof this.tag) + ')')
    }
    if ((this.tag < 0) || ((this.tag | 0) !== this.tag)) {
      throw new Error('Tag must be a positive integer: ' + this.tag)
    }
  }

  /**
   * Convert to a String
   *
   * @returns {string} string of the form '1(2)'
   */
  toString() {
    return `${this.tag}(${JSON.stringify(this.value)})`
  }

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {Object} gen The generator to push onto
   */
  encodeCBOR(gen) {
    gen._pushTag(this.tag)
    return gen.pushAny(this.value)
  }

  /**
   * If we have a converter for this type, do the conversion.  Some converters
   * are built-in.  Additional ones can be passed in.  If you want to remove
   * a built-in converter, pass a converter in whose value is 'null' instead
   * of a function.
   *
   * @param {Object} converters - keys in the object are a tag number, the value
   *   is a function that takes the decoded CBOR and returns a JavaScript value
   *   of the appropriate type.  Throw an exception in the function on errors.
   * @returns {any} - the converted item
   */
  convert(converters) {
    let f = converters != null ? converters[this.tag] : void 0
    if (typeof f !== 'function') {
      f = Tagged['_tag_' + this.tag]
      if (typeof f !== 'function') {
        return this
      }
    }
    try {
      return f.call(Tagged, this.value)
    } catch (error) {
      this.err = error
      return this
    }
  }

  static _tag_0(v) {
    return new Date(v)
  }

  static _tag_1(v) {
    return new Date(v * 1000)
  }

  static _tag_2(v) {
    return utils.bufferToBignumber(v)
  }

  static _tag_3(v) {
    return MINUS_ONE.minus(utils.bufferToBignumber(v))
  }

  static _tag_4(v) {
    return bignumber(v[1]).shiftedBy(v[0])
  }

  static _tag_5(v) {
    return TWO.pow(v[0]).times(v[1])
  }

  static _tag_32(v) {
    return url.parse(v)
  }

  static _tag_35(v) {
    return new RegExp(v)
  }
}

module.exports = Tagged


/***/ }),

/***/ 99873:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(73837)
const bignumber = (__webpack_require__(70794).BigNumber)

const constants = __webpack_require__(19066)
const NUMBYTES = constants.NUMBYTES
const SHIFT32 = constants.SHIFT32
const MAX_SAFE_HIGH = 0x1fffff

exports.hasBigInt = (typeof BigInt === 'function')

/**
 * Convert a UTF8-encoded Buffer to a JS string.  If possible, throw an error
 * on invalid UTF8.  Byte Order Marks are not looked at or stripped.
 */
const TD = (typeof TextDecoder === 'function') ? TextDecoder : util.TextDecoder
/* istanbul ignore else */
if (TD) {
  // node 11+, browsers : node 8.3+
  const td = new TD('utf8', {fatal: true, ignoreBOM: true})
  exports.utf8 = (buf) => td.decode(buf)
  exports.utf8.checksUTF8 = true
} else {
  // TODO: polyfill a slow one or wait for node6 to die
  exports.utf8 = (buf) => buf.toString('utf8') 
  exports.utf8.checksUTF8 = false  
}

exports.parseCBORint = function(ai, buf) {
  switch (ai) {
    case NUMBYTES.ONE:
      return buf.readUInt8(0)
    case NUMBYTES.TWO:
      return buf.readUInt16BE(0)
    case NUMBYTES.FOUR:
      return buf.readUInt32BE(0)
    case NUMBYTES.EIGHT:
      const f = buf.readUInt32BE(0)
      const g = buf.readUInt32BE(4)
      if (f > MAX_SAFE_HIGH) {
        return new bignumber(f).times(SHIFT32).plus(g)
      } else {
        return (f * SHIFT32) + g
      }
    default:
      throw new Error('Invalid additional info for int: ' + ai)
  }
}

exports.writeHalf = function writeHalf(buf, half) {
  // assume 0, -0, NaN, Infinity, and -Infinity have already been caught

  // HACK: everyone settle in.  This isn't going to be pretty.
  // Translate cn-cbor's C code (from Carsten Borman):

  // uint32_t be32;
  // uint16_t be16, u16;
  // union {
  //   float f;
  //   uint32_t u;
  // } u32;
  // u32.f = float_val;

  const u32 = Buffer.allocUnsafe(4)
  u32.writeFloatBE(half, 0)
  const u = u32.readUInt32BE(0)

  // if ((u32.u & 0x1FFF) == 0) { /* worth trying half */

  // hildjj: If the lower 13 bits aren't 0,
  // we will lose precision in the conversion.
  // mant32 = 24bits, mant16 = 11bits, 24-11 = 13
  if ((u & 0x1FFF) !== 0) {
    return false
  }

  //   int s16 = (u32.u >> 16) & 0x8000;
  //   int exp = (u32.u >> 23) & 0xff;
  //   int mant = u32.u & 0x7fffff;

  let s16 = (u >> 16) & 0x8000 // top bit is sign
  const exp = (u >> 23) & 0xff // then 5 bits of exponent
  const mant = u & 0x7fffff

  //   if (exp == 0 && mant == 0)
  //     ;              /* 0.0, -0.0 */

  // hildjj: zeros already handled.  Assert if you don't believe me.

  //   else if (exp >= 113 && exp <= 142) /* normalized */
  //     s16 += ((exp - 112) << 10) + (mant >> 13);

  if ((exp >= 113) && (exp <= 142)) {
    s16 += ((exp - 112) << 10) + (mant >> 13)
  } else if ((exp >= 103) && (exp < 113)) {
    //   else if (exp >= 103 && exp < 113) { /* denorm, exp16 = 0 */
    //     if (mant & ((1 << (126 - exp)) - 1))
    //       goto float32;         /* loss of precision */
    //     s16 += ((mant + 0x800000) >> (126 - exp));

    if (mant & ((1 << (126 - exp)) - 1)) {
      return false
    }
    s16 += ((mant + 0x800000) >> (126 - exp))
  } else {
  //   } else if (exp == 255 && mant == 0) { /* Inf */
  //     s16 += 0x7c00;

    // hildjj: Infinity already handled

    //   } else
    //     goto float32;           /* loss of range */

    return false
  }

  //   ensure_writable(3);
  //   u16 = s16;
  //   be16 = hton16p((const uint8_t*)&u16);
  buf.writeUInt16BE(s16)
  return true
}

exports.parseHalf = function parseHalf(buf) {
  const sign = buf[0] & 0x80 ? -1 : 1
  const exp = (buf[0] & 0x7C) >> 2
  const mant = ((buf[0] & 0x03) << 8) | buf[1]
  if (!exp) {
    return sign * 5.9604644775390625e-8 * mant
  } else if (exp === 0x1f) {
    return sign * (mant ? 0 / 0 : 2e308)
  } else {
    return sign * Math.pow(2, exp - 25) * (1024 + mant)
  }
}

exports.parseCBORfloat = function parseCBORfloat(buf) {
  switch (buf.length) {
    case 2:
      return exports.parseHalf(buf)
    case 4:
      return buf.readFloatBE(0)
    case 8:
      return buf.readDoubleBE(0)
    default:
      throw new Error('Invalid float size: ' + buf.length)
  }
}

exports.hex = function hex(s) {
  return Buffer.from(s.replace(/^0x/, ''), 'hex')
}

exports.bin = function bin(s) {
  s = s.replace(/\s/g, '')
  let start = 0
  let end = (s.length % 8) || 8
  const chunks = []
  while (end <= s.length) {
    chunks.push(parseInt(s.slice(start, end), 2))
    start = end
    end += 8
  }
  return Buffer.from(chunks)
}

exports.extend = function extend(old={}, ...adds) {
  const len = adds.length
  for (let j = 0; j < len; j++) {
    const a = adds[j]
    for (const k in a) {
      const v = a[k]
      old[k] = v
    }
  }
  return old
}

exports.arrayEqual = function arrayEqual(a, b) {
  if ((a == null) && (b == null)) {
    return true
  }
  if ((a == null) || (b == null)) {
    return false
  }
  return (a.length === b.length) && a.every((elem, i) => elem === b[i])
}

exports.bufferEqual = function bufferEqual(a, b) {
  if ((a == null) && (b == null)) {
    return true
  }
  if ((a == null) || (b == null)) {
    return false
  }
  if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && (a.length === b.length))) {
    return false
  }
  const len = a.length
  let ret = true
  let i
  let j
  for (i = j = 0; j < len; i = ++j) {
    const byte = a[i]
    ret = ret && (b[i] === byte)
  }
  return !!ret
}

exports.bufferToBignumber = function bufferToBignumber(buf) {
  return new bignumber(buf.toString('hex'), 16)
}

exports.toBigInt = function toBigInt(num) {
  if (!exports.hasBigInt) {
    return Number(num) // lossy.  Better than nothing?
  }
  return BigInt(num)
}

exports.bigIntize = function bigIntize(obj) {
  const ret = {}
  for (const k in obj) { // stupid node 6
    ret[k] = exports.toBigInt(obj[k])
  }
  return ret
}

exports.bufferToBigInt = function bufferToBigInt(buf) {
  return exports.toBigInt('0x' + buf.toString('hex'))
}

exports.guessEncoding = function guessEncoding(input) {
  if (typeof input == 'string') {
    return 'hex'
  } else if (Buffer.isBuffer(input)) {
    return undefined
  }
  throw new Error('Unknown input type')
}



/***/ }),

/***/ 10071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Tweaked version of nathan7's binary-parse-stream
// (see https://github.com/nathan7/binary-parse-stream)
// Uses NoFilter instead of the readable in the original.  Removes
// the ability to read -1, which was odd and un-needed.
// License for binary-parse-stream: MIT

// binary-parse-stream is now unmaintained, so I'm going to rewrite it as
// more modern JS so I can get tsc to help check types.


const Stream = __webpack_require__(12781)
const NoFilter = __webpack_require__(29911)
const TransformStream = Stream.Transform

/**
 * BinaryParseStream is a TransformStream that consumes buffers and outputs
 * objects on the other end.  It expects your subclass to implement a `_parse`
 * method that is a generator.  When your generator yields a number, it'll be
 * fed a buffer of that length from the input.  When your generator returns,
 * the return value will be pushed to the output side.
 *
 * @class BinaryParseStream
 * @extends {TransformStream}
 */
class BinaryParseStream extends TransformStream {
  constructor(options) {
    super(options)
    // doesn't work to pass these in as opts, for some reason
    this['_writableState'].objectMode = false
    this['_readableState'].objectMode = true

    this.bs = new NoFilter()
    this.__restart()
  }

  _transform(fresh, encoding, cb) {
    this.bs.write(fresh)

    while (this.bs.length >= this.__needed) {
      let ret
      const chunk = (this.__needed === null) ?
        undefined : this.bs.read(this.__needed)

      try {
        ret = this.__parser.next(chunk)
      } catch (e) {
        return cb(e)
      }
  
      if (this.__needed) {
        this.__fresh = false
      }

      if (!ret.done) {
        this.__needed = ret.value || 0
      } else {
        this.push(ret.value)
        this.__restart()
      }
    }
  
    return cb()
  }

  /**
   * @abstract
   */
  /* istanbul ignore next */
  *_parse() {
    throw new Error('Must be implemented in subclass')
  }

  __restart() {
    this.__needed = null
    this.__parser = this._parse()
    this.__fresh = true
  }

  _flush(cb) {
    cb(this.__fresh ? null : new Error('unexpected end of input'))
  }
}

module.exports = BinaryParseStream


/***/ }),

/***/ 77159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.no = exports.noCase = __webpack_require__(74431)
exports.dot = exports.dotCase = __webpack_require__(87315)
exports.swap = exports.swapCase = __webpack_require__(17372)
exports.path = exports.pathCase = __webpack_require__(78900)
exports.upper = exports.upperCase = __webpack_require__(66133)
exports.lower = exports.lowerCase = __webpack_require__(75496)
exports.camel = exports.camelCase = __webpack_require__(46486)
exports.snake = exports.snakeCase = __webpack_require__(96754)
exports.title = exports.titleCase = __webpack_require__(30333)
exports.param = exports.paramCase = __webpack_require__(38371)
exports.header = exports.headerCase = __webpack_require__(26789)
exports.pascal = exports.pascalCase = __webpack_require__(26782)
exports.constant = exports.constantCase = __webpack_require__(55358)
exports.sentence = exports.sentenceCase = __webpack_require__(17791)
exports.isUpper = exports.isUpperCase = __webpack_require__(45237)
exports.isLower = exports.isLowerCase = __webpack_require__(16633)
exports.ucFirst = exports.upperCaseFirst = __webpack_require__(56868)
exports.lcFirst = exports.lowerCaseFirst = __webpack_require__(99475)


/***/ }),

/***/ 55358:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var upperCase = __webpack_require__(66133)
var snakeCase = __webpack_require__(96754)

/**
 * Constant case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return upperCase(snakeCase(value, locale), locale)
}


/***/ }),

/***/ 87315:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)

/**
 * Dot case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '.')
}


/***/ }),

/***/ 26789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)
var upperCase = __webpack_require__(66133)

/**
 * Header case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-').replace(/^.|-./g, function (m) {
    return upperCase(m, locale)
  })
}


/***/ }),

/***/ 16633:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var lowerCase = __webpack_require__(75496)

/**
 * Check if a string is lower case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return lowerCase(string, locale) === string
}


/***/ }),

/***/ 45237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var upperCase = __webpack_require__(66133)

/**
 * Check if a string is upper case.
 *
 * @param  {String}  string
 * @param  {String}  [locale]
 * @return {Boolean}
 */
module.exports = function (string, locale) {
  return upperCase(string, locale) === string
}


/***/ }),

/***/ 67762:
/***/ ((module) => {

/**
 * The base implementation of `_.sum` and `_.sumBy` without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {number} Returns the sum.
 */
function baseSum(array, iteratee) {
  var result,
      index = -1,
      length = array.length;

  while (++index < length) {
    var current = iteratee(array[index]);
    if (current !== undefined) {
      result = result === undefined ? current : (result + current);
    }
  }
  return result;
}

module.exports = baseSum;


/***/ }),

/***/ 3522:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var toString = __webpack_require__(79833);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(reRegExpChar, '\\$&')
    : string;
}

module.exports = escapeRegExp;


/***/ }),

/***/ 51584:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(44239),
    isObjectLike = __webpack_require__(37005);

/** `Object#toString` result references. */
var boolTag = '[object Boolean]';

/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */
function isBoolean(value) {
  return value === true || value === false ||
    (isObjectLike(value) && baseGetTag(value) == boolTag);
}

module.exports = isBoolean;


/***/ }),

/***/ 81763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(44239),
    isObjectLike = __webpack_require__(37005);

/** `Object#toString` result references. */
var numberTag = '[object Number]';

/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
 * classified as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a number, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */
function isNumber(value) {
  return typeof value == 'number' ||
    (isObjectLike(value) && baseGetTag(value) == numberTag);
}

module.exports = isNumber;


/***/ }),

/***/ 47037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(44239),
    isArray = __webpack_require__(1469),
    isObjectLike = __webpack_require__(37005);

/** `Object#toString` result references. */
var stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
}

module.exports = isString;


/***/ }),

/***/ 12297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseSum = __webpack_require__(67762),
    identity = __webpack_require__(6557);

/**
 * Computes the sum of the values in `array`.
 *
 * @static
 * @memberOf _
 * @since 3.4.0
 * @category Math
 * @param {Array} array The array to iterate over.
 * @returns {number} Returns the sum.
 * @example
 *
 * _.sum([4, 2, 8, 6]);
 * // => 20
 */
function sum(array) {
  return (array && array.length)
    ? baseSum(array, identity)
    : 0;
}

module.exports = sum;


/***/ }),

/***/ 99475:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var lowerCase = __webpack_require__(75496)

/**
 * Lower case the first character of a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  if (str == null) {
    return ''
  }

  str = String(str)

  return lowerCase(str.charAt(0), locale) + str.substr(1)
}


/***/ }),

/***/ 75496:
/***/ ((module) => {

/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  az: {
    regexp: /[\u0130]/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  lt: {
    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
    map: {
      '\u0049': '\u0069\u0307',
      '\u004A': '\u006A\u0307',
      '\u012E': '\u012F\u0307',
      '\u00CC': '\u0069\u0307\u0300',
      '\u00CD': '\u0069\u0307\u0301',
      '\u0128': '\u0069\u0307\u0303'
    }
  }
}

/**
 * Lowercase a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  var lang = LANGUAGES[locale]

  str = str == null ? '' : String(str)

  if (lang) {
    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
  }

  return str.toLowerCase()
}


/***/ }),

/***/ 74431:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var lowerCase = __webpack_require__(75496)

var NON_WORD_REGEXP = __webpack_require__(14148)
var CAMEL_CASE_REGEXP = __webpack_require__(33335)
var CAMEL_CASE_UPPER_REGEXP = __webpack_require__(43820)

/**
 * Sentence case a string.
 *
 * @param  {string} str
 * @param  {string} locale
 * @param  {string} replacement
 * @return {string}
 */
module.exports = function (str, locale, replacement) {
  if (str == null) {
    return ''
  }

  replacement = typeof replacement !== 'string' ? ' ' : replacement

  function replace (match, index, value) {
    if (index === 0 || index === (value.length - match.length)) {
      return ''
    }

    return replacement
  }

  str = String(str)
    // Support camel case ("camelCase" -> "camel Case").
    .replace(CAMEL_CASE_REGEXP, '$1 $2')
    // Support odd camel case ("CAMELCase" -> "CAMEL Case").
    .replace(CAMEL_CASE_UPPER_REGEXP, '$1 $2')
    // Remove all non-word characters and replace with a single space.
    .replace(NON_WORD_REGEXP, replace)

  // Lower case the entire string.
  return lowerCase(str, locale)
}


/***/ }),

/***/ 33335:
/***/ ((module) => {

module.exports = /([a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])/g


/***/ }),

/***/ 43820:
/***/ ((module) => {

module.exports = /([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A])([A-Z\xC0-\xD6\xD8-\xDE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u037F\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0528\u052A\u052C\u052E\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u13A0-\u13F5\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA698\uA69A\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA796\uA798\uA79A\uA79C\uA79E\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA-\uA7AD\uA7B0-\uA7B4\uA7B6\uFF21-\uFF3A][a-z\xB5\xDF-\xF6\xF8-\xFF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0529\u052B\u052D\u052F\u0561-\u0587\u13F8-\u13FD\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA699\uA69B\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793-\uA795\uA797\uA799\uA79B\uA79D\uA79F\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7B5\uA7B7\uA7FA\uAB30-\uAB5A\uAB60-\uAB65\uAB70-\uABBF\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])/g


/***/ }),

/***/ 14148:
/***/ ((module) => {

module.exports = /[^A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC0-9\xB2\xB3\xB9\xBC-\xBE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0DE6-\u0DEF\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uA9F0-\uA9F9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g


/***/ }),

/***/ 29911:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const stream = __webpack_require__(12781)
const util = __webpack_require__(73837)

/**
 * NoFilter stream.  Can be used to sink or source data to and from
 * other node streams.  Implemented as the "identity" Transform stream
 * (hence the name), but allows for inspecting data that is in-flight.
 *
 * Allows passing in source data (input, inputEncoding) at creation
 * time.  Source data can also be passed in the options object.
 *
 * @example <caption>source</caption>
 * const n = new NoFilter('Zm9v', 'base64');
 * n.pipe(process.stdout);
 *
 * @example <caption>sink</caption>
 * const n = new Nofilter();
 * // NOTE: 'finish' fires when the input is done writing
 * n.on('finish', function() { console.log(n.toString('base64')); });
 * process.stdin.pipe(n);
 */
class NoFilter extends stream.Transform {
  /**
   * Create an instance of NoFilter.
   *
   * @param {string|Buffer} [input] - Source data
   * @param {string} [inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {Object} [options={}] - Other options
   * @param {string|Buffer} [options.input=null] - Input source data
   * @param {string} [options.inputEncoding=null] - Encoding name for input,
   *   ignored if input is not a String
   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes
   *   to store in the internal buffer before ceasing to read from the
   *   underlying resource. Default=16kb, or 16 for objectMode streams
   * @param {string} [options.encoding=null] - If specified, then buffers will
   *   be decoded to strings using the specified encoding
   * @param {boolean} [options.objectMode=false] - Whether this stream should
   *   behave as a stream of objects. Meaning that stream.read(n) returns a
   *   single value instead of a Buffer of size n
   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode
   *   strings into Buffers before passing them to _write()
   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'
   *   events, setting this stream's objectMode based on the objectMode of the
   *   input stream
   * @param {boolean} [options.readError=false] - If true, when a read()
   *   underflows, throw an error.
   */
  constructor(input, inputEncoding, options) {
    if (options == null) {
      options = {}
    }
    let inp
    let inpE
    switch (typeof(input)) {
      case 'object':
        if (Buffer.isBuffer(input)) {
          inp = input
          if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
            options = inputEncoding
          }
        } else {
          options = input
        }
        break
      case 'string':
        inp = input
        if ((inputEncoding != null) && (typeof(inputEncoding) === 'object')) {
          options = inputEncoding
        } else {
          inpE = inputEncoding
        }
        break
    }

    if ((options == null)) {
      options = {}
    }
    if (inp == null) {
      inp = options.input
    }
    if (inpE == null) {
      inpE = options.inputEncoding
    }
    delete options.input
    delete options.inputEncoding
    const watchPipe = options.watchPipe != null ? options.watchPipe : true
    delete options.watchPipe
    const readError = !! options.readError
    delete options.readError
    super(options)

    this.readError = readError

    if (watchPipe) {
      this.on('pipe', readable => {
        const om = readable._readableState.objectMode
        if ((this.length > 0) && (om !== this._readableState.objectMode)) {
          throw new Error(
            'Do not switch objectMode in the middle of the stream')
        }

        this._readableState.objectMode = om
        return this._writableState.objectMode = om
      })
    }

    if (inp != null) {
      this.end(inp, inpE)
    }
  }

  /**
   * Is the given object a {NoFilter}?
   *
   * @param {Object} obj The object to test.
   * @returns {boolean} true if obj is a NoFilter
   */
  static isNoFilter(obj) {
    return obj instanceof this
  }

  /**
   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.
   *
   * @param {NoFilter} nf1 - The first object to compare
   * @param {NoFilter} nf2 - The second object to compare
   * @returns {number} -1, 0, 1 for less, equal, greater
   *
   * @example
   * const arr = [new NoFilter('1234'), new NoFilter('0123')];
   * arr.sort(NoFilter.compare);
   */
  static compare(nf1, nf2) {
    if (!(nf1 instanceof this)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (nf1 === nf2) {
      return 0
    } else {
      return nf1.compare(nf2)
    }
  }

  /**
   * Returns a buffer which is the result of concatenating all the
   * NoFilters in the list together. If the list has no items, or if
   * the totalLength is 0, then it returns a zero-length buffer.
   *
   * If length is not provided, it is read from the buffers in the
   * list. However, this adds an additional loop to the function, so
   * it is faster to provide the length explicitly if you already know it.
   *
   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object
   *   mode, or all not in object mode.
   * @param {number} [length=null] Number of bytes or objects to read
   * @returns {Buffer|Array} The concatenated values as an array if in object
   *   mode, otherwise a Buffer
   */
  static concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('list argument must be an Array of NoFilters')
    }
    if ((list.length === 0) || (length === 0)) {
      return Buffer.alloc(0)
    }
    if ((length == null)) {
      length = list.reduce((tot, nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError('list argument must be an Array of NoFilters')
        }
        return tot + nf.length
      }, 0)
    }
    let allBufs = true
    let allObjs = true
    const bufs = list.map(nf => {
      if (!(nf instanceof NoFilter)) {
        throw new TypeError('list argument must be an Array of NoFilters')
      }
      const buf = nf.slice()
      if (Buffer.isBuffer(buf)) {
        allObjs = false
      } else {
        allBufs = false
      }
      return buf
    })
    if (allBufs) {
      return Buffer.concat(bufs, length)
    }
    if (allObjs) {
      return [].concat(...bufs).slice(0, length)
    }
    // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays
    // counting objects?  I can't imagine why that would be useful.
    throw new Error('Concatenating mixed object and byte streams not supported')
  }

  /**
   * @private
   */
  _transform(chunk, encoding, callback) {
    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
      chunk = Buffer.from(chunk, encoding)
    }
    this.push(chunk)
    callback()
  }

  /**
   * @private
   */
  _bufArray() {
    let bufs = this._readableState.buffer
    // HACK: replace with something else one day.  This is what I get for
    // relying on internals.
    if (!Array.isArray(bufs)) {
      let b = bufs.head
      bufs = []
      while (b != null) {
        bufs.push(b.data)
        b = b.next
      }
    }
    return bufs
  }

  /**
   * Pulls some data out of the internal buffer and returns it.
   * If there is no data available, then it will return null.
   *
   * If you pass in a size argument, then it will return that many bytes. If
   * size bytes are not available, then it will return null, unless we've
   * ended, in which case it will return the data remaining in the buffer.
   *
   * If you do not specify a size argument, then it will return all the data in
   * the internal buffer.
   *
   * @param {number} [size=null] - Number of bytes to read.
   * @returns {string|Buffer|null} If no data or not enough data, null.  If
   *   decoding output a string, otherwise a Buffer
   * @throws Error - if readError is true and there was underflow
   * @fires NoFilter#read
   */
  read(size) {
    const buf = super.read(size)
    if (buf != null) {
      /*
       * Read event. Fired whenever anything is read from the stream.
       *
       * @event NoFilter#read
       * @type {Buffer|string|Object}
       *
       */
      this.emit('read', buf)
      if (this.readError && (buf.length < size)) {
        throw new Error(`Read ${buf.length}, wanted ${size}`)
      }
    } else if (this.readError) {
      throw new Error(`No data available, wanted ${size}`)
    }
    return buf
  }

  /**
   * Return a promise fulfilled with the full contents, after the 'finish'
   * event fires.  Errors on the stream cause the promise to be rejected.
   *
   * @param {function} [cb=null] - finished/error callback used in *addition*
   *   to the promise
   * @returns {Promise<Buffer|String>} fulfilled when complete
   */
  promise(cb) {
    let done = false
    return new Promise((resolve, reject) => {
      this.on('finish', () => {
        const data = this.read()
        if ((cb != null) && !done) {
          done = true
          cb(null, data)
        }
        resolve(data)
      })
      this.on('error', (er) => {
        if ((cb != null) && !done) {
          done = true
          cb(er)
        }
        reject(er)
      })
    })
  }

  /**
   * Returns a number indicating whether this comes before or after or is the
   * same as the other NoFilter in sort order.
   *
   * @param {NoFilter} other - The other object to compare
   * @returns {Number} -1, 0, 1 for less, equal, greater
   */
  compare(other) {
    if (!(other instanceof NoFilter)) {
      throw new TypeError('Arguments must be NoFilters')
    }
    if (this === other) {
      return 0
    } else {
      const buf1 = this.slice()
      const buf2 = other.slice()
      // these will both be buffers because of the check above.
      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
        return buf1.compare(buf2)
      }
      throw new Error('Cannot compare streams in object mode')
    }
  }

  /**
   * Do these NoFilter's contain the same bytes?  Doesn't work if either is
   * in object mode.
   *
   * @param {NoFilter} other
   * @returns {boolean} Equal?
   */
  equals(other) {
    return this.compare(other) === 0
  }

  /**
   * Read bytes or objects without consuming them.  Useful for diagnostics.
   * Note: as a side-effect, concatenates multiple writes together into what
   * looks like a single write, so that this concat doesn't have to happen
   * multiple times when you're futzing with the same NoFilter.
   *
   * @param {Number} [start=0] - beginning offset
   * @param {Number} [end=length] - ending offset
   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,
   *   concatenated array of contents.
   */
  slice(start, end) {
    if (this._readableState.objectMode) {
      return this._bufArray().slice(start, end)
    }
    const bufs = this._bufArray()
    switch (bufs.length) {
      case 0: return Buffer.alloc(0)
      case 1: return bufs[0].slice(start, end)
      default:
        const b = Buffer.concat(bufs)
        // TODO: store the concatented bufs back
        // @_readableState.buffer = [b]
        return b.slice(start, end)
    }
  }

  /**
    * Get a byte by offset.  I didn't want to get into metaprogramming
    * to give you the `NoFilter[0]` syntax.
    *
    * @param {Number} index - The byte to retrieve
    * @returns {Number} 0-255
    */
  get(index) {
    return this.slice()[index]
  }

  /**
   * Return an object compatible with Buffer's toJSON implementation, so
   * that round-tripping will produce a Buffer.
   *
   * @returns {Object}
   *
   * @example output for 'foo'
   *   { type: 'Buffer', data: [ 102, 111, 111 ] }
   */
  toJSON() {
    const b = this.slice()
    if (Buffer.isBuffer(b)) {
      return b.toJSON()
    } else {
      return b
    }
  }

  /**
   * Decodes and returns a string from buffer data encoded using the specified
   * character set encoding. If encoding is undefined or null, then encoding
   * defaults to 'utf8'. The start and end parameters default to 0 and
   * NoFilter.length when undefined.
   *
   * @param {String} [encoding='utf8'] - Which to use for decoding?
   * @param {Number} [start=0] - Start offset
   * @param {Number} [end=length] - End offset
   * @returns {String}
   */
  toString(encoding, start, end) {
    const buf = this.slice(start, end)
    if (!Buffer.isBuffer(buf)) {
      return JSON.stringify(buf)
    }
    if ((!encoding || (encoding === 'utf8')) && util.TextDecoder) {
      const td = new util.TextDecoder('utf8', {
        fatal: true,
        ignoreBOM: true
      })
      return td.decode(buf)
    }
    return buf.toString(encoding, start, end)
  }

  /**
   * @private
   * @deprecated
   */
  inspect(depth, options) {
    return this[util.inspect.custom](depth, options)
  }

  /**
   * @private
   */
  [util.inspect.custom](depth, options) {
    const bufs = this._bufArray()
    const hex = bufs.map((b) => {
      if (Buffer.isBuffer(b)) {
        if ((options != null ? options.stylize : undefined)) {
          return options.stylize(b.toString('hex'), 'string')
        } else {
          return b.toString('hex')
        }
      } else {
        return util.inspect(b, options)
      }
    }).join(', ')
    return `${this.constructor.name} [${hex}]`
  }

  /**
   * Current readable length, in bytes.
   *
   * @member {number}
   * @readonly
   */
  get length() {
    return this._readableState.length
  }

  /**
   * Write a JavaScript BigInt to the stream.  Negative numbers will be
   * written as their 2's complement version.
   *
   * @param {bigint} val - The value to write
   * @returns {boolean} true on success
   */
  writeBigInt(val) {
    let str = val.toString(16)
    if (val < 0) {
      // two's complement
      // Note: str always starts with '-' here.
      const sz = BigInt(Math.floor(str.length / 2))
      const mask = BigInt(1) << (sz * BigInt(8))
      val = mask + val
      str = val.toString(16)
    }
    if (str.length % 2) {
      str = '0' + str
    }
    return this.push(Buffer.from(str, 'hex'))
  }

  /**
   * Read a variable-sized JavaScript unsigned BigInt from the stream.
   *
   * @param {number}  [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readUBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return BigInt('0x' + b.toString('hex'))
  }

  /**
   * Read a variable-sized JavaScript signed BigInt from the stream in 2's
   * complement format.
   *
   * @param {number} [len=null] - number of bytes to read or all remaining
   *   if null
   * @returns {bigint}
   */
  readBigInt(len) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    let ret = BigInt('0x' + b.toString('hex'))
    // negative?
    if (b[0] & 0x80) {
      // two's complement
      const mask = BigInt(1) << (BigInt(b.length) * BigInt(8))
      ret = ret - mask
    }
    return ret
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _read_gen(meth, len) {
  return function(val) {
    const b = this.read(len)
    if (!Buffer.isBuffer(b)) {
      return null
    }
    return b[meth].call(b, 0, true)
  }
}

/**
 * @param {string} meth - method to call
 * @param {number} len - number of bytes to write
 * @private
 */
function _write_gen(meth, len) {
  return function(val) {
    const b = Buffer.alloc(len)
    b[meth].call(b, val, 0, true)
    return this.push(b)
  }
}

Object.assign(NoFilter.prototype, {
  /**
   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.
   *
   * @function writeUInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value - 0-255
   * @returns {boolean} true on success
   */
  writeUInt8: _write_gen('writeUInt8', 1),

  /**
   * Write a little-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16LE: _write_gen('writeUInt16LE', 2),

  /**
   * Write a big-endian 16-bit unsigned integer to the stream.  Adds
   * 2 bytes.
   *
   * @function writeUInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt16BE: _write_gen('writeUInt16BE', 2),

  /**
   * Write a little-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32LE: _write_gen('writeUInt32LE', 4),

  /**
   * Write a big-endian 32-bit unsigned integer to the stream.  Adds
   * 4 bytes.
   *
   * @function writeUInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeUInt32BE: _write_gen('writeUInt32BE', 4),

  /**
   * Write a signed 8-bit integer to the stream.  Adds 1 byte.
   *
   * @function writeInt8
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt8: _write_gen('writeInt8', 1),

  /**
   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16LE: _write_gen('writeInt16LE', 2),

  /**
   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.
   *
   * @function writeInt16BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt16BE: _write_gen('writeInt16BE', 2),

  /**
   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32LE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32LE: _write_gen('writeInt32LE', 4),

  /**
   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.
   *
   * @function writeInt32BE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeInt32BE: _write_gen('writeInt32BE', 4),

  /**
   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatLE: _write_gen('writeFloatLE', 4),

  /**
   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.
   *
   * @function writeFloatBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeFloatBE: _write_gen('writeFloatBE', 4),

  /**
   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleLE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleLE: _write_gen('writeDoubleLE', 8),

  /**
   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.
   *
   * @function writeDoubleBE
   * @memberOf NoFilter
   * @instance
   * @param {Number} value
   * @returns {boolean} true on success
   */
  writeDoubleBE: _write_gen('writeDoubleBE', 8),

  /**
   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.
   *
   * @function readUInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt8: _read_gen('readUInt8', 1),

  /**
   * Read a little-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16LE: _read_gen('readUInt16LE', 2),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readUInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt16BE: _read_gen('readUInt16BE', 2),

  /**
   * Read a little-endian unsigned 32-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32LE: _read_gen('readUInt32LE', 4),

  /**
   * Read a big-endian unsigned 16-bit integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readUInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readUInt32BE: _read_gen('readUInt32BE', 4),

  /**
   * Read a signed 8-bit integer from the stream.
   * Consumes 1 byte.
   *
   * @function readInt8
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt8: _read_gen('readInt8', 1),

  /**
   * Read a signed 16-bit little-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16LE: _read_gen('readInt16LE', 2),

  /**
   * Read a signed 16-bit big-endian integer from the stream.
   * Consumes 2 bytes.
   *
   * @function readInt16BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt16BE: _read_gen('readInt16BE', 2),

  /**
   * Read a signed 32-bit little-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32LE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32LE: _read_gen('readInt32LE', 4),

  /**
   * Read a signed 32-bit big-endian integer from the stream.
   * Consumes 4 bytes.
   *
   * @function readInt32BE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readInt32BE: _read_gen('readInt32BE', 4),

  /**
   * Read a 32-bit little-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatLE: _read_gen('readFloatLE', 4),

  /**
   * Read a 32-bit big-endian float from the stream.
   * Consumes 4 bytes.
   *
   * @function readFloatBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readFloatBE: _read_gen('readFloatBE', 4),

  /**
   * Read a 64-bit little-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleLE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleLE: _read_gen('readDoubleLE', 8),

  /**
   * Read a 64-bit big-endian float from the stream.
   * Consumes 8 bytes.
   *
   * @function readDoubleBE
   * @memberOf NoFilter
   * @instance
   * @returns {Number} value
   */
  readDoubleBE: _read_gen('readDoubleBE', 8)
})

module.exports = NoFilter


/***/ }),

/***/ 38371:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)

/**
 * Param case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '-')
}


/***/ }),

/***/ 26782:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var camelCase = __webpack_require__(46486)
var upperCaseFirst = __webpack_require__(56868)

/**
 * Pascal case a string.
 *
 * @param  {string}  value
 * @param  {string}  [locale]
 * @param  {boolean} [mergeNumbers]
 * @return {string}
 */
module.exports = function (value, locale, mergeNumbers) {
  return upperCaseFirst(camelCase(value, locale, mergeNumbers), locale)
}


/***/ }),

/***/ 78900:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)

/**
 * Path case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '/')
}


/***/ }),

/***/ 17791:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)
var upperCaseFirst = __webpack_require__(56868)

/**
 * Sentence case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return upperCaseFirst(noCase(value, locale), locale)
}


/***/ }),

/***/ 96754:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)

/**
 * Snake case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale, '_')
}


/***/ }),

/***/ 17372:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var upperCase = __webpack_require__(66133)
var lowerCase = __webpack_require__(75496)

/**
 * Swap the case of a string. Manually iterate over every character and check
 * instead of replacing certain characters for better unicode support.
 *
 * @param  {String} str
 * @param  {String} [locale]
 * @return {String}
 */
module.exports = function (str, locale) {
  if (str == null) {
    return ''
  }

  var result = ''

  for (var i = 0; i < str.length; i++) {
    var c = str[i]
    var u = upperCase(c, locale)

    result += u === c ? lowerCase(c, locale) : u
  }

  return result
}


/***/ }),

/***/ 30333:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var noCase = __webpack_require__(74431)
var upperCase = __webpack_require__(66133)

/**
 * Title case a string.
 *
 * @param  {string} value
 * @param  {string} [locale]
 * @return {string}
 */
module.exports = function (value, locale) {
  return noCase(value, locale).replace(/^.| ./g, function (m) {
    return upperCase(m, locale)
  })
}


/***/ }),

/***/ 56868:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var upperCase = __webpack_require__(66133)

/**
 * Upper case the first character of a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  if (str == null) {
    return ''
  }

  str = String(str)

  return upperCase(str.charAt(0), locale) + str.substr(1)
}


/***/ }),

/***/ 66133:
/***/ ((module) => {

/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /[\u0069]/g,
    map: {
      '\u0069': '\u0130'
    }
  },
  az: {
    regexp: /[\u0069]/g,
    map: {
      '\u0069': '\u0130'
    }
  },
  lt: {
    regexp: /[\u0069\u006A\u012F]\u0307|\u0069\u0307[\u0300\u0301\u0303]/g,
    map: {
      '\u0069\u0307': '\u0049',
      '\u006A\u0307': '\u004A',
      '\u012F\u0307': '\u012E',
      '\u0069\u0307\u0300': '\u00CC',
      '\u0069\u0307\u0301': '\u00CD',
      '\u0069\u0307\u0303': '\u0128'
    }
  }
}

/**
 * Upper case a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  var lang = LANGUAGES[locale]

  str = str == null ? '' : String(str)

  if (lang) {
    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
  }

  return str.toUpperCase()
}


/***/ }),

/***/ 2062:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.adapter = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const Stream_1 = __webpack_require__(99385);
const AdaptedValue = Symbol('adapted-value');
function toAdapterValue(rawValue, adapter) {
    const adapted = adapter(rawValue.value_);
    if (!adapted.adapted) {
        return rawValue;
    }
    return new Value_1.Value(adapted.value, AdaptedValue);
}
class AdapterArbitrary extends Arbitrary_1.Arbitrary {
    constructor(sourceArb, adapter) {
        super();
        this.sourceArb = sourceArb;
        this.adapter = adapter;
        this.adaptValue = (rawValue) => toAdapterValue(rawValue, adapter);
    }
    generate(mrng, biasFactor) {
        const rawValue = this.sourceArb.generate(mrng, biasFactor);
        return this.adaptValue(rawValue);
    }
    canShrinkWithoutContext(value) {
        return this.sourceArb.canShrinkWithoutContext(value) && !this.adapter(value).adapted;
    }
    shrink(value, context) {
        if (context === AdaptedValue) {
            if (!this.sourceArb.canShrinkWithoutContext(value)) {
                return Stream_1.Stream.nil();
            }
            return this.sourceArb.shrink(value, undefined).map(this.adaptValue);
        }
        return this.sourceArb.shrink(value, context).map(this.adaptValue);
    }
}
function adapter(sourceArb, adapter) {
    return new AdapterArbitrary(sourceArb, adapter);
}
exports.adapter = adapter;


/***/ }),

/***/ 28213:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlwaysShrinkableArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Stream_1 = __webpack_require__(99385);
const NoUndefinedAsContext_1 = __webpack_require__(21549);
class AlwaysShrinkableArbitrary extends Arbitrary_1.Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        const value = this.arb.generate(mrng, biasFactor);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    canShrinkWithoutContext(value) {
        return true;
    }
    shrink(value, context) {
        if (context === undefined && !this.arb.canShrinkWithoutContext(value)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? context : undefined;
        return this.arb.shrink(value, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
}
exports.AlwaysShrinkableArbitrary = AlwaysShrinkableArbitrary;


/***/ }),

/***/ 49844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrayArbitrary = void 0;
const Stream_1 = __webpack_require__(99385);
const symbols_1 = __webpack_require__(28620);
const integer_1 = __webpack_require__(97706);
const LazyIterableIterator_1 = __webpack_require__(32871);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const DepthContext_1 = __webpack_require__(10514);
const BuildSlicedGenerator_1 = __webpack_require__(85817);
function biasedMaxLength(minLength, maxLength) {
    if (minLength === maxLength) {
        return minLength;
    }
    return minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2));
}
class ArrayArbitrary extends Arbitrary_1.Arbitrary {
    constructor(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, customSlices) {
        super();
        this.arb = arb;
        this.minLength = minLength;
        this.maxGeneratedLength = maxGeneratedLength;
        this.maxLength = maxLength;
        this.setBuilder = setBuilder;
        this.customSlices = customSlices;
        this.lengthArb = (0, integer_1.integer)({ min: minLength, max: maxGeneratedLength });
        this.depthContext = (0, DepthContext_1.getDepthContextFor)(depthIdentifier);
    }
    preFilter(tab) {
        if (this.setBuilder === undefined) {
            return tab;
        }
        const s = this.setBuilder();
        for (let index = 0; index !== tab.length; ++index) {
            s.tryAdd(tab[index]);
        }
        return s.getData();
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
        let numSkippedInRow = 0;
        const s = setBuilder();
        const slicedGenerator = (0, BuildSlicedGenerator_1.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);
        while (s.size() < N && numSkippedInRow < this.maxGeneratedLength) {
            const current = slicedGenerator.next();
            if (s.tryAdd(current)) {
                numSkippedInRow = 0;
            }
            else {
                numSkippedInRow += 1;
            }
        }
        return s.getData();
    }
    safeGenerateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems) {
        const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
        this.depthContext.depth += depthImpact;
        try {
            return this.generateNItemsNoDuplicates(setBuilder, N, mrng, biasFactorItems);
        }
        finally {
            this.depthContext.depth -= depthImpact;
        }
    }
    generateNItems(N, mrng, biasFactorItems) {
        const items = [];
        const slicedGenerator = (0, BuildSlicedGenerator_1.buildSlicedGenerator)(this.arb, mrng, this.customSlices, biasFactorItems);
        slicedGenerator.attemptExact(N);
        for (let index = 0; index !== N; ++index) {
            const current = slicedGenerator.next();
            items.push(current);
        }
        return items;
    }
    safeGenerateNItems(N, mrng, biasFactorItems) {
        const depthImpact = Math.max(0, N - biasedMaxLength(this.minLength, this.maxGeneratedLength));
        this.depthContext.depth += depthImpact;
        try {
            return this.generateNItems(N, mrng, biasFactorItems);
        }
        finally {
            this.depthContext.depth -= depthImpact;
        }
    }
    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext, startIndex) {
        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
        let cloneable = false;
        const vs = [];
        const itemsContexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
            itemsContexts.push(s.context);
        }
        if (cloneable) {
            ArrayArbitrary.makeItCloneable(vs, items);
        }
        const context = {
            shrunkOnce,
            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined
                ? itemsRawLengthContext
                : undefined,
            itemsContexts,
            startIndex,
        };
        return new Value_1.Value(vs, context);
    }
    generate(mrng, biasFactor) {
        const biasMeta = this.applyBias(mrng, biasFactor);
        const targetSize = biasMeta.size;
        const items = this.setBuilder !== undefined
            ? this.safeGenerateNItemsNoDuplicates(this.setBuilder, targetSize, mrng, biasMeta.biasFactorItems)
            : this.safeGenerateNItems(targetSize, mrng, biasMeta.biasFactorItems);
        return this.wrapper(items, false, undefined, 0);
    }
    applyBias(mrng, biasFactor) {
        if (biasFactor === undefined) {
            return { size: this.lengthArb.generate(mrng, undefined).value };
        }
        if (this.minLength === this.maxGeneratedLength) {
            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
        }
        if (mrng.nextInt(1, biasFactor) !== 1) {
            return { size: this.lengthArb.generate(mrng, undefined).value };
        }
        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxGeneratedLength) {
            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
        }
        const maxBiasedLength = biasedMaxLength(this.minLength, this.maxGeneratedLength);
        const targetSizeValue = (0, integer_1.integer)({ min: this.minLength, max: maxBiasedLength }).generate(mrng, undefined);
        return { size: targetSizeValue.value, biasFactorItems: biasFactor };
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {
            return false;
        }
        for (let index = 0; index !== value.length; ++index) {
            if (!(index in value)) {
                return false;
            }
            if (!this.arb.canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        const filtered = this.preFilter(value.map((item) => new Value_1.Value(item, undefined)));
        return filtered.length === value.length;
    }
    shrinkItemByItem(value, safeContext, endIndex) {
        let shrinks = Stream_1.Stream.nil();
        for (let index = safeContext.startIndex; index < endIndex; ++index) {
            shrinks = shrinks.join((0, LazyIterableIterator_1.makeLazy)(() => this.arb.shrink(value[index], safeContext.itemsContexts[index]).map((v) => {
                const beforeCurrent = value
                    .slice(0, index)
                    .map((v, i) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[i]));
                const afterCurrent = value
                    .slice(index + 1)
                    .map((v, i) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[i + index + 1]));
                return [
                    beforeCurrent.concat(v).concat(afterCurrent),
                    undefined,
                    index,
                ];
            })));
        }
        return shrinks;
    }
    shrinkImpl(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        const safeContext = context !== undefined
            ? context
            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [], startIndex: 0 };
        return (this.lengthArb
            .shrink(value.length, safeContext.lengthContext)
            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)
            .map((lengthValue) => {
            const sliceStart = value.length - lengthValue.value;
            return [
                value
                    .slice(sliceStart)
                    .map((v, index) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext.itemsContexts[index + sliceStart])),
                lengthValue.context,
                0,
            ];
        })
            .join((0, LazyIterableIterator_1.makeLazy)(() => value.length > this.minLength
            ? this.shrinkItemByItem(value, safeContext, 1)
            : this.shrinkItemByItem(value, safeContext, value.length)))
            .join(value.length > this.minLength
            ? (0, LazyIterableIterator_1.makeLazy)(() => {
                const subContext = {
                    shrunkOnce: false,
                    lengthContext: undefined,
                    itemsContexts: safeContext.itemsContexts.slice(1),
                    startIndex: 0,
                };
                return this.shrinkImpl(value.slice(1), subContext)
                    .filter((v) => this.minLength <= v[0].length + 1)
                    .map((v) => {
                    return [
                        [new Value_1.Value((0, symbols_1.cloneIfNeeded)(value[0]), safeContext.itemsContexts[0])].concat(v[0]),
                        undefined,
                        0,
                    ];
                });
            })
            : Stream_1.Stream.nil()));
    }
    shrink(value, context) {
        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1], contextualValue[2]));
    }
}
exports.ArrayArbitrary = ArrayArbitrary;


/***/ }),

/***/ 90254:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayInt64 = void 0;
const Stream_1 = __webpack_require__(99385);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const ArrayInt64_1 = __webpack_require__(35394);
class ArrayInt64Arbitrary extends Arbitrary_1.Arbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
        this.biasedRanges = null;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        const uncheckedValue = mrng.nextArrayInt(range.min, range.max);
        if (uncheckedValue.data.length === 1) {
            uncheckedValue.data.unshift(0);
        }
        return new Value_1.Value(uncheckedValue, undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = this.retrieveBiasedRanges();
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        const unsafeValue = value;
        return (typeof value === 'object' &&
            value !== null &&
            (unsafeValue.sign === -1 || unsafeValue.sign === 1) &&
            Array.isArray(unsafeValue.data) &&
            unsafeValue.data.length === 2 &&
            (((0, ArrayInt64_1.isStrictlySmaller64)(this.min, unsafeValue) && (0, ArrayInt64_1.isStrictlySmaller64)(unsafeValue, this.max)) ||
                (0, ArrayInt64_1.isEqual64)(this.min, unsafeValue) ||
                (0, ArrayInt64_1.isEqual64)(this.max, unsafeValue)));
    }
    shrinkArrayInt64(value, target, tryTargetAsap) {
        const realGap = (0, ArrayInt64_1.substract64)(value, target);
        function* shrinkGen() {
            let previous = tryTargetAsap ? undefined : target;
            const gap = tryTargetAsap ? realGap : (0, ArrayInt64_1.halve64)(realGap);
            for (let toremove = gap; !(0, ArrayInt64_1.isZero64)(toremove); toremove = (0, ArrayInt64_1.halve64)(toremove)) {
                const next = (0, ArrayInt64_1.substract64)(value, toremove);
                yield new Value_1.Value(next, previous);
                previous = next;
            }
        }
        return (0, Stream_1.stream)(shrinkGen());
    }
    shrink(current, context) {
        if (!ArrayInt64Arbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return this.shrinkArrayInt64(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new Value_1.Value(context, undefined));
        }
        return this.shrinkArrayInt64(current, context, false);
    }
    defaultTarget() {
        if (!(0, ArrayInt64_1.isStrictlyPositive64)(this.min) && !(0, ArrayInt64_1.isStrictlyNegative64)(this.max)) {
            return ArrayInt64_1.Zero64;
        }
        return (0, ArrayInt64_1.isStrictlyNegative64)(this.min) ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if ((0, ArrayInt64_1.isZero64)(current)) {
            return false;
        }
        if (current.sign === 1) {
            return (0, ArrayInt64_1.isEqual64)(current, (0, ArrayInt64_1.add64)(context, ArrayInt64_1.Unit64)) && (0, ArrayInt64_1.isStrictlyPositive64)((0, ArrayInt64_1.substract64)(current, this.min));
        }
        else {
            return (0, ArrayInt64_1.isEqual64)(current, (0, ArrayInt64_1.substract64)(context, ArrayInt64_1.Unit64)) && (0, ArrayInt64_1.isStrictlyNegative64)((0, ArrayInt64_1.substract64)(current, this.max));
        }
    }
    static isValidContext(_current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'object' || context === null || !('sign' in context) || !('data' in context)) {
            throw new Error(`Invalid context type passed to ArrayInt64Arbitrary (#1)`);
        }
        return true;
    }
    retrieveBiasedRanges() {
        if (this.biasedRanges != null) {
            return this.biasedRanges;
        }
        if ((0, ArrayInt64_1.isEqual64)(this.min, this.max)) {
            this.biasedRanges = [{ min: this.min, max: this.max }];
            return this.biasedRanges;
        }
        const minStrictlySmallerZero = (0, ArrayInt64_1.isStrictlyNegative64)(this.min);
        const maxStrictlyGreaterZero = (0, ArrayInt64_1.isStrictlyPositive64)(this.max);
        if (minStrictlySmallerZero && maxStrictlyGreaterZero) {
            const logMin = (0, ArrayInt64_1.logLike64)(this.min);
            const logMax = (0, ArrayInt64_1.logLike64)(this.max);
            this.biasedRanges = [
                { min: logMin, max: logMax },
                { min: (0, ArrayInt64_1.substract64)(this.max, logMax), max: this.max },
                { min: this.min, max: (0, ArrayInt64_1.substract64)(this.min, logMin) },
            ];
        }
        else {
            const logGap = (0, ArrayInt64_1.logLike64)((0, ArrayInt64_1.substract64)(this.max, this.min));
            const arbCloseToMin = { min: this.min, max: (0, ArrayInt64_1.add64)(this.min, logGap) };
            const arbCloseToMax = { min: (0, ArrayInt64_1.substract64)(this.max, logGap), max: this.max };
            this.biasedRanges = minStrictlySmallerZero
                ? [arbCloseToMax, arbCloseToMin]
                : [arbCloseToMin, arbCloseToMax];
        }
        return this.biasedRanges;
    }
}
function arrayInt64(min, max) {
    const arb = new ArrayInt64Arbitrary(min, max);
    return arb;
}
exports.arrayInt64 = arrayInt64;


/***/ }),

/***/ 11900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BigIntArbitrary = void 0;
const Stream_1 = __webpack_require__(99385);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const BiasNumericRange_1 = __webpack_require__(96352);
const ShrinkBigInt_1 = __webpack_require__(61798);
class BigIntArbitrary extends Arbitrary_1.Arbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new Value_1.Value(mrng.nextBigInt(range.min, range.max), undefined);
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = (0, BiasNumericRange_1.biasNumericRange)(this.min, this.max, BiasNumericRange_1.bigIntLogLike);
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    canShrinkWithoutContext(value) {
        return typeof value === 'bigint' && this.min <= value && value <= this.max;
    }
    shrink(current, context) {
        if (!BigIntArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return (0, ShrinkBigInt_1.shrinkBigInt)(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new Value_1.Value(context, undefined));
        }
        return (0, ShrinkBigInt_1.shrinkBigInt)(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
            return BigInt(0);
        }
        return this.min < 0 ? this.max : this.min;
    }
    isLastChanceTry(current, context) {
        if (current > 0)
            return current === context + BigInt(1) && current > this.min;
        if (current < 0)
            return current === context - BigInt(1) && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'bigint') {
            throw new Error(`Invalid context type passed to BigIntArbitrary (#1)`);
        }
        const differentSigns = (current > 0 && context < 0) || (current < 0 && context > 0);
        if (context !== BigInt(0) && differentSigns) {
            throw new Error(`Invalid context value passed to BigIntArbitrary (#2)`);
        }
        return true;
    }
}
exports.BigIntArbitrary = BigIntArbitrary;


/***/ }),

/***/ 28733:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloneArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const symbols_1 = __webpack_require__(28620);
const Stream_1 = __webpack_require__(99385);
class CloneArbitrary extends Arbitrary_1.Arbitrary {
    constructor(arb, numValues) {
        super();
        this.arb = arb;
        this.numValues = numValues;
    }
    generate(mrng, biasFactor) {
        const items = [];
        if (this.numValues <= 0) {
            return this.wrapper(items);
        }
        for (let idx = 0; idx !== this.numValues - 1; ++idx) {
            items.push(this.arb.generate(mrng.clone(), biasFactor));
        }
        items.push(this.arb.generate(mrng, biasFactor));
        return this.wrapper(items);
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || value.length !== this.numValues) {
            return false;
        }
        if (value.length === 0) {
            return true;
        }
        for (let index = 1; index < value.length; ++index) {
            if (!Object.is(value[0], value[index])) {
                return false;
            }
        }
        return this.arb.canShrinkWithoutContext(value[0]);
    }
    shrink(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        return new Stream_1.Stream(this.shrinkImpl(value, context !== undefined ? context : [])).map((v) => this.wrapper(v));
    }
    *shrinkImpl(value, contexts) {
        const its = value.map((v, idx) => this.arb.shrink(v, contexts[idx])[Symbol.iterator]());
        let cur = its.map((it) => it.next());
        while (!cur[0].done) {
            yield cur.map((c) => c.value);
            cur = its.map((it) => it.next());
        }
    }
    static makeItCloneable(vs, shrinkables) {
        vs[symbols_1.cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    wrapper(items) {
        let cloneable = false;
        const vs = [];
        const contexts = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
            contexts.push(s.context);
        }
        if (cloneable) {
            CloneArbitrary.makeItCloneable(vs, items);
        }
        return new Value_1.Value(vs, contexts);
    }
}
exports.CloneArbitrary = CloneArbitrary;


/***/ }),

/***/ 43045:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandsArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const CommandsIterable_1 = __webpack_require__(18536);
const CommandWrapper_1 = __webpack_require__(99927);
const ReplayPath_1 = __webpack_require__(26979);
const LazyIterableIterator_1 = __webpack_require__(32871);
const Stream_1 = __webpack_require__(99385);
const oneof_1 = __webpack_require__(89752);
const RestrictedIntegerArbitraryBuilder_1 = __webpack_require__(11446);
class CommandsArbitrary extends Arbitrary_1.Arbitrary {
    constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {
        super();
        this.sourceReplayPath = sourceReplayPath;
        this.disableReplayLog = disableReplayLog;
        this.oneCommandArb = (0, oneof_1.oneof)(...commandArbs).map((c) => new CommandWrapper_1.CommandWrapper(c));
        this.lengthArb = (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedCommands, maxCommands);
        this.replayPath = [];
        this.replayPathPosition = 0;
    }
    metadataForReplay() {
        return this.disableReplayLog ? '' : `replayPath=${JSON.stringify(ReplayPath_1.ReplayPath.stringify(this.replayPath))}`;
    }
    buildValueFor(items, shrunkOnce) {
        const commands = items.map((item) => item.value_);
        const context = { shrunkOnce, items };
        return new Value_1.Value(new CommandsIterable_1.CommandsIterable(commands, () => this.metadataForReplay()), context);
    }
    generate(mrng) {
        const size = this.lengthArb.generate(mrng, undefined);
        const sizeValue = size.value;
        const items = Array(sizeValue);
        for (let idx = 0; idx !== sizeValue; ++idx) {
            const item = this.oneCommandArb.generate(mrng, undefined);
            items[idx] = item;
        }
        this.replayPathPosition = 0;
        return this.buildValueFor(items, false);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    filterOnExecution(itemsRaw) {
        const items = [];
        for (const c of itemsRaw) {
            if (c.value_.hasRan) {
                this.replayPath.push(true);
                items.push(c);
            }
            else
                this.replayPath.push(false);
        }
        return items;
    }
    filterOnReplay(itemsRaw) {
        return itemsRaw.filter((c, idx) => {
            const state = this.replayPath[this.replayPathPosition + idx];
            if (state === undefined)
                throw new Error(`Too short replayPath`);
            if (!state && c.value_.hasRan)
                throw new Error(`Mismatch between replayPath and real execution`);
            return state;
        });
    }
    filterForShrinkImpl(itemsRaw) {
        if (this.replayPathPosition === 0) {
            this.replayPath = this.sourceReplayPath !== null ? ReplayPath_1.ReplayPath.parse(this.sourceReplayPath) : [];
        }
        const items = this.replayPathPosition < this.replayPath.length
            ? this.filterOnReplay(itemsRaw)
            : this.filterOnExecution(itemsRaw);
        this.replayPathPosition += itemsRaw.length;
        return items;
    }
    shrink(_value, context) {
        if (context === undefined) {
            return Stream_1.Stream.nil();
        }
        const safeContext = context;
        const shrunkOnce = safeContext.shrunkOnce;
        const itemsRaw = safeContext.items;
        const items = this.filterForShrinkImpl(itemsRaw);
        if (items.length === 0) {
            return Stream_1.Stream.nil();
        }
        const rootShrink = shrunkOnce
            ? Stream_1.Stream.nil()
            : new Stream_1.Stream([[]][Symbol.iterator]());
        const nextShrinks = [];
        for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {
            nextShrinks.push((0, LazyIterableIterator_1.makeLazy)(() => {
                const fixedStart = items.slice(0, numToKeep);
                return this.lengthArb
                    .shrink(items.length - 1 - numToKeep, undefined)
                    .map((l) => fixedStart.concat(items.slice(items.length - (l.value + 1))));
            }));
        }
        for (let itemAt = 0; itemAt !== items.length; ++itemAt) {
            nextShrinks.push((0, LazyIterableIterator_1.makeLazy)(() => this.oneCommandArb
                .shrink(items[itemAt].value_, items[itemAt].context)
                .map((v) => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));
        }
        return rootShrink.join(...nextShrinks).map((shrinkables) => {
            return this.buildValueFor(shrinkables.map((c) => new Value_1.Value(c.value_.clone(), c.context)), true);
        });
    }
}
exports.CommandsArbitrary = CommandsArbitrary;


/***/ }),

/***/ 17094:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantArbitrary = void 0;
const Stream_1 = __webpack_require__(99385);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const symbols_1 = __webpack_require__(28620);
class ConstantArbitrary extends Arbitrary_1.Arbitrary {
    constructor(values) {
        super();
        this.values = values;
    }
    generate(mrng, _biasFactor) {
        const idx = this.values.length === 1 ? 0 : mrng.nextInt(0, this.values.length - 1);
        const value = this.values[idx];
        if (!(0, symbols_1.hasCloneMethod)(value)) {
            return new Value_1.Value(value, idx);
        }
        return new Value_1.Value(value, idx, () => value[symbols_1.cloneMethod]());
    }
    canShrinkWithoutContext(value) {
        for (let idx = 0; idx !== this.values.length; ++idx) {
            if (Object.is(this.values[idx], value)) {
                return true;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (context === 0 || Object.is(value, this.values[0])) {
            return Stream_1.Stream.nil();
        }
        return Stream_1.Stream.of(new Value_1.Value(this.values[0], 0));
    }
}
exports.ConstantArbitrary = ConstantArbitrary;


/***/ }),

/***/ 74658:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FrequencyArbitrary = void 0;
const Stream_1 = __webpack_require__(99385);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const DepthContext_1 = __webpack_require__(10514);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
class FrequencyArbitrary extends Arbitrary_1.Arbitrary {
    constructor(warbs, constraints, context) {
        super();
        this.warbs = warbs;
        this.constraints = constraints;
        this.context = context;
        let currentWeight = 0;
        this.cumulatedWeights = [];
        for (let idx = 0; idx !== warbs.length; ++idx) {
            currentWeight += warbs[idx].weight;
            this.cumulatedWeights.push(currentWeight);
        }
        this.totalWeight = currentWeight;
    }
    static from(warbs, constraints, label) {
        if (warbs.length === 0) {
            throw new Error(`${label} expects at least one weighted arbitrary`);
        }
        let totalWeight = 0;
        for (let idx = 0; idx !== warbs.length; ++idx) {
            const currentArbitrary = warbs[idx].arbitrary;
            if (currentArbitrary === undefined) {
                throw new Error(`${label} expects arbitraries to be specified`);
            }
            const currentWeight = warbs[idx].weight;
            totalWeight += currentWeight;
            if (!Number.isInteger(currentWeight)) {
                throw new Error(`${label} expects weights to be integer values`);
            }
            if (currentWeight < 0) {
                throw new Error(`${label} expects weights to be superior or equal to 0`);
            }
        }
        if (totalWeight <= 0) {
            throw new Error(`${label} expects the sum of weights to be strictly superior to 0`);
        }
        const sanitizedConstraints = {
            depthBias: (0, MaxLengthFromMinLength_1.depthBiasFromSizeForArbitrary)(constraints.depthSize, constraints.maxDepth !== undefined),
            maxDepth: constraints.maxDepth != undefined ? constraints.maxDepth : Number.POSITIVE_INFINITY,
            withCrossShrink: !!constraints.withCrossShrink,
        };
        return new FrequencyArbitrary(warbs, sanitizedConstraints, (0, DepthContext_1.getDepthContextFor)(constraints.depthIdentifier));
    }
    generate(mrng, biasFactor) {
        if (this.mustGenerateFirst()) {
            return this.safeGenerateForIndex(mrng, 0, biasFactor);
        }
        const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);
        for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {
            if (selected < this.cumulatedWeights[idx]) {
                return this.safeGenerateForIndex(mrng, idx, biasFactor);
            }
        }
        throw new Error(`Unable to generate from fc.frequency`);
    }
    canShrinkWithoutContext(value) {
        return this.canShrinkWithoutContextIndex(value) !== -1;
    }
    shrink(value, context) {
        if (context !== undefined) {
            const safeContext = context;
            const selectedIndex = safeContext.selectedIndex;
            const originalBias = safeContext.originalBias;
            const originalArbitrary = this.warbs[selectedIndex].arbitrary;
            const originalShrinks = originalArbitrary
                .shrink(value, safeContext.originalContext)
                .map((v) => this.mapIntoValue(selectedIndex, v, null, originalBias));
            if (safeContext.clonedMrngForFallbackFirst !== null) {
                if (safeContext.cachedGeneratedForFirst === undefined) {
                    safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);
                }
                const valueFromFirst = safeContext.cachedGeneratedForFirst;
                return Stream_1.Stream.of(valueFromFirst).join(originalShrinks);
            }
            return originalShrinks;
        }
        const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);
        if (potentialSelectedIndex === -1) {
            return Stream_1.Stream.nil();
        }
        return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary
            .shrink(value, undefined)
            .map((v) => this.mapIntoValue(potentialSelectedIndex, v, null, undefined)));
    }
    defaultShrinkForFirst(selectedIndex) {
        ++this.context.depth;
        try {
            if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {
                return Stream_1.Stream.nil();
            }
        }
        finally {
            --this.context.depth;
        }
        const rawShrinkValue = new Value_1.Value(this.warbs[0].fallbackValue.default, undefined);
        return Stream_1.Stream.of(this.mapIntoValue(0, rawShrinkValue, null, undefined));
    }
    canShrinkWithoutContextIndex(value) {
        if (this.mustGenerateFirst()) {
            return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;
        }
        try {
            ++this.context.depth;
            for (let idx = 0; idx !== this.warbs.length; ++idx) {
                const warb = this.warbs[idx];
                if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {
                    return idx;
                }
            }
            return -1;
        }
        finally {
            --this.context.depth;
        }
    }
    mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {
        const context = {
            selectedIndex: idx,
            originalBias: biasFactor,
            originalContext: value.context,
            clonedMrngForFallbackFirst,
        };
        return new Value_1.Value(value.value, context);
    }
    safeGenerateForIndex(mrng, idx, biasFactor) {
        ++this.context.depth;
        try {
            const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);
            const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;
            return this.mapIntoValue(idx, value, clonedMrngForFallbackFirst, biasFactor);
        }
        finally {
            --this.context.depth;
        }
    }
    mustGenerateFirst() {
        return this.constraints.maxDepth <= this.context.depth;
    }
    mustFallbackToFirstInShrink(idx) {
        return idx !== 0 && this.constraints.withCrossShrink && this.warbs[0].weight !== 0;
    }
    computeNegDepthBenefit() {
        const depthBias = this.constraints.depthBias;
        if (depthBias <= 0 || this.warbs[0].weight === 0) {
            return 0;
        }
        const depthBenefit = Math.floor(Math.pow(1 + depthBias, this.context.depth)) - 1;
        return -Math.min(this.totalWeight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;
    }
}
exports.FrequencyArbitrary = FrequencyArbitrary;


/***/ }),

/***/ 57396:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntegerArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const Stream_1 = __webpack_require__(99385);
const BiasNumericRange_1 = __webpack_require__(96352);
const ShrinkInteger_1 = __webpack_require__(28378);
class IntegerArbitrary extends Arbitrary_1.Arbitrary {
    constructor(min, max) {
        super();
        this.min = min;
        this.max = max;
    }
    generate(mrng, biasFactor) {
        const range = this.computeGenerateRange(mrng, biasFactor);
        return new Value_1.Value(mrng.nextInt(range.min, range.max), undefined);
    }
    canShrinkWithoutContext(value) {
        return (typeof value === 'number' &&
            Number.isInteger(value) &&
            !Object.is(value, -0) &&
            this.min <= value &&
            value <= this.max);
    }
    shrink(current, context) {
        if (!IntegerArbitrary.isValidContext(current, context)) {
            const target = this.defaultTarget();
            return (0, ShrinkInteger_1.shrinkInteger)(current, target, true);
        }
        if (this.isLastChanceTry(current, context)) {
            return Stream_1.Stream.of(new Value_1.Value(context, undefined));
        }
        return (0, ShrinkInteger_1.shrinkInteger)(current, context, false);
    }
    defaultTarget() {
        if (this.min <= 0 && this.max >= 0) {
            return 0;
        }
        return this.min < 0 ? this.max : this.min;
    }
    computeGenerateRange(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { min: this.min, max: this.max };
        }
        const ranges = (0, BiasNumericRange_1.biasNumericRange)(this.min, this.max, BiasNumericRange_1.integerLogLike);
        if (ranges.length === 1) {
            return ranges[0];
        }
        const id = mrng.nextInt(-2 * (ranges.length - 1), ranges.length - 2);
        return id < 0 ? ranges[0] : ranges[id + 1];
    }
    isLastChanceTry(current, context) {
        if (current > 0)
            return current === context + 1 && current > this.min;
        if (current < 0)
            return current === context - 1 && current < this.max;
        return false;
    }
    static isValidContext(current, context) {
        if (context === undefined) {
            return false;
        }
        if (typeof context !== 'number') {
            throw new Error(`Invalid context type passed to IntegerArbitrary (#1)`);
        }
        if (context !== 0 && Math.sign(current) !== Math.sign(context)) {
            throw new Error(`Invalid context value passed to IntegerArbitrary (#2)`);
        }
        return true;
    }
}
exports.IntegerArbitrary = IntegerArbitrary;


/***/ }),

/***/ 79749:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LazyArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
class LazyArbitrary extends Arbitrary_1.Arbitrary {
    constructor(name) {
        super();
        this.name = name;
        this.underlying = null;
    }
    generate(mrng, biasFactor) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (!this.underlying) {
            throw new Error(`Lazy arbitrary ${JSON.stringify(this.name)} not correctly initialized`);
        }
        return this.underlying.shrink(value, context);
    }
}
exports.LazyArbitrary = LazyArbitrary;


/***/ }),

/***/ 57681:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MixedCaseArbitrary = void 0;
const bigUintN_1 = __webpack_require__(94088);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const LazyIterableIterator_1 = __webpack_require__(32871);
const ToggleFlags_1 = __webpack_require__(57615);
class MixedCaseArbitrary extends Arbitrary_1.Arbitrary {
    constructor(stringArb, toggleCase, untoggleAll) {
        super();
        this.stringArb = stringArb;
        this.toggleCase = toggleCase;
        this.untoggleAll = untoggleAll;
    }
    buildContextFor(rawStringValue, flagsValue) {
        return {
            rawString: rawStringValue.value,
            rawStringContext: rawStringValue.context,
            flags: flagsValue.value,
            flagsContext: flagsValue.context,
        };
    }
    generate(mrng, biasFactor) {
        const rawStringValue = this.stringArb.generate(mrng, biasFactor);
        const chars = [...rawStringValue.value];
        const togglePositions = (0, ToggleFlags_1.computeTogglePositions)(chars, this.toggleCase);
        const flagsArb = (0, bigUintN_1.bigUintN)(togglePositions.length);
        const flagsValue = flagsArb.generate(mrng, undefined);
        (0, ToggleFlags_1.applyFlagsOnChars)(chars, flagsValue.value, togglePositions, this.toggleCase);
        return new Value_1.Value(chars.join(''), this.buildContextFor(rawStringValue, flagsValue));
    }
    canShrinkWithoutContext(value) {
        if (typeof value !== 'string') {
            return false;
        }
        return this.untoggleAll !== undefined
            ? this.stringArb.canShrinkWithoutContext(this.untoggleAll(value))
            :
                this.stringArb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        let contextSafe;
        if (context !== undefined) {
            contextSafe = context;
        }
        else {
            if (this.untoggleAll !== undefined) {
                const untoggledValue = this.untoggleAll(value);
                const valueChars = [...value];
                const untoggledValueChars = [...untoggledValue];
                const togglePositions = (0, ToggleFlags_1.computeTogglePositions)(untoggledValueChars, this.toggleCase);
                contextSafe = {
                    rawString: untoggledValue,
                    rawStringContext: undefined,
                    flags: (0, ToggleFlags_1.computeFlagsFromChars)(untoggledValueChars, valueChars, togglePositions),
                    flagsContext: undefined,
                };
            }
            else {
                contextSafe = {
                    rawString: value,
                    rawStringContext: undefined,
                    flags: BigInt(0),
                    flagsContext: undefined,
                };
            }
        }
        const rawString = contextSafe.rawString;
        const flags = contextSafe.flags;
        return this.stringArb
            .shrink(rawString, contextSafe.rawStringContext)
            .map((nRawStringValue) => {
            const nChars = [...nRawStringValue.value];
            const nTogglePositions = (0, ToggleFlags_1.computeTogglePositions)(nChars, this.toggleCase);
            const nFlags = (0, ToggleFlags_1.computeNextFlags)(flags, nTogglePositions.length);
            (0, ToggleFlags_1.applyFlagsOnChars)(nChars, nFlags, nTogglePositions, this.toggleCase);
            return new Value_1.Value(nChars.join(''), this.buildContextFor(nRawStringValue, new Value_1.Value(nFlags, undefined)));
        })
            .join((0, LazyIterableIterator_1.makeLazy)(() => {
            const chars = [...rawString];
            const togglePositions = (0, ToggleFlags_1.computeTogglePositions)(chars, this.toggleCase);
            return (0, bigUintN_1.bigUintN)(togglePositions.length)
                .shrink(flags, contextSafe.flagsContext)
                .map((nFlagsValue) => {
                const nChars = chars.slice();
                (0, ToggleFlags_1.applyFlagsOnChars)(nChars, nFlagsValue.value, togglePositions, this.toggleCase);
                return new Value_1.Value(nChars.join(''), this.buildContextFor(new Value_1.Value(rawString, contextSafe.rawStringContext), nFlagsValue));
            });
        }));
    }
}
exports.MixedCaseArbitrary = MixedCaseArbitrary;


/***/ }),

/***/ 41981:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulerArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const Stream_1 = __webpack_require__(99385);
const SchedulerImplem_1 = __webpack_require__(31821);
function buildNextTaskIndex(mrng) {
    const clonedMrng = mrng.clone();
    return {
        clone: () => buildNextTaskIndex(clonedMrng),
        nextTaskIndex: (scheduledTasks) => {
            return mrng.nextInt(0, scheduledTasks.length - 1);
        },
    };
}
class SchedulerArbitrary extends Arbitrary_1.Arbitrary {
    constructor(act) {
        super();
        this.act = act;
    }
    generate(mrng, _biasFactor) {
        return new Value_1.Value(new SchedulerImplem_1.SchedulerImplem(this.act, buildNextTaskIndex(mrng.clone())), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
}
exports.SchedulerArbitrary = SchedulerArbitrary;


/***/ }),

/***/ 70131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StreamArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const symbols_1 = __webpack_require__(28620);
const Stream_1 = __webpack_require__(99385);
const stringify_1 = __webpack_require__(21954);
function prettyPrint(seenValuesStrings) {
    return `Stream(${seenValuesStrings.join(',')})`;
}
class StreamArbitrary extends Arbitrary_1.Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        const appliedBiasFactor = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : undefined;
        const enrichedProducer = () => {
            const seenValues = [];
            const g = function* (arb, clonedMrng) {
                while (true) {
                    const value = arb.generate(clonedMrng, appliedBiasFactor).value;
                    seenValues.push(value);
                    yield value;
                }
            };
            const s = new Stream_1.Stream(g(this.arb, mrng.clone()));
            return Object.defineProperties(s, {
                toString: { value: () => prettyPrint(seenValues.map(stringify_1.stringify)) },
                [stringify_1.toStringMethod]: { value: () => prettyPrint(seenValues.map(stringify_1.stringify)) },
                [stringify_1.asyncToStringMethod]: { value: async () => prettyPrint(await Promise.all(seenValues.map(stringify_1.asyncStringify))) },
                [symbols_1.cloneMethod]: { value: enrichedProducer, enumerable: true },
            });
        };
        return new Value_1.Value(enrichedProducer(), undefined);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
}
exports.StreamArbitrary = StreamArbitrary;


/***/ }),

/***/ 67634:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubarrayArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
const LazyIterableIterator_1 = __webpack_require__(32871);
const Stream_1 = __webpack_require__(99385);
const IsSubarrayOf_1 = __webpack_require__(90743);
const IntegerArbitrary_1 = __webpack_require__(57396);
class SubarrayArbitrary extends Arbitrary_1.Arbitrary {
    constructor(originalArray, isOrdered, minLength, maxLength) {
        super();
        this.originalArray = originalArray;
        this.isOrdered = isOrdered;
        this.minLength = minLength;
        this.maxLength = maxLength;
        if (minLength < 0 || minLength > originalArray.length)
            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');
        if (maxLength < 0 || maxLength > originalArray.length)
            throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');
        if (minLength > maxLength)
            throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');
        this.lengthArb = new IntegerArbitrary_1.IntegerArbitrary(minLength, maxLength);
        this.biasedLengthArb =
            minLength !== maxLength
                ? new IntegerArbitrary_1.IntegerArbitrary(minLength, minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2)))
                : this.lengthArb;
    }
    generate(mrng, biasFactor) {
        const lengthArb = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? this.biasedLengthArb : this.lengthArb;
        const size = lengthArb.generate(mrng, undefined);
        const sizeValue = size.value;
        const remainingElements = this.originalArray.map((_v, idx) => idx);
        const ids = [];
        for (let index = 0; index !== sizeValue; ++index) {
            const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);
            ids.push(remainingElements[selectedIdIndex]);
            remainingElements.splice(selectedIdIndex, 1);
        }
        if (this.isOrdered) {
            ids.sort((a, b) => a - b);
        }
        return new Value_1.Value(ids.map((i) => this.originalArray[i]), size.context);
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value)) {
            return false;
        }
        if (!this.lengthArb.canShrinkWithoutContext(value.length)) {
            return false;
        }
        return (0, IsSubarrayOf_1.isSubarrayOf)(this.originalArray, value);
    }
    shrink(value, context) {
        if (value.length === 0) {
            return Stream_1.Stream.nil();
        }
        return this.lengthArb
            .shrink(value.length, context)
            .map((newSize) => {
            return new Value_1.Value(value.slice(value.length - newSize.value), newSize.context);
        })
            .join(value.length > this.minLength
            ? (0, LazyIterableIterator_1.makeLazy)(() => this.shrink(value.slice(1), undefined)
                .filter((newValue) => this.minLength <= newValue.value.length + 1)
                .map((newValue) => new Value_1.Value([value[0]].concat(newValue.value), undefined)))
            : Stream_1.Stream.nil());
    }
}
exports.SubarrayArbitrary = SubarrayArbitrary;


/***/ }),

/***/ 18404:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TupleArbitrary = void 0;
const Stream_1 = __webpack_require__(99385);
const symbols_1 = __webpack_require__(28620);
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
class TupleArbitrary extends Arbitrary_1.Arbitrary {
    constructor(arbs) {
        super();
        this.arbs = arbs;
        for (let idx = 0; idx !== arbs.length; ++idx) {
            const arb = arbs[idx];
            if (arb == null || arb.generate == null)
                throw new Error(`Invalid parameter encountered at index ${idx}: expecting an Arbitrary`);
        }
    }
    static makeItCloneable(vs, values) {
        return Object.defineProperty(vs, symbols_1.cloneMethod, {
            value: () => {
                const cloned = [];
                for (let idx = 0; idx !== values.length; ++idx) {
                    cloned.push(values[idx].value);
                }
                TupleArbitrary.makeItCloneable(cloned, values);
                return cloned;
            },
        });
    }
    static wrapper(values) {
        let cloneable = false;
        const vs = [];
        const ctxs = [];
        for (let idx = 0; idx !== values.length; ++idx) {
            const v = values[idx];
            cloneable = cloneable || v.hasToBeCloned;
            vs.push(v.value);
            ctxs.push(v.context);
        }
        if (cloneable) {
            TupleArbitrary.makeItCloneable(vs, values);
        }
        return new Value_1.Value(vs, ctxs);
    }
    generate(mrng, biasFactor) {
        return TupleArbitrary.wrapper(this.arbs.map((a) => a.generate(mrng, biasFactor)));
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || value.length !== this.arbs.length) {
            return false;
        }
        for (let index = 0; index !== this.arbs.length; ++index) {
            if (!this.arbs[index].canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        return true;
    }
    shrink(value, context) {
        let s = Stream_1.Stream.nil();
        const safeContext = Array.isArray(context) ? context : [];
        for (let idx = 0; idx !== this.arbs.length; ++idx) {
            const shrinksForIndex = this.arbs[idx]
                .shrink(value[idx], safeContext[idx])
                .map((v) => {
                const nextValues = value.map((v, idx) => new Value_1.Value((0, symbols_1.cloneIfNeeded)(v), safeContext[idx]));
                return nextValues
                    .slice(0, idx)
                    .concat([v])
                    .concat(nextValues.slice(idx + 1));
            })
                .map((values) => TupleArbitrary.wrapper(values));
            s = s.join(shrinksForIndex);
        }
        return s;
    }
}
exports.TupleArbitrary = TupleArbitrary;


/***/ }),

/***/ 75303:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WithShrinkFromOtherArbitrary = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const Value_1 = __webpack_require__(60641);
function isSafeContext(context) {
    return context !== undefined;
}
function toGeneratorValue(value) {
    if (value.hasToBeCloned) {
        return new Value_1.Value(value.value_, { generatorContext: value.context }, () => value.value);
    }
    return new Value_1.Value(value.value_, { generatorContext: value.context });
}
function toShrinkerValue(value) {
    if (value.hasToBeCloned) {
        return new Value_1.Value(value.value_, { shrinkerContext: value.context }, () => value.value);
    }
    return new Value_1.Value(value.value_, { shrinkerContext: value.context });
}
class WithShrinkFromOtherArbitrary extends Arbitrary_1.Arbitrary {
    constructor(generatorArbitrary, shrinkerArbitrary) {
        super();
        this.generatorArbitrary = generatorArbitrary;
        this.shrinkerArbitrary = shrinkerArbitrary;
    }
    generate(mrng, biasFactor) {
        return toGeneratorValue(this.generatorArbitrary.generate(mrng, biasFactor));
    }
    canShrinkWithoutContext(value) {
        return this.shrinkerArbitrary.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        if (!isSafeContext(context)) {
            return this.shrinkerArbitrary.shrink(value, undefined).map(toShrinkerValue);
        }
        if ('generatorContext' in context) {
            return this.generatorArbitrary.shrink(value, context.generatorContext).map(toGeneratorValue);
        }
        return this.shrinkerArbitrary.shrink(value, context.shrinkerContext).map(toShrinkerValue);
    }
}
exports.WithShrinkFromOtherArbitrary = WithShrinkFromOtherArbitrary;


/***/ }),

/***/ 31995:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.anyArbitraryBuilder = void 0;
const stringify_1 = __webpack_require__(21954);
const array_1 = __webpack_require__(78309);
const oneof_1 = __webpack_require__(89752);
const tuple_1 = __webpack_require__(85282);
const bigInt_1 = __webpack_require__(57750);
const date_1 = __webpack_require__(18123);
const float32Array_1 = __webpack_require__(39330);
const float64Array_1 = __webpack_require__(76417);
const int16Array_1 = __webpack_require__(21465);
const int32Array_1 = __webpack_require__(37226);
const int8Array_1 = __webpack_require__(55525);
const uint16Array_1 = __webpack_require__(96702);
const uint32Array_1 = __webpack_require__(3594);
const uint8Array_1 = __webpack_require__(83468);
const uint8ClampedArray_1 = __webpack_require__(74729);
const sparseArray_1 = __webpack_require__(98975);
const KeyValuePairsToObject_1 = __webpack_require__(25424);
const ArrayToMap_1 = __webpack_require__(39175);
const ArrayToSet_1 = __webpack_require__(62865);
const ObjectToPrototypeLess_1 = __webpack_require__(55833);
const letrec_1 = __webpack_require__(72234);
const uniqueArray_1 = __webpack_require__(20005);
const DepthContext_1 = __webpack_require__(10514);
function mapOf(ka, va, maxKeys, size, depthIdentifier) {
    return (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)(ka, va), {
        maxLength: maxKeys,
        size,
        comparator: 'SameValueZero',
        selector: (t) => t[0],
        depthIdentifier,
    }).map(ArrayToMap_1.arrayToMapMapper, ArrayToMap_1.arrayToMapUnmapper);
}
function dictOf(ka, va, maxKeys, size, depthIdentifier) {
    return (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)(ka, va), {
        maxLength: maxKeys,
        size,
        selector: (t) => t[0],
        depthIdentifier,
    }).map(KeyValuePairsToObject_1.keyValuePairsToObjectMapper, KeyValuePairsToObject_1.keyValuePairsToObjectUnmapper);
}
function setOf(va, maxKeys, size, depthIdentifier) {
    return (0, uniqueArray_1.uniqueArray)(va, { maxLength: maxKeys, size, comparator: 'SameValueZero', depthIdentifier }).map(ArrayToSet_1.arrayToSetMapper, ArrayToSet_1.arrayToSetUnmapper);
}
function prototypeLessOf(objectArb) {
    return objectArb.map(ObjectToPrototypeLess_1.objectToPrototypeLessMapper, ObjectToPrototypeLess_1.objectToPrototypeLessUnmapper);
}
function typedArray(constraints) {
    return (0, oneof_1.oneof)((0, int8Array_1.int8Array)(constraints), (0, uint8Array_1.uint8Array)(constraints), (0, uint8ClampedArray_1.uint8ClampedArray)(constraints), (0, int16Array_1.int16Array)(constraints), (0, uint16Array_1.uint16Array)(constraints), (0, int32Array_1.int32Array)(constraints), (0, uint32Array_1.uint32Array)(constraints), (0, float32Array_1.float32Array)(constraints), (0, float64Array_1.float64Array)(constraints));
}
function anyArbitraryBuilder(constraints) {
    const arbitrariesForBase = constraints.values;
    const depthSize = constraints.depthSize;
    const depthIdentifier = (0, DepthContext_1.createDepthIdentifier)();
    const maxDepth = constraints.maxDepth;
    const maxKeys = constraints.maxKeys;
    const size = constraints.size;
    const baseArb = (0, oneof_1.oneof)(...arbitrariesForBase, ...(constraints.withBigInt ? [(0, bigInt_1.bigInt)()] : []), ...(constraints.withDate ? [(0, date_1.date)()] : []));
    return (0, letrec_1.letrec)((tie) => ({
        anything: (0, oneof_1.oneof)({ maxDepth, depthSize, depthIdentifier }, baseArb, tie('array'), tie('object'), ...(constraints.withMap ? [tie('map')] : []), ...(constraints.withSet ? [tie('set')] : []), ...(constraints.withObjectString ? [tie('anything').map((o) => (0, stringify_1.stringify)(o))] : []), ...(constraints.withNullPrototype ? [prototypeLessOf(tie('object'))] : []), ...(constraints.withTypedArray ? [typedArray({ maxLength: maxKeys, size })] : []), ...(constraints.withSparseArray
            ? [(0, sparseArray_1.sparseArray)(tie('anything'), { maxNumElements: maxKeys, size, depthIdentifier })]
            : [])),
        keys: constraints.withObjectString
            ? (0, oneof_1.oneof)({ arbitrary: constraints.key, weight: 10 }, { arbitrary: tie('anything').map((o) => (0, stringify_1.stringify)(o)), weight: 1 })
            : constraints.key,
        array: (0, array_1.array)(tie('anything'), { maxLength: maxKeys, size, depthIdentifier }),
        set: setOf(tie('anything'), maxKeys, size, depthIdentifier),
        map: (0, oneof_1.oneof)(mapOf(tie('keys'), tie('anything'), maxKeys, size, depthIdentifier), mapOf(tie('anything'), tie('anything'), maxKeys, size, depthIdentifier)),
        object: dictOf(tie('keys'), tie('anything'), maxKeys, size, depthIdentifier),
    })).anything;
}
exports.anyArbitraryBuilder = anyArbitraryBuilder;


/***/ }),

/***/ 42650:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boxedArbitraryBuilder = void 0;
const UnboxedToBoxed_1 = __webpack_require__(15548);
function boxedArbitraryBuilder(arb) {
    return arb.map(UnboxedToBoxed_1.unboxedToBoxedMapper, UnboxedToBoxed_1.unboxedToBoxedUnmapper);
}
exports.boxedArbitraryBuilder = boxedArbitraryBuilder;


/***/ }),

/***/ 39607:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCharacterArbitrary = void 0;
const integer_1 = __webpack_require__(97706);
const IndexToCharString_1 = __webpack_require__(34431);
function buildCharacterArbitrary(min, max, mapToCode, unmapFromCode) {
    return (0, integer_1.integer)({ min, max }).map((n) => (0, IndexToCharString_1.indexToCharStringMapper)(mapToCode(n)), (c) => unmapFromCode((0, IndexToCharString_1.indexToCharStringUnmapper)(c)));
}
exports.buildCharacterArbitrary = buildCharacterArbitrary;


/***/ }),

/***/ 40085:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildAlphaNumericPercentArbitrary = exports.buildAlphaNumericArbitrary = exports.buildLowerAlphaNumericArbitrary = exports.buildLowerAlphaArbitrary = void 0;
const fullUnicode_1 = __webpack_require__(96005);
const oneof_1 = __webpack_require__(89752);
const mapToConstant_1 = __webpack_require__(99613);
const lowerCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x61) };
const upperCaseMapper = { num: 26, build: (v) => String.fromCharCode(v + 0x41) };
const numericMapper = { num: 10, build: (v) => String.fromCharCode(v + 0x30) };
function percentCharArbMapper(c) {
    const encoded = encodeURIComponent(c);
    return c !== encoded ? encoded : `%${c.charCodeAt(0).toString(16)}`;
}
function percentCharArbUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported');
    }
    const decoded = decodeURIComponent(value);
    return decoded;
}
const percentCharArb = (0, fullUnicode_1.fullUnicode)().map(percentCharArbMapper, percentCharArbUnmapper);
const buildLowerAlphaArbitrary = (others) => (0, mapToConstant_1.mapToConstant)(lowerCaseMapper, { num: others.length, build: (v) => others[v] });
exports.buildLowerAlphaArbitrary = buildLowerAlphaArbitrary;
const buildLowerAlphaNumericArbitrary = (others) => (0, mapToConstant_1.mapToConstant)(lowerCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });
exports.buildLowerAlphaNumericArbitrary = buildLowerAlphaNumericArbitrary;
const buildAlphaNumericArbitrary = (others) => (0, mapToConstant_1.mapToConstant)(lowerCaseMapper, upperCaseMapper, numericMapper, { num: others.length, build: (v) => others[v] });
exports.buildAlphaNumericArbitrary = buildAlphaNumericArbitrary;
const buildAlphaNumericPercentArbitrary = (others) => (0, oneof_1.oneof)({ weight: 10, arbitrary: (0, exports.buildAlphaNumericArbitrary)(others) }, { weight: 1, arbitrary: percentCharArb });
exports.buildAlphaNumericPercentArbitrary = buildAlphaNumericPercentArbitrary;


/***/ }),

/***/ 71909:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildCompareFunctionArbitrary = void 0;
const TextEscaper_1 = __webpack_require__(92325);
const symbols_1 = __webpack_require__(28620);
const hash_1 = __webpack_require__(21537);
const stringify_1 = __webpack_require__(21954);
const integer_1 = __webpack_require__(97706);
const tuple_1 = __webpack_require__(85282);
function buildCompareFunctionArbitrary(cmp) {
    return (0, tuple_1.tuple)((0, integer_1.integer)().noShrink(), (0, integer_1.integer)({ min: 1, max: 0xffffffff }).noShrink()).map(([seed, hashEnvSize]) => {
        const producer = () => {
            const recorded = {};
            const f = (a, b) => {
                const reprA = (0, stringify_1.stringify)(a);
                const reprB = (0, stringify_1.stringify)(b);
                const hA = (0, hash_1.hash)(`${seed}${reprA}`) % hashEnvSize;
                const hB = (0, hash_1.hash)(`${seed}${reprB}`) % hashEnvSize;
                const val = cmp(hA, hB);
                recorded[`[${reprA},${reprB}]`] = val;
                return val;
            };
            return Object.assign(f, {
                toString: () => {
                    const seenValues = Object.keys(recorded)
                        .sort()
                        .map((k) => `${k} => ${(0, stringify_1.stringify)(recorded[k])}`)
                        .map((line) => `/* ${(0, TextEscaper_1.escapeForMultilineComments)(line)} */`);
                    return `function(a, b) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const cmp = ${cmp};
  const hA = hash('${seed}' + stringify(a)) % ${hashEnvSize};
  const hB = hash('${seed}' + stringify(b)) % ${hashEnvSize};
  return cmp(hA, hB);
}`;
                },
                [symbols_1.cloneMethod]: producer,
            });
        };
        return producer();
    });
}
exports.buildCompareFunctionArbitrary = buildCompareFunctionArbitrary;


/***/ }),

/***/ 61472:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildPaddedNumberArbitrary = void 0;
const integer_1 = __webpack_require__(97706);
const NumberToPaddedEight_1 = __webpack_require__(32872);
function buildPaddedNumberArbitrary(min, max) {
    return (0, integer_1.integer)({ min, max }).map(NumberToPaddedEight_1.numberToPaddedEightMapper, NumberToPaddedEight_1.numberToPaddedEightUnmapper);
}
exports.buildPaddedNumberArbitrary = buildPaddedNumberArbitrary;


/***/ }),

/***/ 45056:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildPartialRecordArbitrary = void 0;
const option_1 = __webpack_require__(91953);
const tuple_1 = __webpack_require__(85282);
const EnumerableKeysExtractor_1 = __webpack_require__(34322);
const ValuesAndSeparateKeysToObject_1 = __webpack_require__(40683);
const noKeyValue = Symbol('no-key');
function buildPartialRecordArbitrary(recordModel, requiredKeys) {
    const keys = (0, EnumerableKeysExtractor_1.extractEnumerableKeys)(recordModel);
    const arbs = [];
    for (let index = 0; index !== keys.length; ++index) {
        const k = keys[index];
        const requiredArbitrary = recordModel[k];
        if (requiredKeys === undefined || requiredKeys.indexOf(k) !== -1)
            arbs.push(requiredArbitrary);
        else
            arbs.push((0, option_1.option)(requiredArbitrary, { nil: noKeyValue }));
    }
    return (0, tuple_1.tuple)(...arbs).map((0, ValuesAndSeparateKeysToObject_1.buildValuesAndSeparateKeysToObjectMapper)(keys, noKeyValue), (0, ValuesAndSeparateKeysToObject_1.buildValuesAndSeparateKeysToObjectUnmapper)(keys, noKeyValue));
}
exports.buildPartialRecordArbitrary = buildPartialRecordArbitrary;


/***/ }),

/***/ 11446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.restrictedIntegerArbitraryBuilder = void 0;
const integer_1 = __webpack_require__(97706);
const WithShrinkFromOtherArbitrary_1 = __webpack_require__(75303);
function restrictedIntegerArbitraryBuilder(min, maxGenerated, max) {
    const generatorArbitrary = (0, integer_1.integer)({ min, max: maxGenerated });
    if (maxGenerated === max) {
        return generatorArbitrary;
    }
    const shrinkerArbitrary = (0, integer_1.integer)({ min, max });
    return new WithShrinkFromOtherArbitrary_1.WithShrinkFromOtherArbitrary(generatorArbitrary, shrinkerArbitrary);
}
exports.restrictedIntegerArbitraryBuilder = restrictedIntegerArbitraryBuilder;


/***/ }),

/***/ 28670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildStringifiedNatArbitrary = void 0;
const constantFrom_1 = __webpack_require__(80305);
const nat_1 = __webpack_require__(45697);
const tuple_1 = __webpack_require__(85282);
const NatToStringifiedNat_1 = __webpack_require__(16415);
function buildStringifiedNatArbitrary(maxValue) {
    return (0, tuple_1.tuple)((0, constantFrom_1.constantFrom)('dec', 'oct', 'hex'), (0, nat_1.nat)(maxValue)).map(NatToStringifiedNat_1.natToStringifiedNatMapper, NatToStringifiedNat_1.natToStringifiedNatUnmapper);
}
exports.buildStringifiedNatArbitrary = buildStringifiedNatArbitrary;


/***/ }),

/***/ 13048:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.typedIntArrayArbitraryArbitraryBuilder = void 0;
const array_1 = __webpack_require__(78309);
function typedIntArrayArbitraryArbitraryBuilder(constraints, defaultMin, defaultMax, TypedArrayClass, arbitraryBuilder) {
    const generatorName = TypedArrayClass.name;
    const { min = defaultMin, max = defaultMax } = constraints, arrayConstraints = __rest(constraints, ["min", "max"]);
    if (min > max) {
        throw new Error(`Invalid range passed to ${generatorName}: min must be lower than or equal to max`);
    }
    if (min < defaultMin) {
        throw new Error(`Invalid min value passed to ${generatorName}: min must be greater than or equal to ${defaultMin}`);
    }
    if (max > defaultMax) {
        throw new Error(`Invalid max value passed to ${generatorName}: max must be lower than or equal to ${defaultMax}`);
    }
    return (0, array_1.array)(arbitraryBuilder({ min, max }), arrayConstraints).map((data) => TypedArrayClass.from(data), (value) => {
        if (!(value instanceof TypedArrayClass))
            throw new Error('Invalid type');
        return [...value];
    });
}
exports.typedIntArrayArbitraryArbitraryBuilder = typedIntArrayArbitraryArbitraryBuilder;


/***/ }),

/***/ 57218:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildUriPathArbitrary = void 0;
const webSegment_1 = __webpack_require__(28845);
const array_1 = __webpack_require__(78309);
const SegmentsToPath_1 = __webpack_require__(66724);
function sqrtSize(size) {
    switch (size) {
        case 'xsmall':
            return ['xsmall', 'xsmall'];
        case 'small':
            return ['small', 'xsmall'];
        case 'medium':
            return ['small', 'small'];
        case 'large':
            return ['medium', 'small'];
        case 'xlarge':
            return ['medium', 'medium'];
    }
}
function buildUriPathArbitrary(resolvedSize) {
    const [segmentSize, numSegmentSize] = sqrtSize(resolvedSize);
    return (0, array_1.array)((0, webSegment_1.webSegment)({ size: segmentSize }), { size: numSegmentSize }).map(SegmentsToPath_1.segmentsToPathMapper, SegmentsToPath_1.segmentsToPathUnmapper);
}
exports.buildUriPathArbitrary = buildUriPathArbitrary;


/***/ }),

/***/ 65026:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildUriQueryOrFragmentArbitrary = void 0;
const CharacterRangeArbitraryBuilder_1 = __webpack_require__(40085);
const stringOf_1 = __webpack_require__(85082);
function buildUriQueryOrFragmentArbitrary(size) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@', '/', '?'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size });
}
exports.buildUriQueryOrFragmentArbitrary = buildUriQueryOrFragmentArbitrary;


/***/ }),

/***/ 35394:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.logLike64 = exports.halve64 = exports.add64 = exports.negative64 = exports.substract64 = exports.clone64 = exports.isStrictlySmaller64 = exports.isEqual64 = exports.isStrictlyPositive64 = exports.isStrictlyNegative64 = exports.isZero64 = exports.Unit64 = exports.Zero64 = void 0;
exports.Zero64 = { sign: 1, data: [0, 0] };
exports.Unit64 = { sign: 1, data: [0, 1] };
function isZero64(a) {
    return a.data[0] === 0 && a.data[1] === 0;
}
exports.isZero64 = isZero64;
function isStrictlyNegative64(a) {
    return a.sign === -1 && !isZero64(a);
}
exports.isStrictlyNegative64 = isStrictlyNegative64;
function isStrictlyPositive64(a) {
    return a.sign === 1 && !isZero64(a);
}
exports.isStrictlyPositive64 = isStrictlyPositive64;
function isEqual64(a, b) {
    if (a.data[0] === b.data[0] && a.data[1] === b.data[1]) {
        return a.sign === b.sign || (a.data[0] === 0 && a.data[1] === 0);
    }
    return false;
}
exports.isEqual64 = isEqual64;
function isStrictlySmaller64Internal(a, b) {
    return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);
}
function isStrictlySmaller64(a, b) {
    if (a.sign === b.sign) {
        return a.sign === 1
            ? isStrictlySmaller64Internal(a.data, b.data)
            : isStrictlySmaller64Internal(b.data, a.data);
    }
    return a.sign === -1 && (!isZero64(a) || !isZero64(b));
}
exports.isStrictlySmaller64 = isStrictlySmaller64;
function clone64(a) {
    return { sign: a.sign, data: [a.data[0], a.data[1]] };
}
exports.clone64 = clone64;
function substract64DataInternal(a, b) {
    let reminderLow = 0;
    let low = a[1] - b[1];
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    return [a[0] - b[0] - reminderLow, low];
}
function substract64Internal(a, b) {
    if (a.sign === 1 && b.sign === -1) {
        const low = a.data[1] + b.data[1];
        const high = a.data[0] + b.data[0] + (low > 0xffffffff ? 1 : 0);
        return { sign: 1, data: [high >>> 0, low >>> 0] };
    }
    return {
        sign: 1,
        data: a.sign === 1 ? substract64DataInternal(a.data, b.data) : substract64DataInternal(b.data, a.data),
    };
}
function substract64(arrayIntA, arrayIntB) {
    if (isStrictlySmaller64(arrayIntA, arrayIntB)) {
        const out = substract64Internal(arrayIntB, arrayIntA);
        out.sign = -1;
        return out;
    }
    return substract64Internal(arrayIntA, arrayIntB);
}
exports.substract64 = substract64;
function negative64(arrayIntA) {
    return {
        sign: -arrayIntA.sign,
        data: [arrayIntA.data[0], arrayIntA.data[1]],
    };
}
exports.negative64 = negative64;
function add64(arrayIntA, arrayIntB) {
    if (isZero64(arrayIntB)) {
        if (isZero64(arrayIntA)) {
            return clone64(exports.Zero64);
        }
        return clone64(arrayIntA);
    }
    return substract64(arrayIntA, negative64(arrayIntB));
}
exports.add64 = add64;
function halve64(a) {
    return {
        sign: a.sign,
        data: [Math.floor(a.data[0] / 2), (a.data[0] % 2 === 1 ? 0x80000000 : 0) + Math.floor(a.data[1] / 2)],
    };
}
exports.halve64 = halve64;
function logLike64(a) {
    return {
        sign: a.sign,
        data: [0, Math.floor(Math.log(a.data[0] * 0x100000000 + a.data[1]) / Math.log(2))],
    };
}
exports.logLike64 = logLike64;


/***/ }),

/***/ 96352:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.biasNumericRange = exports.bigIntLogLike = exports.integerLogLike = void 0;
function integerLogLike(v) {
    return Math.floor(Math.log(v) / Math.log(2));
}
exports.integerLogLike = integerLogLike;
function bigIntLogLike(v) {
    if (v === BigInt(0))
        return BigInt(0);
    return BigInt(v.toString().length);
}
exports.bigIntLogLike = bigIntLogLike;
function biasNumericRange(min, max, logLike) {
    if (min === max) {
        return [{ min: min, max: max }];
    }
    if (min < 0 && max > 0) {
        const logMin = logLike(-min);
        const logMax = logLike(max);
        return [
            { min: -logMin, max: logMax },
            { min: (max - logMax), max: max },
            { min: min, max: min + logMin },
        ];
    }
    const logGap = logLike((max - min));
    const arbCloseToMin = { min: min, max: min + logGap };
    const arbCloseToMax = { min: (max - logGap), max: max };
    return min < 0
        ? [arbCloseToMax, arbCloseToMin]
        : [arbCloseToMin, arbCloseToMax];
}
exports.biasNumericRange = biasNumericRange;


/***/ }),

/***/ 15536:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildSchedulerFor = void 0;
const SchedulerImplem_1 = __webpack_require__(31821);
function buildNextTaskIndex(ordering) {
    let numTasks = 0;
    return {
        clone: () => buildNextTaskIndex(ordering),
        nextTaskIndex: (scheduledTasks) => {
            if (ordering.length <= numTasks) {
                throw new Error(`Invalid schedulerFor defined: too many tasks have been scheduled`);
            }
            const taskIndex = scheduledTasks.findIndex((t) => t.taskId === ordering[numTasks]);
            if (taskIndex === -1) {
                throw new Error(`Invalid schedulerFor defined: unable to find next task`);
            }
            ++numTasks;
            return taskIndex;
        },
    };
}
function buildSchedulerFor(act, ordering) {
    return new SchedulerImplem_1.SchedulerImplem(act, buildNextTaskIndex(ordering));
}
exports.buildSchedulerFor = buildSchedulerFor;


/***/ }),

/***/ 85817:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildSlicedGenerator = void 0;
const NoopSlicedGenerator_1 = __webpack_require__(16149);
const SlicedBasedGenerator_1 = __webpack_require__(73347);
function buildSlicedGenerator(arb, mrng, slices, biasFactor) {
    if (biasFactor === undefined || slices.length === 0 || mrng.nextInt(1, biasFactor) !== 1) {
        return new NoopSlicedGenerator_1.NoopSlicedGenerator(arb, mrng, biasFactor);
    }
    return new SlicedBasedGenerator_1.SlicedBasedGenerator(arb, mrng, slices, biasFactor);
}
exports.buildSlicedGenerator = buildSlicedGenerator;


/***/ }),

/***/ 61839:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomEqualSet = void 0;
class CustomEqualSet {
    constructor(isEqual) {
        this.isEqual = isEqual;
        this.data = [];
    }
    tryAdd(value) {
        for (let idx = 0; idx !== this.data.length; ++idx) {
            if (this.isEqual(this.data[idx], value)) {
                return false;
            }
        }
        this.data.push(value);
        return true;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data.slice();
    }
}
exports.CustomEqualSet = CustomEqualSet;


/***/ }),

/***/ 10514:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDepthIdentifier = exports.getDepthContextFor = void 0;
const depthContextCache = new Map();
function getDepthContextFor(contextMeta) {
    if (contextMeta === undefined) {
        return { depth: 0 };
    }
    if (typeof contextMeta !== 'string') {
        return contextMeta;
    }
    const cachedContext = depthContextCache.get(contextMeta);
    if (cachedContext !== undefined) {
        return cachedContext;
    }
    const context = { depth: 0 };
    depthContextCache.set(contextMeta, context);
    return context;
}
exports.getDepthContextFor = getDepthContextFor;
function createDepthIdentifier() {
    const identifier = { depth: 0 };
    return identifier;
}
exports.createDepthIdentifier = createDepthIdentifier;


/***/ }),

/***/ 87034:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToDouble = exports.doubleToIndex = exports.decomposeDouble = void 0;
const ArrayInt64_1 = __webpack_require__(35394);
const INDEX_POSITIVE_INFINITY = { sign: 1, data: [2146435072, 0] };
const INDEX_NEGATIVE_INFINITY = { sign: -1, data: [2146435072, 1] };
function decomposeDouble(d) {
    const maxSignificand = 2 - Number.EPSILON;
    for (let exponent = -1022; exponent !== 1024; ++exponent) {
        const powExponent = 2 ** exponent;
        const maxForExponent = maxSignificand * powExponent;
        if (Math.abs(d) <= maxForExponent) {
            return { exponent, significand: d / powExponent };
        }
    }
    return { exponent: Number.NaN, significand: Number.NaN };
}
exports.decomposeDouble = decomposeDouble;
function positiveNumberToInt64(n) {
    return [~~(n / 0x100000000), n >>> 0];
}
function indexInDoubleFromDecomp(exponent, significand) {
    if (exponent === -1022) {
        const rescaledSignificand = significand * 2 ** 52;
        return positiveNumberToInt64(rescaledSignificand);
    }
    const rescaledSignificand = (significand - 1) * 2 ** 52;
    const exponentOnlyHigh = (exponent + 1023) * 2 ** 20;
    const index = positiveNumberToInt64(rescaledSignificand);
    index[0] += exponentOnlyHigh;
    return index;
}
function doubleToIndex(d) {
    if (d === Number.POSITIVE_INFINITY) {
        return (0, ArrayInt64_1.clone64)(INDEX_POSITIVE_INFINITY);
    }
    if (d === Number.NEGATIVE_INFINITY) {
        return (0, ArrayInt64_1.clone64)(INDEX_NEGATIVE_INFINITY);
    }
    const decomp = decomposeDouble(d);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (d > 0 || (d === 0 && 1 / d === Number.POSITIVE_INFINITY)) {
        return { sign: 1, data: indexInDoubleFromDecomp(exponent, significand) };
    }
    else {
        const indexOpposite = indexInDoubleFromDecomp(exponent, -significand);
        if (indexOpposite[1] === 0xffffffff) {
            indexOpposite[0] += 1;
            indexOpposite[1] = 0;
        }
        else {
            indexOpposite[1] += 1;
        }
        return { sign: -1, data: indexOpposite };
    }
}
exports.doubleToIndex = doubleToIndex;
function indexToDouble(index) {
    if (index.sign === -1) {
        const indexOpposite = { sign: 1, data: [index.data[0], index.data[1]] };
        if (indexOpposite.data[1] === 0) {
            indexOpposite.data[0] -= 1;
            indexOpposite.data[1] = 0xffffffff;
        }
        else {
            indexOpposite.data[1] -= 1;
        }
        return -indexToDouble(indexOpposite);
    }
    if ((0, ArrayInt64_1.isEqual64)(index, INDEX_POSITIVE_INFINITY)) {
        return Number.POSITIVE_INFINITY;
    }
    if (index.data[0] < 0x200000) {
        return (index.data[0] * 0x100000000 + index.data[1]) * 2 ** -1074;
    }
    const postIndexHigh = index.data[0] - 0x200000;
    const exponent = -1021 + (postIndexHigh >> 20);
    const significand = 1 + ((postIndexHigh & 0xfffff) * 2 ** 32 + index.data[1]) * Number.EPSILON;
    return significand * 2 ** exponent;
}
exports.indexToDouble = indexToDouble;


/***/ }),

/***/ 34322:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extractEnumerableKeys = void 0;
function extractEnumerableKeys(instance) {
    const keys = Object.keys(instance);
    const symbols = Object.getOwnPropertySymbols(instance);
    for (let index = 0; index !== symbols.length; ++index) {
        const symbol = symbols[index];
        const descriptor = Object.getOwnPropertyDescriptor(instance, symbol);
        if (descriptor && descriptor.enumerable) {
            keys.push(symbol);
        }
    }
    return keys;
}
exports.extractEnumerableKeys = extractEnumerableKeys;


/***/ }),

/***/ 64301:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToFloat = exports.floatToIndex = exports.decomposeFloat = exports.EPSILON_32 = exports.MAX_VALUE_32 = exports.MIN_VALUE_32 = void 0;
exports.MIN_VALUE_32 = 2 ** -126 * 2 ** -23;
exports.MAX_VALUE_32 = 2 ** 127 * (1 + (2 ** 23 - 1) / 2 ** 23);
exports.EPSILON_32 = 2 ** -23;
const INDEX_POSITIVE_INFINITY = 2139095040;
const INDEX_NEGATIVE_INFINITY = -2139095041;
function decomposeFloat(f) {
    const maxSignificand = 1 + (2 ** 23 - 1) / 2 ** 23;
    for (let exponent = -126; exponent !== 128; ++exponent) {
        const powExponent = 2 ** exponent;
        const maxForExponent = maxSignificand * powExponent;
        if (Math.abs(f) <= maxForExponent) {
            return { exponent, significand: f / powExponent };
        }
    }
    return { exponent: Number.NaN, significand: Number.NaN };
}
exports.decomposeFloat = decomposeFloat;
function indexInFloatFromDecomp(exponent, significand) {
    if (exponent === -126) {
        return significand * 0x800000;
    }
    return (exponent + 127) * 0x800000 + (significand - 1) * 0x800000;
}
function floatToIndex(f) {
    if (f === Number.POSITIVE_INFINITY) {
        return INDEX_POSITIVE_INFINITY;
    }
    if (f === Number.NEGATIVE_INFINITY) {
        return INDEX_NEGATIVE_INFINITY;
    }
    const decomp = decomposeFloat(f);
    const exponent = decomp.exponent;
    const significand = decomp.significand;
    if (Number.isNaN(exponent) || Number.isNaN(significand) || !Number.isInteger(significand * 0x800000)) {
        return Number.NaN;
    }
    if (f > 0 || (f === 0 && 1 / f === Number.POSITIVE_INFINITY)) {
        return indexInFloatFromDecomp(exponent, significand);
    }
    else {
        return -indexInFloatFromDecomp(exponent, -significand) - 1;
    }
}
exports.floatToIndex = floatToIndex;
function indexToFloat(index) {
    if (index < 0) {
        return -indexToFloat(-index - 1);
    }
    if (index === INDEX_POSITIVE_INFINITY) {
        return Number.POSITIVE_INFINITY;
    }
    if (index < 0x1000000) {
        return index * 2 ** -149;
    }
    const postIndex = index - 0x1000000;
    const exponent = -125 + (postIndex >> 23);
    const significand = 1 + (postIndex & 0x7fffff) / 0x800000;
    return significand * 2 ** exponent;
}
exports.indexToFloat = indexToFloat;


/***/ }),

/***/ 37913:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.filterInvalidSubdomainLabel = void 0;
function filterInvalidSubdomainLabel(subdomainLabel) {
    if (subdomainLabel.length > 63) {
        return false;
    }
    return (subdomainLabel.length < 4 ||
        subdomainLabel[0] !== 'x' ||
        subdomainLabel[1] !== 'n' ||
        subdomainLabel[2] !== '-' ||
        subdomainLabel[3] !== '-');
}
exports.filterInvalidSubdomainLabel = filterInvalidSubdomainLabel;


/***/ }),

/***/ 90743:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSubarrayOf = void 0;
function isSubarrayOf(source, small) {
    const countMap = new Map();
    let countMinusZero = 0;
    for (const sourceEntry of source) {
        if (Object.is(sourceEntry, -0)) {
            ++countMinusZero;
        }
        else {
            const oldCount = countMap.get(sourceEntry) || 0;
            countMap.set(sourceEntry, oldCount + 1);
        }
    }
    for (let index = 0; index !== small.length; ++index) {
        if (!(index in small)) {
            return false;
        }
        const smallEntry = small[index];
        if (Object.is(smallEntry, -0)) {
            if (countMinusZero === 0)
                return false;
            --countMinusZero;
        }
        else {
            const oldCount = countMap.get(smallEntry) || 0;
            if (oldCount === 0)
                return false;
            countMap.set(smallEntry, oldCount - 1);
        }
    }
    return true;
}
exports.isSubarrayOf = isSubarrayOf;


/***/ }),

/***/ 29143:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.jsonConstraintsBuilder = void 0;
const boolean_1 = __webpack_require__(81258);
const constant_1 = __webpack_require__(27440);
const double_1 = __webpack_require__(24893);
function jsonConstraintsBuilder(stringArbitrary, constraints) {
    const { depthSize, maxDepth } = constraints;
    const key = stringArbitrary;
    const values = [
        (0, boolean_1.boolean)(),
        (0, double_1.double)({ noDefaultInfinity: true, noNaN: true }),
        stringArbitrary,
        (0, constant_1.constant)(null),
    ];
    return { key, values, depthSize, maxDepth };
}
exports.jsonConstraintsBuilder = jsonConstraintsBuilder;


/***/ }),

/***/ 70883:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveSize = exports.depthBiasFromSizeForArbitrary = exports.maxGeneratedLengthFromSizeForArbitrary = exports.relativeSizeToSize = exports.maxLengthFromMinLength = exports.DefaultSize = exports.MaxLengthUpperBound = void 0;
const GlobalParameters_1 = __webpack_require__(85165);
exports.MaxLengthUpperBound = 0x7fffffff;
const orderedSize = ['xsmall', 'small', 'medium', 'large', 'xlarge'];
const orderedRelativeSize = ['-4', '-3', '-2', '-1', '=', '+1', '+2', '+3', '+4'];
exports.DefaultSize = 'small';
function maxLengthFromMinLength(minLength, size) {
    switch (size) {
        case 'xsmall':
            return Math.floor(1.1 * minLength) + 1;
        case 'small':
            return 2 * minLength + 10;
        case 'medium':
            return 11 * minLength + 100;
        case 'large':
            return 101 * minLength + 1000;
        case 'xlarge':
            return 1001 * minLength + 10000;
        default:
            throw new Error(`Unable to compute lengths based on received size: ${size}`);
    }
}
exports.maxLengthFromMinLength = maxLengthFromMinLength;
function relativeSizeToSize(size, defaultSize) {
    const sizeInRelative = orderedRelativeSize.indexOf(size);
    if (sizeInRelative === -1) {
        return size;
    }
    const defaultSizeInSize = orderedSize.indexOf(defaultSize);
    if (defaultSizeInSize === -1) {
        throw new Error(`Unable to offset size based on the unknown defaulted one: ${defaultSize}`);
    }
    const resultingSizeInSize = defaultSizeInSize + sizeInRelative - 4;
    return resultingSizeInSize < 0
        ? orderedSize[0]
        : resultingSizeInSize >= orderedSize.length
            ? orderedSize[orderedSize.length - 1]
            : orderedSize[resultingSizeInSize];
}
exports.relativeSizeToSize = relativeSizeToSize;
function maxGeneratedLengthFromSizeForArbitrary(size, minLength, maxLength, specifiedMaxLength) {
    const { baseSize: defaultSize = exports.DefaultSize, defaultSizeToMaxWhenMaxSpecified } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
    const definedSize = size !== undefined ? size : specifiedMaxLength && defaultSizeToMaxWhenMaxSpecified ? 'max' : defaultSize;
    if (definedSize === 'max') {
        return maxLength;
    }
    const finalSize = relativeSizeToSize(definedSize, defaultSize);
    return Math.min(maxLengthFromMinLength(minLength, finalSize), maxLength);
}
exports.maxGeneratedLengthFromSizeForArbitrary = maxGeneratedLengthFromSizeForArbitrary;
function depthBiasFromSizeForArbitrary(depthSizeOrSize, specifiedMaxDepth) {
    if (typeof depthSizeOrSize === 'number') {
        return 1 / depthSizeOrSize;
    }
    const { baseSize: defaultSize = exports.DefaultSize, defaultSizeToMaxWhenMaxSpecified } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
    const definedSize = depthSizeOrSize !== undefined
        ? depthSizeOrSize
        : specifiedMaxDepth && defaultSizeToMaxWhenMaxSpecified
            ? 'max'
            : defaultSize;
    if (definedSize === 'max') {
        return 0;
    }
    const finalSize = relativeSizeToSize(definedSize, defaultSize);
    switch (finalSize) {
        case 'xsmall':
            return 1;
        case 'small':
            return 0.5;
        case 'medium':
            return 0.25;
        case 'large':
            return 0.125;
        case 'xlarge':
            return 0.0625;
    }
}
exports.depthBiasFromSizeForArbitrary = depthBiasFromSizeForArbitrary;
function resolveSize(size) {
    const { baseSize: defaultSize = exports.DefaultSize } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
    if (size === undefined) {
        return defaultSize;
    }
    return relativeSizeToSize(size, defaultSize);
}
exports.resolveSize = resolveSize;


/***/ }),

/***/ 21549:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noUndefinedAsContext = exports.UndefinedContextPlaceholder = void 0;
const Value_1 = __webpack_require__(60641);
exports.UndefinedContextPlaceholder = Symbol('UndefinedContextPlaceholder');
function noUndefinedAsContext(value) {
    if (value.context !== undefined) {
        return value;
    }
    if (value.hasToBeCloned) {
        return new Value_1.Value(value.value_, exports.UndefinedContextPlaceholder, () => value.value);
    }
    return new Value_1.Value(value.value_, exports.UndefinedContextPlaceholder);
}
exports.noUndefinedAsContext = noUndefinedAsContext;


/***/ }),

/***/ 92113:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toQualifiedObjectConstraints = void 0;
const boolean_1 = __webpack_require__(81258);
const constant_1 = __webpack_require__(27440);
const double_1 = __webpack_require__(24893);
const maxSafeInteger_1 = __webpack_require__(39371);
const oneof_1 = __webpack_require__(89752);
const string_1 = __webpack_require__(22320);
const BoxedArbitraryBuilder_1 = __webpack_require__(42650);
function defaultValues(constraints) {
    return [
        (0, boolean_1.boolean)(),
        (0, maxSafeInteger_1.maxSafeInteger)(),
        (0, double_1.double)(),
        (0, string_1.string)(constraints),
        (0, oneof_1.oneof)((0, string_1.string)(constraints), (0, constant_1.constant)(null), (0, constant_1.constant)(undefined)),
    ];
}
function boxArbitraries(arbs) {
    return arbs.map((arb) => (0, BoxedArbitraryBuilder_1.boxedArbitraryBuilder)(arb));
}
function boxArbitrariesIfNeeded(arbs, boxEnabled) {
    return boxEnabled ? boxArbitraries(arbs).concat(arbs) : arbs;
}
function toQualifiedObjectConstraints(settings = {}) {
    function orDefault(optionalValue, defaultValue) {
        return optionalValue !== undefined ? optionalValue : defaultValue;
    }
    const valueConstraints = { size: settings.size };
    return {
        key: orDefault(settings.key, (0, string_1.string)(valueConstraints)),
        values: boxArbitrariesIfNeeded(orDefault(settings.values, defaultValues(valueConstraints)), orDefault(settings.withBoxedValues, false)),
        depthSize: settings.depthSize,
        maxDepth: settings.maxDepth,
        maxKeys: settings.maxKeys,
        size: settings.size,
        withSet: orDefault(settings.withSet, false),
        withMap: orDefault(settings.withMap, false),
        withObjectString: orDefault(settings.withObjectString, false),
        withNullPrototype: orDefault(settings.withNullPrototype, false),
        withBigInt: orDefault(settings.withBigInt, false),
        withDate: orDefault(settings.withDate, false),
        withTypedArray: orDefault(settings.withTypedArray, false),
        withSparseArray: orDefault(settings.withSparseArray, false),
    };
}
exports.toQualifiedObjectConstraints = toQualifiedObjectConstraints;


/***/ }),

/***/ 30556:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SameValueSet = void 0;
class SameValueSet {
    constructor(selector) {
        this.selector = selector;
        this.selectedItemsExceptMinusZero = new Set();
        this.data = [];
        this.hasMinusZero = false;
    }
    tryAdd(value) {
        const selected = this.selector(value);
        if (Object.is(selected, -0)) {
            if (this.hasMinusZero) {
                return false;
            }
            this.data.push(value);
            this.hasMinusZero = true;
            return true;
        }
        const sizeBefore = this.selectedItemsExceptMinusZero.size;
        this.selectedItemsExceptMinusZero.add(selected);
        if (sizeBefore !== this.selectedItemsExceptMinusZero.size) {
            this.data.push(value);
            return true;
        }
        return false;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}
exports.SameValueSet = SameValueSet;


/***/ }),

/***/ 47238:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SameValueZeroSet = void 0;
class SameValueZeroSet {
    constructor(selector) {
        this.selector = selector;
        this.selectedItems = new Set();
        this.data = [];
    }
    tryAdd(value) {
        const selected = this.selector(value);
        const sizeBefore = this.selectedItems.size;
        this.selectedItems.add(selected);
        if (sizeBefore !== this.selectedItems.size) {
            this.data.push(value);
            return true;
        }
        return false;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}
exports.SameValueZeroSet = SameValueZeroSet;


/***/ }),

/***/ 61798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shrinkBigInt = void 0;
const Stream_1 = __webpack_require__(99385);
const Value_1 = __webpack_require__(60641);
function halveBigInt(n) {
    return n / BigInt(2);
}
function shrinkBigInt(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for (let toremove = gap; toremove > 0; toremove = halveBigInt(toremove)) {
            const next = current - toremove;
            yield new Value_1.Value(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveBigInt(realGap);
        for (let toremove = gap; toremove < 0; toremove = halveBigInt(toremove)) {
            const next = current - toremove;
            yield new Value_1.Value(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? (0, Stream_1.stream)(shrinkDecr()) : (0, Stream_1.stream)(shrinkIncr());
}
exports.shrinkBigInt = shrinkBigInt;


/***/ }),

/***/ 28378:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shrinkInteger = void 0;
const Value_1 = __webpack_require__(60641);
const Stream_1 = __webpack_require__(99385);
function halvePosInteger(n) {
    return Math.floor(n / 2);
}
function halveNegInteger(n) {
    return Math.ceil(n / 2);
}
function shrinkInteger(current, target, tryTargetAsap) {
    const realGap = current - target;
    function* shrinkDecr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halvePosInteger(realGap);
        for (let toremove = gap; toremove > 0; toremove = halvePosInteger(toremove)) {
            const next = toremove === realGap ? target : current - toremove;
            yield new Value_1.Value(next, previous);
            previous = next;
        }
    }
    function* shrinkIncr() {
        let previous = tryTargetAsap ? undefined : target;
        const gap = tryTargetAsap ? realGap : halveNegInteger(realGap);
        for (let toremove = gap; toremove < 0; toremove = halveNegInteger(toremove)) {
            const next = toremove === realGap ? target : current - toremove;
            yield new Value_1.Value(next, previous);
            previous = next;
        }
    }
    return realGap > 0 ? (0, Stream_1.stream)(shrinkDecr()) : (0, Stream_1.stream)(shrinkIncr());
}
exports.shrinkInteger = shrinkInteger;


/***/ }),

/***/ 90381:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createSlicesForString = void 0;
const dangerousStrings = [
    '__defineGetter__',
    '__defineSetter__',
    '__lookupGetter__',
    '__lookupSetter__',
    '__proto__',
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf',
    'apply',
    'arguments',
    'bind',
    'call',
    'caller',
    'length',
    'name',
    'prototype',
    'key',
    'ref',
];
function computeCandidateString(dangerous, charArbitrary, stringSplitter) {
    let candidate;
    try {
        candidate = stringSplitter(dangerous);
    }
    catch (err) {
        return undefined;
    }
    for (const entry of candidate) {
        if (!charArbitrary.canShrinkWithoutContext(entry)) {
            return undefined;
        }
    }
    return candidate;
}
function createSlicesForString(charArbitrary, stringSplitter) {
    const slicesForString = [];
    for (const dangerous of dangerousStrings) {
        const candidate = computeCandidateString(dangerous, charArbitrary, stringSplitter);
        if (candidate !== undefined) {
            slicesForString.push(candidate);
        }
    }
    return slicesForString;
}
exports.createSlicesForString = createSlicesForString;


/***/ }),

/***/ 24423:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StrictlyEqualSet = void 0;
class StrictlyEqualSet {
    constructor(selector) {
        this.selector = selector;
        this.selectedItemsExceptNaN = new Set();
        this.data = [];
    }
    tryAdd(value) {
        const selected = this.selector(value);
        if (Number.isNaN(selected)) {
            this.data.push(value);
            return true;
        }
        const sizeBefore = this.selectedItemsExceptNaN.size;
        this.selectedItemsExceptNaN.add(selected);
        if (sizeBefore !== this.selectedItemsExceptNaN.size) {
            this.data.push(value);
            return true;
        }
        return false;
    }
    size() {
        return this.data.length;
    }
    getData() {
        return this.data;
    }
}
exports.StrictlyEqualSet = StrictlyEqualSet;


/***/ }),

/***/ 92325:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escapeForMultilineComments = exports.escapeForTemplateString = void 0;
function escapeForTemplateString(originalText) {
    return originalText.replace(/([$`\\])/g, '\\$1').replace(/\r/g, '\\r');
}
exports.escapeForTemplateString = escapeForTemplateString;
function escapeForMultilineComments(originalText) {
    return originalText.replace(/\*\//g, '*\\/');
}
exports.escapeForMultilineComments = escapeForMultilineComments;


/***/ }),

/***/ 57615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.applyFlagsOnChars = exports.computeFlagsFromChars = exports.computeTogglePositions = exports.computeNextFlags = exports.countToggledBits = void 0;
function countToggledBits(n) {
    let count = 0;
    while (n > BigInt(0)) {
        if (n & BigInt(1))
            ++count;
        n >>= BigInt(1);
    }
    return count;
}
exports.countToggledBits = countToggledBits;
function computeNextFlags(flags, nextSize) {
    const allowedMask = (BigInt(1) << BigInt(nextSize)) - BigInt(1);
    const preservedFlags = flags & allowedMask;
    let numMissingFlags = countToggledBits(flags - preservedFlags);
    let nFlags = preservedFlags;
    for (let mask = BigInt(1); mask <= allowedMask && numMissingFlags !== 0; mask <<= BigInt(1)) {
        if (!(nFlags & mask)) {
            nFlags |= mask;
            --numMissingFlags;
        }
    }
    return nFlags;
}
exports.computeNextFlags = computeNextFlags;
function computeTogglePositions(chars, toggleCase) {
    const positions = [];
    for (let idx = chars.length - 1; idx !== -1; --idx) {
        if (toggleCase(chars[idx]) !== chars[idx])
            positions.push(idx);
    }
    return positions;
}
exports.computeTogglePositions = computeTogglePositions;
function computeFlagsFromChars(untoggledChars, toggledChars, togglePositions) {
    let flags = BigInt(0);
    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {
        if (untoggledChars[togglePositions[idx]] !== toggledChars[togglePositions[idx]]) {
            flags |= mask;
        }
    }
    return flags;
}
exports.computeFlagsFromChars = computeFlagsFromChars;
function applyFlagsOnChars(chars, flags, togglePositions, toggleCase) {
    for (let idx = 0, mask = BigInt(1); idx !== togglePositions.length; ++idx, mask <<= BigInt(1)) {
        if (flags & mask)
            chars[togglePositions[idx]] = toggleCase(chars[togglePositions[idx]]);
    }
}
exports.applyFlagsOnChars = applyFlagsOnChars;


/***/ }),

/***/ 16149:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoopSlicedGenerator = void 0;
class NoopSlicedGenerator {
    constructor(arb, mrng, biasFactor) {
        this.arb = arb;
        this.mrng = mrng;
        this.biasFactor = biasFactor;
    }
    attemptExact() {
        return;
    }
    next() {
        return this.arb.generate(this.mrng, this.biasFactor);
    }
}
exports.NoopSlicedGenerator = NoopSlicedGenerator;


/***/ }),

/***/ 31821:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SchedulerImplem = void 0;
const TextEscaper_1 = __webpack_require__(92325);
const symbols_1 = __webpack_require__(28620);
const stringify_1 = __webpack_require__(21954);
class SchedulerImplem {
    constructor(act, taskSelector) {
        this.act = act;
        this.taskSelector = taskSelector;
        this.lastTaskId = 0;
        this.sourceTaskSelector = taskSelector.clone();
        this.scheduledTasks = [];
        this.triggeredTasks = [];
        this.scheduledWatchers = [];
    }
    static buildLog(reportItem) {
        return `[task\${${reportItem.taskId}}] ${reportItem.label.length !== 0 ? `${reportItem.schedulingType}::${reportItem.label}` : reportItem.schedulingType} ${reportItem.status}${reportItem.outputValue !== undefined ? ` with value ${(0, TextEscaper_1.escapeForTemplateString)(reportItem.outputValue)}` : ''}`;
    }
    log(schedulingType, taskId, label, metadata, status, data) {
        this.triggeredTasks.push({
            status,
            schedulingType,
            taskId,
            label,
            metadata,
            outputValue: data !== undefined ? (0, stringify_1.stringify)(data) : undefined,
        });
    }
    scheduleInternal(schedulingType, label, task, metadata, thenTaskToBeAwaited) {
        let trigger = null;
        const taskId = ++this.lastTaskId;
        const scheduledPromise = new Promise((resolve, reject) => {
            trigger = () => {
                (thenTaskToBeAwaited ? task.then(() => thenTaskToBeAwaited()) : task).then((data) => {
                    this.log(schedulingType, taskId, label, metadata, 'resolved', data);
                    return resolve(data);
                }, (err) => {
                    this.log(schedulingType, taskId, label, metadata, 'rejected', err);
                    return reject(err);
                });
            };
        });
        this.scheduledTasks.push({
            original: task,
            scheduled: scheduledPromise,
            trigger: trigger,
            schedulingType,
            taskId,
            label,
            metadata,
        });
        if (this.scheduledWatchers.length !== 0) {
            this.scheduledWatchers[0]();
        }
        return scheduledPromise;
    }
    schedule(task, label, metadata) {
        return this.scheduleInternal('promise', label || '', task, metadata);
    }
    scheduleFunction(asyncFunction) {
        return (...args) => this.scheduleInternal('function', `${asyncFunction.name}(${args.map(stringify_1.stringify).join(',')})`, asyncFunction(...args), undefined);
    }
    scheduleSequence(sequenceBuilders) {
        const status = { done: false, faulty: false };
        const dummyResolvedPromise = { then: (f) => f() };
        let resolveSequenceTask = () => { };
        const sequenceTask = new Promise((resolve) => (resolveSequenceTask = resolve));
        sequenceBuilders
            .reduce((previouslyScheduled, item) => {
            const [builder, label, metadata] = typeof item === 'function' ? [item, item.name, undefined] : [item.builder, item.label, item.metadata];
            return previouslyScheduled.then(() => {
                const scheduled = this.scheduleInternal('sequence', label, dummyResolvedPromise, metadata, () => builder());
                scheduled.catch(() => {
                    status.faulty = true;
                    resolveSequenceTask();
                });
                return scheduled;
            });
        }, dummyResolvedPromise)
            .then(() => {
            status.done = true;
            resolveSequenceTask();
        }, () => {
        });
        return Object.assign(status, {
            task: Promise.resolve(sequenceTask).then(() => {
                return { done: status.done, faulty: status.faulty };
            }),
        });
    }
    count() {
        return this.scheduledTasks.length;
    }
    async internalWaitOne() {
        if (this.scheduledTasks.length === 0) {
            throw new Error('No task scheduled');
        }
        const taskIndex = this.taskSelector.nextTaskIndex(this.scheduledTasks);
        const [scheduledTask] = this.scheduledTasks.splice(taskIndex, 1);
        scheduledTask.trigger();
        try {
            await scheduledTask.scheduled;
        }
        catch (_err) {
        }
    }
    async waitOne() {
        await this.act(async () => await this.internalWaitOne());
    }
    async waitAll() {
        while (this.scheduledTasks.length > 0) {
            await this.waitOne();
        }
    }
    async waitFor(unscheduledTask) {
        let taskResolved = false;
        let awaiterPromise = null;
        const awaiter = async () => {
            while (!taskResolved && this.scheduledTasks.length > 0) {
                await this.waitOne();
            }
            awaiterPromise = null;
        };
        const handleNotified = () => {
            if (awaiterPromise !== null) {
                return;
            }
            awaiterPromise = Promise.resolve().then(awaiter);
        };
        const clearAndReplaceWatcher = () => {
            const handleNotifiedIndex = this.scheduledWatchers.indexOf(handleNotified);
            if (handleNotifiedIndex !== -1) {
                this.scheduledWatchers.splice(handleNotifiedIndex, 1);
            }
            if (handleNotifiedIndex === 0 && this.scheduledWatchers.length !== 0) {
                this.scheduledWatchers[0]();
            }
        };
        const rewrappedTask = unscheduledTask.then((ret) => {
            taskResolved = true;
            if (awaiterPromise === null) {
                clearAndReplaceWatcher();
                return ret;
            }
            return awaiterPromise.then(() => {
                clearAndReplaceWatcher();
                return ret;
            });
        }, (err) => {
            taskResolved = true;
            if (awaiterPromise === null) {
                clearAndReplaceWatcher();
                throw err;
            }
            return awaiterPromise.then(() => {
                clearAndReplaceWatcher();
                throw err;
            });
        });
        if (this.scheduledTasks.length > 0 && this.scheduledWatchers.length === 0) {
            handleNotified();
        }
        this.scheduledWatchers.push(handleNotified);
        return rewrappedTask;
    }
    report() {
        return [
            ...this.triggeredTasks,
            ...this.scheduledTasks.map((t) => ({
                status: 'pending',
                schedulingType: t.schedulingType,
                taskId: t.taskId,
                label: t.label,
                metadata: t.metadata,
            })),
        ];
    }
    toString() {
        return ('schedulerFor()`\n' +
            this.report()
                .map(SchedulerImplem.buildLog)
                .map((log) => `-> ${log}`)
                .join('\n') +
            '`');
    }
    [symbols_1.cloneMethod]() {
        return new SchedulerImplem(this.act, this.sourceTaskSelector);
    }
}
exports.SchedulerImplem = SchedulerImplem;


/***/ }),

/***/ 73347:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlicedBasedGenerator = void 0;
const Value_1 = __webpack_require__(60641);
class SlicedBasedGenerator {
    constructor(arb, mrng, slices, biasFactor) {
        this.arb = arb;
        this.mrng = mrng;
        this.slices = slices;
        this.biasFactor = biasFactor;
        this.activeSliceIndex = 0;
        this.nextIndexInSlice = 0;
        this.lastIndexInSlice = -1;
    }
    attemptExact(targetLength) {
        if (targetLength !== 0 && this.mrng.nextInt(1, this.biasFactor) === 1) {
            const eligibleIndices = [];
            for (let index = 0; index !== this.slices.length; ++index) {
                const slice = this.slices[index];
                if (slice.length === targetLength) {
                    eligibleIndices.push(index);
                }
            }
            if (eligibleIndices.length === 0) {
                return;
            }
            this.activeSliceIndex = eligibleIndices[this.mrng.nextInt(0, eligibleIndices.length - 1)];
            this.nextIndexInSlice = 0;
            this.lastIndexInSlice = targetLength - 1;
        }
    }
    next() {
        if (this.nextIndexInSlice <= this.lastIndexInSlice) {
            return new Value_1.Value(this.slices[this.activeSliceIndex][this.nextIndexInSlice++], undefined);
        }
        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
            return this.arb.generate(this.mrng, this.biasFactor);
        }
        this.activeSliceIndex = this.mrng.nextInt(0, this.slices.length - 1);
        const slice = this.slices[this.activeSliceIndex];
        if (this.mrng.nextInt(1, this.biasFactor) !== 1) {
            this.nextIndexInSlice = 1;
            this.lastIndexInSlice = slice.length - 1;
            return new Value_1.Value(slice[0], undefined);
        }
        const rangeBoundaryA = this.mrng.nextInt(0, slice.length - 1);
        const rangeBoundaryB = this.mrng.nextInt(0, slice.length - 1);
        this.nextIndexInSlice = Math.min(rangeBoundaryA, rangeBoundaryB);
        this.lastIndexInSlice = Math.max(rangeBoundaryA, rangeBoundaryB);
        return new Value_1.Value(slice[this.nextIndexInSlice++], undefined);
    }
}
exports.SlicedBasedGenerator = SlicedBasedGenerator;


/***/ }),

/***/ 39175:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayToMapUnmapper = exports.arrayToMapMapper = void 0;
function arrayToMapMapper(data) {
    return new Map(data);
}
exports.arrayToMapMapper = arrayToMapMapper;
function arrayToMapUnmapper(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Incompatible instance received: should be a non-null object');
    }
    if (!('constructor' in value) || value.constructor !== Map) {
        throw new Error('Incompatible instance received: should be of exact type Map');
    }
    return Array.from(value);
}
exports.arrayToMapUnmapper = arrayToMapUnmapper;


/***/ }),

/***/ 62865:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.arrayToSetUnmapper = exports.arrayToSetMapper = void 0;
function arrayToSetMapper(data) {
    return new Set(data);
}
exports.arrayToSetMapper = arrayToSetMapper;
function arrayToSetUnmapper(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Incompatible instance received: should be a non-null object');
    }
    if (!('constructor' in value) || value.constructor !== Set) {
        throw new Error('Incompatible instance received: should be of exact type Set');
    }
    return Array.from(value);
}
exports.arrayToSetUnmapper = arrayToSetUnmapper;


/***/ }),

/***/ 70049:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.charsToStringUnmapper = exports.charsToStringMapper = void 0;
function charsToStringMapper(tab) {
    return tab.join('');
}
exports.charsToStringMapper = charsToStringMapper;
function charsToStringUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Cannot unmap the passed value');
    }
    return value.split('');
}
exports.charsToStringUnmapper = charsToStringUnmapper;


/***/ }),

/***/ 70172:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.codePointsToStringUnmapper = exports.codePointsToStringMapper = void 0;
function codePointsToStringMapper(tab) {
    return tab.join('');
}
exports.codePointsToStringMapper = codePointsToStringMapper;
function codePointsToStringUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Cannot unmap the passed value');
    }
    return [...value];
}
exports.codePointsToStringUnmapper = codePointsToStringUnmapper;


/***/ }),

/***/ 72210:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.noTrailingUnmapper = exports.noTrailingMapper = exports.singleTrailingUnmapper = exports.singleTrailingMapper = exports.multiTrailingUnmapperOne = exports.multiTrailingMapperOne = exports.multiTrailingUnmapper = exports.multiTrailingMapper = exports.onlyTrailingUnmapper = exports.onlyTrailingMapper = exports.fullySpecifiedUnmapper = exports.fullySpecifiedMapper = void 0;
function readBh(value) {
    if (value.length === 0)
        return [];
    else
        return value.split(':');
}
function extractEhAndL(value) {
    const valueSplits = value.split(':');
    if (valueSplits.length >= 2 && valueSplits[valueSplits.length - 1].length <= 4) {
        return [
            valueSplits.slice(0, valueSplits.length - 2),
            `${valueSplits[valueSplits.length - 2]}:${valueSplits[valueSplits.length - 1]}`,
        ];
    }
    return [valueSplits.slice(0, valueSplits.length - 1), valueSplits[valueSplits.length - 1]];
}
function fullySpecifiedMapper(data) {
    return `${data[0].join(':')}:${data[1]}`;
}
exports.fullySpecifiedMapper = fullySpecifiedMapper;
function fullySpecifiedUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    return extractEhAndL(value);
}
exports.fullySpecifiedUnmapper = fullySpecifiedUnmapper;
function onlyTrailingMapper(data) {
    return `::${data[0].join(':')}:${data[1]}`;
}
exports.onlyTrailingMapper = onlyTrailingMapper;
function onlyTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.startsWith('::'))
        throw new Error('Invalid value');
    return extractEhAndL(value.substring(2));
}
exports.onlyTrailingUnmapper = onlyTrailingUnmapper;
function multiTrailingMapper(data) {
    return `${data[0].join(':')}::${data[1].join(':')}:${data[2]}`;
}
exports.multiTrailingMapper = multiTrailingMapper;
function multiTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    const [bhString, trailingString] = value.split('::', 2);
    const [eh, l] = extractEhAndL(trailingString);
    return [readBh(bhString), eh, l];
}
exports.multiTrailingUnmapper = multiTrailingUnmapper;
function multiTrailingMapperOne(data) {
    return multiTrailingMapper([data[0], [data[1]], data[2]]);
}
exports.multiTrailingMapperOne = multiTrailingMapperOne;
function multiTrailingUnmapperOne(value) {
    const out = multiTrailingUnmapper(value);
    return [out[0], out[1].join(':'), out[2]];
}
exports.multiTrailingUnmapperOne = multiTrailingUnmapperOne;
function singleTrailingMapper(data) {
    return `${data[0].join(':')}::${data[1]}`;
}
exports.singleTrailingMapper = singleTrailingMapper;
function singleTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    const [bhString, trailing] = value.split('::', 2);
    return [readBh(bhString), trailing];
}
exports.singleTrailingUnmapper = singleTrailingUnmapper;
function noTrailingMapper(data) {
    return `${data[0].join(':')}::`;
}
exports.noTrailingMapper = noTrailingMapper;
function noTrailingUnmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.endsWith('::'))
        throw new Error('Invalid value');
    return [readBh(value.substring(0, value.length - 2))];
}
exports.noTrailingUnmapper = noTrailingUnmapper;


/***/ }),

/***/ 34431:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToCharStringUnmapper = exports.indexToCharStringMapper = void 0;
exports.indexToCharStringMapper = String.fromCodePoint;
function indexToCharStringUnmapper(c) {
    if (typeof c !== 'string') {
        throw new Error('Cannot unmap non-string');
    }
    if (c.length === 0 || c.length > 2) {
        throw new Error('Cannot unmap string with more or less than one character');
    }
    const c1 = c.charCodeAt(0);
    if (c.length === 1) {
        return c1;
    }
    const c2 = c.charCodeAt(1);
    if (c1 < 0xd800 || c1 > 0xdbff || c2 < 0xdc00 || c2 > 0xdfff) {
        throw new Error('Cannot unmap invalid surrogate pairs');
    }
    return c.codePointAt(0);
}
exports.indexToCharStringUnmapper = indexToCharStringUnmapper;


/***/ }),

/***/ 64153:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToMappedConstantUnmapperFor = exports.indexToMappedConstantMapperFor = void 0;
function indexToMappedConstantMapperFor(entries) {
    return function indexToMappedConstantMapper(choiceIndex) {
        let idx = -1;
        let numSkips = 0;
        while (choiceIndex >= numSkips) {
            numSkips += entries[++idx].num;
        }
        return entries[idx].build(choiceIndex - numSkips + entries[idx].num);
    };
}
exports.indexToMappedConstantMapperFor = indexToMappedConstantMapperFor;
function buildReverseMapping(entries) {
    const reverseMapping = { mapping: new Map(), negativeZeroIndex: undefined };
    let choiceIndex = 0;
    for (let entryIdx = 0; entryIdx !== entries.length; ++entryIdx) {
        const entry = entries[entryIdx];
        for (let idxInEntry = 0; idxInEntry !== entry.num; ++idxInEntry) {
            const value = entry.build(idxInEntry);
            if (value === 0 && 1 / value === Number.NEGATIVE_INFINITY) {
                reverseMapping.negativeZeroIndex = choiceIndex;
            }
            else {
                reverseMapping.mapping.set(value, choiceIndex);
            }
            ++choiceIndex;
        }
    }
    return reverseMapping;
}
function indexToMappedConstantUnmapperFor(entries) {
    let reverseMapping = null;
    return function indexToMappedConstantUnmapper(value) {
        if (reverseMapping === null) {
            reverseMapping = buildReverseMapping(entries);
        }
        const choiceIndex = Object.is(value, -0) ? reverseMapping.negativeZeroIndex : reverseMapping.mapping.get(value);
        if (choiceIndex === undefined) {
            throw new Error('Unknown value encountered cannot be built using this mapToConstant');
        }
        return choiceIndex;
    };
}
exports.indexToMappedConstantUnmapperFor = indexToMappedConstantUnmapperFor;


/***/ }),

/***/ 29546:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.indexToPrintableIndexUnmapper = exports.indexToPrintableIndexMapper = void 0;
function indexToPrintableIndexMapper(v) {
    if (v < 95)
        return v + 0x20;
    if (v <= 0x7e)
        return v - 95;
    return v;
}
exports.indexToPrintableIndexMapper = indexToPrintableIndexMapper;
function indexToPrintableIndexUnmapper(v) {
    if (v >= 0x20 && v <= 0x7e)
        return v - 0x20;
    if (v >= 0 && v <= 0x1f)
        return v + 95;
    return v;
}
exports.indexToPrintableIndexUnmapper = indexToPrintableIndexUnmapper;


/***/ }),

/***/ 25424:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.keyValuePairsToObjectUnmapper = exports.keyValuePairsToObjectMapper = void 0;
function keyValuePairsToObjectMapper(items) {
    const obj = {};
    for (const keyValue of items) {
        Object.defineProperty(obj, keyValue[0], {
            enumerable: true,
            configurable: true,
            writable: true,
            value: keyValue[1],
        });
    }
    return obj;
}
exports.keyValuePairsToObjectMapper = keyValuePairsToObjectMapper;
function buildInvalidPropertyNameFilter(obj) {
    return function invalidPropertyNameFilter(key) {
        const descriptor = Object.getOwnPropertyDescriptor(obj, key);
        return (descriptor === undefined ||
            !descriptor.configurable ||
            !descriptor.enumerable ||
            !descriptor.writable ||
            descriptor.get !== undefined ||
            descriptor.set !== undefined);
    };
}
function keyValuePairsToObjectUnmapper(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Incompatible instance received: should be a non-null object');
    }
    if (!('constructor' in value) || value.constructor !== Object) {
        throw new Error('Incompatible instance received: should be of exact type Object');
    }
    if (Object.getOwnPropertySymbols(value).length > 0) {
        throw new Error('Incompatible instance received: should contain symbols');
    }
    if (Object.getOwnPropertyNames(value).find(buildInvalidPropertyNameFilter(value)) !== undefined) {
        throw new Error('Incompatible instance received: should contain only c/e/w properties without get/set');
    }
    return Object.entries(value);
}
exports.keyValuePairsToObjectUnmapper = keyValuePairsToObjectUnmapper;


/***/ }),

/***/ 16415:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.natToStringifiedNatUnmapper = exports.tryParseStringifiedNat = exports.natToStringifiedNatMapper = void 0;
function natToStringifiedNatMapper(options) {
    const [style, v] = options;
    switch (style) {
        case 'oct':
            return `0${Number(v).toString(8)}`;
        case 'hex':
            return `0x${Number(v).toString(16)}`;
        case 'dec':
        default:
            return `${v}`;
    }
}
exports.natToStringifiedNatMapper = natToStringifiedNatMapper;
function tryParseStringifiedNat(stringValue, radix) {
    const parsedNat = Number.parseInt(stringValue, radix);
    if (parsedNat.toString(radix) !== stringValue) {
        throw new Error('Invalid value');
    }
    return parsedNat;
}
exports.tryParseStringifiedNat = tryParseStringifiedNat;
function natToStringifiedNatUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    if (value.length >= 2 && value[0] === '0') {
        if (value[1] === 'x') {
            return ['hex', tryParseStringifiedNat(value.substr(2), 16)];
        }
        return ['oct', tryParseStringifiedNat(value.substr(1), 8)];
    }
    return ['dec', tryParseStringifiedNat(value, 10)];
}
exports.natToStringifiedNatUnmapper = natToStringifiedNatUnmapper;


/***/ }),

/***/ 32872:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numberToPaddedEightUnmapper = exports.numberToPaddedEightMapper = void 0;
function numberToPaddedEightMapper(n) {
    return n.toString(16).padStart(8, '0');
}
exports.numberToPaddedEightMapper = numberToPaddedEightMapper;
function numberToPaddedEightUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported type');
    }
    if (value.length !== 8) {
        throw new Error('Unsupported value: invalid length');
    }
    const n = parseInt(value, 16);
    if (value !== numberToPaddedEightMapper(n)) {
        throw new Error('Unsupported value: invalid content');
    }
    return n;
}
exports.numberToPaddedEightUnmapper = numberToPaddedEightUnmapper;


/***/ }),

/***/ 55833:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.objectToPrototypeLessUnmapper = exports.objectToPrototypeLessMapper = void 0;
function objectToPrototypeLessMapper(o) {
    return Object.assign(Object.create(null), o);
}
exports.objectToPrototypeLessMapper = objectToPrototypeLessMapper;
function objectToPrototypeLessUnmapper(value) {
    if (typeof value !== 'object' || value === null) {
        throw new Error('Incompatible instance received: should be a non-null object');
    }
    if ('__proto__' in value) {
        throw new Error('Incompatible instance received: should not have any __proto__');
    }
    return Object.assign({}, value);
}
exports.objectToPrototypeLessUnmapper = objectToPrototypeLessUnmapper;


/***/ }),

/***/ 71162:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.paddedEightsToUuidUnmapper = exports.paddedEightsToUuidMapper = void 0;
function paddedEightsToUuidMapper(t) {
    return `${t[0]}-${t[1].substring(4)}-${t[1].substring(0, 4)}-${t[2].substring(0, 4)}-${t[2].substring(4)}${t[3]}`;
}
exports.paddedEightsToUuidMapper = paddedEightsToUuidMapper;
const UuidRegex = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/;
function paddedEightsToUuidUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported type');
    }
    const m = UuidRegex.exec(value);
    if (m === null) {
        throw new Error('Unsupported type');
    }
    return [m[1], m[3] + m[2], m[4] + m[5].substring(0, 4), m[5].substring(4)];
}
exports.paddedEightsToUuidUnmapper = paddedEightsToUuidUnmapper;


/***/ }),

/***/ 50250:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.partsToUrlUnmapper = exports.partsToUrlMapper = void 0;
function partsToUrlMapper(data) {
    const [scheme, authority, path] = data;
    const query = data[3] === null ? '' : `?${data[3]}`;
    const fragments = data[4] === null ? '' : `#${data[4]}`;
    return `${scheme}://${authority}${path}${query}${fragments}`;
}
exports.partsToUrlMapper = partsToUrlMapper;
const UrlSplitRegex = /^([[A-Za-z][A-Za-z0-9+.-]*):\/\/([^/?#]*)([^?#]*)(\?[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?(#[A-Za-z0-9\-._~!$&'()*+,;=:@/?%]*)?$/;
function partsToUrlUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Incompatible value received: type');
    }
    const m = UrlSplitRegex.exec(value);
    if (m === null) {
        throw new Error('Incompatible value received');
    }
    const scheme = m[1];
    const authority = m[2];
    const path = m[3];
    const query = m[4];
    const fragments = m[5];
    return [
        scheme,
        authority,
        path,
        query !== undefined ? query.substring(1) : null,
        fragments !== undefined ? fragments.substring(1) : null,
    ];
}
exports.partsToUrlUnmapper = partsToUrlUnmapper;


/***/ }),

/***/ 16387:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.patternsToStringUnmapperFor = exports.patternsToStringMapper = void 0;
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
function patternsToStringMapper(tab) {
    return tab.join('');
}
exports.patternsToStringMapper = patternsToStringMapper;
function patternsToStringUnmapperFor(patternsArb, constraints) {
    return function patternsToStringUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported value');
        }
        const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
        const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.MaxLengthUpperBound;
        if (value.length === 0) {
            if (minLength > 0) {
                throw new Error('Unable to unmap received string');
            }
            return [];
        }
        const stack = [{ endIndexChunks: 0, nextStartIndex: 1, chunks: [] }];
        while (stack.length > 0) {
            const last = stack.pop();
            for (let index = last.nextStartIndex; index <= value.length; ++index) {
                const chunk = value.substring(last.endIndexChunks, index);
                if (patternsArb.canShrinkWithoutContext(chunk)) {
                    const newChunks = last.chunks.concat([chunk]);
                    if (index === value.length) {
                        if (newChunks.length < minLength || newChunks.length > maxLength) {
                            break;
                        }
                        return newChunks;
                    }
                    stack.push({ endIndexChunks: last.endIndexChunks, nextStartIndex: index + 1, chunks: last.chunks });
                    stack.push({ endIndexChunks: index, nextStartIndex: index + 1, chunks: newChunks });
                    break;
                }
            }
        }
        throw new Error('Unable to unmap received string');
    };
}
exports.patternsToStringUnmapperFor = patternsToStringUnmapperFor;


/***/ }),

/***/ 66724:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.segmentsToPathUnmapper = exports.segmentsToPathMapper = void 0;
function segmentsToPathMapper(segments) {
    return segments.map((v) => `/${v}`).join('');
}
exports.segmentsToPathMapper = segmentsToPathMapper;
function segmentsToPathUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Incompatible value received: type');
    }
    if (value.length !== 0 && value[0] !== '/') {
        throw new Error('Incompatible value received: start');
    }
    return value.split('/').splice(1);
}
exports.segmentsToPathUnmapper = segmentsToPathUnmapper;


/***/ }),

/***/ 1686:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringToBase64Unmapper = exports.stringToBase64Mapper = void 0;
function stringToBase64Mapper(s) {
    switch (s.length % 4) {
        case 0:
            return s;
        case 3:
            return `${s}=`;
        case 2:
            return `${s}==`;
        default:
            return s.slice(1);
    }
}
exports.stringToBase64Mapper = stringToBase64Mapper;
function stringToBase64Unmapper(value) {
    if (typeof value !== 'string' || value.length % 4 !== 0) {
        throw new Error('Invalid string received');
    }
    const lastTrailingIndex = value.indexOf('=');
    if (lastTrailingIndex === -1) {
        return value;
    }
    const numTrailings = value.length - lastTrailingIndex;
    if (numTrailings > 2) {
        throw new Error('Cannot unmap the passed value');
    }
    return value.substring(0, lastTrailingIndex);
}
exports.stringToBase64Unmapper = stringToBase64Unmapper;


/***/ }),

/***/ 55756:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.timeToDateUnmapper = exports.timeToDateMapper = void 0;
function timeToDateMapper(time) {
    return new Date(time);
}
exports.timeToDateMapper = timeToDateMapper;
function timeToDateUnmapper(value) {
    if (!(value instanceof Date) || value.constructor !== Date) {
        throw new Error('Not a valid value for date unmapper');
    }
    return value.getTime();
}
exports.timeToDateUnmapper = timeToDateUnmapper;


/***/ }),

/***/ 15548:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unboxedToBoxedUnmapper = exports.unboxedToBoxedMapper = void 0;
function unboxedToBoxedMapper(value) {
    switch (typeof value) {
        case 'boolean':
            return new Boolean(value);
        case 'number':
            return new Number(value);
        case 'string':
            return new String(value);
        default:
            return value;
    }
}
exports.unboxedToBoxedMapper = unboxedToBoxedMapper;
function unboxedToBoxedUnmapper(value) {
    if (typeof value !== 'object' || value === null || !('constructor' in value)) {
        return value;
    }
    return value.constructor === Boolean || value.constructor === Number || value.constructor === String
        ?
            value.valueOf()
        : value;
}
exports.unboxedToBoxedUnmapper = unboxedToBoxedUnmapper;


/***/ }),

/***/ 40683:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildValuesAndSeparateKeysToObjectUnmapper = exports.buildValuesAndSeparateKeysToObjectMapper = void 0;
function buildValuesAndSeparateKeysToObjectMapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectMapper(gs) {
        const obj = {};
        for (let idx = 0; idx !== keys.length; ++idx) {
            const valueWrapper = gs[idx];
            if (valueWrapper !== noKeyValue) {
                Object.defineProperty(obj, keys[idx], {
                    value: valueWrapper,
                    configurable: true,
                    enumerable: true,
                    writable: true,
                });
            }
        }
        return obj;
    };
}
exports.buildValuesAndSeparateKeysToObjectMapper = buildValuesAndSeparateKeysToObjectMapper;
function buildValuesAndSeparateKeysToObjectUnmapper(keys, noKeyValue) {
    return function valuesAndSeparateKeysToObjectUnmapper(value) {
        if (typeof value !== 'object' || value === null) {
            throw new Error('Incompatible instance received: should be a non-null object');
        }
        if (!('constructor' in value) || value.constructor !== Object) {
            throw new Error('Incompatible instance received: should be of exact type Object');
        }
        let extractedPropertiesCount = 0;
        const extractedValues = [];
        for (let idx = 0; idx !== keys.length; ++idx) {
            const descriptor = Object.getOwnPropertyDescriptor(value, keys[idx]);
            if (descriptor !== undefined) {
                if (!descriptor.configurable || !descriptor.enumerable || !descriptor.writable) {
                    throw new Error('Incompatible instance received: should contain only c/e/w properties');
                }
                if (descriptor.get !== undefined || descriptor.set !== undefined) {
                    throw new Error('Incompatible instance received: should contain only no get/set properties');
                }
                ++extractedPropertiesCount;
                extractedValues.push(descriptor.value);
            }
            else {
                extractedValues.push(noKeyValue);
            }
        }
        const namePropertiesCount = Object.getOwnPropertyNames(value).length;
        const symbolPropertiesCount = Object.getOwnPropertySymbols(value).length;
        if (extractedPropertiesCount !== namePropertiesCount + symbolPropertiesCount) {
            throw new Error('Incompatible instance received: should not contain extra properties');
        }
        return extractedValues;
    };
}
exports.buildValuesAndSeparateKeysToObjectUnmapper = buildValuesAndSeparateKeysToObjectUnmapper;


/***/ }),

/***/ 11406:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sentencesToParagraphUnmapper = exports.sentencesToParagraphMapper = exports.wordsToSentenceUnmapperFor = exports.wordsToSentenceMapper = exports.wordsToJoinedStringUnmapperFor = exports.wordsToJoinedStringMapper = void 0;
function wordsToJoinedStringMapper(words) {
    return words.map((w) => (w[w.length - 1] === ',' ? w.substr(0, w.length - 1) : w)).join(' ');
}
exports.wordsToJoinedStringMapper = wordsToJoinedStringMapper;
function wordsToJoinedStringUnmapperFor(wordsArbitrary) {
    return function wordsToJoinedStringUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported type');
        }
        const words = [];
        for (const candidate of value.split(' ')) {
            if (wordsArbitrary.canShrinkWithoutContext(candidate))
                words.push(candidate);
            else if (wordsArbitrary.canShrinkWithoutContext(candidate + ','))
                words.push(candidate + ',');
            else
                throw new Error('Unsupported word');
        }
        return words;
    };
}
exports.wordsToJoinedStringUnmapperFor = wordsToJoinedStringUnmapperFor;
function wordsToSentenceMapper(words) {
    let sentence = words.join(' ');
    if (sentence[sentence.length - 1] === ',') {
        sentence = sentence.substr(0, sentence.length - 1);
    }
    return sentence[0].toUpperCase() + sentence.substring(1) + '.';
}
exports.wordsToSentenceMapper = wordsToSentenceMapper;
function wordsToSentenceUnmapperFor(wordsArbitrary) {
    return function wordsToSentenceUnmapper(value) {
        if (typeof value !== 'string') {
            throw new Error('Unsupported type');
        }
        if (value.length < 2 ||
            value[value.length - 1] !== '.' ||
            value[value.length - 2] === ',' ||
            value[0].toLowerCase().toUpperCase() !== value[0]) {
            throw new Error('Unsupported value');
        }
        const adaptedValue = value[0].toLowerCase() + value.substring(1, value.length - 1);
        const words = [];
        const candidates = adaptedValue.split(' ');
        for (let idx = 0; idx !== candidates.length; ++idx) {
            const candidate = candidates[idx];
            if (wordsArbitrary.canShrinkWithoutContext(candidate))
                words.push(candidate);
            else if (idx === candidates.length - 1 && wordsArbitrary.canShrinkWithoutContext(candidate + ','))
                words.push(candidate + ',');
            else
                throw new Error('Unsupported word');
        }
        return words;
    };
}
exports.wordsToSentenceUnmapperFor = wordsToSentenceUnmapperFor;
function sentencesToParagraphMapper(sentences) {
    return sentences.join(' ');
}
exports.sentencesToParagraphMapper = sentencesToParagraphMapper;
function sentencesToParagraphUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported type');
    }
    const sentences = value.split('. ');
    for (let idx = 0; idx < sentences.length - 1; ++idx) {
        sentences[idx] += '.';
    }
    return sentences;
}
exports.sentencesToParagraphUnmapper = sentencesToParagraphUnmapper;


/***/ }),

/***/ 47111:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.anything = void 0;
const AnyArbitraryBuilder_1 = __webpack_require__(31995);
const QualifiedObjectConstraints_1 = __webpack_require__(92113);
function anything(constraints) {
    return (0, AnyArbitraryBuilder_1.anyArbitraryBuilder)((0, QualifiedObjectConstraints_1.toQualifiedObjectConstraints)(constraints));
}
exports.anything = anything;


/***/ }),

/***/ 78309:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.array = void 0;
const ArrayArbitrary_1 = __webpack_require__(49844);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
function array(arb, constraints = {}) {
    const size = constraints.size;
    const minLength = constraints.minLength || 0;
    const maxLengthOrUnset = constraints.maxLength;
    const depthIdentifier = constraints.depthIdentifier;
    const maxLength = maxLengthOrUnset !== undefined ? maxLengthOrUnset : MaxLengthFromMinLength_1.MaxLengthUpperBound;
    const specifiedMaxLength = maxLengthOrUnset !== undefined;
    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minLength, maxLength, specifiedMaxLength);
    const customSlices = constraints.experimentalCustomSlices || [];
    return new ArrayArbitrary_1.ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, undefined, customSlices);
}
exports.array = array;


/***/ }),

/***/ 98670:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ascii = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
const IndexToPrintableIndex_1 = __webpack_require__(29546);
function ascii() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0x00, 0x7f, IndexToPrintableIndex_1.indexToPrintableIndexMapper, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper);
}
exports.ascii = ascii;


/***/ }),

/***/ 8846:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asciiString = void 0;
const array_1 = __webpack_require__(78309);
const ascii_1 = __webpack_require__(98670);
const CodePointsToString_1 = __webpack_require__(70172);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function asciiString(constraints = {}) {
    const charArbitrary = (0, ascii_1.ascii)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.asciiString = asciiString;


/***/ }),

/***/ 62767:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64 = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
function base64Mapper(v) {
    if (v < 26)
        return v + 65;
    if (v < 52)
        return v + 97 - 26;
    if (v < 62)
        return v + 48 - 52;
    return v === 62 ? 43 : 47;
}
function base64Unmapper(v) {
    if (v >= 65 && v <= 90)
        return v - 65;
    if (v >= 97 && v <= 122)
        return v - 97 + 26;
    if (v >= 48 && v <= 57)
        return v - 48 + 52;
    return v === 43 ? 62 : v === 47 ? 63 : -1;
}
function base64() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0, 63, base64Mapper, base64Unmapper);
}
exports.base64 = base64;


/***/ }),

/***/ 62547:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.base64String = void 0;
const array_1 = __webpack_require__(78309);
const base64_1 = __webpack_require__(62767);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
const CodePointsToString_1 = __webpack_require__(70172);
const StringToBase64_1 = __webpack_require__(1686);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function base64String(constraints = {}) {
    const { minLength: unscaledMinLength = 0, maxLength: unscaledMaxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound, size } = constraints;
    const minLength = unscaledMinLength + 3 - ((unscaledMinLength + 3) % 4);
    const maxLength = unscaledMaxLength - (unscaledMaxLength % 4);
    const requestedSize = constraints.maxLength === undefined && size === undefined ? '=' : size;
    if (minLength > maxLength)
        throw new Error('Minimal length should be inferior or equal to maximal length');
    if (minLength % 4 !== 0)
        throw new Error('Minimal length of base64 strings must be a multiple of 4');
    if (maxLength % 4 !== 0)
        throw new Error('Maximal length of base64 strings must be a multiple of 4');
    const charArbitrary = (0, base64_1.base64)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = {
        minLength,
        maxLength,
        size: requestedSize,
        experimentalCustomSlices,
    };
    return (0, array_1.array)(charArbitrary, enrichedConstraints)
        .map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper)
        .map(StringToBase64_1.stringToBase64Mapper, StringToBase64_1.stringToBase64Unmapper);
}
exports.base64String = base64String;


/***/ }),

/***/ 57750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigInt = void 0;
const BigIntArbitrary_1 = __webpack_require__(11900);
function buildCompleteBigIntConstraints(constraints) {
    const DefaultPow = 256;
    const DefaultMin = BigInt(-1) << BigInt(DefaultPow - 1);
    const DefaultMax = (BigInt(1) << BigInt(DefaultPow - 1)) - BigInt(1);
    const min = constraints.min;
    const max = constraints.max;
    return {
        min: min !== undefined ? min : DefaultMin - (max !== undefined && max < BigInt(0) ? max * max : BigInt(0)),
        max: max !== undefined ? max : DefaultMax + (min !== undefined && min > BigInt(0) ? min * min : BigInt(0)),
    };
}
function extractBigIntConstraints(args) {
    if (args[0] === undefined) {
        return {};
    }
    if (args[1] === undefined) {
        const constraints = args[0];
        return constraints;
    }
    return { min: args[0], max: args[1] };
}
function bigInt(...args) {
    const constraints = buildCompleteBigIntConstraints(extractBigIntConstraints(args));
    if (constraints.min > constraints.max) {
        throw new Error('fc.bigInt expects max to be greater than or equal to min');
    }
    return new BigIntArbitrary_1.BigIntArbitrary(constraints.min, constraints.max);
}
exports.bigInt = bigInt;


/***/ }),

/***/ 77632:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigInt64Array = void 0;
const bigInt_1 = __webpack_require__(57750);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function bigInt64Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, BigInt('-9223372036854775808'), BigInt('9223372036854775807'), BigInt64Array, bigInt_1.bigInt);
}
exports.bigInt64Array = bigInt64Array;


/***/ }),

/***/ 33001:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigIntN = void 0;
const BigIntArbitrary_1 = __webpack_require__(11900);
function bigIntN(n) {
    if (n < 1) {
        throw new Error('fc.bigIntN expects requested number of bits to be superior or equal to 1');
    }
    const min = BigInt(-1) << BigInt(n - 1);
    const max = (BigInt(1) << BigInt(n - 1)) - BigInt(1);
    return new BigIntArbitrary_1.BigIntArbitrary(min, max);
}
exports.bigIntN = bigIntN;


/***/ }),

/***/ 92546:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUint = void 0;
const BigIntArbitrary_1 = __webpack_require__(11900);
function computeDefaultMax() {
    return (BigInt(1) << BigInt(256)) - BigInt(1);
}
function bigUint(constraints) {
    const requestedMax = typeof constraints === 'object' ? constraints.max : constraints;
    const max = requestedMax !== undefined ? requestedMax : computeDefaultMax();
    if (max < 0) {
        throw new Error('fc.bigUint expects max to be greater than or equal to zero');
    }
    return new BigIntArbitrary_1.BigIntArbitrary(BigInt(0), max);
}
exports.bigUint = bigUint;


/***/ }),

/***/ 14897:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUint64Array = void 0;
const bigInt_1 = __webpack_require__(57750);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function bigUint64Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, BigInt(0), BigInt('18446744073709551615'), BigUint64Array, bigInt_1.bigInt);
}
exports.bigUint64Array = bigUint64Array;


/***/ }),

/***/ 94088:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.bigUintN = void 0;
const BigIntArbitrary_1 = __webpack_require__(11900);
function bigUintN(n) {
    if (n < 0) {
        throw new Error('fc.bigUintN expects requested number of bits to be superior or equal to 0');
    }
    const min = BigInt(0);
    const max = (BigInt(1) << BigInt(n)) - BigInt(1);
    return new BigIntArbitrary_1.BigIntArbitrary(min, max);
}
exports.bigUintN = bigUintN;


/***/ }),

/***/ 81258:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolean = void 0;
const integer_1 = __webpack_require__(97706);
function booleanMapper(v) {
    return v === 1;
}
function booleanUnmapper(v) {
    if (typeof v !== 'boolean')
        throw new Error('Unsupported input type');
    return v === true ? 1 : 0;
}
function boolean() {
    return (0, integer_1.integer)({ min: 0, max: 1 }).map(booleanMapper, booleanUnmapper).noBias();
}
exports.boolean = boolean;


/***/ }),

/***/ 69165:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.char = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
function identity(v) {
    return v;
}
function char() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0x20, 0x7e, identity, identity);
}
exports.char = char;


/***/ }),

/***/ 22097:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.char16bits = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
const IndexToPrintableIndex_1 = __webpack_require__(29546);
function char16bits() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0x0000, 0xffff, IndexToPrintableIndex_1.indexToPrintableIndexMapper, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper);
}
exports.char16bits = char16bits;


/***/ }),

/***/ 55939:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.clone = void 0;
const CloneArbitrary_1 = __webpack_require__(28733);
function clone(arb, numValues) {
    return new CloneArbitrary_1.CloneArbitrary(arb, numValues);
}
exports.clone = clone;


/***/ }),

/***/ 15811:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.commands = void 0;
const CommandsArbitrary_1 = __webpack_require__(43045);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
function commands(commandArbs, constraints = {}) {
    const { size, maxCommands = MaxLengthFromMinLength_1.MaxLengthUpperBound, disableReplayLog = false, replayPath = null } = constraints;
    const specifiedMaxCommands = constraints.maxCommands !== undefined;
    const maxGeneratedCommands = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, 0, maxCommands, specifiedMaxCommands);
    return new CommandsArbitrary_1.CommandsArbitrary(commandArbs, maxGeneratedCommands, maxCommands, replayPath, disableReplayLog);
}
exports.commands = commands;


/***/ }),

/***/ 22543:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareBooleanFunc = void 0;
const CompareFunctionArbitraryBuilder_1 = __webpack_require__(71909);
function compareBooleanFunc() {
    return (0, CompareFunctionArbitraryBuilder_1.buildCompareFunctionArbitrary)(Object.assign((hA, hB) => hA < hB, {
        toString() {
            return '(hA, hB) => hA < hB';
        },
    }));
}
exports.compareBooleanFunc = compareBooleanFunc;


/***/ }),

/***/ 21104:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.compareFunc = void 0;
const CompareFunctionArbitraryBuilder_1 = __webpack_require__(71909);
function compareFunc() {
    return (0, CompareFunctionArbitraryBuilder_1.buildCompareFunctionArbitrary)(Object.assign((hA, hB) => hA - hB, {
        toString() {
            return '(hA, hB) => hA - hB';
        },
    }));
}
exports.compareFunc = compareFunc;


/***/ }),

/***/ 27440:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constant = void 0;
const ConstantArbitrary_1 = __webpack_require__(17094);
function constant(value) {
    return new ConstantArbitrary_1.ConstantArbitrary([value]);
}
exports.constant = constant;


/***/ }),

/***/ 80305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.constantFrom = void 0;
const ConstantArbitrary_1 = __webpack_require__(17094);
function constantFrom(...values) {
    if (values.length === 0) {
        throw new Error('fc.constantFrom expects at least one parameter');
    }
    return new ConstantArbitrary_1.ConstantArbitrary(values);
}
exports.constantFrom = constantFrom;


/***/ }),

/***/ 47068:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.context = void 0;
const symbols_1 = __webpack_require__(28620);
const constant_1 = __webpack_require__(27440);
class ContextImplem {
    constructor() {
        this.receivedLogs = [];
    }
    log(data) {
        this.receivedLogs.push(data);
    }
    size() {
        return this.receivedLogs.length;
    }
    toString() {
        return JSON.stringify({ logs: this.receivedLogs });
    }
    [symbols_1.cloneMethod]() {
        return new ContextImplem();
    }
}
function context() {
    return (0, constant_1.constant)(new ContextImplem());
}
exports.context = context;


/***/ }),

/***/ 18123:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.date = void 0;
const integer_1 = __webpack_require__(97706);
const TimeToDate_1 = __webpack_require__(55756);
function date(constraints) {
    const intMin = constraints && constraints.min !== undefined ? constraints.min.getTime() : -8640000000000000;
    const intMax = constraints && constraints.max !== undefined ? constraints.max.getTime() : 8640000000000000;
    if (Number.isNaN(intMin))
        throw new Error('fc.date min must be valid instance of Date');
    if (Number.isNaN(intMax))
        throw new Error('fc.date max must be valid instance of Date');
    if (intMin > intMax)
        throw new Error('fc.date max must be greater or equal to min');
    return (0, integer_1.integer)({ min: intMin, max: intMax }).map(TimeToDate_1.timeToDateMapper, TimeToDate_1.timeToDateUnmapper);
}
exports.date = date;


/***/ }),

/***/ 64444:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dictionary = void 0;
const tuple_1 = __webpack_require__(85282);
const uniqueArray_1 = __webpack_require__(20005);
const KeyValuePairsToObject_1 = __webpack_require__(25424);
function dictionaryKeyExtractor(entry) {
    return entry[0];
}
function dictionary(keyArb, valueArb, constraints = {}) {
    return (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)(keyArb, valueArb), {
        minLength: constraints.minKeys,
        maxLength: constraints.maxKeys,
        size: constraints.size,
        selector: dictionaryKeyExtractor,
    }).map(KeyValuePairsToObject_1.keyValuePairsToObjectMapper, KeyValuePairsToObject_1.keyValuePairsToObjectUnmapper);
}
exports.dictionary = dictionary;


/***/ }),

/***/ 90301:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.domain = void 0;
const array_1 = __webpack_require__(78309);
const CharacterRangeArbitraryBuilder_1 = __webpack_require__(40085);
const option_1 = __webpack_require__(91953);
const stringOf_1 = __webpack_require__(85082);
const tuple_1 = __webpack_require__(85282);
const InvalidSubdomainLabelFiIter_1 = __webpack_require__(37913);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
const AdapterArbitrary_1 = __webpack_require__(2062);
function toSubdomainLabelMapper([f, d]) {
    return d === null ? f : `${f}${d[0]}${d[1]}`;
}
function toSubdomainLabelUnmapper(value) {
    if (typeof value !== 'string' || value.length === 0) {
        throw new Error('Unsupported');
    }
    if (value.length === 1) {
        return [value[0], null];
    }
    return [value[0], [value.substring(1, value.length - 1), value[value.length - 1]]];
}
function subdomainLabel(size) {
    const alphaNumericArb = (0, CharacterRangeArbitraryBuilder_1.buildLowerAlphaNumericArbitrary)([]);
    const alphaNumericHyphenArb = (0, CharacterRangeArbitraryBuilder_1.buildLowerAlphaNumericArbitrary)(['-']);
    return (0, tuple_1.tuple)(alphaNumericArb, (0, option_1.option)((0, tuple_1.tuple)((0, stringOf_1.stringOf)(alphaNumericHyphenArb, { size, maxLength: 61 }), alphaNumericArb)))
        .map(toSubdomainLabelMapper, toSubdomainLabelUnmapper)
        .filter(InvalidSubdomainLabelFiIter_1.filterInvalidSubdomainLabel);
}
function labelsMapper(elements) {
    return `${elements[0].join('.')}.${elements[1]}`;
}
function labelsUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported type');
    }
    const lastDotIndex = value.lastIndexOf('.');
    return [value.substring(0, lastDotIndex).split('.'), value.substring(lastDotIndex + 1)];
}
function labelsAdapter(labels) {
    const [subDomains, suffix] = labels;
    let lengthNotIncludingIndex = suffix.length;
    for (let index = 0; index !== subDomains.length; ++index) {
        lengthNotIncludingIndex += 1 + subDomains[index].length;
        if (lengthNotIncludingIndex > 255) {
            return { adapted: true, value: [subDomains.slice(0, index), suffix] };
        }
    }
    return { adapted: false, value: labels };
}
function domain(constraints = {}) {
    const resolvedSize = (0, MaxLengthFromMinLength_1.resolveSize)(constraints.size);
    const resolvedSizeMinusOne = (0, MaxLengthFromMinLength_1.relativeSizeToSize)('-1', resolvedSize);
    const alphaNumericArb = (0, CharacterRangeArbitraryBuilder_1.buildLowerAlphaArbitrary)([]);
    const publicSuffixArb = (0, stringOf_1.stringOf)(alphaNumericArb, { minLength: 2, maxLength: 63, size: resolvedSizeMinusOne });
    return ((0, AdapterArbitrary_1.adapter)((0, tuple_1.tuple)((0, array_1.array)(subdomainLabel(resolvedSize), { size: resolvedSizeMinusOne, minLength: 1, maxLength: 127 }), publicSuffixArb), labelsAdapter).map(labelsMapper, labelsUnmapper));
}
exports.domain = domain;


/***/ }),

/***/ 24893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.double = void 0;
const ArrayInt64_1 = __webpack_require__(35394);
const ArrayInt64Arbitrary_1 = __webpack_require__(90254);
const DoubleHelpers_1 = __webpack_require__(87034);
function safeDoubleToIndex(d, constraintsLabel) {
    if (Number.isNaN(d)) {
        throw new Error('fc.double constraints.' + constraintsLabel + ' must be a 32-bit float');
    }
    return (0, DoubleHelpers_1.doubleToIndex)(d);
}
function unmapperDoubleToIndex(value) {
    if (typeof value !== 'number')
        throw new Error('Unsupported type');
    return (0, DoubleHelpers_1.doubleToIndex)(value);
}
function double(constraints = {}) {
    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY, } = constraints;
    const minIndex = safeDoubleToIndex(min, 'min');
    const maxIndex = safeDoubleToIndex(max, 'max');
    if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, minIndex)) {
        throw new Error('fc.double constraints.min must be smaller or equal to constraints.max');
    }
    if (noNaN) {
        return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndex, maxIndex).map(DoubleHelpers_1.indexToDouble, unmapperDoubleToIndex);
    }
    const positiveMaxIdx = (0, ArrayInt64_1.isStrictlyPositive64)(maxIndex);
    const minIndexWithNaN = positiveMaxIdx ? minIndex : (0, ArrayInt64_1.substract64)(minIndex, ArrayInt64_1.Unit64);
    const maxIndexWithNaN = positiveMaxIdx ? (0, ArrayInt64_1.add64)(maxIndex, ArrayInt64_1.Unit64) : maxIndex;
    return (0, ArrayInt64Arbitrary_1.arrayInt64)(minIndexWithNaN, maxIndexWithNaN).map((index) => {
        if ((0, ArrayInt64_1.isStrictlySmaller64)(maxIndex, index) || (0, ArrayInt64_1.isStrictlySmaller64)(index, minIndex))
            return Number.NaN;
        else
            return (0, DoubleHelpers_1.indexToDouble)(index);
    }, (value) => {
        if (typeof value !== 'number')
            throw new Error('Unsupported type');
        if (Number.isNaN(value))
            return !(0, ArrayInt64_1.isEqual64)(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;
        return (0, DoubleHelpers_1.doubleToIndex)(value);
    });
}
exports.double = double;


/***/ }),

/***/ 11043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.emailAddress = void 0;
const array_1 = __webpack_require__(78309);
const CharacterRangeArbitraryBuilder_1 = __webpack_require__(40085);
const domain_1 = __webpack_require__(90301);
const stringOf_1 = __webpack_require__(85082);
const tuple_1 = __webpack_require__(85282);
const AdapterArbitrary_1 = __webpack_require__(2062);
function dotAdapter(a) {
    let currentLength = a[0].length;
    for (let index = 1; index !== a.length; ++index) {
        currentLength += 1 + a[index].length;
        if (currentLength > 64) {
            return { adapted: true, value: a.slice(0, index) };
        }
    }
    return { adapted: false, value: a };
}
function dotMapper(a) {
    return a.join('.');
}
function dotUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported');
    }
    return value.split('.');
}
function atMapper(data) {
    return `${data[0]}@${data[1]}`;
}
function atUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported');
    }
    return value.split('@', 2);
}
function emailAddress(constraints = {}) {
    const others = ['!', '#', '$', '%', '&', "'", '*', '+', '-', '/', '=', '?', '^', '_', '`', '{', '|', '}', '~'];
    const atextArb = (0, CharacterRangeArbitraryBuilder_1.buildLowerAlphaNumericArbitrary)(others);
    const localPartArb = (0, AdapterArbitrary_1.adapter)((0, array_1.array)((0, stringOf_1.stringOf)(atextArb, {
        minLength: 1,
        maxLength: 64,
        size: constraints.size,
    }), { minLength: 1, maxLength: 32, size: constraints.size }), dotAdapter).map(dotMapper, dotUnmapper);
    return (0, tuple_1.tuple)(localPartArb, (0, domain_1.domain)({ size: constraints.size })).map(atMapper, atUnmapper);
}
exports.emailAddress = emailAddress;


/***/ }),

/***/ 38506:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.falsy = void 0;
const constantFrom_1 = __webpack_require__(80305);
function falsy(constraints) {
    if (!constraints || !constraints.withBigInt) {
        return (0, constantFrom_1.constantFrom)(false, null, undefined, 0, '', NaN);
    }
    return (0, constantFrom_1.constantFrom)(false, null, undefined, 0, '', NaN, BigInt(0));
}
exports.falsy = falsy;


/***/ }),

/***/ 80031:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float = void 0;
const integer_1 = __webpack_require__(97706);
const FloatHelpers_1 = __webpack_require__(64301);
function safeFloatToIndex(f, constraintsLabel) {
    const conversionTrick = 'you can convert any double to a 32-bit float by using `new Float32Array([myDouble])[0]`';
    const errorMessage = 'fc.float constraints.' + constraintsLabel + ' must be a 32-bit float - ' + conversionTrick;
    if (Number.isNaN(f) || (Number.isFinite(f) && (f < -FloatHelpers_1.MAX_VALUE_32 || f > FloatHelpers_1.MAX_VALUE_32))) {
        throw new Error(errorMessage);
    }
    const index = (0, FloatHelpers_1.floatToIndex)(f);
    if (!Number.isInteger(index)) {
        throw new Error(errorMessage);
    }
    return index;
}
function unmapperFloatToIndex(value) {
    if (typeof value !== 'number')
        throw new Error('Unsupported type');
    return (0, FloatHelpers_1.floatToIndex)(value);
}
function float(constraints = {}) {
    const { noDefaultInfinity = false, noNaN = false, min = noDefaultInfinity ? -FloatHelpers_1.MAX_VALUE_32 : Number.NEGATIVE_INFINITY, max = noDefaultInfinity ? FloatHelpers_1.MAX_VALUE_32 : Number.POSITIVE_INFINITY, } = constraints;
    const minIndex = safeFloatToIndex(min, 'min');
    const maxIndex = safeFloatToIndex(max, 'max');
    if (minIndex > maxIndex) {
        throw new Error('fc.float constraints.min must be smaller or equal to constraints.max');
    }
    if (noNaN) {
        return (0, integer_1.integer)({ min: minIndex, max: maxIndex }).map(FloatHelpers_1.indexToFloat, unmapperFloatToIndex);
    }
    const minIndexWithNaN = maxIndex > 0 ? minIndex : minIndex - 1;
    const maxIndexWithNaN = maxIndex > 0 ? maxIndex + 1 : maxIndex;
    return (0, integer_1.integer)({ min: minIndexWithNaN, max: maxIndexWithNaN }).map((index) => {
        if (index > maxIndex || index < minIndex)
            return Number.NaN;
        else
            return (0, FloatHelpers_1.indexToFloat)(index);
    }, (value) => {
        if (typeof value !== 'number')
            throw new Error('Unsupported type');
        if (Number.isNaN(value))
            return maxIndex !== maxIndexWithNaN ? maxIndexWithNaN : minIndexWithNaN;
        return (0, FloatHelpers_1.floatToIndex)(value);
    });
}
exports.float = float;


/***/ }),

/***/ 39330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float32Array = void 0;
const float_1 = __webpack_require__(80031);
const array_1 = __webpack_require__(78309);
function toTypedMapper(data) {
    return Float32Array.from(data);
}
function fromTypedUnmapper(value) {
    if (!(value instanceof Float32Array))
        throw new Error('Unexpected type');
    return [...value];
}
function float32Array(constraints = {}) {
    return (0, array_1.array)((0, float_1.float)(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}
exports.float32Array = float32Array;


/***/ }),

/***/ 76417:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.float64Array = void 0;
const double_1 = __webpack_require__(24893);
const array_1 = __webpack_require__(78309);
function toTypedMapper(data) {
    return Float64Array.from(data);
}
function fromTypedUnmapper(value) {
    if (!(value instanceof Float64Array))
        throw new Error('Unexpected type');
    return [...value];
}
function float64Array(constraints = {}) {
    return (0, array_1.array)((0, double_1.double)(constraints), constraints).map(toTypedMapper, fromTypedUnmapper);
}
exports.float64Array = float64Array;


/***/ }),

/***/ 96005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullUnicode = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
const IndexToPrintableIndex_1 = __webpack_require__(29546);
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return (0, IndexToPrintableIndex_1.indexToPrintableIndexMapper)(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return (0, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper)(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function fullUnicode() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0x0000, 0x10ffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.fullUnicode = fullUnicode;


/***/ }),

/***/ 8344:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fullUnicodeString = void 0;
const array_1 = __webpack_require__(78309);
const fullUnicode_1 = __webpack_require__(96005);
const CodePointsToString_1 = __webpack_require__(70172);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function fullUnicodeString(constraints = {}) {
    const charArbitrary = (0, fullUnicode_1.fullUnicode)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.fullUnicodeString = fullUnicodeString;


/***/ }),

/***/ 53731:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.func = void 0;
const hash_1 = __webpack_require__(21537);
const stringify_1 = __webpack_require__(21954);
const symbols_1 = __webpack_require__(28620);
const array_1 = __webpack_require__(78309);
const integer_1 = __webpack_require__(97706);
const tuple_1 = __webpack_require__(85282);
const TextEscaper_1 = __webpack_require__(92325);
function func(arb) {
    return (0, tuple_1.tuple)((0, array_1.array)(arb, { minLength: 1 }), (0, integer_1.integer)().noShrink()).map(([outs, seed]) => {
        const producer = () => {
            const recorded = {};
            const f = (...args) => {
                const repr = (0, stringify_1.stringify)(args);
                const val = outs[(0, hash_1.hash)(`${seed}${repr}`) % outs.length];
                recorded[repr] = val;
                return (0, symbols_1.hasCloneMethod)(val) ? val[symbols_1.cloneMethod]() : val;
            };
            function prettyPrint(stringifiedOuts) {
                const seenValues = Object.keys(recorded)
                    .sort()
                    .map((k) => `${k} => ${(0, stringify_1.stringify)(recorded[k])}`)
                    .map((line) => `/* ${(0, TextEscaper_1.escapeForMultilineComments)(line)} */`);
                return `function(...args) {
  // With hash and stringify coming from fast-check${seenValues.length !== 0 ? `\n  ${seenValues.join('\n  ')}` : ''}
  const outs = ${stringifiedOuts};
  return outs[hash('${seed}' + stringify(args)) % outs.length];
}`;
            }
            return Object.defineProperties(f, {
                toString: { value: () => prettyPrint((0, stringify_1.stringify)(outs)) },
                [stringify_1.toStringMethod]: { value: () => prettyPrint((0, stringify_1.stringify)(outs)) },
                [stringify_1.asyncToStringMethod]: { value: async () => prettyPrint(await (0, stringify_1.asyncStringify)(outs)) },
                [symbols_1.cloneMethod]: { value: producer, configurable: true },
            });
        };
        return producer();
    });
}
exports.func = func;


/***/ }),

/***/ 94383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexa = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
function hexaMapper(v) {
    return v < 10
        ? v + 48
        : v + 97 - 10;
}
function hexaUnmapper(v) {
    return v < 58
        ? v - 48
        : v >= 97 && v < 103
            ? v - 97 + 10
            : -1;
}
function hexa() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0, 15, hexaMapper, hexaUnmapper);
}
exports.hexa = hexa;


/***/ }),

/***/ 3547:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hexaString = void 0;
const array_1 = __webpack_require__(78309);
const hexa_1 = __webpack_require__(94383);
const CodePointsToString_1 = __webpack_require__(70172);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function hexaString(constraints = {}) {
    const charArbitrary = (0, hexa_1.hexa)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.hexaString = hexaString;


/***/ }),

/***/ 78278:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.infiniteStream = void 0;
const StreamArbitrary_1 = __webpack_require__(70131);
function infiniteStream(arb) {
    return new StreamArbitrary_1.StreamArbitrary(arb);
}
exports.infiniteStream = infiniteStream;


/***/ }),

/***/ 21465:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int16Array = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function int16Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, -32768, 32767, Int16Array, integer_1.integer);
}
exports.int16Array = int16Array;


/***/ }),

/***/ 37226:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int32Array = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function int32Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, -0x80000000, 0x7fffffff, Int32Array, integer_1.integer);
}
exports.int32Array = int32Array;


/***/ }),

/***/ 55525:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.int8Array = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function int8Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, -128, 127, Int8Array, integer_1.integer);
}
exports.int8Array = int8Array;


/***/ }),

/***/ 97706:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integer = void 0;
const IntegerArbitrary_1 = __webpack_require__(57396);
function buildCompleteIntegerConstraints(constraints) {
    const min = constraints.min !== undefined ? constraints.min : -0x80000000;
    const max = constraints.max !== undefined ? constraints.max : 0x7fffffff;
    return { min, max };
}
function integer(constraints = {}) {
    const fullConstraints = buildCompleteIntegerConstraints(constraints);
    if (fullConstraints.min > fullConstraints.max) {
        throw new Error('fc.integer maximum value should be equal or greater than the minimum one');
    }
    if (!Number.isInteger(fullConstraints.min)) {
        throw new Error('fc.integer minimum value should be an integer');
    }
    if (!Number.isInteger(fullConstraints.max)) {
        throw new Error('fc.integer maximum value should be an integer');
    }
    return new IntegerArbitrary_1.IntegerArbitrary(fullConstraints.min, fullConstraints.max);
}
exports.integer = integer;


/***/ }),

/***/ 20638:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV4 = void 0;
const nat_1 = __webpack_require__(45697);
const tuple_1 = __webpack_require__(85282);
const NatToStringifiedNat_1 = __webpack_require__(16415);
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.').map((v) => (0, NatToStringifiedNat_1.tryParseStringifiedNat)(v, 10));
}
function ipV4() {
    return (0, tuple_1.tuple)((0, nat_1.nat)(255), (0, nat_1.nat)(255), (0, nat_1.nat)(255), (0, nat_1.nat)(255)).map(dotJoinerMapper, dotJoinerUnmapper);
}
exports.ipV4 = ipV4;


/***/ }),

/***/ 11750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV4Extended = void 0;
const oneof_1 = __webpack_require__(89752);
const tuple_1 = __webpack_require__(85282);
const StringifiedNatArbitraryBuilder_1 = __webpack_require__(28670);
function dotJoinerMapper(data) {
    return data.join('.');
}
function dotJoinerUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Invalid type');
    }
    return value.split('.');
}
function ipV4Extended() {
    return (0, oneof_1.oneof)((0, tuple_1.tuple)((0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255)).map(dotJoinerMapper, dotJoinerUnmapper), (0, tuple_1.tuple)((0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(65535)).map(dotJoinerMapper, dotJoinerUnmapper), (0, tuple_1.tuple)((0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(255), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(16777215)).map(dotJoinerMapper, dotJoinerUnmapper), (0, StringifiedNatArbitraryBuilder_1.buildStringifiedNatArbitrary)(4294967295));
}
exports.ipV4Extended = ipV4Extended;


/***/ }),

/***/ 11187:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ipV6 = void 0;
const array_1 = __webpack_require__(78309);
const oneof_1 = __webpack_require__(89752);
const hexaString_1 = __webpack_require__(3547);
const tuple_1 = __webpack_require__(85282);
const ipV4_1 = __webpack_require__(20638);
const EntitiesToIPv6_1 = __webpack_require__(72210);
function h16sTol32Mapper([a, b]) {
    return `${a}:${b}`;
}
function h16sTol32Unmapper(value) {
    if (typeof value !== 'string')
        throw new Error('Invalid type');
    if (!value.includes(':'))
        throw new Error('Invalid value');
    return value.split(':', 2);
}
function ipV6() {
    const h16Arb = (0, hexaString_1.hexaString)({ minLength: 1, maxLength: 4, size: 'max' });
    const ls32Arb = (0, oneof_1.oneof)((0, tuple_1.tuple)(h16Arb, h16Arb).map(h16sTol32Mapper, h16sTol32Unmapper), (0, ipV4_1.ipV4)());
    return (0, oneof_1.oneof)((0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 6, maxLength: 6, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.fullySpecifiedMapper, EntitiesToIPv6_1.fullySpecifiedUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 5, maxLength: 5, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.onlyTrailingMapper, EntitiesToIPv6_1.onlyTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 1, size: 'max' }), (0, array_1.array)(h16Arb, { minLength: 4, maxLength: 4, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 2, size: 'max' }), (0, array_1.array)(h16Arb, { minLength: 3, maxLength: 3, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 3, size: 'max' }), (0, array_1.array)(h16Arb, { minLength: 2, maxLength: 2, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapper, EntitiesToIPv6_1.multiTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 4, size: 'max' }), h16Arb, ls32Arb).map(EntitiesToIPv6_1.multiTrailingMapperOne, EntitiesToIPv6_1.multiTrailingUnmapperOne), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 5, size: 'max' }), ls32Arb).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 6, size: 'max' }), h16Arb).map(EntitiesToIPv6_1.singleTrailingMapper, EntitiesToIPv6_1.singleTrailingUnmapper), (0, tuple_1.tuple)((0, array_1.array)(h16Arb, { minLength: 0, maxLength: 7, size: 'max' })).map(EntitiesToIPv6_1.noTrailingMapper, EntitiesToIPv6_1.noTrailingUnmapper));
}
exports.ipV6 = ipV6;


/***/ }),

/***/ 28678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.json = void 0;
const jsonValue_1 = __webpack_require__(91134);
function json(constraints = {}) {
    const arb = (0, jsonValue_1.jsonValue)(constraints);
    return arb.map(JSON.stringify);
}
exports.json = json;


/***/ }),

/***/ 91134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.jsonValue = void 0;
const string_1 = __webpack_require__(22320);
const JsonConstraintsBuilder_1 = __webpack_require__(29143);
const anything_1 = __webpack_require__(47111);
function jsonValue(constraints = {}) {
    return (0, anything_1.anything)((0, JsonConstraintsBuilder_1.jsonConstraintsBuilder)((0, string_1.string)(), constraints));
}
exports.jsonValue = jsonValue;


/***/ }),

/***/ 72234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.letrec = void 0;
const LazyArbitrary_1 = __webpack_require__(79749);
function letrec(builder) {
    const lazyArbs = Object.create(null);
    const tie = (key) => {
        if (!Object.prototype.hasOwnProperty.call(lazyArbs, key)) {
            lazyArbs[key] = new LazyArbitrary_1.LazyArbitrary(String(key));
        }
        return lazyArbs[key];
    };
    const strictArbs = builder(tie);
    for (const key in strictArbs) {
        if (!Object.prototype.hasOwnProperty.call(strictArbs, key)) {
            continue;
        }
        const lazyAtKey = lazyArbs[key];
        const lazyArb = lazyAtKey !== undefined ? lazyAtKey : new LazyArbitrary_1.LazyArbitrary(key);
        lazyArb.underlying = strictArbs[key];
        lazyArbs[key] = lazyArb;
    }
    return strictArbs;
}
exports.letrec = letrec;


/***/ }),

/***/ 99531:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.lorem = void 0;
const array_1 = __webpack_require__(78309);
const constant_1 = __webpack_require__(27440);
const oneof_1 = __webpack_require__(89752);
const WordsToLorem_1 = __webpack_require__(11406);
const h = (v, w) => {
    return { arbitrary: (0, constant_1.constant)(v), weight: w };
};
function loremWord() {
    return (0, oneof_1.oneof)(h('non', 6), h('adipiscing', 5), h('ligula', 5), h('enim', 5), h('pellentesque', 5), h('in', 5), h('augue', 5), h('et', 5), h('nulla', 5), h('lorem', 4), h('sit', 4), h('sed', 4), h('diam', 4), h('fermentum', 4), h('ut', 4), h('eu', 4), h('aliquam', 4), h('mauris', 4), h('vitae', 4), h('felis', 4), h('ipsum', 3), h('dolor', 3), h('amet,', 3), h('elit', 3), h('euismod', 3), h('mi', 3), h('orci', 3), h('erat', 3), h('praesent', 3), h('egestas', 3), h('leo', 3), h('vel', 3), h('sapien', 3), h('integer', 3), h('curabitur', 3), h('convallis', 3), h('purus', 3), h('risus', 2), h('suspendisse', 2), h('lectus', 2), h('nec,', 2), h('ultricies', 2), h('sed,', 2), h('cras', 2), h('elementum', 2), h('ultrices', 2), h('maecenas', 2), h('massa,', 2), h('varius', 2), h('a,', 2), h('semper', 2), h('proin', 2), h('nec', 2), h('nisl', 2), h('amet', 2), h('duis', 2), h('congue', 2), h('libero', 2), h('vestibulum', 2), h('pede', 2), h('blandit', 2), h('sodales', 2), h('ante', 2), h('nibh', 2), h('ac', 2), h('aenean', 2), h('massa', 2), h('suscipit', 2), h('sollicitudin', 2), h('fusce', 2), h('tempus', 2), h('aliquam,', 2), h('nunc', 2), h('ullamcorper', 2), h('rhoncus', 2), h('metus', 2), h('faucibus,', 2), h('justo', 2), h('magna', 2), h('at', 2), h('tincidunt', 2), h('consectetur', 1), h('tortor,', 1), h('dignissim', 1), h('congue,', 1), h('non,', 1), h('porttitor,', 1), h('nonummy', 1), h('molestie,', 1), h('est', 1), h('eleifend', 1), h('mi,', 1), h('arcu', 1), h('scelerisque', 1), h('vitae,', 1), h('consequat', 1), h('in,', 1), h('pretium', 1), h('volutpat', 1), h('pharetra', 1), h('tempor', 1), h('bibendum', 1), h('odio', 1), h('dui', 1), h('primis', 1), h('faucibus', 1), h('luctus', 1), h('posuere', 1), h('cubilia', 1), h('curae,', 1), h('hendrerit', 1), h('velit', 1), h('mauris,', 1), h('gravida', 1), h('ornare', 1), h('ut,', 1), h('pulvinar', 1), h('varius,', 1), h('turpis', 1), h('nibh,', 1), h('eros', 1), h('id', 1), h('aliquet', 1), h('quis', 1), h('lobortis', 1), h('consectetuer', 1), h('morbi', 1), h('vehicula', 1), h('tortor', 1), h('tellus,', 1), h('id,', 1), h('eu,', 1), h('quam', 1), h('feugiat,', 1), h('posuere,', 1), h('iaculis', 1), h('lectus,', 1), h('tristique', 1), h('mollis,', 1), h('nisl,', 1), h('vulputate', 1), h('sem', 1), h('vivamus', 1), h('placerat', 1), h('imperdiet', 1), h('cursus', 1), h('rutrum', 1), h('iaculis,', 1), h('augue,', 1), h('lacus', 1));
}
function lorem(constraints = {}) {
    const { maxCount, mode = 'words', size } = constraints;
    if (maxCount !== undefined && maxCount < 1) {
        throw new Error(`lorem has to produce at least one word/sentence`);
    }
    const wordArbitrary = loremWord();
    if (mode === 'sentences') {
        const sentence = (0, array_1.array)(wordArbitrary, { minLength: 1, size: 'small' }).map(WordsToLorem_1.wordsToSentenceMapper, (0, WordsToLorem_1.wordsToSentenceUnmapperFor)(wordArbitrary));
        return (0, array_1.array)(sentence, { minLength: 1, maxLength: maxCount, size }).map(WordsToLorem_1.sentencesToParagraphMapper, WordsToLorem_1.sentencesToParagraphUnmapper);
    }
    else {
        return (0, array_1.array)(wordArbitrary, { minLength: 1, maxLength: maxCount, size }).map(WordsToLorem_1.wordsToJoinedStringMapper, (0, WordsToLorem_1.wordsToJoinedStringUnmapperFor)(wordArbitrary));
    }
}
exports.lorem = lorem;


/***/ }),

/***/ 99613:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mapToConstant = void 0;
const nat_1 = __webpack_require__(45697);
const IndexToMappedConstant_1 = __webpack_require__(64153);
function computeNumChoices(options) {
    if (options.length === 0)
        throw new Error(`fc.mapToConstant expects at least one option`);
    let numChoices = 0;
    for (let idx = 0; idx !== options.length; ++idx) {
        if (options[idx].num < 0)
            throw new Error(`fc.mapToConstant expects all options to have a number of entries greater or equal to zero`);
        numChoices += options[idx].num;
    }
    if (numChoices === 0)
        throw new Error(`fc.mapToConstant expects at least one choice among options`);
    return numChoices;
}
function mapToConstant(...entries) {
    const numChoices = computeNumChoices(entries);
    return (0, nat_1.nat)({ max: numChoices - 1 }).map((0, IndexToMappedConstant_1.indexToMappedConstantMapperFor)(entries), (0, IndexToMappedConstant_1.indexToMappedConstantUnmapperFor)(entries));
}
exports.mapToConstant = mapToConstant;


/***/ }),

/***/ 39371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxSafeInteger = void 0;
const IntegerArbitrary_1 = __webpack_require__(57396);
function maxSafeInteger() {
    return new IntegerArbitrary_1.IntegerArbitrary(Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER);
}
exports.maxSafeInteger = maxSafeInteger;


/***/ }),

/***/ 91353:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.maxSafeNat = void 0;
const IntegerArbitrary_1 = __webpack_require__(57396);
function maxSafeNat() {
    return new IntegerArbitrary_1.IntegerArbitrary(0, Number.MAX_SAFE_INTEGER);
}
exports.maxSafeNat = maxSafeNat;


/***/ }),

/***/ 53837:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.memo = void 0;
let contextRemainingDepth = 10;
function memo(builder) {
    const previous = {};
    return ((maxDepth) => {
        const n = maxDepth !== undefined ? maxDepth : contextRemainingDepth;
        if (!Object.prototype.hasOwnProperty.call(previous, n)) {
            const prev = contextRemainingDepth;
            contextRemainingDepth = n - 1;
            previous[n] = builder(n);
            contextRemainingDepth = prev;
        }
        return previous[n];
    });
}
exports.memo = memo;


/***/ }),

/***/ 27181:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mixedCase = void 0;
const MixedCaseArbitrary_1 = __webpack_require__(57681);
function defaultToggleCase(rawChar) {
    const upper = rawChar.toUpperCase();
    if (upper !== rawChar)
        return upper;
    return rawChar.toLowerCase();
}
function mixedCase(stringArb, constraints) {
    if (typeof BigInt === 'undefined') {
        throw new Error(`mixedCase requires BigInt support`);
    }
    const toggleCase = (constraints && constraints.toggleCase) || defaultToggleCase;
    const untoggleAll = constraints && constraints.untoggleAll;
    return new MixedCaseArbitrary_1.MixedCaseArbitrary(stringArb, toggleCase, untoggleAll);
}
exports.mixedCase = mixedCase;


/***/ }),

/***/ 45697:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.nat = void 0;
const IntegerArbitrary_1 = __webpack_require__(57396);
function nat(arg) {
    const max = typeof arg === 'number' ? arg : arg && arg.max !== undefined ? arg.max : 0x7fffffff;
    if (max < 0) {
        throw new Error('fc.nat value should be greater than or equal to 0');
    }
    if (!Number.isInteger(max)) {
        throw new Error('fc.nat maximum value should be an integer');
    }
    return new IntegerArbitrary_1.IntegerArbitrary(0, max);
}
exports.nat = nat;


/***/ }),

/***/ 41574:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.object = void 0;
const dictionary_1 = __webpack_require__(64444);
const AnyArbitraryBuilder_1 = __webpack_require__(31995);
const QualifiedObjectConstraints_1 = __webpack_require__(92113);
function objectInternal(constraints) {
    return (0, dictionary_1.dictionary)(constraints.key, (0, AnyArbitraryBuilder_1.anyArbitraryBuilder)(constraints), {
        maxKeys: constraints.maxKeys,
        size: constraints.size,
    });
}
function object(constraints) {
    return objectInternal((0, QualifiedObjectConstraints_1.toQualifiedObjectConstraints)(constraints));
}
exports.object = object;


/***/ }),

/***/ 89752:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.oneof = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const FrequencyArbitrary_1 = __webpack_require__(74658);
function isOneOfContraints(param) {
    return (param != null &&
        typeof param === 'object' &&
        !('generate' in param) &&
        !('arbitrary' in param) &&
        !('weight' in param));
}
function toWeightedArbitrary(maybeWeightedArbitrary) {
    if ((0, Arbitrary_1.isArbitrary)(maybeWeightedArbitrary)) {
        return { arbitrary: maybeWeightedArbitrary, weight: 1 };
    }
    return maybeWeightedArbitrary;
}
function oneof(...args) {
    const constraints = args[0];
    if (isOneOfContraints(constraints)) {
        const weightedArbs = args.slice(1).map(toWeightedArbitrary);
        return FrequencyArbitrary_1.FrequencyArbitrary.from(weightedArbs, constraints, 'fc.oneof');
    }
    const weightedArbs = args.map(toWeightedArbitrary);
    return FrequencyArbitrary_1.FrequencyArbitrary.from(weightedArbs, {}, 'fc.oneof');
}
exports.oneof = oneof;


/***/ }),

/***/ 91953:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.option = void 0;
const constant_1 = __webpack_require__(27440);
const FrequencyArbitrary_1 = __webpack_require__(74658);
function option(arb, constraints = {}) {
    const freq = constraints.freq == null ? 5 : constraints.freq;
    const nilValue = Object.prototype.hasOwnProperty.call(constraints, 'nil') ? constraints.nil : null;
    const nilArb = (0, constant_1.constant)(nilValue);
    const weightedArbs = [
        { arbitrary: nilArb, weight: 1, fallbackValue: { default: nilValue } },
        { arbitrary: arb, weight: freq },
    ];
    const frequencyConstraints = {
        withCrossShrink: true,
        depthSize: constraints.depthSize,
        maxDepth: constraints.maxDepth,
        depthIdentifier: constraints.depthIdentifier,
    };
    return FrequencyArbitrary_1.FrequencyArbitrary.from(weightedArbs, frequencyConstraints, 'fc.option');
}
exports.option = option;


/***/ }),

/***/ 22066:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.record = void 0;
const PartialRecordArbitraryBuilder_1 = __webpack_require__(45056);
function record(recordModel, constraints) {
    if (constraints == null) {
        return (0, PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary)(recordModel, undefined);
    }
    if ('withDeletedKeys' in constraints && 'requiredKeys' in constraints) {
        throw new Error(`requiredKeys and withDeletedKeys cannot be used together in fc.record`);
    }
    const requireDeletedKeys = ('requiredKeys' in constraints && constraints.requiredKeys !== undefined) ||
        ('withDeletedKeys' in constraints && !!constraints.withDeletedKeys);
    if (!requireDeletedKeys) {
        return (0, PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary)(recordModel, undefined);
    }
    const requiredKeys = ('requiredKeys' in constraints ? constraints.requiredKeys : undefined) || [];
    for (let idx = 0; idx !== requiredKeys.length; ++idx) {
        const descriptor = Object.getOwnPropertyDescriptor(recordModel, requiredKeys[idx]);
        if (descriptor === undefined) {
            throw new Error(`requiredKeys cannot reference keys that have not been defined in recordModel`);
        }
        if (!descriptor.enumerable) {
            throw new Error(`requiredKeys cannot reference keys that have are enumerable in recordModel`);
        }
    }
    return (0, PartialRecordArbitraryBuilder_1.buildPartialRecordArbitrary)(recordModel, requiredKeys);
}
exports.record = record;


/***/ }),

/***/ 5062:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.schedulerFor = exports.scheduler = void 0;
const BuildSchedulerFor_1 = __webpack_require__(15536);
const SchedulerArbitrary_1 = __webpack_require__(41981);
function scheduler(constraints) {
    const { act = (f) => f() } = constraints || {};
    return new SchedulerArbitrary_1.SchedulerArbitrary(act);
}
exports.scheduler = scheduler;
function schedulerFor(customOrderingOrConstraints, constraintsOrUndefined) {
    const { act = (f) => f() } = Array.isArray(customOrderingOrConstraints)
        ? constraintsOrUndefined || {}
        : customOrderingOrConstraints || {};
    if (Array.isArray(customOrderingOrConstraints)) {
        return (0, BuildSchedulerFor_1.buildSchedulerFor)(act, customOrderingOrConstraints);
    }
    return function (_strs, ...ordering) {
        return (0, BuildSchedulerFor_1.buildSchedulerFor)(act, ordering);
    };
}
exports.schedulerFor = schedulerFor;


/***/ }),

/***/ 69994:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.shuffledSubarray = void 0;
const SubarrayArbitrary_1 = __webpack_require__(67634);
function shuffledSubarray(originalArray, constraints = {}) {
    const { minLength = 0, maxLength = originalArray.length } = constraints;
    return new SubarrayArbitrary_1.SubarrayArbitrary(originalArray, false, minLength, maxLength);
}
exports.shuffledSubarray = shuffledSubarray;


/***/ }),

/***/ 98975:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sparseArray = void 0;
const tuple_1 = __webpack_require__(85282);
const uniqueArray_1 = __webpack_require__(20005);
const RestrictedIntegerArbitraryBuilder_1 = __webpack_require__(11446);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
function extractMaxIndex(indexesAndValues) {
    let maxIndex = -1;
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);
    }
    return maxIndex;
}
function arrayFromItems(length, indexesAndValues) {
    const array = Array(length);
    for (let index = 0; index !== indexesAndValues.length; ++index) {
        const it = indexesAndValues[index];
        if (it[0] < length)
            array[it[0]] = it[1];
    }
    return array;
}
function sparseArray(arb, constraints = {}) {
    const { size, minNumElements = 0, maxLength = MaxLengthFromMinLength_1.MaxLengthUpperBound, maxNumElements = maxLength, noTrailingHole, depthIdentifier, } = constraints;
    const maxGeneratedNumElements = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);
    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);
    if (minNumElements > maxLength) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal length of the array`);
    }
    if (minNumElements > maxNumElements) {
        throw new Error(`The minimal number of non-hole elements cannot be higher than the maximal number of non-holes`);
    }
    const resultedMaxNumElements = Math.min(maxNumElements, maxLength);
    const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';
    const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);
    const maxIndexAuthorized = Math.max(maxLength - 1, 0);
    const sparseArrayNoTrailingHole = (0, uniqueArray_1.uniqueArray)((0, tuple_1.tuple)((0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {
        size: resultedSizeMaxNumElements,
        minLength: minNumElements,
        maxLength: resultedMaxNumElements,
        selector: (item) => item[0],
        depthIdentifier,
    }).map((items) => {
        const lastIndex = extractMaxIndex(items);
        return arrayFromItems(lastIndex + 1, items);
    }, (value) => {
        if (!Array.isArray(value)) {
            throw new Error('Not supported entry type');
        }
        if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {
            throw new Error('No trailing hole');
        }
        return Object.entries(value).map((entry) => [Number(entry[0]), entry[1]]);
    });
    if (noTrailingHole || maxLength === minNumElements) {
        return sparseArrayNoTrailingHole;
    }
    return (0, tuple_1.tuple)(sparseArrayNoTrailingHole, (0, RestrictedIntegerArbitraryBuilder_1.restrictedIntegerArbitraryBuilder)(minNumElements, maxGeneratedLength, maxLength)).map((data) => {
        const sparse = data[0];
        const targetLength = data[1];
        if (sparse.length >= targetLength) {
            return sparse;
        }
        const longerSparse = sparse.slice();
        longerSparse.length = targetLength;
        return longerSparse;
    }, (value) => {
        if (!Array.isArray(value)) {
            throw new Error('Not supported entry type');
        }
        return [value, value.length];
    });
}
exports.sparseArray = sparseArray;


/***/ }),

/***/ 22320:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string = void 0;
const array_1 = __webpack_require__(78309);
const char_1 = __webpack_require__(69165);
const CodePointsToString_1 = __webpack_require__(70172);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function string(constraints = {}) {
    const charArbitrary = (0, char_1.char)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.string = string;


/***/ }),

/***/ 58447:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.string16bits = void 0;
const array_1 = __webpack_require__(78309);
const char16bits_1 = __webpack_require__(22097);
const CharsToString_1 = __webpack_require__(70049);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function string16bits(constraints = {}) {
    const charArbitrary = (0, char16bits_1.char16bits)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CharsToString_1.charsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CharsToString_1.charsToStringMapper, CharsToString_1.charsToStringUnmapper);
}
exports.string16bits = string16bits;


/***/ }),

/***/ 85082:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringOf = void 0;
const array_1 = __webpack_require__(78309);
const PatternsToString_1 = __webpack_require__(16387);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function stringOf(charArb, constraints = {}) {
    const unmapper = (0, PatternsToString_1.patternsToStringUnmapperFor)(charArb, constraints);
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArb, unmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArb, enrichedConstraints).map(PatternsToString_1.patternsToStringMapper, unmapper);
}
exports.stringOf = stringOf;


/***/ }),

/***/ 22650:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.subarray = void 0;
const SubarrayArbitrary_1 = __webpack_require__(67634);
function subarray(originalArray, constraints = {}) {
    const { minLength = 0, maxLength = originalArray.length } = constraints;
    return new SubarrayArbitrary_1.SubarrayArbitrary(originalArray, true, minLength, maxLength);
}
exports.subarray = subarray;


/***/ }),

/***/ 85282:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tuple = void 0;
const TupleArbitrary_1 = __webpack_require__(18404);
function tuple(...arbs) {
    return new TupleArbitrary_1.TupleArbitrary(arbs);
}
exports.tuple = tuple;


/***/ }),

/***/ 96702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint16Array = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function uint16Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 65535, Uint16Array, integer_1.integer);
}
exports.uint16Array = uint16Array;


/***/ }),

/***/ 3594:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint32Array = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function uint32Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 0xffffffff, Uint32Array, integer_1.integer);
}
exports.uint32Array = uint32Array;


/***/ }),

/***/ 83468:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint8Array = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function uint8Array(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 255, Uint8Array, integer_1.integer);
}
exports.uint8Array = uint8Array;


/***/ }),

/***/ 74729:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uint8ClampedArray = void 0;
const integer_1 = __webpack_require__(97706);
const TypedIntArrayArbitraryBuilder_1 = __webpack_require__(13048);
function uint8ClampedArray(constraints = {}) {
    return (0, TypedIntArrayArbitraryBuilder_1.typedIntArrayArbitraryArbitraryBuilder)(constraints, 0, 255, Uint8ClampedArray, integer_1.integer);
}
exports.uint8ClampedArray = uint8ClampedArray;


/***/ }),

/***/ 83405:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicode = void 0;
const CharacterArbitraryBuilder_1 = __webpack_require__(39607);
const IndexToPrintableIndex_1 = __webpack_require__(29546);
const gapSize = 0xdfff + 1 - 0xd800;
function unicodeMapper(v) {
    if (v < 0xd800)
        return (0, IndexToPrintableIndex_1.indexToPrintableIndexMapper)(v);
    return v + gapSize;
}
function unicodeUnmapper(v) {
    if (v < 0xd800)
        return (0, IndexToPrintableIndex_1.indexToPrintableIndexUnmapper)(v);
    if (v <= 0xdfff)
        return -1;
    return v - gapSize;
}
function unicode() {
    return (0, CharacterArbitraryBuilder_1.buildCharacterArbitrary)(0x0000, 0xffff - gapSize, unicodeMapper, unicodeUnmapper);
}
exports.unicode = unicode;


/***/ }),

/***/ 66556:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeJson = void 0;
const unicodeJsonValue_1 = __webpack_require__(22883);
function unicodeJson(constraints = {}) {
    const arb = (0, unicodeJsonValue_1.unicodeJsonValue)(constraints);
    return arb.map(JSON.stringify);
}
exports.unicodeJson = unicodeJson;


/***/ }),

/***/ 22883:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeJsonValue = void 0;
const unicodeString_1 = __webpack_require__(20671);
const JsonConstraintsBuilder_1 = __webpack_require__(29143);
const anything_1 = __webpack_require__(47111);
function unicodeJsonValue(constraints = {}) {
    return (0, anything_1.anything)((0, JsonConstraintsBuilder_1.jsonConstraintsBuilder)((0, unicodeString_1.unicodeString)(), constraints));
}
exports.unicodeJsonValue = unicodeJsonValue;


/***/ }),

/***/ 20671:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unicodeString = void 0;
const array_1 = __webpack_require__(78309);
const unicode_1 = __webpack_require__(83405);
const CodePointsToString_1 = __webpack_require__(70172);
const SlicesForStringBuilder_1 = __webpack_require__(90381);
function unicodeString(constraints = {}) {
    const charArbitrary = (0, unicode_1.unicode)();
    const experimentalCustomSlices = (0, SlicesForStringBuilder_1.createSlicesForString)(charArbitrary, CodePointsToString_1.codePointsToStringUnmapper);
    const enrichedConstraints = Object.assign(Object.assign({}, constraints), { experimentalCustomSlices });
    return (0, array_1.array)(charArbitrary, enrichedConstraints).map(CodePointsToString_1.codePointsToStringMapper, CodePointsToString_1.codePointsToStringUnmapper);
}
exports.unicodeString = unicodeString;


/***/ }),

/***/ 20005:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uniqueArray = void 0;
const ArrayArbitrary_1 = __webpack_require__(49844);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
const CustomEqualSet_1 = __webpack_require__(61839);
const StrictlyEqualSet_1 = __webpack_require__(24423);
const SameValueSet_1 = __webpack_require__(30556);
const SameValueZeroSet_1 = __webpack_require__(47238);
function buildUniqueArraySetBuilder(constraints) {
    if (typeof constraints.comparator === 'function') {
        if (constraints.selector === undefined) {
            const comparator = constraints.comparator;
            const isEqualForBuilder = (nextA, nextB) => comparator(nextA.value_, nextB.value_);
            return () => new CustomEqualSet_1.CustomEqualSet(isEqualForBuilder);
        }
        const comparator = constraints.comparator;
        const selector = constraints.selector;
        const refinedSelector = (next) => selector(next.value_);
        const isEqualForBuilder = (nextA, nextB) => comparator(refinedSelector(nextA), refinedSelector(nextB));
        return () => new CustomEqualSet_1.CustomEqualSet(isEqualForBuilder);
    }
    const selector = constraints.selector || ((v) => v);
    const refinedSelector = (next) => selector(next.value_);
    switch (constraints.comparator) {
        case 'IsStrictlyEqual':
            return () => new StrictlyEqualSet_1.StrictlyEqualSet(refinedSelector);
        case 'SameValueZero':
            return () => new SameValueZeroSet_1.SameValueZeroSet(refinedSelector);
        case 'SameValue':
        case undefined:
            return () => new SameValueSet_1.SameValueSet(refinedSelector);
    }
}
function uniqueArray(arb, constraints = {}) {
    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;
    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthFromMinLength_1.MaxLengthUpperBound;
    const maxGeneratedLength = (0, MaxLengthFromMinLength_1.maxGeneratedLengthFromSizeForArbitrary)(constraints.size, minLength, maxLength, constraints.maxLength !== undefined);
    const depthIdentifier = constraints.depthIdentifier;
    const setBuilder = buildUniqueArraySetBuilder(constraints);
    const arrayArb = new ArrayArbitrary_1.ArrayArbitrary(arb, minLength, maxGeneratedLength, maxLength, depthIdentifier, setBuilder, []);
    if (minLength === 0)
        return arrayArb;
    return arrayArb.filter((tab) => tab.length >= minLength);
}
exports.uniqueArray = uniqueArray;


/***/ }),

/***/ 44615:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuid = void 0;
const tuple_1 = __webpack_require__(85282);
const PaddedNumberArbitraryBuilder_1 = __webpack_require__(61472);
const PaddedEightsToUuid_1 = __webpack_require__(71162);
function uuid() {
    const padded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const secondPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x10000000, 0x5fffffff);
    const thirdPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, tuple_1.tuple)(padded, secondPadded, thirdPadded, padded).map(PaddedEightsToUuid_1.paddedEightsToUuidMapper, PaddedEightsToUuid_1.paddedEightsToUuidUnmapper);
}
exports.uuid = uuid;


/***/ }),

/***/ 88029:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uuidV = void 0;
const tuple_1 = __webpack_require__(85282);
const PaddedNumberArbitraryBuilder_1 = __webpack_require__(61472);
const PaddedEightsToUuid_1 = __webpack_require__(71162);
function uuidV(versionNumber) {
    const padded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0, 0xffffffff);
    const offsetSecond = versionNumber * 0x10000000;
    const secondPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(offsetSecond, offsetSecond + 0x0fffffff);
    const thirdPadded = (0, PaddedNumberArbitraryBuilder_1.buildPaddedNumberArbitrary)(0x80000000, 0xbfffffff);
    return (0, tuple_1.tuple)(padded, secondPadded, thirdPadded, padded).map(PaddedEightsToUuid_1.paddedEightsToUuidMapper, PaddedEightsToUuid_1.paddedEightsToUuidUnmapper);
}
exports.uuidV = uuidV;


/***/ }),

/***/ 76718:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webAuthority = void 0;
const CharacterRangeArbitraryBuilder_1 = __webpack_require__(40085);
const constant_1 = __webpack_require__(27440);
const domain_1 = __webpack_require__(90301);
const ipV4_1 = __webpack_require__(20638);
const ipV4Extended_1 = __webpack_require__(11750);
const ipV6_1 = __webpack_require__(11187);
const nat_1 = __webpack_require__(45697);
const oneof_1 = __webpack_require__(89752);
const option_1 = __webpack_require__(91953);
const stringOf_1 = __webpack_require__(85082);
const tuple_1 = __webpack_require__(85282);
function hostUserInfo(size) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size });
}
function userHostPortMapper([u, h, p]) {
    return (u === null ? '' : `${u}@`) + h + (p === null ? '' : `:${p}`);
}
function userHostPortUnmapper(value) {
    if (typeof value !== 'string') {
        throw new Error('Unsupported');
    }
    const atPosition = value.indexOf('@');
    const user = atPosition !== -1 ? value.substring(0, atPosition) : null;
    const portRegex = /:(\d+)$/;
    const m = portRegex.exec(value);
    const port = m !== null ? Number(m[1]) : null;
    const host = m !== null ? value.substring(atPosition + 1, value.length - m[1].length - 1) : value.substring(atPosition + 1);
    return [user, host, port];
}
function bracketedMapper(s) {
    return `[${s}]`;
}
function bracketedUnmapper(value) {
    if (typeof value !== 'string' || value[0] !== '[' || value[value.length - 1] !== ']') {
        throw new Error('Unsupported');
    }
    return value.substring(1, value.length - 1);
}
function webAuthority(constraints) {
    const c = constraints || {};
    const size = c.size;
    const hostnameArbs = [(0, domain_1.domain)({ size })]
        .concat(c.withIPv4 === true ? [(0, ipV4_1.ipV4)()] : [])
        .concat(c.withIPv6 === true ? [(0, ipV6_1.ipV6)().map(bracketedMapper, bracketedUnmapper)] : [])
        .concat(c.withIPv4Extended === true ? [(0, ipV4Extended_1.ipV4Extended)()] : []);
    return (0, tuple_1.tuple)(c.withUserInfo === true ? (0, option_1.option)(hostUserInfo(size)) : (0, constant_1.constant)(null), (0, oneof_1.oneof)(...hostnameArbs), c.withPort === true ? (0, option_1.option)((0, nat_1.nat)(65535)) : (0, constant_1.constant)(null)).map(userHostPortMapper, userHostPortUnmapper);
}
exports.webAuthority = webAuthority;


/***/ }),

/***/ 56859:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webFragments = void 0;
const UriQueryOrFragmentArbitraryBuilder_1 = __webpack_require__(65026);
function webFragments(constraints = {}) {
    return (0, UriQueryOrFragmentArbitraryBuilder_1.buildUriQueryOrFragmentArbitrary)(constraints.size);
}
exports.webFragments = webFragments;


/***/ }),

/***/ 6924:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webQueryParameters = void 0;
const UriQueryOrFragmentArbitraryBuilder_1 = __webpack_require__(65026);
function webQueryParameters(constraints = {}) {
    return (0, UriQueryOrFragmentArbitraryBuilder_1.buildUriQueryOrFragmentArbitrary)(constraints.size);
}
exports.webQueryParameters = webQueryParameters;


/***/ }),

/***/ 28845:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webSegment = void 0;
const CharacterRangeArbitraryBuilder_1 = __webpack_require__(40085);
const stringOf_1 = __webpack_require__(85082);
function webSegment(constraints = {}) {
    const others = ['-', '.', '_', '~', '!', '$', '&', "'", '(', ')', '*', '+', ',', ';', '=', ':', '@'];
    return (0, stringOf_1.stringOf)((0, CharacterRangeArbitraryBuilder_1.buildAlphaNumericPercentArbitrary)(others), { size: constraints.size });
}
exports.webSegment = webSegment;


/***/ }),

/***/ 30412:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.webUrl = void 0;
const constantFrom_1 = __webpack_require__(80305);
const constant_1 = __webpack_require__(27440);
const option_1 = __webpack_require__(91953);
const tuple_1 = __webpack_require__(85282);
const webQueryParameters_1 = __webpack_require__(6924);
const webFragments_1 = __webpack_require__(56859);
const webAuthority_1 = __webpack_require__(76718);
const PartsToUrl_1 = __webpack_require__(50250);
const MaxLengthFromMinLength_1 = __webpack_require__(70883);
const UriPathArbitraryBuilder_1 = __webpack_require__(57218);
function webUrl(constraints) {
    const c = constraints || {};
    const resolvedSize = (0, MaxLengthFromMinLength_1.resolveSize)(c.size);
    const resolvedAuthoritySettingsSize = c.authoritySettings !== undefined && c.authoritySettings.size !== undefined
        ? (0, MaxLengthFromMinLength_1.relativeSizeToSize)(c.authoritySettings.size, resolvedSize)
        : resolvedSize;
    const resolvedAuthoritySettings = Object.assign(Object.assign({}, c.authoritySettings), { size: resolvedAuthoritySettingsSize });
    const validSchemes = c.validSchemes || ['http', 'https'];
    const schemeArb = (0, constantFrom_1.constantFrom)(...validSchemes);
    const authorityArb = (0, webAuthority_1.webAuthority)(resolvedAuthoritySettings);
    const pathArb = (0, UriPathArbitraryBuilder_1.buildUriPathArbitrary)(resolvedSize);
    return (0, tuple_1.tuple)(schemeArb, authorityArb, pathArb, c.withQueryParameters === true ? (0, option_1.option)((0, webQueryParameters_1.webQueryParameters)({ size: resolvedSize })) : (0, constant_1.constant)(null), c.withFragments === true ? (0, option_1.option)((0, webFragments_1.webFragments)({ size: resolvedSize })) : (0, constant_1.constant)(null)).map(PartsToUrl_1.partsToUrlMapper, PartsToUrl_1.partsToUrlUnmapper);
}
exports.webUrl = webUrl;


/***/ }),

/***/ 40305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertIsArbitrary = exports.isArbitrary = exports.Arbitrary = void 0;
const Stream_1 = __webpack_require__(99385);
const symbols_1 = __webpack_require__(28620);
const Value_1 = __webpack_require__(60641);
class Arbitrary {
    filter(refinement) {
        return new FilterArbitrary(this, refinement);
    }
    map(mapper, unmapper) {
        return new MapArbitrary(this, mapper, unmapper);
    }
    chain(chainer) {
        return new ChainArbitrary(this, chainer);
    }
    noShrink() {
        return new NoShrinkArbitrary(this);
    }
    noBias() {
        return new NoBiasArbitrary(this);
    }
}
exports.Arbitrary = Arbitrary;
class ChainArbitrary extends Arbitrary {
    constructor(arb, chainer) {
        super();
        this.arb = arb;
        this.chainer = chainer;
    }
    generate(mrng, biasFactor) {
        const clonedMrng = mrng.clone();
        const src = this.arb.generate(mrng, biasFactor);
        return this.valueChainer(src, mrng, clonedMrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return (!context.stoppedForOriginal
                ? this.arb
                    .shrink(context.originalValue, context.originalContext)
                    .map((v) => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias))
                : Stream_1.Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map((dst) => {
                const newContext = Object.assign(Object.assign({}, context), { chainedContext: dst.context, stoppedForOriginal: true });
                return new Value_1.Value(dst.value_, newContext);
            }));
        }
        return Stream_1.Stream.nil();
    }
    valueChainer(v, generateMrng, clonedMrng, biasFactor) {
        const chainedArbitrary = this.chainer(v.value_);
        const dst = chainedArbitrary.generate(generateMrng, biasFactor);
        const context = {
            originalBias: biasFactor,
            originalValue: v.value_,
            originalContext: v.context,
            stoppedForOriginal: false,
            chainedArbitrary,
            chainedContext: dst.context,
            clonedMrng,
        };
        return new Value_1.Value(dst.value_, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalBias' in context &&
            'originalValue' in context &&
            'originalContext' in context &&
            'stoppedForOriginal' in context &&
            'chainedArbitrary' in context &&
            'chainedContext' in context &&
            'clonedMrng' in context);
    }
}
class MapArbitrary extends Arbitrary {
    constructor(arb, mapper, unmapper) {
        super();
        this.arb = arb;
        this.mapper = mapper;
        this.unmapper = unmapper;
        this.bindValueMapper = this.valueMapper.bind(this);
    }
    generate(mrng, biasFactor) {
        const g = this.arb.generate(mrng, biasFactor);
        return this.valueMapper(g);
    }
    canShrinkWithoutContext(value) {
        if (this.unmapper !== undefined) {
            try {
                const unmapped = this.unmapper(value);
                return this.arb.canShrinkWithoutContext(unmapped);
            }
            catch (_err) {
                return false;
            }
        }
        return false;
    }
    shrink(value, context) {
        if (this.isSafeContext(context)) {
            return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);
        }
        if (this.unmapper !== undefined) {
            const unmapped = this.unmapper(value);
            return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);
        }
        return Stream_1.Stream.nil();
    }
    mapperWithCloneIfNeeded(v) {
        const sourceValue = v.value;
        const mappedValue = this.mapper(sourceValue);
        if (v.hasToBeCloned &&
            ((typeof mappedValue === 'object' && mappedValue !== null) || typeof mappedValue === 'function') &&
            Object.isExtensible(mappedValue) &&
            !(0, symbols_1.hasCloneMethod)(mappedValue)) {
            Object.defineProperty(mappedValue, symbols_1.cloneMethod, { get: () => () => this.mapperWithCloneIfNeeded(v)[0] });
        }
        return [mappedValue, sourceValue];
    }
    valueMapper(v) {
        const [mappedValue, sourceValue] = this.mapperWithCloneIfNeeded(v);
        const context = { originalValue: sourceValue, originalContext: v.context };
        return new Value_1.Value(mappedValue, context);
    }
    isSafeContext(context) {
        return (context != null &&
            typeof context === 'object' &&
            'originalValue' in context &&
            'originalContext' in context);
    }
}
class FilterArbitrary extends Arbitrary {
    constructor(arb, refinement) {
        super();
        this.arb = arb;
        this.refinement = refinement;
        this.bindRefinementOnValue = this.refinementOnValue.bind(this);
    }
    generate(mrng, biasFactor) {
        while (true) {
            const g = this.arb.generate(mrng, biasFactor);
            if (this.refinementOnValue(g)) {
                return g;
            }
        }
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value) && this.refinement(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);
    }
    refinementOnValue(v) {
        return this.refinement(v.value);
    }
}
class NoShrinkArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, biasFactor) {
        return this.arb.generate(mrng, biasFactor);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(_value, _context) {
        return Stream_1.Stream.nil();
    }
    noShrink() {
        return this;
    }
}
class NoBiasArbitrary extends Arbitrary {
    constructor(arb) {
        super();
        this.arb = arb;
    }
    generate(mrng, _biasFactor) {
        return this.arb.generate(mrng, undefined);
    }
    canShrinkWithoutContext(value) {
        return this.arb.canShrinkWithoutContext(value);
    }
    shrink(value, context) {
        return this.arb.shrink(value, context);
    }
    noBias() {
        return this;
    }
}
function isArbitrary(instance) {
    return (typeof instance === 'object' &&
        instance !== null &&
        'generate' in instance &&
        'shrink' in instance &&
        'canShrinkWithoutContext' in instance);
}
exports.isArbitrary = isArbitrary;
function assertIsArbitrary(instance) {
    if (!isArbitrary(instance)) {
        throw new Error('Unexpected value received: not an instance of Arbitrary');
    }
}
exports.assertIsArbitrary = assertIsArbitrary;


/***/ }),

/***/ 60641:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Value = void 0;
const symbols_1 = __webpack_require__(28620);
class Value {
    constructor(value_, context, customGetValue = undefined) {
        this.value_ = value_;
        this.context = context;
        this.hasToBeCloned = customGetValue !== undefined || (0, symbols_1.hasCloneMethod)(value_);
        this.readOnce = false;
        if (this.hasToBeCloned) {
            Object.defineProperty(this, 'value', { get: customGetValue !== undefined ? customGetValue : this.getValue });
        }
        else {
            this.value = value_;
        }
    }
    getValue() {
        if (this.hasToBeCloned) {
            if (!this.readOnce) {
                this.readOnce = true;
                return this.value_;
            }
            return this.value_[symbols_1.cloneMethod]();
        }
        return this.value_;
    }
}
exports.Value = Value;


/***/ }),

/***/ 8316:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scheduledModelRun = exports.asyncModelRun = exports.modelRun = void 0;
const ScheduledCommand_1 = __webpack_require__(84113);
const genericModelRun = (s, cmds, initialValue, runCmd, then) => {
    return s.then((o) => {
        const { model, real } = o;
        let state = initialValue;
        for (const c of cmds) {
            state = then(state, () => {
                return runCmd(c, model, real);
            });
        }
        return state;
    });
};
const internalModelRun = (s, cmds) => {
    const then = (_p, c) => c();
    const setupProducer = {
        then: (fun) => {
            fun(s());
            return undefined;
        },
    };
    const runSync = (cmd, m, r) => {
        if (cmd.check(m))
            cmd.run(m, r);
        return undefined;
    };
    return genericModelRun(setupProducer, cmds, undefined, runSync, then);
};
const isAsyncSetup = (s) => {
    return typeof s.then === 'function';
};
const internalAsyncModelRun = async (s, cmds, defaultPromise = Promise.resolve()) => {
    const then = (p, c) => p.then(c);
    const setupProducer = {
        then: (fun) => {
            const out = s();
            if (isAsyncSetup(out))
                return out.then(fun);
            else
                return fun(out);
        },
    };
    const runAsync = async (cmd, m, r) => {
        if (await cmd.check(m))
            await cmd.run(m, r);
    };
    return await genericModelRun(setupProducer, cmds, defaultPromise, runAsync, then);
};
function modelRun(s, cmds) {
    internalModelRun(s, cmds);
}
exports.modelRun = modelRun;
async function asyncModelRun(s, cmds) {
    await internalAsyncModelRun(s, cmds);
}
exports.asyncModelRun = asyncModelRun;
async function scheduledModelRun(scheduler, s, cmds) {
    const scheduledCommands = (0, ScheduledCommand_1.scheduleCommands)(scheduler, cmds);
    const out = internalAsyncModelRun(s, scheduledCommands, scheduler.schedule(Promise.resolve(), 'startModel'));
    await scheduler.waitAll();
    await out;
}
exports.scheduledModelRun = scheduledModelRun;


/***/ }),

/***/ 26979:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReplayPath = void 0;
class ReplayPath {
    static parse(replayPathStr) {
        const [serializedCount, serializedChanges] = replayPathStr.split(':');
        const counts = this.parseCounts(serializedCount);
        const changes = this.parseChanges(serializedChanges);
        return this.parseOccurences(counts, changes);
    }
    static stringify(replayPath) {
        const occurences = this.countOccurences(replayPath);
        const serializedCount = this.stringifyCounts(occurences);
        const serializedChanges = this.stringifyChanges(occurences);
        return `${serializedCount}:${serializedChanges}`;
    }
    static intToB64(n) {
        if (n < 26)
            return String.fromCharCode(n + 65);
        if (n < 52)
            return String.fromCharCode(n + 97 - 26);
        if (n < 62)
            return String.fromCharCode(n + 48 - 52);
        return String.fromCharCode(n === 62 ? 43 : 47);
    }
    static b64ToInt(c) {
        if (c >= 'a')
            return c.charCodeAt(0) - 97 + 26;
        if (c >= 'A')
            return c.charCodeAt(0) - 65;
        if (c >= '0')
            return c.charCodeAt(0) - 48 + 52;
        return c === '+' ? 62 : 63;
    }
    static countOccurences(replayPath) {
        return replayPath.reduce((counts, cur) => {
            if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur)
                counts.push({ value: cur, count: 1 });
            else
                counts[counts.length - 1].count += 1;
            return counts;
        }, []);
    }
    static parseOccurences(counts, changes) {
        const replayPath = [];
        for (let idx = 0; idx !== counts.length; ++idx) {
            const count = counts[idx];
            const value = changes[idx];
            for (let num = 0; num !== count; ++num)
                replayPath.push(value);
        }
        return replayPath;
    }
    static stringifyChanges(occurences) {
        let serializedChanges = '';
        for (let idx = 0; idx < occurences.length; idx += 6) {
            const changesInt = occurences
                .slice(idx, idx + 6)
                .reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);
            serializedChanges += this.intToB64(changesInt);
        }
        return serializedChanges;
    }
    static parseChanges(serializedChanges) {
        const changesInt = serializedChanges.split('').map((c) => this.b64ToInt(c));
        const changes = [];
        for (let idx = 0; idx !== changesInt.length; ++idx) {
            let current = changesInt[idx];
            for (let n = 0; n !== 6; ++n, current >>= 1) {
                changes.push(current % 2 === 1);
            }
        }
        return changes;
    }
    static stringifyCounts(occurences) {
        return occurences.map(({ count }) => this.intToB64(count - 1)).join('');
    }
    static parseCounts(serializedCount) {
        return serializedCount.split('').map((c) => this.b64ToInt(c) + 1);
    }
}
exports.ReplayPath = ReplayPath;


/***/ }),

/***/ 99927:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandWrapper = void 0;
const stringify_1 = __webpack_require__(21954);
const symbols_1 = __webpack_require__(28620);
class CommandWrapper {
    constructor(cmd) {
        this.cmd = cmd;
        this.hasRan = false;
        if ((0, stringify_1.hasToStringMethod)(cmd)) {
            const method = cmd[stringify_1.toStringMethod];
            this[stringify_1.toStringMethod] = function toStringMethod() {
                return method.call(cmd);
            };
        }
        if ((0, stringify_1.hasAsyncToStringMethod)(cmd)) {
            const method = cmd[stringify_1.asyncToStringMethod];
            this[stringify_1.asyncToStringMethod] = function asyncToStringMethod() {
                return method.call(cmd);
            };
        }
    }
    check(m) {
        return this.cmd.check(m);
    }
    run(m, r) {
        this.hasRan = true;
        return this.cmd.run(m, r);
    }
    clone() {
        if ((0, symbols_1.hasCloneMethod)(this.cmd))
            return new CommandWrapper(this.cmd[symbols_1.cloneMethod]());
        return new CommandWrapper(this.cmd);
    }
    toString() {
        return this.cmd.toString();
    }
}
exports.CommandWrapper = CommandWrapper;


/***/ }),

/***/ 18536:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandsIterable = void 0;
const symbols_1 = __webpack_require__(28620);
class CommandsIterable {
    constructor(commands, metadataForReplay) {
        this.commands = commands;
        this.metadataForReplay = metadataForReplay;
    }
    [Symbol.iterator]() {
        return this.commands[Symbol.iterator]();
    }
    [symbols_1.cloneMethod]() {
        return new CommandsIterable(this.commands.map((c) => c.clone()), this.metadataForReplay);
    }
    toString() {
        const serializedCommands = this.commands
            .filter((c) => c.hasRan)
            .map((c) => c.toString())
            .join(',');
        const metadata = this.metadataForReplay();
        return metadata.length !== 0 ? `${serializedCommands} /*${metadata}*/` : serializedCommands;
    }
}
exports.CommandsIterable = CommandsIterable;


/***/ }),

/***/ 84113:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.scheduleCommands = exports.ScheduledCommand = void 0;
class ScheduledCommand {
    constructor(s, cmd) {
        this.s = s;
        this.cmd = cmd;
    }
    async check(m) {
        let error = null;
        let checkPassed = false;
        const status = await this.s.scheduleSequence([
            {
                label: `check@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        checkPassed = await Promise.resolve(this.cmd.check(m));
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
        return checkPassed;
    }
    async run(m, r) {
        let error = null;
        const status = await this.s.scheduleSequence([
            {
                label: `run@${this.cmd.toString()}`,
                builder: async () => {
                    try {
                        await this.cmd.run(m, r);
                    }
                    catch (err) {
                        error = err;
                        throw err;
                    }
                },
            },
        ]).task;
        if (status.faulty) {
            throw error;
        }
    }
}
exports.ScheduledCommand = ScheduledCommand;
const scheduleCommands = function* (s, cmds) {
    for (const cmd of cmds) {
        yield new ScheduledCommand(s, cmd);
    }
};
exports.scheduleCommands = scheduleCommands;


/***/ }),

/***/ 17246:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pre = void 0;
const PreconditionFailure_1 = __webpack_require__(64431);
function pre(expectTruthy) {
    if (!expectTruthy) {
        throw new PreconditionFailure_1.PreconditionFailure();
    }
}
exports.pre = pre;


/***/ }),

/***/ 64431:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreconditionFailure = void 0;
class PreconditionFailure extends Error {
    constructor(interruptExecution = false) {
        super();
        this.interruptExecution = interruptExecution;
        this.footprint = PreconditionFailure.SharedFootPrint;
    }
    static isFailure(err) {
        return err != null && err.footprint === PreconditionFailure.SharedFootPrint;
    }
}
exports.PreconditionFailure = PreconditionFailure;
PreconditionFailure.SharedFootPrint = Symbol('fast-check/PreconditionFailure');


/***/ }),

/***/ 97098:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AsyncProperty = void 0;
const PreconditionFailure_1 = __webpack_require__(64431);
const IRawProperty_1 = __webpack_require__(86602);
const GlobalParameters_1 = __webpack_require__(85165);
const Stream_1 = __webpack_require__(99385);
const NoUndefinedAsContext_1 = __webpack_require__(21549);
class AsyncProperty {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { asyncBeforeEach, asyncAfterEach, beforeEach, afterEach } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined && beforeEach !== undefined) {
            throw Error('Global "asyncBeforeEach" and "beforeEach" parameters can\'t be set at the same time when running async properties');
        }
        if (asyncAfterEach !== undefined && afterEach !== undefined) {
            throw Error('Global "asyncAfterEach" and "afterEach" parameters can\'t be set at the same time when running async properties');
        }
        this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;
        this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, IRawProperty_1.runIdToFrequency)(runId) : undefined);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = value.context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
    async run(v) {
        await this.beforeEachHook();
        try {
            const output = await this.predicate(v);
            return output == null || output === true
                ? null
                : { error: undefined, errorMessage: 'Property failed by returning false' };
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack) {
                return { error: err, errorMessage: `${err}\n\nStack trace: ${err.stack}` };
            }
            return { error: err, errorMessage: String(err) };
        }
        finally {
            await this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.AsyncProperty = AsyncProperty;
AsyncProperty.dummyHook = () => { };


/***/ }),

/***/ 98171:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncProperty = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const tuple_1 = __webpack_require__(85282);
const AsyncProperty_generic_1 = __webpack_require__(97098);
const AlwaysShrinkableArbitrary_1 = __webpack_require__(28213);
function asyncProperty(...args) {
    if (args.length < 2) {
        throw new Error('asyncProperty expects at least two parameters');
    }
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    arbs.forEach(Arbitrary_1.assertIsArbitrary);
    const mappedArbs = arbs.map((arb) => new AlwaysShrinkableArbitrary_1.AlwaysShrinkableArbitrary(arb));
    return new AsyncProperty_generic_1.AsyncProperty((0, tuple_1.tuple)(...mappedArbs), (t) => p(...t));
}
exports.asyncProperty = asyncProperty;


/***/ }),

/***/ 86602:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.runIdToFrequency = void 0;
const runIdToFrequency = (runId) => 2 + Math.floor(Math.log(runId + 1) / Math.log(10));
exports.runIdToFrequency = runIdToFrequency;


/***/ }),

/***/ 202:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IgnoreEqualValuesProperty = void 0;
const stringify_1 = __webpack_require__(21954);
const PreconditionFailure_1 = __webpack_require__(64431);
function fromSyncCached(cachedValue) {
    return cachedValue === null ? new PreconditionFailure_1.PreconditionFailure() : cachedValue;
}
function fromCached(...data) {
    if (data[1])
        return data[0].then(fromSyncCached);
    return fromSyncCached(data[0]);
}
function fromCachedUnsafe(cachedValue, isAsync) {
    return fromCached(cachedValue, isAsync);
}
class IgnoreEqualValuesProperty {
    constructor(property, skipRuns) {
        this.property = property;
        this.skipRuns = skipRuns;
        this.coveredCases = new Map();
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        const stringifiedValue = (0, stringify_1.stringify)(v);
        if (this.coveredCases.has(stringifiedValue)) {
            const lastOutput = this.coveredCases.get(stringifiedValue);
            if (!this.skipRuns) {
                return lastOutput;
            }
            return fromCachedUnsafe(lastOutput, this.property.isAsync());
        }
        const out = this.property.run(v);
        this.coveredCases.set(stringifiedValue, out);
        return out;
    }
}
exports.IgnoreEqualValuesProperty = IgnoreEqualValuesProperty;


/***/ }),

/***/ 25734:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Property = void 0;
const PreconditionFailure_1 = __webpack_require__(64431);
const IRawProperty_1 = __webpack_require__(86602);
const GlobalParameters_1 = __webpack_require__(85165);
const Stream_1 = __webpack_require__(99385);
const NoUndefinedAsContext_1 = __webpack_require__(21549);
class Property {
    constructor(arb, predicate) {
        this.arb = arb;
        this.predicate = predicate;
        const { beforeEach = Property.dummyHook, afterEach = Property.dummyHook, asyncBeforeEach, asyncAfterEach, } = (0, GlobalParameters_1.readConfigureGlobal)() || {};
        if (asyncBeforeEach !== undefined) {
            throw Error('"asyncBeforeEach" can\'t be set when running synchronous properties');
        }
        if (asyncAfterEach !== undefined) {
            throw Error('"asyncAfterEach" can\'t be set when running synchronous properties');
        }
        this.beforeEachHook = beforeEach;
        this.afterEachHook = afterEach;
    }
    isAsync() {
        return false;
    }
    generate(mrng, runId) {
        const value = this.arb.generate(mrng, runId != null ? (0, IRawProperty_1.runIdToFrequency)(runId) : undefined);
        return (0, NoUndefinedAsContext_1.noUndefinedAsContext)(value);
    }
    shrink(value) {
        if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {
            return Stream_1.Stream.nil();
        }
        const safeContext = value.context !== NoUndefinedAsContext_1.UndefinedContextPlaceholder ? value.context : undefined;
        return this.arb.shrink(value.value_, safeContext).map(NoUndefinedAsContext_1.noUndefinedAsContext);
    }
    run(v) {
        this.beforeEachHook();
        try {
            const output = this.predicate(v);
            return output == null || output === true
                ? null
                : { error: undefined, errorMessage: 'Property failed by returning false' };
        }
        catch (err) {
            if (PreconditionFailure_1.PreconditionFailure.isFailure(err))
                return err;
            if (err instanceof Error && err.stack) {
                return { error: err, errorMessage: `${err}\n\nStack trace: ${err.stack}` };
            }
            return { error: err, errorMessage: String(err) };
        }
        finally {
            this.afterEachHook();
        }
    }
    beforeEach(hookFunction) {
        const previousBeforeEachHook = this.beforeEachHook;
        this.beforeEachHook = () => hookFunction(previousBeforeEachHook);
        return this;
    }
    afterEach(hookFunction) {
        const previousAfterEachHook = this.afterEachHook;
        this.afterEachHook = () => hookFunction(previousAfterEachHook);
        return this;
    }
}
exports.Property = Property;
Property.dummyHook = () => { };


/***/ }),

/***/ 84147:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.property = void 0;
const Arbitrary_1 = __webpack_require__(40305);
const tuple_1 = __webpack_require__(85282);
const Property_generic_1 = __webpack_require__(25734);
const AlwaysShrinkableArbitrary_1 = __webpack_require__(28213);
function property(...args) {
    if (args.length < 2) {
        throw new Error('property expects at least two parameters');
    }
    const arbs = args.slice(0, args.length - 1);
    const p = args[args.length - 1];
    arbs.forEach(Arbitrary_1.assertIsArbitrary);
    const mappedArbs = arbs.map((arb) => new AlwaysShrinkableArbitrary_1.AlwaysShrinkableArbitrary(arb));
    return new Property_generic_1.Property((0, tuple_1.tuple)(...mappedArbs), (t) => p(...t));
}
exports.property = property;


/***/ }),

/***/ 48904:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkipAfterProperty = void 0;
const PreconditionFailure_1 = __webpack_require__(64431);
class SkipAfterProperty {
    constructor(property, getTime, timeLimit, interruptExecution) {
        this.property = property;
        this.getTime = getTime;
        this.interruptExecution = interruptExecution;
        this.skipAfterTime = this.getTime() + timeLimit;
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        if (this.getTime() >= this.skipAfterTime) {
            const preconditionFailure = new PreconditionFailure_1.PreconditionFailure(this.interruptExecution);
            if (this.isAsync()) {
                return Promise.resolve(preconditionFailure);
            }
            else {
                return preconditionFailure;
            }
        }
        return this.property.run(v);
    }
}
exports.SkipAfterProperty = SkipAfterProperty;


/***/ }),

/***/ 38101:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeoutProperty = void 0;
const timeoutAfter = (timeMs) => {
    let timeoutHandle = null;
    const promise = new Promise((resolve) => {
        timeoutHandle = setTimeout(() => {
            resolve({ error: undefined, errorMessage: `Property timeout: exceeded limit of ${timeMs} milliseconds` });
        }, timeMs);
    });
    return {
        clear: () => clearTimeout(timeoutHandle),
        promise,
    };
};
class TimeoutProperty {
    constructor(property, timeMs) {
        this.property = property;
        this.timeMs = timeMs;
    }
    isAsync() {
        return true;
    }
    generate(mrng, runId) {
        return this.property.generate(mrng, runId);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    async run(v) {
        const t = timeoutAfter(this.timeMs);
        const propRun = Promise.race([this.property.run(v), t.promise]);
        propRun.then(t.clear, t.clear);
        return propRun;
    }
}
exports.TimeoutProperty = TimeoutProperty;


/***/ }),

/***/ 80543:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnbiasedProperty = void 0;
class UnbiasedProperty {
    constructor(property) {
        this.property = property;
    }
    isAsync() {
        return this.property.isAsync();
    }
    generate(mrng, _runId) {
        return this.property.generate(mrng, undefined);
    }
    shrink(value) {
        return this.property.shrink(value);
    }
    run(v) {
        return this.property.run(v);
    }
}
exports.UnbiasedProperty = UnbiasedProperty;


/***/ }),

/***/ 32368:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decorateProperty = void 0;
const SkipAfterProperty_1 = __webpack_require__(48904);
const TimeoutProperty_1 = __webpack_require__(38101);
const UnbiasedProperty_1 = __webpack_require__(80543);
const IgnoreEqualValuesProperty_1 = __webpack_require__(202);
function decorateProperty(rawProperty, qParams) {
    let prop = rawProperty;
    if (rawProperty.isAsync() && qParams.timeout != null) {
        prop = new TimeoutProperty_1.TimeoutProperty(prop, qParams.timeout);
    }
    if (qParams.unbiased) {
        prop = new UnbiasedProperty_1.UnbiasedProperty(prop);
    }
    if (qParams.skipAllAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.skipAllAfterTimeLimit, false);
    }
    if (qParams.interruptAfterTimeLimit != null) {
        prop = new SkipAfterProperty_1.SkipAfterProperty(prop, Date.now, qParams.interruptAfterTimeLimit, true);
    }
    if (qParams.skipEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, true);
    }
    if (qParams.ignoreEqualValues) {
        prop = new IgnoreEqualValuesProperty_1.IgnoreEqualValuesProperty(prop, false);
    }
    return prop;
}
exports.decorateProperty = decorateProperty;


/***/ }),

/***/ 20865:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assert = exports.check = void 0;
const Stream_1 = __webpack_require__(99385);
const GlobalParameters_1 = __webpack_require__(85165);
const QualifiedParameters_1 = __webpack_require__(49813);
const DecorateProperty_1 = __webpack_require__(32368);
const RunnerIterator_1 = __webpack_require__(15382);
const SourceValuesIterator_1 = __webpack_require__(73483);
const Tosser_1 = __webpack_require__(83171);
const PathWalker_1 = __webpack_require__(47388);
const RunDetailsFormatter_1 = __webpack_require__(61585);
function runIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
async function asyncRunIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {
    const runner = new RunnerIterator_1.RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);
    for (const v of runner) {
        const out = await property.run(v);
        runner.handleResult(out);
    }
    return runner.runExecution;
}
function runnerPathWalker(valueProducers, shrink, path) {
    const pathPoints = path.split(':');
    const pathStream = (0, Stream_1.stream)(valueProducers)
        .drop(pathPoints.length > 0 ? +pathPoints[0] : 0)
        .map((producer) => producer());
    const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');
    return (0, Stream_1.stream)((0, PathWalker_1.pathWalk)(adaptedPath, pathStream, shrink)).map((v) => () => v);
}
function buildInitialValues(valueProducers, shrink, qParams) {
    if (qParams.path.length === 0) {
        return (0, Stream_1.stream)(valueProducers);
    }
    return runnerPathWalker(valueProducers, shrink, qParams.path);
}
function check(rawProperty, params) {
    if (rawProperty == null || rawProperty.generate == null)
        throw new Error('Invalid property encountered, please use a valid property');
    if (rawProperty.run == null)
        throw new Error('Invalid property encountered, please use a valid property not an arbitrary');
    const qParams = QualifiedParameters_1.QualifiedParameters.read(Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params));
    if (qParams.reporter !== null && qParams.asyncReporter !== null)
        throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');
    if (qParams.asyncReporter !== null && !rawProperty.isAsync())
        throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');
    const property = (0, DecorateProperty_1.decorateProperty)(rawProperty, qParams);
    const generator = (0, Tosser_1.toss)(property, qParams.seed, qParams.randomType, qParams.examples);
    const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;
    const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;
    const shrink = property.shrink.bind(property);
    const initialValues = buildInitialValues(generator, shrink, qParams);
    const sourceValues = new SourceValuesIterator_1.SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);
    const finalShrink = !qParams.endOnFailure ? shrink : Stream_1.Stream.nil;
    return property.isAsync()
        ? asyncRunIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then((e) => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams))
        : runIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);
}
exports.check = check;
function assert(property, params) {
    const out = check(property, params);
    if (property.isAsync())
        return out.then(RunDetailsFormatter_1.asyncReportRunDetails);
    else
        (0, RunDetailsFormatter_1.reportRunDetails)(out);
}
exports.assert = assert;


/***/ }),

/***/ 15382:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunnerIterator = void 0;
const PreconditionFailure_1 = __webpack_require__(64431);
const RunExecution_1 = __webpack_require__(25667);
class RunnerIterator {
    constructor(sourceValues, shrink, verbose, interruptedAsFailure) {
        this.sourceValues = sourceValues;
        this.shrink = shrink;
        this.runExecution = new RunExecution_1.RunExecution(verbose, interruptedAsFailure);
        this.currentIdx = -1;
        this.nextValues = sourceValues;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        const nextValue = this.nextValues.next();
        if (nextValue.done || this.runExecution.interrupted) {
            return { done: true, value: undefined };
        }
        this.currentValue = nextValue.value;
        ++this.currentIdx;
        return { done: false, value: nextValue.value.value_ };
    }
    handleResult(result) {
        if (result != null && typeof result === 'object' && !PreconditionFailure_1.PreconditionFailure.isFailure(result)) {
            this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);
            this.currentIdx = -1;
            this.nextValues = this.shrink(this.currentValue);
        }
        else if (result != null) {
            if (!result.interruptExecution) {
                this.runExecution.skip(this.currentValue.value_);
                this.sourceValues.skippedOne();
            }
            else {
                this.runExecution.interrupt();
            }
        }
        else {
            this.runExecution.success(this.currentValue.value_);
        }
    }
}
exports.RunnerIterator = RunnerIterator;


/***/ }),

/***/ 50552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.statistics = exports.sample = void 0;
const Stream_1 = __webpack_require__(99385);
const Property_generic_1 = __webpack_require__(25734);
const UnbiasedProperty_1 = __webpack_require__(80543);
const GlobalParameters_1 = __webpack_require__(85165);
const QualifiedParameters_1 = __webpack_require__(49813);
const Tosser_1 = __webpack_require__(83171);
const PathWalker_1 = __webpack_require__(47388);
function toProperty(generator, qParams) {
    const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync')
        ? new Property_generic_1.Property(generator, () => true)
        : generator;
    return qParams.unbiased === true ? new UnbiasedProperty_1.UnbiasedProperty(prop) : prop;
}
function streamSample(generator, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), { numRuns: params }) : Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const nextProperty = toProperty(generator, qParams);
    const shrink = nextProperty.shrink.bind(nextProperty);
    const tossedValues = (0, Stream_1.stream)((0, Tosser_1.toss)(nextProperty, qParams.seed, qParams.randomType, qParams.examples));
    if (qParams.path.length === 0) {
        return tossedValues.take(qParams.numRuns).map((s) => s().value_);
    }
    return (0, Stream_1.stream)((0, PathWalker_1.pathWalk)(qParams.path, tossedValues.map((s) => s()), shrink))
        .take(qParams.numRuns)
        .map((s) => s.value_);
}
function sample(generator, params) {
    return [...streamSample(generator, params)];
}
exports.sample = sample;
function round2(n) {
    return (Math.round(n * 100) / 100).toFixed(2);
}
function statistics(generator, classify, params) {
    const extendedParams = typeof params === 'number'
        ? Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), { numRuns: params }) : Object.assign(Object.assign({}, (0, GlobalParameters_1.readConfigureGlobal)()), params);
    const qParams = QualifiedParameters_1.QualifiedParameters.read(extendedParams);
    const recorded = {};
    for (const g of streamSample(generator, params)) {
        const out = classify(g);
        const categories = Array.isArray(out) ? out : [out];
        for (const c of categories) {
            recorded[c] = (recorded[c] || 0) + 1;
        }
    }
    const data = Object.entries(recorded)
        .sort((a, b) => b[1] - a[1])
        .map((i) => [i[0], `${round2((i[1] * 100.0) / qParams.numRuns)}%`]);
    const longestName = data.map((i) => i[0].length).reduce((p, c) => Math.max(p, c), 0);
    const longestPercent = data.map((i) => i[1].length).reduce((p, c) => Math.max(p, c), 0);
    for (const item of data) {
        qParams.logger(`${item[0].padEnd(longestName, '.')}..${item[1].padStart(longestPercent, '.')}`);
    }
}
exports.statistics = statistics;


/***/ }),

/***/ 73483:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceValuesIterator = void 0;
class SourceValuesIterator {
    constructor(initialValues, maxInitialIterations, remainingSkips) {
        this.initialValues = initialValues;
        this.maxInitialIterations = maxInitialIterations;
        this.remainingSkips = remainingSkips;
    }
    [Symbol.iterator]() {
        return this;
    }
    next() {
        if (--this.maxInitialIterations !== -1 && this.remainingSkips >= 0) {
            const n = this.initialValues.next();
            if (!n.done)
                return { value: n.value(), done: false };
        }
        return { value: undefined, done: true };
    }
    skippedOne() {
        --this.remainingSkips;
        ++this.maxInitialIterations;
    }
}
exports.SourceValuesIterator = SourceValuesIterator;


/***/ }),

/***/ 83171:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toss = void 0;
const pure_rand_1 = __webpack_require__(23691);
const Random_1 = __webpack_require__(1424);
const Value_1 = __webpack_require__(60641);
function lazyGenerate(generator, rng, idx) {
    return () => generator.generate(new Random_1.Random(rng), idx);
}
function* toss(generator, seed, random, examples) {
    yield* examples.map((e) => () => new Value_1.Value(e, undefined));
    let idx = 0;
    let rng = random(seed);
    for (;;) {
        rng = rng.jump ? rng.jump() : (0, pure_rand_1.skipN)(rng, 42);
        yield lazyGenerate(generator, rng, idx++);
    }
}
exports.toss = toss;


/***/ }),

/***/ 85165:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = void 0;
let globalParameters = {};
function configureGlobal(parameters) {
    globalParameters = parameters;
}
exports.configureGlobal = configureGlobal;
function readConfigureGlobal() {
    return globalParameters;
}
exports.readConfigureGlobal = readConfigureGlobal;
function resetConfigureGlobal() {
    globalParameters = {};
}
exports.resetConfigureGlobal = resetConfigureGlobal;


/***/ }),

/***/ 49813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QualifiedParameters = void 0;
const pure_rand_1 = __webpack_require__(23691);
const VerbosityLevel_1 = __webpack_require__(42070);
class QualifiedParameters {
    constructor(op) {
        const p = op || {};
        this.seed = QualifiedParameters.readSeed(p);
        this.randomType = QualifiedParameters.readRandomType(p);
        this.numRuns = QualifiedParameters.readNumRuns(p);
        this.verbose = QualifiedParameters.readVerbose(p);
        this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);
        this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);
        this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);
        this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);
        this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');
        this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');
        this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');
        this.logger = QualifiedParameters.readOrDefault(p, 'logger', (v) => {
            console.log(v);
        });
        this.path = QualifiedParameters.readOrDefault(p, 'path', '');
        this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');
        this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);
        this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');
        this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);
        this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);
    }
    toParameters() {
        const orUndefined = (value) => (value !== null ? value : undefined);
        return {
            seed: this.seed,
            randomType: this.randomType,
            numRuns: this.numRuns,
            maxSkipsPerRun: this.maxSkipsPerRun,
            timeout: orUndefined(this.timeout),
            skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),
            interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),
            markInterruptAsFailure: this.markInterruptAsFailure,
            skipEqualValues: this.skipEqualValues,
            ignoreEqualValues: this.ignoreEqualValues,
            path: this.path,
            logger: this.logger,
            unbiased: this.unbiased,
            verbose: this.verbose,
            examples: this.examples,
            endOnFailure: this.endOnFailure,
            reporter: orUndefined(this.reporter),
            asyncReporter: orUndefined(this.asyncReporter),
        };
    }
    static read(op) {
        return new QualifiedParameters(op);
    }
}
exports.QualifiedParameters = QualifiedParameters;
QualifiedParameters.readSeed = (p) => {
    if (p.seed == null)
        return Date.now() ^ (Math.random() * 0x100000000);
    const seed32 = p.seed | 0;
    if (p.seed === seed32)
        return seed32;
    const gap = p.seed - seed32;
    return seed32 ^ (gap * 0x100000000);
};
QualifiedParameters.readRandomType = (p) => {
    if (p.randomType == null)
        return pure_rand_1.default.xorshift128plus;
    if (typeof p.randomType === 'string') {
        switch (p.randomType) {
            case 'mersenne':
                return pure_rand_1.default.mersenne;
            case 'congruential':
                return pure_rand_1.default.congruential;
            case 'congruential32':
                return pure_rand_1.default.congruential32;
            case 'xorshift128plus':
                return pure_rand_1.default.xorshift128plus;
            case 'xoroshiro128plus':
                return pure_rand_1.default.xoroshiro128plus;
            default:
                throw new Error(`Invalid random specified: '${p.randomType}'`);
        }
    }
    return p.randomType;
};
QualifiedParameters.readNumRuns = (p) => {
    const defaultValue = 100;
    if (p.numRuns != null)
        return p.numRuns;
    if (p.num_runs != null)
        return p.num_runs;
    return defaultValue;
};
QualifiedParameters.readVerbose = (p) => {
    if (p.verbose == null)
        return VerbosityLevel_1.VerbosityLevel.None;
    if (typeof p.verbose === 'boolean') {
        return p.verbose === true ? VerbosityLevel_1.VerbosityLevel.Verbose : VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose <= VerbosityLevel_1.VerbosityLevel.None) {
        return VerbosityLevel_1.VerbosityLevel.None;
    }
    if (p.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        return VerbosityLevel_1.VerbosityLevel.VeryVerbose;
    }
    return p.verbose | 0;
};
QualifiedParameters.readBoolean = (p, key) => p[key] === true;
QualifiedParameters.readOrDefault = (p, key, defaultValue) => {
    const value = p[key];
    return value != null ? value : defaultValue;
};


/***/ }),

/***/ 42070:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VerbosityLevel = void 0;
var VerbosityLevel;
(function (VerbosityLevel) {
    VerbosityLevel[VerbosityLevel["None"] = 0] = "None";
    VerbosityLevel[VerbosityLevel["Verbose"] = 1] = "Verbose";
    VerbosityLevel[VerbosityLevel["VeryVerbose"] = 2] = "VeryVerbose";
})(VerbosityLevel = exports.VerbosityLevel || (exports.VerbosityLevel = {}));


/***/ }),

/***/ 86293:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecutionStatus = void 0;
var ExecutionStatus;
(function (ExecutionStatus) {
    ExecutionStatus[ExecutionStatus["Success"] = 0] = "Success";
    ExecutionStatus[ExecutionStatus["Skipped"] = -1] = "Skipped";
    ExecutionStatus[ExecutionStatus["Failure"] = 1] = "Failure";
})(ExecutionStatus = exports.ExecutionStatus || (exports.ExecutionStatus = {}));


/***/ }),

/***/ 25667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RunExecution = void 0;
const VerbosityLevel_1 = __webpack_require__(42070);
const ExecutionStatus_1 = __webpack_require__(86293);
class RunExecution {
    constructor(verbosity, interruptedAsFailure) {
        this.verbosity = verbosity;
        this.interruptedAsFailure = interruptedAsFailure;
        this.isSuccess = () => this.pathToFailure == null;
        this.firstFailure = () => (this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1);
        this.numShrinks = () => (this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0);
        this.rootExecutionTrees = [];
        this.currentLevelExecutionTrees = this.rootExecutionTrees;
        this.failure = null;
        this.numSkips = 0;
        this.numSuccesses = 0;
        this.interrupted = false;
    }
    appendExecutionTree(status, value) {
        const currentTree = { status, value, children: [] };
        this.currentLevelExecutionTrees.push(currentTree);
        return currentTree;
    }
    fail(value, id, failure) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.Verbose) {
            const currentTree = this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Failure, value);
            this.currentLevelExecutionTrees = currentTree.children;
        }
        if (this.pathToFailure == null)
            this.pathToFailure = `${id}`;
        else
            this.pathToFailure += `:${id}`;
        this.value = value;
        this.failure = failure;
    }
    skip(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Skipped, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSkips;
        }
    }
    success(value) {
        if (this.verbosity >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
            this.appendExecutionTree(ExecutionStatus_1.ExecutionStatus.Success, value);
        }
        if (this.pathToFailure == null) {
            ++this.numSuccesses;
        }
    }
    interrupt() {
        this.interrupted = true;
    }
    extractFailures() {
        if (this.isSuccess()) {
            return [];
        }
        const failures = [];
        let cursor = this.rootExecutionTrees;
        while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus_1.ExecutionStatus.Failure) {
            const failureTree = cursor[cursor.length - 1];
            failures.push(failureTree.value);
            cursor = failureTree.children;
        }
        return failures;
    }
    toRunDetails(seed, basePath, maxSkips, qParams) {
        if (!this.isSuccess()) {
            return {
                failed: true,
                interrupted: this.interrupted,
                numRuns: this.firstFailure() + 1 - this.numSkips,
                numSkips: this.numSkips,
                numShrinks: this.numShrinks(),
                seed,
                counterexample: this.value,
                counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),
                error: this.failure.errorMessage,
                errorInstance: this.failure.error,
                failures: this.extractFailures(),
                executionSummary: this.rootExecutionTrees,
                verbose: this.verbosity,
                runConfiguration: qParams.toParameters(),
            };
        }
        const failed = this.numSkips > maxSkips || (this.interrupted && this.interruptedAsFailure);
        return {
            failed,
            interrupted: this.interrupted,
            numRuns: this.numSuccesses,
            numSkips: this.numSkips,
            numShrinks: 0,
            seed,
            counterexample: null,
            counterexamplePath: null,
            error: null,
            errorInstance: null,
            failures: [],
            executionSummary: this.rootExecutionTrees,
            verbose: this.verbosity,
            runConfiguration: qParams.toParameters(),
        };
    }
}
exports.RunExecution = RunExecution;
RunExecution.mergePaths = (offsetPath, path) => {
    if (offsetPath.length === 0)
        return path;
    const offsetItems = offsetPath.split(':');
    const remainingItems = path.split(':');
    const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];
    return [...offsetItems.slice(0, offsetItems.length - 1), `${middle}`, ...remainingItems.slice(1)].join(':');
};


/***/ }),

/***/ 47388:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.pathWalk = void 0;
const Stream_1 = __webpack_require__(99385);
function pathWalk(path, initialValues, shrink) {
    let values = (0, Stream_1.stream)(initialValues);
    const segments = path.split(':').map((text) => +text);
    if (segments.length === 0)
        return values;
    if (!segments.every((v) => !Number.isNaN(v))) {
        throw new Error(`Unable to replay, got invalid path=${path}`);
    }
    values = values.drop(segments[0]);
    for (const s of segments.slice(1)) {
        const valueToShrink = values.getNthOrLast(0);
        if (valueToShrink == null) {
            throw new Error(`Unable to replay, got wrong path=${path}`);
        }
        values = shrink(valueToShrink).drop(s);
    }
    return values;
}
exports.pathWalk = pathWalk;


/***/ }),

/***/ 61585:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncReportRunDetails = exports.reportRunDetails = void 0;
const stringify_1 = __webpack_require__(21954);
const VerbosityLevel_1 = __webpack_require__(42070);
const ExecutionStatus_1 = __webpack_require__(86293);
function formatHints(hints) {
    if (hints.length === 1) {
        return `Hint: ${hints[0]}`;
    }
    return hints.map((h, idx) => `Hint (${idx + 1}): ${h}`).join('\n');
}
function formatFailures(failures, stringifyOne) {
    return `Encountered failures were:\n- ${failures.map(stringifyOne).join('\n- ')}`;
}
function formatExecutionSummary(executionTrees, stringifyOne) {
    const summaryLines = [];
    const remainingTreesAndDepth = [];
    for (const tree of executionTrees.slice().reverse()) {
        remainingTreesAndDepth.push({ depth: 1, tree });
    }
    while (remainingTreesAndDepth.length !== 0) {
        const currentTreeAndDepth = remainingTreesAndDepth.pop();
        const currentTree = currentTreeAndDepth.tree;
        const currentDepth = currentTreeAndDepth.depth;
        const statusIcon = currentTree.status === ExecutionStatus_1.ExecutionStatus.Success
            ? '\x1b[32m\u221A\x1b[0m'
            : currentTree.status === ExecutionStatus_1.ExecutionStatus.Failure
                ? '\x1b[31m\xD7\x1b[0m'
                : '\x1b[33m!\x1b[0m';
        const leftPadding = Array(currentDepth).join('. ');
        summaryLines.push(`${leftPadding}${statusIcon} ${stringifyOne(currentTree.value)}`);
        for (const tree of currentTree.children.slice().reverse()) {
            remainingTreesAndDepth.push({ depth: currentDepth + 1, tree });
        }
    }
    return `Execution summary:\n${summaryLines.join('\n')}`;
}
function preFormatTooManySkipped(out, stringifyOne) {
    const message = `Failed to run property, too many pre-condition failures encountered\n{ seed: ${out.seed} }\n\nRan ${out.numRuns} time(s)\nSkipped ${out.numSkips} time(s)`;
    let details = null;
    const hints = [
        'Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries',
        'Increase failure tolerance by setting maxSkipsPerRun to an higher value',
    ];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function preFormatFailure(out, stringifyOne) {
    const message = `Property failed after ${out.numRuns} tests\n{ seed: ${out.seed}, path: "${out.counterexamplePath}", endOnFailure: true }\nCounterexample: ${stringifyOne(out.counterexample)}\nShrunk ${out.numShrinks} time(s)\nGot error: ${out.error}`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else if (out.verbose === VerbosityLevel_1.VerbosityLevel.Verbose) {
        details = formatFailures(out.failures, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');
    }
    return { message, details, hints };
}
function preFormatEarlyInterrupted(out, stringifyOne) {
    const message = `Property interrupted after ${out.numRuns} tests\n{ seed: ${out.seed} }`;
    let details = null;
    const hints = [];
    if (out.verbose >= VerbosityLevel_1.VerbosityLevel.VeryVerbose) {
        details = formatExecutionSummary(out.executionSummary, stringifyOne);
    }
    else {
        hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');
    }
    return { message, details, hints };
}
function defaultReportMessageInternal(out, stringifyOne) {
    if (!out.failed)
        return;
    const { message, details, hints } = out.counterexamplePath === null
        ? out.interrupted
            ? preFormatEarlyInterrupted(out, stringifyOne)
            : preFormatTooManySkipped(out, stringifyOne)
        : preFormatFailure(out, stringifyOne);
    let errorMessage = message;
    if (details != null)
        errorMessage += `\n\n${details}`;
    if (hints.length > 0)
        errorMessage += `\n\n${formatHints(hints)}`;
    return errorMessage;
}
function defaultReportMessage(out) {
    return defaultReportMessageInternal(out, stringify_1.stringify);
}
exports.defaultReportMessage = defaultReportMessage;
async function asyncDefaultReportMessage(out) {
    const pendingStringifieds = [];
    function stringifyOne(value) {
        const stringified = (0, stringify_1.possiblyAsyncStringify)(value);
        if (typeof stringified === 'string') {
            return stringified;
        }
        pendingStringifieds.push(Promise.all([value, stringified]));
        return '\u2026';
    }
    const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);
    if (pendingStringifieds.length === 0) {
        return firstTryMessage;
    }
    const registeredValues = new Map(await Promise.all(pendingStringifieds));
    function stringifySecond(value) {
        const asyncStringifiedIfRegistered = registeredValues.get(value);
        if (asyncStringifiedIfRegistered !== undefined) {
            return asyncStringifiedIfRegistered;
        }
        return (0, stringify_1.stringify)(value);
    }
    return defaultReportMessageInternal(out, stringifySecond);
}
exports.asyncDefaultReportMessage = asyncDefaultReportMessage;
function throwIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(defaultReportMessage(out));
}
async function asyncThrowIfFailed(out) {
    if (!out.failed)
        return;
    throw new Error(await asyncDefaultReportMessage(out));
}
function reportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return throwIfFailed(out);
}
exports.reportRunDetails = reportRunDetails;
async function asyncReportRunDetails(out) {
    if (out.runConfiguration.asyncReporter)
        return out.runConfiguration.asyncReporter(out);
    else if (out.runConfiguration.reporter)
        return out.runConfiguration.reporter(out);
    else
        return asyncThrowIfFailed(out);
}
exports.asyncReportRunDetails = asyncReportRunDetails;


/***/ }),

/***/ 28620:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cloneIfNeeded = exports.hasCloneMethod = exports.cloneMethod = void 0;
exports.cloneMethod = Symbol('fast-check/cloneMethod');
function hasCloneMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.cloneMethod in instance &&
        typeof instance[exports.cloneMethod] === 'function');
}
exports.hasCloneMethod = hasCloneMethod;
function cloneIfNeeded(instance) {
    return hasCloneMethod(instance) ? instance[exports.cloneMethod]() : instance;
}
exports.cloneIfNeeded = cloneIfNeeded;


/***/ }),

/***/ 58668:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sparseArray = exports.array = exports.subarray = exports.shuffledSubarray = exports.clone = exports.oneof = exports.option = exports.mapToConstant = exports.constantFrom = exports.constant = exports.lorem = exports.base64String = exports.hexaString = exports.fullUnicodeString = exports.unicodeString = exports.stringOf = exports.string16bits = exports.asciiString = exports.string = exports.mixedCase = exports.base64 = exports.hexa = exports.fullUnicode = exports.unicode = exports.char16bits = exports.ascii = exports.char = exports.bigUint = exports.bigInt = exports.bigUintN = exports.bigIntN = exports.maxSafeNat = exports.maxSafeInteger = exports.nat = exports.integer = exports.double = exports.float = exports.falsy = exports.boolean = exports.asyncProperty = exports.property = exports.PreconditionFailure = exports.pre = exports.assert = exports.check = exports.statistics = exports.sample = exports.__commitHash = exports.__version = exports.__type = void 0;
exports.cloneMethod = exports.Value = exports.Arbitrary = exports.schedulerFor = exports.scheduler = exports.commands = exports.scheduledModelRun = exports.modelRun = exports.asyncModelRun = exports.bigUint64Array = exports.bigInt64Array = exports.float64Array = exports.float32Array = exports.uint32Array = exports.int32Array = exports.uint16Array = exports.int16Array = exports.uint8ClampedArray = exports.uint8Array = exports.int8Array = exports.uuidV = exports.uuid = exports.emailAddress = exports.webUrl = exports.webQueryParameters = exports.webFragments = exports.webSegment = exports.webAuthority = exports.domain = exports.ipV6 = exports.ipV4Extended = exports.ipV4 = exports.date = exports.context = exports.func = exports.compareFunc = exports.compareBooleanFunc = exports.memo = exports.letrec = exports.unicodeJsonValue = exports.unicodeJson = exports.jsonValue = exports.json = exports.object = exports.anything = exports.dictionary = exports.record = exports.tuple = exports.uniqueArray = exports.infiniteStream = void 0;
exports.createDepthIdentifier = exports.stream = exports.Stream = exports.Random = exports.ExecutionStatus = exports.resetConfigureGlobal = exports.readConfigureGlobal = exports.configureGlobal = exports.VerbosityLevel = exports.hash = exports.asyncDefaultReportMessage = exports.defaultReportMessage = exports.asyncStringify = exports.stringify = exports.getDepthContextFor = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = exports.hasCloneMethod = exports.cloneIfNeeded = void 0;
const Pre_1 = __webpack_require__(17246);
Object.defineProperty(exports, "pre", ({ enumerable: true, get: function () { return Pre_1.pre; } }));
const AsyncProperty_1 = __webpack_require__(98171);
Object.defineProperty(exports, "asyncProperty", ({ enumerable: true, get: function () { return AsyncProperty_1.asyncProperty; } }));
const Property_1 = __webpack_require__(84147);
Object.defineProperty(exports, "property", ({ enumerable: true, get: function () { return Property_1.property; } }));
const Runner_1 = __webpack_require__(20865);
Object.defineProperty(exports, "assert", ({ enumerable: true, get: function () { return Runner_1.assert; } }));
Object.defineProperty(exports, "check", ({ enumerable: true, get: function () { return Runner_1.check; } }));
const Sampler_1 = __webpack_require__(50552);
Object.defineProperty(exports, "sample", ({ enumerable: true, get: function () { return Sampler_1.sample; } }));
Object.defineProperty(exports, "statistics", ({ enumerable: true, get: function () { return Sampler_1.statistics; } }));
const array_1 = __webpack_require__(78309);
Object.defineProperty(exports, "array", ({ enumerable: true, get: function () { return array_1.array; } }));
const bigInt_1 = __webpack_require__(57750);
Object.defineProperty(exports, "bigInt", ({ enumerable: true, get: function () { return bigInt_1.bigInt; } }));
const bigIntN_1 = __webpack_require__(33001);
Object.defineProperty(exports, "bigIntN", ({ enumerable: true, get: function () { return bigIntN_1.bigIntN; } }));
const bigUint_1 = __webpack_require__(92546);
Object.defineProperty(exports, "bigUint", ({ enumerable: true, get: function () { return bigUint_1.bigUint; } }));
const bigUintN_1 = __webpack_require__(94088);
Object.defineProperty(exports, "bigUintN", ({ enumerable: true, get: function () { return bigUintN_1.bigUintN; } }));
const boolean_1 = __webpack_require__(81258);
Object.defineProperty(exports, "boolean", ({ enumerable: true, get: function () { return boolean_1.boolean; } }));
const falsy_1 = __webpack_require__(38506);
Object.defineProperty(exports, "falsy", ({ enumerable: true, get: function () { return falsy_1.falsy; } }));
const ascii_1 = __webpack_require__(98670);
Object.defineProperty(exports, "ascii", ({ enumerable: true, get: function () { return ascii_1.ascii; } }));
const base64_1 = __webpack_require__(62767);
Object.defineProperty(exports, "base64", ({ enumerable: true, get: function () { return base64_1.base64; } }));
const char_1 = __webpack_require__(69165);
Object.defineProperty(exports, "char", ({ enumerable: true, get: function () { return char_1.char; } }));
const char16bits_1 = __webpack_require__(22097);
Object.defineProperty(exports, "char16bits", ({ enumerable: true, get: function () { return char16bits_1.char16bits; } }));
const fullUnicode_1 = __webpack_require__(96005);
Object.defineProperty(exports, "fullUnicode", ({ enumerable: true, get: function () { return fullUnicode_1.fullUnicode; } }));
const hexa_1 = __webpack_require__(94383);
Object.defineProperty(exports, "hexa", ({ enumerable: true, get: function () { return hexa_1.hexa; } }));
const unicode_1 = __webpack_require__(83405);
Object.defineProperty(exports, "unicode", ({ enumerable: true, get: function () { return unicode_1.unicode; } }));
const constant_1 = __webpack_require__(27440);
Object.defineProperty(exports, "constant", ({ enumerable: true, get: function () { return constant_1.constant; } }));
const constantFrom_1 = __webpack_require__(80305);
Object.defineProperty(exports, "constantFrom", ({ enumerable: true, get: function () { return constantFrom_1.constantFrom; } }));
const context_1 = __webpack_require__(47068);
Object.defineProperty(exports, "context", ({ enumerable: true, get: function () { return context_1.context; } }));
const date_1 = __webpack_require__(18123);
Object.defineProperty(exports, "date", ({ enumerable: true, get: function () { return date_1.date; } }));
const clone_1 = __webpack_require__(55939);
Object.defineProperty(exports, "clone", ({ enumerable: true, get: function () { return clone_1.clone; } }));
const dictionary_1 = __webpack_require__(64444);
Object.defineProperty(exports, "dictionary", ({ enumerable: true, get: function () { return dictionary_1.dictionary; } }));
const emailAddress_1 = __webpack_require__(11043);
Object.defineProperty(exports, "emailAddress", ({ enumerable: true, get: function () { return emailAddress_1.emailAddress; } }));
const double_1 = __webpack_require__(24893);
Object.defineProperty(exports, "double", ({ enumerable: true, get: function () { return double_1.double; } }));
const float_1 = __webpack_require__(80031);
Object.defineProperty(exports, "float", ({ enumerable: true, get: function () { return float_1.float; } }));
const compareBooleanFunc_1 = __webpack_require__(22543);
Object.defineProperty(exports, "compareBooleanFunc", ({ enumerable: true, get: function () { return compareBooleanFunc_1.compareBooleanFunc; } }));
const compareFunc_1 = __webpack_require__(21104);
Object.defineProperty(exports, "compareFunc", ({ enumerable: true, get: function () { return compareFunc_1.compareFunc; } }));
const func_1 = __webpack_require__(53731);
Object.defineProperty(exports, "func", ({ enumerable: true, get: function () { return func_1.func; } }));
const domain_1 = __webpack_require__(90301);
Object.defineProperty(exports, "domain", ({ enumerable: true, get: function () { return domain_1.domain; } }));
const integer_1 = __webpack_require__(97706);
Object.defineProperty(exports, "integer", ({ enumerable: true, get: function () { return integer_1.integer; } }));
const maxSafeInteger_1 = __webpack_require__(39371);
Object.defineProperty(exports, "maxSafeInteger", ({ enumerable: true, get: function () { return maxSafeInteger_1.maxSafeInteger; } }));
const maxSafeNat_1 = __webpack_require__(91353);
Object.defineProperty(exports, "maxSafeNat", ({ enumerable: true, get: function () { return maxSafeNat_1.maxSafeNat; } }));
const nat_1 = __webpack_require__(45697);
Object.defineProperty(exports, "nat", ({ enumerable: true, get: function () { return nat_1.nat; } }));
const ipV4_1 = __webpack_require__(20638);
Object.defineProperty(exports, "ipV4", ({ enumerable: true, get: function () { return ipV4_1.ipV4; } }));
const ipV4Extended_1 = __webpack_require__(11750);
Object.defineProperty(exports, "ipV4Extended", ({ enumerable: true, get: function () { return ipV4Extended_1.ipV4Extended; } }));
const ipV6_1 = __webpack_require__(11187);
Object.defineProperty(exports, "ipV6", ({ enumerable: true, get: function () { return ipV6_1.ipV6; } }));
const letrec_1 = __webpack_require__(72234);
Object.defineProperty(exports, "letrec", ({ enumerable: true, get: function () { return letrec_1.letrec; } }));
const lorem_1 = __webpack_require__(99531);
Object.defineProperty(exports, "lorem", ({ enumerable: true, get: function () { return lorem_1.lorem; } }));
const mapToConstant_1 = __webpack_require__(99613);
Object.defineProperty(exports, "mapToConstant", ({ enumerable: true, get: function () { return mapToConstant_1.mapToConstant; } }));
const memo_1 = __webpack_require__(53837);
Object.defineProperty(exports, "memo", ({ enumerable: true, get: function () { return memo_1.memo; } }));
const mixedCase_1 = __webpack_require__(27181);
Object.defineProperty(exports, "mixedCase", ({ enumerable: true, get: function () { return mixedCase_1.mixedCase; } }));
const object_1 = __webpack_require__(41574);
Object.defineProperty(exports, "object", ({ enumerable: true, get: function () { return object_1.object; } }));
const json_1 = __webpack_require__(28678);
Object.defineProperty(exports, "json", ({ enumerable: true, get: function () { return json_1.json; } }));
const anything_1 = __webpack_require__(47111);
Object.defineProperty(exports, "anything", ({ enumerable: true, get: function () { return anything_1.anything; } }));
const unicodeJsonValue_1 = __webpack_require__(22883);
Object.defineProperty(exports, "unicodeJsonValue", ({ enumerable: true, get: function () { return unicodeJsonValue_1.unicodeJsonValue; } }));
const jsonValue_1 = __webpack_require__(91134);
Object.defineProperty(exports, "jsonValue", ({ enumerable: true, get: function () { return jsonValue_1.jsonValue; } }));
const unicodeJson_1 = __webpack_require__(66556);
Object.defineProperty(exports, "unicodeJson", ({ enumerable: true, get: function () { return unicodeJson_1.unicodeJson; } }));
const oneof_1 = __webpack_require__(89752);
Object.defineProperty(exports, "oneof", ({ enumerable: true, get: function () { return oneof_1.oneof; } }));
const option_1 = __webpack_require__(91953);
Object.defineProperty(exports, "option", ({ enumerable: true, get: function () { return option_1.option; } }));
const record_1 = __webpack_require__(22066);
Object.defineProperty(exports, "record", ({ enumerable: true, get: function () { return record_1.record; } }));
const uniqueArray_1 = __webpack_require__(20005);
Object.defineProperty(exports, "uniqueArray", ({ enumerable: true, get: function () { return uniqueArray_1.uniqueArray; } }));
const infiniteStream_1 = __webpack_require__(78278);
Object.defineProperty(exports, "infiniteStream", ({ enumerable: true, get: function () { return infiniteStream_1.infiniteStream; } }));
const asciiString_1 = __webpack_require__(8846);
Object.defineProperty(exports, "asciiString", ({ enumerable: true, get: function () { return asciiString_1.asciiString; } }));
const base64String_1 = __webpack_require__(62547);
Object.defineProperty(exports, "base64String", ({ enumerable: true, get: function () { return base64String_1.base64String; } }));
const fullUnicodeString_1 = __webpack_require__(8344);
Object.defineProperty(exports, "fullUnicodeString", ({ enumerable: true, get: function () { return fullUnicodeString_1.fullUnicodeString; } }));
const hexaString_1 = __webpack_require__(3547);
Object.defineProperty(exports, "hexaString", ({ enumerable: true, get: function () { return hexaString_1.hexaString; } }));
const string_1 = __webpack_require__(22320);
Object.defineProperty(exports, "string", ({ enumerable: true, get: function () { return string_1.string; } }));
const string16bits_1 = __webpack_require__(58447);
Object.defineProperty(exports, "string16bits", ({ enumerable: true, get: function () { return string16bits_1.string16bits; } }));
const stringOf_1 = __webpack_require__(85082);
Object.defineProperty(exports, "stringOf", ({ enumerable: true, get: function () { return stringOf_1.stringOf; } }));
const unicodeString_1 = __webpack_require__(20671);
Object.defineProperty(exports, "unicodeString", ({ enumerable: true, get: function () { return unicodeString_1.unicodeString; } }));
const subarray_1 = __webpack_require__(22650);
Object.defineProperty(exports, "subarray", ({ enumerable: true, get: function () { return subarray_1.subarray; } }));
const shuffledSubarray_1 = __webpack_require__(69994);
Object.defineProperty(exports, "shuffledSubarray", ({ enumerable: true, get: function () { return shuffledSubarray_1.shuffledSubarray; } }));
const tuple_1 = __webpack_require__(85282);
Object.defineProperty(exports, "tuple", ({ enumerable: true, get: function () { return tuple_1.tuple; } }));
const uuid_1 = __webpack_require__(44615);
Object.defineProperty(exports, "uuid", ({ enumerable: true, get: function () { return uuid_1.uuid; } }));
const uuidV_1 = __webpack_require__(88029);
Object.defineProperty(exports, "uuidV", ({ enumerable: true, get: function () { return uuidV_1.uuidV; } }));
const webAuthority_1 = __webpack_require__(76718);
Object.defineProperty(exports, "webAuthority", ({ enumerable: true, get: function () { return webAuthority_1.webAuthority; } }));
const webFragments_1 = __webpack_require__(56859);
Object.defineProperty(exports, "webFragments", ({ enumerable: true, get: function () { return webFragments_1.webFragments; } }));
const webQueryParameters_1 = __webpack_require__(6924);
Object.defineProperty(exports, "webQueryParameters", ({ enumerable: true, get: function () { return webQueryParameters_1.webQueryParameters; } }));
const webSegment_1 = __webpack_require__(28845);
Object.defineProperty(exports, "webSegment", ({ enumerable: true, get: function () { return webSegment_1.webSegment; } }));
const webUrl_1 = __webpack_require__(30412);
Object.defineProperty(exports, "webUrl", ({ enumerable: true, get: function () { return webUrl_1.webUrl; } }));
const commands_1 = __webpack_require__(15811);
Object.defineProperty(exports, "commands", ({ enumerable: true, get: function () { return commands_1.commands; } }));
const ModelRunner_1 = __webpack_require__(8316);
Object.defineProperty(exports, "asyncModelRun", ({ enumerable: true, get: function () { return ModelRunner_1.asyncModelRun; } }));
Object.defineProperty(exports, "modelRun", ({ enumerable: true, get: function () { return ModelRunner_1.modelRun; } }));
Object.defineProperty(exports, "scheduledModelRun", ({ enumerable: true, get: function () { return ModelRunner_1.scheduledModelRun; } }));
const Random_1 = __webpack_require__(1424);
Object.defineProperty(exports, "Random", ({ enumerable: true, get: function () { return Random_1.Random; } }));
const GlobalParameters_1 = __webpack_require__(85165);
Object.defineProperty(exports, "configureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.configureGlobal; } }));
Object.defineProperty(exports, "readConfigureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.readConfigureGlobal; } }));
Object.defineProperty(exports, "resetConfigureGlobal", ({ enumerable: true, get: function () { return GlobalParameters_1.resetConfigureGlobal; } }));
const VerbosityLevel_1 = __webpack_require__(42070);
Object.defineProperty(exports, "VerbosityLevel", ({ enumerable: true, get: function () { return VerbosityLevel_1.VerbosityLevel; } }));
const ExecutionStatus_1 = __webpack_require__(86293);
Object.defineProperty(exports, "ExecutionStatus", ({ enumerable: true, get: function () { return ExecutionStatus_1.ExecutionStatus; } }));
const symbols_1 = __webpack_require__(28620);
Object.defineProperty(exports, "cloneMethod", ({ enumerable: true, get: function () { return symbols_1.cloneMethod; } }));
Object.defineProperty(exports, "cloneIfNeeded", ({ enumerable: true, get: function () { return symbols_1.cloneIfNeeded; } }));
Object.defineProperty(exports, "hasCloneMethod", ({ enumerable: true, get: function () { return symbols_1.hasCloneMethod; } }));
const Stream_1 = __webpack_require__(99385);
Object.defineProperty(exports, "Stream", ({ enumerable: true, get: function () { return Stream_1.Stream; } }));
Object.defineProperty(exports, "stream", ({ enumerable: true, get: function () { return Stream_1.stream; } }));
const hash_1 = __webpack_require__(21537);
Object.defineProperty(exports, "hash", ({ enumerable: true, get: function () { return hash_1.hash; } }));
const stringify_1 = __webpack_require__(21954);
Object.defineProperty(exports, "stringify", ({ enumerable: true, get: function () { return stringify_1.stringify; } }));
Object.defineProperty(exports, "asyncStringify", ({ enumerable: true, get: function () { return stringify_1.asyncStringify; } }));
Object.defineProperty(exports, "toStringMethod", ({ enumerable: true, get: function () { return stringify_1.toStringMethod; } }));
Object.defineProperty(exports, "hasToStringMethod", ({ enumerable: true, get: function () { return stringify_1.hasToStringMethod; } }));
Object.defineProperty(exports, "asyncToStringMethod", ({ enumerable: true, get: function () { return stringify_1.asyncToStringMethod; } }));
Object.defineProperty(exports, "hasAsyncToStringMethod", ({ enumerable: true, get: function () { return stringify_1.hasAsyncToStringMethod; } }));
const scheduler_1 = __webpack_require__(5062);
Object.defineProperty(exports, "scheduler", ({ enumerable: true, get: function () { return scheduler_1.scheduler; } }));
Object.defineProperty(exports, "schedulerFor", ({ enumerable: true, get: function () { return scheduler_1.schedulerFor; } }));
const RunDetailsFormatter_1 = __webpack_require__(61585);
Object.defineProperty(exports, "defaultReportMessage", ({ enumerable: true, get: function () { return RunDetailsFormatter_1.defaultReportMessage; } }));
Object.defineProperty(exports, "asyncDefaultReportMessage", ({ enumerable: true, get: function () { return RunDetailsFormatter_1.asyncDefaultReportMessage; } }));
const PreconditionFailure_1 = __webpack_require__(64431);
Object.defineProperty(exports, "PreconditionFailure", ({ enumerable: true, get: function () { return PreconditionFailure_1.PreconditionFailure; } }));
const int8Array_1 = __webpack_require__(55525);
Object.defineProperty(exports, "int8Array", ({ enumerable: true, get: function () { return int8Array_1.int8Array; } }));
const int16Array_1 = __webpack_require__(21465);
Object.defineProperty(exports, "int16Array", ({ enumerable: true, get: function () { return int16Array_1.int16Array; } }));
const int32Array_1 = __webpack_require__(37226);
Object.defineProperty(exports, "int32Array", ({ enumerable: true, get: function () { return int32Array_1.int32Array; } }));
const uint8Array_1 = __webpack_require__(83468);
Object.defineProperty(exports, "uint8Array", ({ enumerable: true, get: function () { return uint8Array_1.uint8Array; } }));
const uint8ClampedArray_1 = __webpack_require__(74729);
Object.defineProperty(exports, "uint8ClampedArray", ({ enumerable: true, get: function () { return uint8ClampedArray_1.uint8ClampedArray; } }));
const uint16Array_1 = __webpack_require__(96702);
Object.defineProperty(exports, "uint16Array", ({ enumerable: true, get: function () { return uint16Array_1.uint16Array; } }));
const uint32Array_1 = __webpack_require__(3594);
Object.defineProperty(exports, "uint32Array", ({ enumerable: true, get: function () { return uint32Array_1.uint32Array; } }));
const float32Array_1 = __webpack_require__(39330);
Object.defineProperty(exports, "float32Array", ({ enumerable: true, get: function () { return float32Array_1.float32Array; } }));
const float64Array_1 = __webpack_require__(76417);
Object.defineProperty(exports, "float64Array", ({ enumerable: true, get: function () { return float64Array_1.float64Array; } }));
const sparseArray_1 = __webpack_require__(98975);
Object.defineProperty(exports, "sparseArray", ({ enumerable: true, get: function () { return sparseArray_1.sparseArray; } }));
const Arbitrary_1 = __webpack_require__(40305);
Object.defineProperty(exports, "Arbitrary", ({ enumerable: true, get: function () { return Arbitrary_1.Arbitrary; } }));
const Value_1 = __webpack_require__(60641);
Object.defineProperty(exports, "Value", ({ enumerable: true, get: function () { return Value_1.Value; } }));
const DepthContext_1 = __webpack_require__(10514);
Object.defineProperty(exports, "createDepthIdentifier", ({ enumerable: true, get: function () { return DepthContext_1.createDepthIdentifier; } }));
Object.defineProperty(exports, "getDepthContextFor", ({ enumerable: true, get: function () { return DepthContext_1.getDepthContextFor; } }));
const bigInt64Array_1 = __webpack_require__(77632);
Object.defineProperty(exports, "bigInt64Array", ({ enumerable: true, get: function () { return bigInt64Array_1.bigInt64Array; } }));
const bigUint64Array_1 = __webpack_require__(14897);
Object.defineProperty(exports, "bigUint64Array", ({ enumerable: true, get: function () { return bigUint64Array_1.bigUint64Array; } }));
const __type = 'commonjs';
exports.__type = __type;
const __version = '3.1.1';
exports.__version = __version;
const __commitHash = '35ac775d3a2353a9458b1426c2ac97397b99cdbd';
exports.__commitHash = __commitHash;


/***/ }),

/***/ 96418:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const fc = __webpack_require__(58668);
exports["default"] = fc;
__exportStar(__webpack_require__(58668), exports);


/***/ }),

/***/ 1424:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Random = void 0;
const pure_rand_1 = __webpack_require__(23691);
class Random {
    constructor(sourceRng) {
        this.internalRng = sourceRng.clone();
    }
    clone() {
        return new Random(this.internalRng);
    }
    next(bits) {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(0, (1 << bits) - 1, this.internalRng);
    }
    nextBoolean() {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(0, 1, this.internalRng) == 1;
    }
    nextInt(min, max) {
        return (0, pure_rand_1.unsafeUniformIntDistribution)(min == null ? Random.MIN_INT : min, max == null ? Random.MAX_INT : max, this.internalRng);
    }
    nextBigInt(min, max) {
        return (0, pure_rand_1.unsafeUniformBigIntDistribution)(min, max, this.internalRng);
    }
    nextArrayInt(min, max) {
        return (0, pure_rand_1.unsafeUniformArrayIntDistribution)(min, max, this.internalRng);
    }
    nextDouble() {
        const a = this.next(26);
        const b = this.next(27);
        return (a * Random.DBL_FACTOR + b) * Random.DBL_DIVISOR;
    }
}
exports.Random = Random;
Random.MIN_INT = 0x80000000 | 0;
Random.MAX_INT = 0x7fffffff | 0;
Random.DBL_FACTOR = Math.pow(2, 27);
Random.DBL_DIVISOR = Math.pow(2, -53);


/***/ }),

/***/ 32871:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeLazy = void 0;
class LazyIterableIterator {
    constructor(producer) {
        this.producer = producer;
    }
    [Symbol.iterator]() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it;
    }
    next() {
        if (this.it === undefined) {
            this.it = this.producer();
        }
        return this.it.next();
    }
}
function makeLazy(producer) {
    return new LazyIterableIterator(producer);
}
exports.makeLazy = makeLazy;


/***/ }),

/***/ 99385:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stream = exports.Stream = void 0;
const StreamHelpers_1 = __webpack_require__(59026);
class Stream {
    constructor(g) {
        this.g = g;
    }
    static nil() {
        return new Stream((0, StreamHelpers_1.nilHelper)());
    }
    static of(...elements) {
        return new Stream(elements[Symbol.iterator]());
    }
    next() {
        return this.g.next();
    }
    [Symbol.iterator]() {
        return this.g;
    }
    map(f) {
        return new Stream((0, StreamHelpers_1.mapHelper)(this.g, f));
    }
    flatMap(f) {
        return new Stream((0, StreamHelpers_1.flatMapHelper)(this.g, f));
    }
    dropWhile(f) {
        let foundEligible = false;
        function* helper(v) {
            if (foundEligible || !f(v)) {
                foundEligible = true;
                yield v;
            }
        }
        return this.flatMap(helper);
    }
    drop(n) {
        let idx = 0;
        function helper() {
            return idx++ < n;
        }
        return this.dropWhile(helper);
    }
    takeWhile(f) {
        return new Stream((0, StreamHelpers_1.takeWhileHelper)(this.g, f));
    }
    take(n) {
        return new Stream((0, StreamHelpers_1.takeNHelper)(this.g, n));
    }
    filter(f) {
        return new Stream((0, StreamHelpers_1.filterHelper)(this.g, f));
    }
    every(f) {
        for (const v of this.g) {
            if (!f(v)) {
                return false;
            }
        }
        return true;
    }
    has(f) {
        for (const v of this.g) {
            if (f(v)) {
                return [true, v];
            }
        }
        return [false, null];
    }
    join(...others) {
        return new Stream((0, StreamHelpers_1.joinHelper)(this.g, others));
    }
    getNthOrLast(nth) {
        let remaining = nth;
        let last = null;
        for (const v of this.g) {
            if (remaining-- === 0)
                return v;
            last = v;
        }
        return last;
    }
}
exports.Stream = Stream;
function stream(g) {
    return new Stream(g);
}
exports.stream = stream;


/***/ }),

/***/ 59026:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.joinHelper = exports.takeWhileHelper = exports.takeNHelper = exports.filterHelper = exports.flatMapHelper = exports.mapHelper = exports.nilHelper = void 0;
class Nil {
    [Symbol.iterator]() {
        return this;
    }
    next(value) {
        return { value, done: true };
    }
}
Nil.nil = new Nil();
function nilHelper() {
    return Nil.nil;
}
exports.nilHelper = nilHelper;
function* mapHelper(g, f) {
    for (const v of g) {
        yield f(v);
    }
}
exports.mapHelper = mapHelper;
function* flatMapHelper(g, f) {
    for (const v of g) {
        yield* f(v);
    }
}
exports.flatMapHelper = flatMapHelper;
function* filterHelper(g, f) {
    for (const v of g) {
        if (f(v)) {
            yield v;
        }
    }
}
exports.filterHelper = filterHelper;
function* takeNHelper(g, n) {
    for (let i = 0; i < n; ++i) {
        const cur = g.next();
        if (cur.done) {
            break;
        }
        yield cur.value;
    }
}
exports.takeNHelper = takeNHelper;
function* takeWhileHelper(g, f) {
    let cur = g.next();
    while (!cur.done && f(cur.value)) {
        yield cur.value;
        cur = g.next();
    }
}
exports.takeWhileHelper = takeWhileHelper;
function* joinHelper(g, others) {
    for (let cur = g.next(); !cur.done; cur = g.next()) {
        yield cur.value;
    }
    for (const s of others) {
        for (let cur = s.next(); !cur.done; cur = s.next()) {
            yield cur.value;
        }
    }
}
exports.joinHelper = joinHelper;


/***/ }),

/***/ 21537:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.hash = void 0;
const crc32Table = [
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3, 0x0edb8832,
    0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7, 0x136c9856, 0x646ba8c0, 0xfd62f97a,
    0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3,
    0x45df5c75, 0xdcd60dcf, 0xabd13d59, 0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab,
    0xb6662d3d, 0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01, 0x6b6b51f4,
    0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65, 0x4db26158, 0x3ab551ce, 0xa3bc0074,
    0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525,
    0x206f85b3, 0xb966d409, 0xce61e49f, 0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615,
    0x73dc1683, 0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7, 0xfed41b76,
    0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b, 0xd80d2bda, 0xaf0a1b4c, 0x36034af6,
    0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7,
    0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d, 0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7,
    0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45, 0xa00ae278,
    0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9, 0xbdbdf21c, 0xcabac28a, 0x53b39330,
    0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,
];
function hash(repr) {
    let crc = 0xffffffff;
    for (let idx = 0; idx < repr.length; ++idx) {
        const c = repr.charCodeAt(idx);
        if (c < 0x80) {
            crc = crc32Table[(crc & 0xff) ^ c] ^ (crc >> 8);
        }
        else if (c < 0x800) {
            crc = crc32Table[(crc & 0xff) ^ (192 | ((c >> 6) & 31))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
        else if (c >= 0xd800 && c < 0xe000) {
            const cNext = repr.charCodeAt(++idx);
            if (c >= 0xdc00 || cNext < 0xdc00 || cNext > 0xdfff || Number.isNaN(cNext)) {
                idx -= 1;
                crc = crc32Table[(crc & 0xff) ^ 0xef] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbf] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ 0xbd] ^ (crc >> 8);
            }
            else {
                const c1 = (c & 1023) + 64;
                const c2 = cNext & 1023;
                crc = crc32Table[(crc & 0xff) ^ (240 | ((c1 >> 8) & 7))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c1 >> 2) & 63))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | ((c2 >> 6) & 15) | ((c1 & 3) << 4))] ^ (crc >> 8);
                crc = crc32Table[(crc & 0xff) ^ (128 | (c2 & 63))] ^ (crc >> 8);
            }
        }
        else {
            crc = crc32Table[(crc & 0xff) ^ (224 | ((c >> 12) & 15))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | ((c >> 6) & 63))] ^ (crc >> 8);
            crc = crc32Table[(crc & 0xff) ^ (128 | (c & 63))] ^ (crc >> 8);
        }
    }
    return (crc | 0) + 0x80000000;
}
exports.hash = hash;


/***/ }),

/***/ 21954:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncStringify = exports.possiblyAsyncStringify = exports.stringify = exports.stringifyInternal = exports.hasAsyncToStringMethod = exports.asyncToStringMethod = exports.hasToStringMethod = exports.toStringMethod = void 0;
exports.toStringMethod = Symbol('fast-check/toStringMethod');
function hasToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.toStringMethod in instance &&
        typeof instance[exports.toStringMethod] === 'function');
}
exports.hasToStringMethod = hasToStringMethod;
exports.asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');
function hasAsyncToStringMethod(instance) {
    return (instance !== null &&
        (typeof instance === 'object' || typeof instance === 'function') &&
        exports.asyncToStringMethod in instance &&
        typeof instance[exports.asyncToStringMethod] === 'function');
}
exports.hasAsyncToStringMethod = hasAsyncToStringMethod;
const findSymbolNameRegex = /^Symbol\((.*)\)$/;
function getSymbolDescription(s) {
    if (s.description !== undefined)
        return s.description;
    const m = findSymbolNameRegex.exec(String(s));
    return m && m[1].length ? m[1] : null;
}
function stringifyNumber(numValue) {
    switch (numValue) {
        case 0:
            return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';
        case Number.NEGATIVE_INFINITY:
            return 'Number.NEGATIVE_INFINITY';
        case Number.POSITIVE_INFINITY:
            return 'Number.POSITIVE_INFINITY';
        default:
            return numValue === numValue ? String(numValue) : 'Number.NaN';
    }
}
function isSparseArray(arr) {
    let previousNumberedIndex = -1;
    for (const index in arr) {
        const numberedIndex = Number(index);
        if (numberedIndex !== previousNumberedIndex + 1)
            return true;
        previousNumberedIndex = numberedIndex;
    }
    return previousNumberedIndex + 1 !== arr.length;
}
function stringifyInternal(value, previousValues, getAsyncContent) {
    const currentValues = previousValues.concat([value]);
    if (typeof value === 'object') {
        if (previousValues.indexOf(value) !== -1) {
            return '[cyclic]';
        }
    }
    if (hasAsyncToStringMethod(value)) {
        const content = getAsyncContent(value);
        if (content.state === 'fulfilled') {
            return content.value;
        }
    }
    if (hasToStringMethod(value)) {
        try {
            return value[exports.toStringMethod]();
        }
        catch (err) {
        }
    }
    switch (Object.prototype.toString.call(value)) {
        case '[object Array]': {
            const arr = value;
            if (arr.length >= 50 && isSparseArray(arr)) {
                const assignments = [];
                for (const index in arr) {
                    if (!Number.isNaN(Number(index)))
                        assignments.push(`${index}:${stringifyInternal(arr[index], currentValues, getAsyncContent)}`);
                }
                return assignments.length !== 0
                    ? `Object.assign(Array(${arr.length}),{${assignments.join(',')}})`
                    : `Array(${arr.length})`;
            }
            const stringifiedArray = arr.map((v) => stringifyInternal(v, currentValues, getAsyncContent)).join(',');
            return arr.length === 0 || arr.length - 1 in arr ? `[${stringifiedArray}]` : `[${stringifiedArray},]`;
        }
        case '[object BigInt]':
            return `${value}n`;
        case '[object Boolean]':
            return typeof value === 'boolean' ? JSON.stringify(value) : `new Boolean(${JSON.stringify(value)})`;
        case '[object Date]': {
            const d = value;
            return Number.isNaN(d.getTime()) ? `new Date(NaN)` : `new Date(${JSON.stringify(d.toISOString())})`;
        }
        case '[object Map]':
            return `new Map(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object Null]':
            return `null`;
        case '[object Number]':
            return typeof value === 'number' ? stringifyNumber(value) : `new Number(${stringifyNumber(Number(value))})`;
        case '[object Object]': {
            try {
                const toStringAccessor = value.toString;
                if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {
                    return value.toString();
                }
            }
            catch (err) {
                return '[object Object]';
            }
            const mapper = (k) => `${k === '__proto__'
                ? '["__proto__"]'
                : typeof k === 'symbol'
                    ? `[${stringifyInternal(k, currentValues, getAsyncContent)}]`
                    : JSON.stringify(k)}:${stringifyInternal(value[k], currentValues, getAsyncContent)}`;
            const stringifiedProperties = [
                ...Object.keys(value).map(mapper),
                ...Object.getOwnPropertySymbols(value)
                    .filter((s) => {
                    const descriptor = Object.getOwnPropertyDescriptor(value, s);
                    return descriptor && descriptor.enumerable;
                })
                    .map(mapper),
            ];
            const rawRepr = '{' + stringifiedProperties.join(',') + '}';
            if (Object.getPrototypeOf(value) === null) {
                return rawRepr === '{}' ? 'Object.create(null)' : `Object.assign(Object.create(null),${rawRepr})`;
            }
            return rawRepr;
        }
        case '[object Set]':
            return `new Set(${stringifyInternal(Array.from(value), currentValues, getAsyncContent)})`;
        case '[object String]':
            return typeof value === 'string' ? JSON.stringify(value) : `new String(${JSON.stringify(value)})`;
        case '[object Symbol]': {
            const s = value;
            if (Symbol.keyFor(s) !== undefined) {
                return `Symbol.for(${JSON.stringify(Symbol.keyFor(s))})`;
            }
            const desc = getSymbolDescription(s);
            if (desc === null) {
                return 'Symbol()';
            }
            const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];
            return s === knownSymbol ? desc : `Symbol(${JSON.stringify(desc)})`;
        }
        case '[object Promise]': {
            const promiseContent = getAsyncContent(value);
            switch (promiseContent.state) {
                case 'fulfilled':
                    return `Promise.resolve(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'rejected':
                    return `Promise.reject(${stringifyInternal(promiseContent.value, currentValues, getAsyncContent)})`;
                case 'pending':
                    return `new Promise(() => {/*pending*/})`;
                case 'unknown':
                default:
                    return `new Promise(() => {/*unknown*/})`;
            }
        }
        case '[object Error]':
            if (value instanceof Error) {
                return `new Error(${stringifyInternal(value.message, currentValues, getAsyncContent)})`;
            }
            break;
        case '[object Undefined]':
            return `undefined`;
        case '[object Int8Array]':
        case '[object Uint8Array]':
        case '[object Uint8ClampedArray]':
        case '[object Int16Array]':
        case '[object Uint16Array]':
        case '[object Int32Array]':
        case '[object Uint32Array]':
        case '[object Float32Array]':
        case '[object Float64Array]':
        case '[object BigInt64Array]':
        case '[object BigUint64Array]': {
            if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {
                return `Buffer.from(${stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent)})`;
            }
            const valuePrototype = Object.getPrototypeOf(value);
            const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;
            if (typeof className === 'string') {
                const typedArray = value;
                const valuesFromTypedArr = typedArray.values();
                return `${className}.from(${stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent)})`;
            }
            break;
        }
    }
    try {
        return value.toString();
    }
    catch (_a) {
        return Object.prototype.toString.call(value);
    }
}
exports.stringifyInternal = stringifyInternal;
function stringify(value) {
    return stringifyInternal(value, [], () => ({ state: 'unknown', value: undefined }));
}
exports.stringify = stringify;
function possiblyAsyncStringify(value) {
    const stillPendingMarker = Symbol();
    const pendingPromisesForCache = [];
    const cache = new Map();
    function createDelay0() {
        let handleId = null;
        const cancel = () => {
            if (handleId !== null) {
                clearTimeout(handleId);
            }
        };
        const delay = new Promise((resolve) => {
            handleId = setTimeout(() => {
                handleId = null;
                resolve(stillPendingMarker);
            }, 0);
        });
        return { delay, cancel };
    }
    const unknownState = { state: 'unknown', value: undefined };
    const getAsyncContent = function getAsyncContent(data) {
        const cacheKey = data;
        if (cache.has(cacheKey)) {
            return cache.get(cacheKey);
        }
        const delay0 = createDelay0();
        const p = exports.asyncToStringMethod in data
            ? Promise.resolve().then(() => data[exports.asyncToStringMethod]())
            : data;
        p.catch(() => { });
        pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then((successValue) => {
            if (successValue === stillPendingMarker)
                cache.set(cacheKey, { state: 'pending', value: undefined });
            else
                cache.set(cacheKey, { state: 'fulfilled', value: successValue });
            delay0.cancel();
        }, (errorValue) => {
            cache.set(cacheKey, { state: 'rejected', value: errorValue });
            delay0.cancel();
        }));
        cache.set(cacheKey, unknownState);
        return unknownState;
    };
    function loop() {
        const stringifiedValue = stringifyInternal(value, [], getAsyncContent);
        if (pendingPromisesForCache.length === 0) {
            return stringifiedValue;
        }
        return Promise.all(pendingPromisesForCache.splice(0)).then(loop);
    }
    return loop();
}
exports.possiblyAsyncStringify = possiblyAsyncStringify;
async function asyncStringify(value) {
    return Promise.resolve(possiblyAsyncStringify(value));
}
exports.asyncStringify = asyncStringify;


/***/ }),

/***/ 18042:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformArrayIntDistribution = void 0;
var UnsafeUniformArrayIntDistribution_1 = __webpack_require__(42289);
function uniformArrayIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformArrayIntDistribution = uniformArrayIntDistribution;


/***/ }),

/***/ 91968:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformBigIntDistribution = void 0;
var UnsafeUniformBigIntDistribution_1 = __webpack_require__(78065);
function uniformBigIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformBigIntDistribution = uniformBigIntDistribution;


/***/ }),

/***/ 15351:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.uniformIntDistribution = void 0;
var UnsafeUniformIntDistribution_1 = __webpack_require__(40036);
function uniformIntDistribution(from, to, rng) {
    if (rng != null) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution)(from, to, nextRng), nextRng];
    }
    return function (rng) {
        var nextRng = rng.clone();
        return [(0, UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution)(from, to, nextRng), nextRng];
    };
}
exports.uniformIntDistribution = uniformIntDistribution;


/***/ }),

/***/ 42289:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformArrayIntDistribution = void 0;
var ArrayInt_1 = __webpack_require__(47832);
var UnsafeUniformArrayIntDistributionInternal_1 = __webpack_require__(4937);
function unsafeUniformArrayIntDistribution(from, to, rng) {
    var rangeSize = (0, ArrayInt_1.trimArrayIntInplace)((0, ArrayInt_1.addOneToPositiveArrayInt)((0, ArrayInt_1.substractArrayIntToNew)(to, from)));
    var emptyArrayIntData = rangeSize.data.slice(0);
    var g = (0, UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal)(emptyArrayIntData, rangeSize.data, rng);
    return (0, ArrayInt_1.trimArrayIntInplace)((0, ArrayInt_1.addArrayIntToNew)({ sign: 1, data: g }, from));
}
exports.unsafeUniformArrayIntDistribution = unsafeUniformArrayIntDistribution;


/***/ }),

/***/ 78065:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformBigIntDistribution = void 0;
function unsafeUniformBigIntDistribution(from, to, rng) {
    var diff = to - from + BigInt(1);
    var MinRng = BigInt(rng.min());
    var NumValues = BigInt(rng.max() - rng.min() + 1);
    var FinalNumValues = NumValues;
    var NumIterations = BigInt(1);
    while (FinalNumValues < diff) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = FinalNumValues - (FinalNumValues % diff);
    while (true) {
        var value = BigInt(0);
        for (var num = BigInt(0); num !== NumIterations; ++num) {
            var out = rng.unsafeNext();
            value = NumValues * value + (BigInt(out) - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value % diff;
            return inDiff + from;
        }
    }
}
exports.unsafeUniformBigIntDistribution = unsafeUniformBigIntDistribution;


/***/ }),

/***/ 40036:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistribution = void 0;
var UnsafeUniformIntDistributionInternal_1 = __webpack_require__(79977);
var ArrayInt_1 = __webpack_require__(47832);
var UnsafeUniformArrayIntDistributionInternal_1 = __webpack_require__(4937);
var sharedA = { sign: 1, data: [0, 0] };
var sharedB = { sign: 1, data: [0, 0] };
var sharedC = { sign: 1, data: [0, 0] };
var sharedData = [0, 0];
function uniformLargeIntInternal(from, to, rangeSize, rng) {
    var rangeSizeArrayIntValue = rangeSize <= Number.MAX_SAFE_INTEGER
        ? (0, ArrayInt_1.fromNumberToArrayInt64)(sharedC, rangeSize)
        : (0, ArrayInt_1.substractArrayInt64)(sharedC, (0, ArrayInt_1.fromNumberToArrayInt64)(sharedA, to), (0, ArrayInt_1.fromNumberToArrayInt64)(sharedB, from));
    if (rangeSizeArrayIntValue.data[1] === 0xffffffff) {
        rangeSizeArrayIntValue.data[0] += 1;
        rangeSizeArrayIntValue.data[1] = 0;
    }
    else {
        rangeSizeArrayIntValue.data[1] += 1;
    }
    (0, UnsafeUniformArrayIntDistributionInternal_1.unsafeUniformArrayIntDistributionInternal)(sharedData, rangeSizeArrayIntValue.data, rng);
    return sharedData[0] * 0x100000000 + sharedData[1] + from;
}
function unsafeUniformIntDistribution(from, to, rng) {
    var rangeSize = to - from;
    if (rangeSize <= 0xffffffff) {
        var g = (0, UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal)(rangeSize + 1, rng);
        return g + from;
    }
    return uniformLargeIntInternal(from, to, rangeSize, rng);
}
exports.unsafeUniformIntDistribution = unsafeUniformIntDistribution;


/***/ }),

/***/ 47832:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.substractArrayInt64 = exports.fromNumberToArrayInt64 = exports.trimArrayIntInplace = exports.substractArrayIntToNew = exports.addOneToPositiveArrayInt = exports.addArrayIntToNew = void 0;
function addArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return substractArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var data = [];
    var reminder = 0;
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA + vB + reminder;
        data.push(current >>> 0);
        reminder = ~~(current / 0x100000000);
    }
    if (reminder !== 0) {
        data.push(reminder);
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.addArrayIntToNew = addArrayIntToNew;
function addOneToPositiveArrayInt(arrayInt) {
    arrayInt.sign = 1;
    var data = arrayInt.data;
    for (var index = data.length - 1; index >= 0; --index) {
        if (data[index] === 0xffffffff) {
            data[index] = 0;
        }
        else {
            data[index] += 1;
            return arrayInt;
        }
    }
    data.unshift(1);
    return arrayInt;
}
exports.addOneToPositiveArrayInt = addOneToPositiveArrayInt;
function isStrictlySmaller(dataA, dataB) {
    var maxLength = Math.max(dataA.length, dataB.length);
    for (var index = 0; index < maxLength; ++index) {
        var indexA = index + dataA.length - maxLength;
        var indexB = index + dataB.length - maxLength;
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        if (vA < vB)
            return true;
        if (vA > vB)
            return false;
    }
    return false;
}
function substractArrayIntToNew(arrayIntA, arrayIntB) {
    if (arrayIntA.sign !== arrayIntB.sign) {
        return addArrayIntToNew(arrayIntA, { sign: -arrayIntB.sign, data: arrayIntB.data });
    }
    var dataA = arrayIntA.data;
    var dataB = arrayIntB.data;
    if (isStrictlySmaller(dataA, dataB)) {
        var out = substractArrayIntToNew(arrayIntB, arrayIntA);
        out.sign = -out.sign;
        return out;
    }
    var data = [];
    var reminder = 0;
    for (var indexA = dataA.length - 1, indexB = dataB.length - 1; indexA >= 0 || indexB >= 0; --indexA, --indexB) {
        var vA = indexA >= 0 ? dataA[indexA] : 0;
        var vB = indexB >= 0 ? dataB[indexB] : 0;
        var current = vA - vB - reminder;
        data.push(current >>> 0);
        reminder = current < 0 ? 1 : 0;
    }
    return { sign: arrayIntA.sign, data: data.reverse() };
}
exports.substractArrayIntToNew = substractArrayIntToNew;
function trimArrayIntInplace(arrayInt) {
    var data = arrayInt.data;
    var firstNonZero = 0;
    for (; firstNonZero !== data.length && data[firstNonZero] === 0; ++firstNonZero) { }
    if (firstNonZero === data.length) {
        arrayInt.sign = 1;
        arrayInt.data = [0];
        return arrayInt;
    }
    data.splice(0, firstNonZero);
    return arrayInt;
}
exports.trimArrayIntInplace = trimArrayIntInplace;
function fromNumberToArrayInt64(out, n) {
    if (n < 0) {
        var posN = -n;
        out.sign = -1;
        out.data[0] = ~~(posN / 0x100000000);
        out.data[1] = posN >>> 0;
    }
    else {
        out.sign = 1;
        out.data[0] = ~~(n / 0x100000000);
        out.data[1] = n >>> 0;
    }
    return out;
}
exports.fromNumberToArrayInt64 = fromNumberToArrayInt64;
function substractArrayInt64(out, arrayIntA, arrayIntB) {
    var lowA = arrayIntA.data[1];
    var highA = arrayIntA.data[0];
    var signA = arrayIntA.sign;
    var lowB = arrayIntB.data[1];
    var highB = arrayIntB.data[0];
    var signB = arrayIntB.sign;
    out.sign = 1;
    if (signA === 1 && signB === -1) {
        var low_1 = lowA + lowB;
        var high = highA + highB + (low_1 > 0xffffffff ? 1 : 0);
        out.data[0] = high >>> 0;
        out.data[1] = low_1 >>> 0;
        return out;
    }
    var lowFirst = lowA;
    var highFirst = highA;
    var lowSecond = lowB;
    var highSecond = highB;
    if (signA === -1) {
        lowFirst = lowB;
        highFirst = highB;
        lowSecond = lowA;
        highSecond = highA;
    }
    var reminderLow = 0;
    var low = lowFirst - lowSecond;
    if (low < 0) {
        reminderLow = 1;
        low = low >>> 0;
    }
    out.data[0] = highFirst - highSecond - reminderLow;
    out.data[1] = low;
    return out;
}
exports.substractArrayInt64 = substractArrayInt64;


/***/ }),

/***/ 4937:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformArrayIntDistributionInternal = void 0;
var UnsafeUniformIntDistributionInternal_1 = __webpack_require__(79977);
function unsafeUniformArrayIntDistributionInternal(out, rangeSize, rng) {
    var rangeLength = rangeSize.length;
    while (true) {
        for (var index = 0; index !== rangeLength; ++index) {
            var indexRangeSize = index === 0 ? rangeSize[0] + 1 : 0x100000000;
            var g = (0, UnsafeUniformIntDistributionInternal_1.unsafeUniformIntDistributionInternal)(indexRangeSize, rng);
            out[index] = g;
        }
        for (var index = 0; index !== rangeLength; ++index) {
            var current = out[index];
            var currentInRange = rangeSize[index];
            if (current < currentInRange) {
                return out;
            }
            else if (current > currentInRange) {
                break;
            }
        }
    }
}
exports.unsafeUniformArrayIntDistributionInternal = unsafeUniformArrayIntDistributionInternal;


/***/ }),

/***/ 79977:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistributionInternal = void 0;
function unsafeUniformIntDistributionInternal(rangeSize, rng) {
    var MinRng = rng.min();
    var NumValues = rng.max() - rng.min() + 1;
    if (rangeSize <= NumValues) {
        var nrng_1 = rng;
        var MaxAllowed = NumValues - (NumValues % rangeSize);
        while (true) {
            var out = nrng_1.unsafeNext();
            var deltaV = out - MinRng;
            if (deltaV < MaxAllowed) {
                return deltaV % rangeSize;
            }
        }
    }
    var FinalNumValues = NumValues * NumValues;
    var NumIterations = 2;
    while (FinalNumValues < rangeSize) {
        FinalNumValues *= NumValues;
        ++NumIterations;
    }
    var MaxAcceptedRandom = rangeSize * Math.floor((1 * FinalNumValues) / rangeSize);
    var nrng = rng;
    while (true) {
        var value = 0;
        for (var num = 0; num !== NumIterations; ++num) {
            var out = nrng.unsafeNext();
            value = NumValues * value + (out - MinRng);
        }
        if (value < MaxAcceptedRandom) {
            var inDiff = value - rangeSize * Math.floor((1 * value) / rangeSize);
            return inDiff;
        }
    }
}
exports.unsafeUniformIntDistributionInternal = unsafeUniformIntDistributionInternal;


/***/ }),

/***/ 27086:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.congruential32 = exports.congruential = void 0;
var MULTIPLIER = 0x000343fd;
var INCREMENT = 0x00269ec3;
var MASK = 0xffffffff;
var MASK_2 = (1 << 31) - 1;
var computeNextSeed = function (seed) {
    return (seed * MULTIPLIER + INCREMENT) & MASK;
};
var computeValueFromNextSeed = function (nextseed) {
    return (nextseed & MASK_2) >> 16;
};
var LinearCongruential = (function () {
    function LinearCongruential(seed) {
        this.seed = seed;
    }
    LinearCongruential.prototype.min = function () {
        return LinearCongruential.min;
    };
    LinearCongruential.prototype.max = function () {
        return LinearCongruential.max;
    };
    LinearCongruential.prototype.clone = function () {
        return new LinearCongruential(this.seed);
    };
    LinearCongruential.prototype.next = function () {
        var nextRng = new LinearCongruential(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential.prototype.unsafeNext = function () {
        this.seed = computeNextSeed(this.seed);
        return computeValueFromNextSeed(this.seed);
    };
    LinearCongruential.min = 0;
    LinearCongruential.max = Math.pow(2, 15) - 1;
    return LinearCongruential;
}());
var LinearCongruential32 = (function () {
    function LinearCongruential32(seed) {
        this.seed = seed;
    }
    LinearCongruential32.prototype.min = function () {
        return LinearCongruential32.min;
    };
    LinearCongruential32.prototype.max = function () {
        return LinearCongruential32.max;
    };
    LinearCongruential32.prototype.clone = function () {
        return new LinearCongruential32(this.seed);
    };
    LinearCongruential32.prototype.next = function () {
        var nextRng = new LinearCongruential32(this.seed);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    LinearCongruential32.prototype.unsafeNext = function () {
        var s1 = computeNextSeed(this.seed);
        var v1 = computeValueFromNextSeed(s1);
        var s2 = computeNextSeed(s1);
        var v2 = computeValueFromNextSeed(s2);
        this.seed = computeNextSeed(s2);
        var v3 = computeValueFromNextSeed(this.seed);
        var vnext = v3 + ((v2 + (v1 << 15)) << 15);
        return ((vnext + 0x80000000) | 0) + 0x80000000;
    };
    LinearCongruential32.min = 0;
    LinearCongruential32.max = 0xffffffff;
    return LinearCongruential32;
}());
var congruential = function (seed) {
    return new LinearCongruential(seed);
};
exports.congruential = congruential;
var congruential32 = function (seed) {
    return new LinearCongruential32(seed);
};
exports.congruential32 = congruential32;


/***/ }),

/***/ 27110:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
var MersenneTwister = (function () {
    function MersenneTwister(states, index) {
        this.states = states;
        this.index = index;
    }
    MersenneTwister.twist = function (prev) {
        var mt = prev.slice();
        for (var idx = 0; idx !== MersenneTwister.N - MersenneTwister.M; ++idx) {
            var y_1 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M] ^ (y_1 >>> 1) ^ (-(y_1 & 1) & MersenneTwister.A);
        }
        for (var idx = MersenneTwister.N - MersenneTwister.M; idx !== MersenneTwister.N - 1; ++idx) {
            var y_2 = (mt[idx] & MersenneTwister.MASK_UPPER) + (mt[idx + 1] & MersenneTwister.MASK_LOWER);
            mt[idx] = mt[idx + MersenneTwister.M - MersenneTwister.N] ^ (y_2 >>> 1) ^ (-(y_2 & 1) & MersenneTwister.A);
        }
        var y = (mt[MersenneTwister.N - 1] & MersenneTwister.MASK_UPPER) + (mt[0] & MersenneTwister.MASK_LOWER);
        mt[MersenneTwister.N - 1] = mt[MersenneTwister.M - 1] ^ (y >>> 1) ^ (-(y & 1) & MersenneTwister.A);
        return mt;
    };
    MersenneTwister.seeded = function (seed) {
        var out = Array(MersenneTwister.N);
        out[0] = seed;
        for (var idx = 1; idx !== MersenneTwister.N; ++idx) {
            var xored = out[idx - 1] ^ (out[idx - 1] >>> 30);
            out[idx] = (Math.imul(MersenneTwister.F, xored) + idx) | 0;
        }
        return out;
    };
    MersenneTwister.from = function (seed) {
        return new MersenneTwister(MersenneTwister.twist(MersenneTwister.seeded(seed)), 0);
    };
    MersenneTwister.prototype.min = function () {
        return MersenneTwister.min;
    };
    MersenneTwister.prototype.max = function () {
        return MersenneTwister.max;
    };
    MersenneTwister.prototype.clone = function () {
        return new MersenneTwister(this.states, this.index);
    };
    MersenneTwister.prototype.next = function () {
        var nextRng = new MersenneTwister(this.states, this.index);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    MersenneTwister.prototype.unsafeNext = function () {
        var y = this.states[this.index];
        y ^= this.states[this.index] >>> MersenneTwister.U;
        y ^= (y << MersenneTwister.S) & MersenneTwister.B;
        y ^= (y << MersenneTwister.T) & MersenneTwister.C;
        y ^= y >>> MersenneTwister.L;
        if (++this.index >= MersenneTwister.N) {
            this.states = MersenneTwister.twist(this.states);
            this.index = 0;
        }
        return y >>> 0;
    };
    MersenneTwister.min = 0;
    MersenneTwister.max = 0xffffffff;
    MersenneTwister.N = 624;
    MersenneTwister.M = 397;
    MersenneTwister.R = 31;
    MersenneTwister.A = 0x9908b0df;
    MersenneTwister.F = 1812433253;
    MersenneTwister.U = 11;
    MersenneTwister.S = 7;
    MersenneTwister.B = 0x9d2c5680;
    MersenneTwister.T = 15;
    MersenneTwister.C = 0xefc60000;
    MersenneTwister.L = 18;
    MersenneTwister.MASK_LOWER = Math.pow(2, MersenneTwister.R) - 1;
    MersenneTwister.MASK_UPPER = Math.pow(2, MersenneTwister.R);
    return MersenneTwister;
}());
function default_1(seed) {
    return MersenneTwister.from(seed);
}
exports["default"] = default_1;


/***/ }),

/***/ 40415:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.skipN = exports.unsafeSkipN = exports.generateN = exports.unsafeGenerateN = void 0;
function unsafeGenerateN(rng, num) {
    var out = [];
    for (var idx = 0; idx != num; ++idx) {
        out.push(rng.unsafeNext());
    }
    return out;
}
exports.unsafeGenerateN = unsafeGenerateN;
function generateN(rng, num) {
    var nextRng = rng.clone();
    var out = unsafeGenerateN(nextRng, num);
    return [out, nextRng];
}
exports.generateN = generateN;
function unsafeSkipN(rng, num) {
    for (var idx = 0; idx != num; ++idx) {
        rng.unsafeNext();
    }
}
exports.unsafeSkipN = unsafeSkipN;
function skipN(rng, num) {
    var nextRng = rng.clone();
    unsafeSkipN(nextRng, num);
    return nextRng;
}
exports.skipN = skipN;


/***/ }),

/***/ 11497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.xorshift128plus = void 0;
var XorShift128Plus = (function () {
    function XorShift128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XorShift128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XorShift128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XorShift128Plus.prototype.clone = function () {
        return new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XorShift128Plus.prototype.next = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XorShift128Plus.prototype.unsafeNext = function () {
        var a0 = this.s00 ^ (this.s00 << 23);
        var a1 = this.s01 ^ ((this.s01 << 23) | (this.s00 >>> 9));
        var b0 = a0 ^ this.s10 ^ ((a0 >>> 18) | (a1 << 14)) ^ ((this.s10 >>> 5) | (this.s11 << 27));
        var b1 = a1 ^ this.s11 ^ (a1 >>> 18) ^ (this.s11 >>> 5);
        var out = (this.s00 + this.s10) | 0;
        this.s01 = this.s11;
        this.s00 = this.s10;
        this.s11 = b1;
        this.s10 = b0;
        return out;
    };
    XorShift128Plus.prototype.jump = function () {
        var nextRng = new XorShift128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XorShift128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0x635d2dff, 0x8a5cd789, 0x5c472f96, 0x121fd215];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XorShift128Plus;
}());
var xorshift128plus = function (seed) {
    return new XorShift128Plus(-1, ~seed, seed | 0, 0);
};
exports.xorshift128plus = xorshift128plus;


/***/ }),

/***/ 43652:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

exports.__esModule = true;
exports.xoroshiro128plus = void 0;
var XoroShiro128Plus = (function () {
    function XoroShiro128Plus(s01, s00, s11, s10) {
        this.s01 = s01;
        this.s00 = s00;
        this.s11 = s11;
        this.s10 = s10;
    }
    XoroShiro128Plus.prototype.min = function () {
        return -0x80000000;
    };
    XoroShiro128Plus.prototype.max = function () {
        return 0x7fffffff;
    };
    XoroShiro128Plus.prototype.clone = function () {
        return new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
    };
    XoroShiro128Plus.prototype.next = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        var out = nextRng.unsafeNext();
        return [out, nextRng];
    };
    XoroShiro128Plus.prototype.unsafeNext = function () {
        var out = (this.s00 + this.s10) | 0;
        var a0 = this.s10 ^ this.s00;
        var a1 = this.s11 ^ this.s01;
        var s00 = this.s00;
        var s01 = this.s01;
        this.s00 = (s00 << 24) ^ (s01 >>> 8) ^ a0 ^ (a0 << 16);
        this.s01 = (s01 << 24) ^ (s00 >>> 8) ^ a1 ^ ((a1 << 16) | (a0 >>> 16));
        this.s10 = (a1 << 5) ^ (a0 >>> 27);
        this.s11 = (a0 << 5) ^ (a1 >>> 27);
        return out;
    };
    XoroShiro128Plus.prototype.jump = function () {
        var nextRng = new XoroShiro128Plus(this.s01, this.s00, this.s11, this.s10);
        nextRng.unsafeJump();
        return nextRng;
    };
    XoroShiro128Plus.prototype.unsafeJump = function () {
        var ns01 = 0;
        var ns00 = 0;
        var ns11 = 0;
        var ns10 = 0;
        var jump = [0xd8f554a5, 0xdf900294, 0x4b3201fc, 0x170865df];
        for (var i = 0; i !== 4; ++i) {
            for (var mask = 1; mask; mask <<= 1) {
                if (jump[i] & mask) {
                    ns01 ^= this.s01;
                    ns00 ^= this.s00;
                    ns11 ^= this.s11;
                    ns10 ^= this.s10;
                }
                this.unsafeNext();
            }
        }
        this.s01 = ns01;
        this.s00 = ns00;
        this.s11 = ns11;
        this.s10 = ns10;
    };
    return XoroShiro128Plus;
}());
var xoroshiro128plus = function (seed) {
    return new XoroShiro128Plus(-1, ~seed, seed | 0, 0);
};
exports.xoroshiro128plus = xoroshiro128plus;


/***/ }),

/***/ 27384:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

exports.__esModule = true;
exports.unsafeUniformIntDistribution = exports.unsafeUniformBigIntDistribution = exports.unsafeUniformArrayIntDistribution = exports.uniformIntDistribution = exports.uniformBigIntDistribution = exports.uniformArrayIntDistribution = exports.xoroshiro128plus = exports.xorshift128plus = exports.mersenne = exports.congruential32 = exports.congruential = exports.unsafeSkipN = exports.unsafeGenerateN = exports.skipN = exports.generateN = exports.__commitHash = exports.__version = exports.__type = void 0;
var RandomGenerator_1 = __webpack_require__(40415);
exports.generateN = RandomGenerator_1.generateN;
exports.skipN = RandomGenerator_1.skipN;
exports.unsafeGenerateN = RandomGenerator_1.unsafeGenerateN;
exports.unsafeSkipN = RandomGenerator_1.unsafeSkipN;
var LinearCongruential_1 = __webpack_require__(27086);
exports.congruential = LinearCongruential_1.congruential;
exports.congruential32 = LinearCongruential_1.congruential32;
var MersenneTwister_1 = __webpack_require__(27110);
exports.mersenne = MersenneTwister_1["default"];
var XorShift_1 = __webpack_require__(11497);
exports.xorshift128plus = XorShift_1.xorshift128plus;
var XoroShiro_1 = __webpack_require__(43652);
exports.xoroshiro128plus = XoroShiro_1.xoroshiro128plus;
var UniformArrayIntDistribution_1 = __webpack_require__(18042);
exports.uniformArrayIntDistribution = UniformArrayIntDistribution_1.uniformArrayIntDistribution;
var UniformBigIntDistribution_1 = __webpack_require__(91968);
exports.uniformBigIntDistribution = UniformBigIntDistribution_1.uniformBigIntDistribution;
var UniformIntDistribution_1 = __webpack_require__(15351);
exports.uniformIntDistribution = UniformIntDistribution_1.uniformIntDistribution;
var UnsafeUniformArrayIntDistribution_1 = __webpack_require__(42289);
exports.unsafeUniformArrayIntDistribution = UnsafeUniformArrayIntDistribution_1.unsafeUniformArrayIntDistribution;
var UnsafeUniformBigIntDistribution_1 = __webpack_require__(78065);
exports.unsafeUniformBigIntDistribution = UnsafeUniformBigIntDistribution_1.unsafeUniformBigIntDistribution;
var UnsafeUniformIntDistribution_1 = __webpack_require__(40036);
exports.unsafeUniformIntDistribution = UnsafeUniformIntDistribution_1.unsafeUniformIntDistribution;
var __type = 'commonjs';
exports.__type = __type;
var __version = '5.0.1';
exports.__version = __version;
var __commitHash = '229c91e5c41acd30afc2cccabe9ba93c99db5df7';
exports.__commitHash = __commitHash;


/***/ }),

/***/ 23691:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
exports.__esModule = true;
var prand = __webpack_require__(27384);
exports["default"] = prand;
__exportStar(__webpack_require__(27384), exports);


/***/ }),

/***/ 13012:
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Big: () => (/* binding */ Big),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/*
 *  big.js v6.0.3
 *  A small, fast, easy-to-use library for arbitrary-precision decimal arithmetic.
 *  Copyright (c) 2020 Michael Mclaughlin
 *  https://github.com/MikeMcl/big.js/LICENCE.md
 */


/************************************** EDITABLE DEFAULTS *****************************************/


  // The default values below must be integers within the stated ranges.

  /*
   * The maximum number of decimal places (DP) of the results of operations involving division:
   * div and sqrt, and pow with negative exponents.
   */
var DP = 20,          // 0 to MAX_DP

  /*
   * The rounding mode (RM) used when rounding to the above decimal places.
   *
   *  0  Towards zero (i.e. truncate, no rounding).       (ROUND_DOWN)
   *  1  To nearest neighbour. If equidistant, round up.  (ROUND_HALF_UP)
   *  2  To nearest neighbour. If equidistant, to even.   (ROUND_HALF_EVEN)
   *  3  Away from zero.                                  (ROUND_UP)
   */
  RM = 1,             // 0, 1, 2 or 3

  // The maximum value of DP and Big.DP.
  MAX_DP = 1E6,       // 0 to 1000000

  // The maximum magnitude of the exponent argument to the pow method.
  MAX_POWER = 1E6,    // 1 to 1000000

  /*
   * The negative exponent (NE) at and beneath which toString returns exponential notation.
   * (JavaScript numbers: -7)
   * -1000000 is the minimum recommended exponent value of a Big.
   */
  NE = -7,            // 0 to -1000000

  /*
   * The positive exponent (PE) at and above which toString returns exponential notation.
   * (JavaScript numbers: 21)
   * 1000000 is the maximum recommended exponent value of a Big, but this limit is not enforced.
   */
  PE = 21,            // 0 to 1000000

  /*
   * When true, an error will be thrown if a primitive number is passed to the Big constructor,
   * or if valueOf is called, or if toNumber is called on a Big which cannot be converted to a
   * primitive number without a loss of precision.
   */
  STRICT = false,     // true or false


/**************************************************************************************************/


  // Error messages.
  NAME = '[big.js] ',
  INVALID = NAME + 'Invalid ',
  INVALID_DP = INVALID + 'decimal places',
  INVALID_RM = INVALID + 'rounding mode',
  DIV_BY_ZERO = NAME + 'Division by zero',

  // The shared prototype object.
  P = {},
  UNDEFINED = void 0,
  NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;


/*
 * Create and return a Big constructor.
 */
function _Big_() {

  /*
   * The Big constructor and exported function.
   * Create and return a new instance of a Big number object.
   *
   * n {number|string|Big} A numeric value.
   */
  function Big(n) {
    var x = this;

    // Enable constructor usage without new.
    if (!(x instanceof Big)) return n === UNDEFINED ? _Big_() : new Big(n);

    // Duplicate.
    if (n instanceof Big) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      if (typeof n !== 'string') {
        if (Big.strict === true) {
          throw TypeError(INVALID + 'number');
        }

        // Minus zero?
        n = n === 0 && 1 / n < 0 ? '-0' : String(n);
      }

      parse(x, n);
    }

    // Retain a reference to this Big constructor.
    // Shadow Big.prototype.constructor which points to Object.
    x.constructor = Big;
  }

  Big.prototype = P;
  Big.DP = DP;
  Big.RM = RM;
  Big.NE = NE;
  Big.PE = PE;
  Big.strict = STRICT;

  return Big;
}


/*
 * Parse the number or string value passed to a Big constructor.
 *
 * x {Big} A Big number instance.
 * n {number|string} A numeric value.
 */
function parse(x, n) {
  var e, i, nl;

  if (!NUMERIC.test(n)) {
    throw Error(INVALID + 'number');
  }

  // Determine sign.
  x.s = n.charAt(0) == '-' ? (n = n.slice(1), -1) : 1;

  // Decimal point?
  if ((e = n.indexOf('.')) > -1) n = n.replace('.', '');

  // Exponential form?
  if ((i = n.search(/e/i)) > 0) {

    // Determine exponent.
    if (e < 0) e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {

    // Integer.
    e = n.length;
  }

  nl = n.length;

  // Determine leading zeros.
  for (i = 0; i < nl && n.charAt(i) == '0';) ++i;

  if (i == nl) {

    // Zero.
    x.c = [x.e = 0];
  } else {

    // Determine trailing zeros.
    for (; nl > 0 && n.charAt(--nl) == '0';);
    x.e = e - i - 1;
    x.c = [];

    // Convert string to array of digits without leading/trailing zeros.
    for (e = 0; i <= nl;) x.c[e++] = +n.charAt(i++);
  }

  return x;
}


/*
 * Round Big x to a maximum of sd significant digits using rounding mode rm.
 *
 * x {Big} The Big to round.
 * sd {number} Significant digits: integer, 0 to MAX_DP inclusive.
 * rm {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 * [more] {boolean} Whether the result of division was truncated.
 */
function round(x, sd, rm, more) {
  var xc = x.c;

  if (rm === UNDEFINED) rm = Big.RM;
  if (rm !== 0 && rm !== 1 && rm !== 2 && rm !== 3) {
    throw Error(INVALID_RM);
  }

  if (sd < 1) {
    more =
      rm === 3 && (more || !!xc[0]) || sd === 0 && (
      rm === 1 && xc[0] >= 5 ||
      rm === 2 && (xc[0] > 5 || xc[0] === 5 && (more || xc[1] !== UNDEFINED))
    );

    xc.length = 1;

    if (more) {

      // 1, 0.1, 0.01, 0.001, 0.0001 etc.
      x.e = x.e - sd + 1;
      xc[0] = 1;
    } else {

      // Zero.
      xc[0] = x.e = 0;
    }
  } else if (sd < xc.length) {

    // xc[sd] is the digit after the digit that may be rounded up.
    more =
      rm === 1 && xc[sd] >= 5 ||
      rm === 2 && (xc[sd] > 5 || xc[sd] === 5 &&
        (more || xc[sd + 1] !== UNDEFINED || xc[sd - 1] & 1)) ||
      rm === 3 && (more || !!xc[0]);

    // Remove any digits after the required precision.
    xc.length = sd--;

    // Round up?
    if (more) {

      // Rounding up may mean the previous digit has to be rounded up.
      for (; ++xc[sd] > 9;) {
        xc[sd] = 0;
        if (!sd--) {
          ++x.e;
          xc.unshift(1);
        }
      }
    }

    // Remove trailing zeros.
    for (sd = xc.length; !xc[--sd];) xc.pop();
  }

  return x;
}


/*
 * Return a string representing the value of Big x in normal or exponential notation.
 * Handles P.toExponential, P.toFixed, P.toJSON, P.toPrecision, P.toString and P.valueOf.
 */
function stringify(x, doExponential, isNonzero) {
  var e = x.e,
    s = x.c.join(''),
    n = s.length;

  // Exponential notation?
  if (doExponential) {
    s = s.charAt(0) + (n > 1 ? '.' + s.slice(1) : '') + (e < 0 ? 'e' : 'e+') + e;

  // Normal notation.
  } else if (e < 0) {
    for (; ++e;) s = '0' + s;
    s = '0.' + s;
  } else if (e > 0) {
    if (++e > n) {
      for (e -= n; e--;) s += '0';
    } else if (e < n) {
      s = s.slice(0, e) + '.' + s.slice(e);
    }
  } else if (n > 1) {
    s = s.charAt(0) + '.' + s.slice(1);
  }

  return x.s < 0 && isNonzero ? '-' + s : s;
}


// Prototype/instance methods


/*
 * Return a new Big whose value is the absolute value of this Big.
 */
P.abs = function () {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};


/*
 * Return 1 if the value of this Big is greater than the value of Big y,
 *       -1 if the value of this Big is less than the value of Big y, or
 *        0 if they have the same value.
 */
P.cmp = function (y) {
  var isneg,
    x = this,
    xc = x.c,
    yc = (y = new x.constructor(y)).c,
    i = x.s,
    j = y.s,
    k = x.e,
    l = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) return !xc[0] ? !yc[0] ? 0 : -j : i;

  // Signs differ?
  if (i != j) return i;

  isneg = i < 0;

  // Compare exponents.
  if (k != l) return k > l ^ isneg ? 1 : -1;

  j = (k = xc.length) < (l = yc.length) ? k : l;

  // Compare digit by digit.
  for (i = -1; ++i < j;) {
    if (xc[i] != yc[i]) return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }

  // Compare lengths.
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};


/*
 * Return a new Big whose value is the value of this Big divided by the value of Big y, rounded,
 * if necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.div = function (y) {
  var x = this,
    Big = x.constructor,
    a = x.c,                  // dividend
    b = (y = new Big(y)).c,   // divisor
    k = x.s == y.s ? 1 : -1,
    dp = Big.DP;

  if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }

  // Divisor is zero?
  if (!b[0]) {
    throw Error(DIV_BY_ZERO);
  }

  // Dividend is 0? Return +-0.
  if (!a[0]) {
    y.s = k;
    y.c = [y.e = 0];
    return y;
  }

  var bl, bt, n, cmp, ri,
    bz = b.slice(),
    ai = bl = b.length,
    al = a.length,
    r = a.slice(0, bl),   // remainder
    rl = r.length,
    q = y,                // quotient
    qc = q.c = [],
    qi = 0,
    p = dp + (q.e = x.e - y.e) + 1;    // precision of the result

  q.s = k;
  k = p < 0 ? 0 : p;

  // Create version of divisor with leading zero.
  bz.unshift(0);

  // Add zeros to make remainder as long as divisor.
  for (; rl++ < bl;) r.push(0);

  do {

    // n is how many times the divisor goes into current remainder.
    for (n = 0; n < 10; n++) {

      // Compare divisor and remainder.
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl;) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }

      // If divisor < remainder, subtract divisor from remainder.
      if (cmp < 0) {

        // Remainder can't be more than 1 digit longer than divisor.
        // Equalise lengths using divisor with extra leading zero?
        for (bt = rl == bl ? b : bz; rl;) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri];) r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }

        for (; !r[0];) r.shift();
      } else {
        break;
      }
    }

    // Add the digit n to the result array.
    qc[qi++] = cmp ? n : ++n;

    // Update the remainder.
    if (r[0] && cmp) r[rl] = a[ai] || 0;
    else r = [a[ai]];

  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);

  // Leading zero? Do not remove if result is simply zero (qi == 1).
  if (!qc[0] && qi != 1) {

    // There can't be more than one zero.
    qc.shift();
    q.e--;
    p--;
  }

  // Round?
  if (qi > p) round(q, p, Big.RM, r[0] !== UNDEFINED);

  return q;
};


/*
 * Return true if the value of this Big is equal to the value of Big y, otherwise return false.
 */
P.eq = function (y) {
  return this.cmp(y) === 0;
};


/*
 * Return true if the value of this Big is greater than the value of Big y, otherwise return
 * false.
 */
P.gt = function (y) {
  return this.cmp(y) > 0;
};


/*
 * Return true if the value of this Big is greater than or equal to the value of Big y, otherwise
 * return false.
 */
P.gte = function (y) {
  return this.cmp(y) > -1;
};


/*
 * Return true if the value of this Big is less than the value of Big y, otherwise return false.
 */
P.lt = function (y) {
  return this.cmp(y) < 0;
};


/*
 * Return true if the value of this Big is less than or equal to the value of Big y, otherwise
 * return false.
 */
P.lte = function (y) {
  return this.cmp(y) < 1;
};


/*
 * Return a new Big whose value is the value of this Big minus the value of Big y.
 */
P.minus = P.sub = function (y) {
  var i, j, t, xlty,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  // Signs differ?
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }

  var xc = x.c.slice(),
    xe = x.e,
    yc = y.c,
    ye = y.e;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (yc[0]) {
      y.s = -b;
    } else if (xc[0]) {
      y = new Big(x);
    } else {
      y.s = 1;
    }
    return y;
  }

  // Determine which is the bigger number. Prepend zeros to equalise exponents.
  if (a = xe - ye) {

    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }

    t.reverse();
    for (b = a; b--;) t.push(0);
    t.reverse();
  } else {

    // Exponents equal. Check digit by digit.
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;

    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }

  // x < y? Point xc to the array of the bigger number.
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }

  /*
   * Append zeros to xc if shorter. No need to add zeros to yc if shorter as subtraction only
   * needs to start at yc.length.
   */
  if ((b = (j = yc.length) - (i = xc.length)) > 0) for (; b--;) xc[i++] = 0;

  // Subtract yc from xc.
  for (b = i; j > a;) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i];) xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }

    xc[j] -= yc[j];
  }

  // Remove trailing zeros.
  for (; xc[--b] === 0;) xc.pop();

  // Remove leading zeros and adjust exponent accordingly.
  for (; xc[0] === 0;) {
    xc.shift();
    --ye;
  }

  if (!xc[0]) {

    // n - n = +0
    y.s = 1;

    // Result must be zero.
    xc = [ye = 0];
  }

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a new Big whose value is the value of this Big modulo the value of Big y.
 */
P.mod = function (y) {
  var ygtx,
    x = this,
    Big = x.constructor,
    a = x.s,
    b = (y = new Big(y)).s;

  if (!y.c[0]) {
    throw Error(DIV_BY_ZERO);
  }

  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;

  if (ygtx) return new Big(x);

  a = Big.DP;
  b = Big.RM;
  Big.DP = Big.RM = 0;
  x = x.div(y);
  Big.DP = a;
  Big.RM = b;

  return this.minus(x.times(y));
};


/*
 * Return a new Big whose value is the value of this Big plus the value of Big y.
 */
P.plus = P.add = function (y) {
  var e, k, t,
    x = this,
    Big = x.constructor;

  y = new Big(y);

  // Signs differ?
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }

  var xe = x.e,
    xc = x.c,
    ye = y.e,
    yc = y.c;

  // Either zero?
  if (!xc[0] || !yc[0]) {
    if (!yc[0]) {
      if (xc[0]) {
        y = new Big(x);
      } else {
        y.s = x.s;
      }
    }
    return y;
  }

  xc = xc.slice();

  // Prepend zeros to equalise exponents.
  // Note: reverse faster than unshifts.
  if (e = xe - ye) {
    if (e > 0) {
      ye = xe;
      t = yc;
    } else {
      e = -e;
      t = xc;
    }

    t.reverse();
    for (; e--;) t.push(0);
    t.reverse();
  }

  // Point xc to the longer array.
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }

  e = yc.length;

  // Only start adding at yc.length - 1 as the further digits of xc can be left as they are.
  for (k = 0; e; xc[e] %= 10) k = (xc[--e] = xc[e] + yc[e] + k) / 10 | 0;

  // No need to check for zero, as +x + +y != 0 && -x + -y != 0

  if (k) {
    xc.unshift(k);
    ++ye;
  }

  // Remove trailing zeros.
  for (e = xc.length; xc[--e] === 0;) xc.pop();

  y.c = xc;
  y.e = ye;

  return y;
};


/*
 * Return a Big whose value is the value of this Big raised to the power n.
 * If n is negative, round to a maximum of Big.DP decimal places using rounding
 * mode Big.RM.
 *
 * n {number} Integer, -MAX_POWER to MAX_POWER inclusive.
 */
P.pow = function (n) {
  var x = this,
    one = new x.constructor('1'),
    y = one,
    isneg = n < 0;

  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER) {
    throw Error(INVALID + 'exponent');
  }

  if (isneg) n = -n;

  for (;;) {
    if (n & 1) y = y.times(x);
    n >>= 1;
    if (!n) break;
    x = x.times(x);
  }

  return isneg ? one.div(y) : y;
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum precision of sd
 * significant digits using rounding mode rm, or Big.RM if rm is not specified.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.prec = function (sd, rm) {
  if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
    throw Error(INVALID + 'precision');
  }
  return round(new this.constructor(this), sd, rm);
};


/*
 * Return a new Big whose value is the value of this Big rounded to a maximum of dp decimal places
 * using rounding mode rm, or Big.RM if rm is not specified.
 * If dp is negative, round to an integer which is a multiple of 10**-dp.
 * If dp is not specified, round to 0 decimal places.
 *
 * dp? {number} Integer, -MAX_DP to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.round = function (dp, rm) {
  if (dp === UNDEFINED) dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP) {
    throw Error(INVALID_DP);
  }
  return round(new this.constructor(this), dp + this.e + 1, rm);
};


/*
 * Return a new Big whose value is the square root of the value of this Big, rounded, if
 * necessary, to a maximum of Big.DP decimal places using rounding mode Big.RM.
 */
P.sqrt = function () {
  var r, c, t,
    x = this,
    Big = x.constructor,
    s = x.s,
    e = x.e,
    half = new Big('0.5');

  // Zero?
  if (!x.c[0]) return new Big(x);

  // Negative?
  if (s < 0) {
    throw Error(NAME + 'No square root');
  }

  // Estimate.
  s = Math.sqrt(x + '');

  // Math.sqrt underflow/overflow?
  // Re-estimate: pass x coefficient to Math.sqrt as integer, then adjust the result exponent.
  if (s === 0 || s === 1 / 0) {
    c = x.c.join('');
    if (!(c.length + e & 1)) c += '0';
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big((s == 1 / 0 ? '5e' : (s = s.toExponential()).slice(0, s.indexOf('e') + 1)) + e);
  } else {
    r = new Big(s + '');
  }

  e = r.e + (Big.DP += 4);

  // Newton-Raphson iteration.
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join('') !== r.c.slice(0, e).join(''));

  return round(r, (Big.DP -= 4) + r.e + 1, Big.RM);
};


/*
 * Return a new Big whose value is the value of this Big times the value of Big y.
 */
P.times = P.mul = function (y) {
  var c,
    x = this,
    Big = x.constructor,
    xc = x.c,
    yc = (y = new Big(y)).c,
    a = xc.length,
    b = yc.length,
    i = x.e,
    j = y.e;

  // Determine sign of result.
  y.s = x.s == y.s ? 1 : -1;

  // Return signed 0 if either 0.
  if (!xc[0] || !yc[0]) {
    y.c = [y.e = 0];
    return y;
  }

  // Initialise exponent of result as x.e + y.e.
  y.e = i + j;

  // If array xc has fewer digits than yc, swap xc and yc, and lengths.
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }

  // Initialise coefficient array of result with zeros.
  for (c = new Array(j = a + b); j--;) c[j] = 0;

  // Multiply.

  // i is initially xc.length.
  for (i = b; i--;) {
    b = 0;

    // a is yc.length.
    for (j = a + i; j > i;) {

      // Current sum of products at this digit position, plus carry.
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;

      // carry
      b = b / 10 | 0;
    }

    c[j] = b;
  }

  // Increment result exponent if there is a final carry, otherwise remove leading zero.
  if (b) ++y.e;
  else c.shift();

  // Remove trailing zeros.
  for (i = c.length; !c[--i];) c.pop();
  y.c = c;

  return y;
};


/*
 * Return a string representing the value of this Big in exponential notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toExponential = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), ++dp, rm);
    for (; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, true, !!n);
};


/*
 * Return a string representing the value of this Big in normal notation rounded to dp fixed
 * decimal places using rounding mode rm, or Big.RM if rm is not specified.
 *
 * dp? {number} Decimal places: integer, 0 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 *
 * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.
 * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.
 */
P.toFixed = function (dp, rm) {
  var x = this,
    n = x.c[0];

  if (dp !== UNDEFINED) {
    if (dp !== ~~dp || dp < 0 || dp > MAX_DP) {
      throw Error(INVALID_DP);
    }
    x = round(new x.constructor(x), dp + x.e + 1, rm);

    // x.e may have changed if the value is rounded up.
    for (dp = dp + x.e + 1; x.c.length < dp;) x.c.push(0);
  }

  return stringify(x, false, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Omit the sign for negative zero.
 */
P.toJSON = P.toString = function () {
  var x = this,
    Big = x.constructor;
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, !!x.c[0]);
};


/*
 * Return the value of this Big as a primitve number.
 */
P.toNumber = function () {
  var n = Number(stringify(this, true, true));
  if (this.constructor.strict === true && !this.eq(n.toString())) {
    throw Error(NAME + 'Imprecise conversion');
  }
  return n;
};


/*
 * Return a string representing the value of this Big rounded to sd significant digits using
 * rounding mode rm, or Big.RM if rm is not specified.
 * Use exponential notation if sd is less than the number of digits necessary to represent
 * the integer part of the value in normal notation.
 *
 * sd {number} Significant digits: integer, 1 to MAX_DP inclusive.
 * rm? {number} Rounding mode: 0 (down), 1 (half-up), 2 (half-even) or 3 (up).
 */
P.toPrecision = function (sd, rm) {
  var x = this,
    Big = x.constructor,
    n = x.c[0];

  if (sd !== UNDEFINED) {
    if (sd !== ~~sd || sd < 1 || sd > MAX_DP) {
      throw Error(INVALID + 'precision');
    }
    x = round(new Big(x), sd, rm);
    for (; x.c.length < sd;) x.c.push(0);
  }

  return stringify(x, sd <= x.e || x.e <= Big.NE || x.e >= Big.PE, !!n);
};


/*
 * Return a string representing the value of this Big.
 * Return exponential notation if this Big has a positive exponent equal to or greater than
 * Big.PE, or a negative exponent equal to or less than Big.NE.
 * Include the sign for negative zero.
 */
P.valueOf = function () {
  var x = this,
    Big = x.constructor;
  if (Big.strict === true) {
    throw Error(NAME + 'valueOf disallowed');
  }
  return stringify(x, x.e <= Big.NE || x.e >= Big.PE, true);
};


// Export


var Big = _Big_();

/// <reference types="https://raw.githubusercontent.com/DefinitelyTyped/DefinitelyTyped/master/types/big.js/index.d.ts" />
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Big);


/***/ })

};
;
//# sourceMappingURL=7657.bundled.js.map