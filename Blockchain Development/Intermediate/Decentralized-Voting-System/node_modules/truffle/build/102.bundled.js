#!/usr/bin/env node

"use strict";
exports.id = 102;
exports.ids = [102];
exports.modules = {

/***/ 90670:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Abi = exports.ConstructorEntry = exports.FallbackEntry = exports.ReceiveEntry = exports.FunctionEntry = exports.ErrorEntry = exports.EventEntry = exports.EventParameter = exports.Parameter = void 0;
const fc = __importStar(__webpack_require__(96418));
const change_case_1 = __webpack_require__(77159);
const wordLists_1 = __importDefault(__webpack_require__(94147));
const Parameter = () => fc
    .tuple(fc.record({
    name: ParameterName()
}), TypeRecord())
    .map(([{ name }, type]) => (Object.assign({ name }, type)));
exports.Parameter = Parameter;
const EventParameter = () => fc
    .tuple(fc.record({
    name: ParameterName(),
    indexed: fc.boolean()
}), TypeRecord())
    .map(([{ name, indexed }, type]) => (Object.assign({ name, indexed }, type)));
exports.EventParameter = EventParameter;
const EventEntry = () => fc.record({
    type: fc.constant("event"),
    name: EventName(),
    inputs: fc.array((0, exports.EventParameter)(), { maxLength: 10 }).filter(inputs => {
        if (inputs.filter(({ indexed }) => indexed).length > 3) {
            // only up to 3 params can be indexed
            return false;
        }
        // names that are not blank should be unique
        const names = inputs.map(({ name }) => name).filter(name => name !== "");
        return names.length === new Set(names).size;
    }),
    anonymous: fc.boolean()
});
exports.EventEntry = EventEntry;
const ErrorEntry = () => fc.record({
    type: fc.constant("error"),
    name: ErrorName(),
    inputs: fc.array((0, exports.Parameter)(), { maxLength: 10 }).filter(inputs => {
        // names that are not blank should be unique
        const names = inputs.map(({ name }) => name).filter(name => name !== "");
        return names.length === new Set(names).size;
    })
});
exports.ErrorEntry = ErrorEntry;
const FunctionEntry = () => fc
    .tuple(fc.record({
    type: fc.constant("function")
}, { withDeletedKeys: true }), fc.record({
    name: FunctionName(),
    inputs: fc.array((0, exports.Parameter)(), { maxLength: 10 })
}), fc.record({
    outputs: fc.array((0, exports.Parameter)(), { maxLength: 10 })
}, { withDeletedKeys: true }), fc
    .tuple(fc.oneof(fc.constant("pure"), fc.constant("view"), fc.constant("nonpayable"), fc.constant("payable")), fc.boolean(), fc.boolean())
    .map(([stateMutability, includeLegacy, includeModern]) => {
    const payable = stateMutability === "payable";
    const constant = stateMutability === "view" || stateMutability === "pure";
    const modern = { stateMutability };
    const legacy = { payable, constant };
    return includeLegacy && includeModern
        ? Object.assign(Object.assign({}, modern), legacy) : includeModern
        ? modern
        : legacy;
}))
    .map(records => records.reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {}))
    .filter(entry => {
    const { inputs, outputs = [] } = entry;
    // names that are not blank should be unique
    const names = [...inputs, ...outputs]
        .map(({ name }) => name)
        .filter(name => name !== "");
    return names.length === new Set(names).size;
});
exports.FunctionEntry = FunctionEntry;
const ReceiveEntry = () => fc.record({
    type: fc.constant("receive"),
    stateMutability: fc.constant("payable")
});
exports.ReceiveEntry = ReceiveEntry;
const FallbackEntry = () => fc
    .tuple(fc.record({
    type: fc.constant("fallback")
}), fc
    .tuple(fc.oneof(fc.constant("nonpayable"), fc.constant("payable")), fc.boolean(), fc.boolean())
    .map(([stateMutability, includeLegacy, includeModern]) => {
    const payable = stateMutability === "payable";
    const modern = { stateMutability };
    const legacy = { payable };
    return includeLegacy && includeModern
        ? Object.assign(Object.assign({}, modern), legacy) : includeModern
        ? modern
        : legacy;
}))
    .map(([{ type }, mutabilityFields]) => (Object.assign({ type }, mutabilityFields)));
exports.FallbackEntry = FallbackEntry;
const ConstructorEntry = () => fc
    .tuple(fc.record({
    type: fc.constant("constructor"),
    inputs: fc.array((0, exports.Parameter)(), { maxLength: 10 }).filter(inputs => {
        // names that are not blank should be unique
        const names = inputs
            .map(({ name }) => name)
            .filter(name => name !== "");
        return names.length === new Set(names).size;
    })
}), fc
    .tuple(fc.oneof(fc.constant("nonpayable"), fc.constant("payable")), fc.boolean(), fc.boolean())
    .map(([stateMutability, includeLegacy, includeModern]) => {
    const payable = stateMutability === "payable";
    const modern = { stateMutability };
    const legacy = { payable };
    return includeLegacy && includeModern
        ? Object.assign(Object.assign({}, modern), legacy) : includeModern
        ? modern
        : legacy;
}))
    .map(([{ type, inputs }, mutabilityFields]) => (Object.assign({ type,
    inputs }, mutabilityFields)));
exports.ConstructorEntry = ConstructorEntry;
const Abi = () => fc
    .tuple((0, exports.ConstructorEntry)(), (0, exports.FallbackEntry)(), (0, exports.ReceiveEntry)(), fc.array(fc.oneof((0, exports.FunctionEntry)(), (0, exports.EventEntry)(), (0, exports.ErrorEntry)())))
    .chain(([constructor, fallback, receive, entries]) => fc.shuffledSubarray([constructor, fallback, receive, ...entries]));
exports.Abi = Abi;
var Numerics;
(function (Numerics) {
    // 0 < n <= 32
    // use subtraction so that fast-check treats 32 as simpler than 1
    Numerics.Bytes = () => fc.nat(31).map(k => 32 - k);
    // 0 < n <= 256, 8 | n
    Numerics.Bits = () => Numerics.Bytes().map(k => 8 * k);
    // 0 < n <= 80
    // use fancy math so that fast-check treats 18 as the simplest case
    //
    //     0 ----------------- 79
    //     lines up as:
    //     18 ------ 80, 0 --- 17
    Numerics.DecimalPlaces = () => fc.nat(79).map(k => ((k + 17) % 80) + 1);
    Numerics.Precision = () => fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());
})(Numerics || (Numerics = {}));
var Primitives;
(function (Primitives) {
    Primitives.Uint = () => Numerics.Bits().map(m => `uint${m}`);
    Primitives.Int = () => Numerics.Bits().map(m => `int${m}`);
    Primitives.Address = () => fc.constant("address");
    Primitives.Bool = () => fc.constant("bool");
    Primitives.Fixed = () => Numerics.Precision().map(([m, n]) => `fixed${m}x${n}`);
    Primitives.Ufixed = () => Numerics.Precision().map(([m, n]) => `ufixed${m}x${n}`);
    Primitives.BytesM = () => Numerics.Bytes().map(m => `bytes${m}`);
    Primitives.Function = () => fc.constant("function");
    Primitives.Bytes = () => fc.constant("bytes");
    Primitives.String = () => fc.constant("string");
    Primitives.Tuple = () => fc.constant("tuple");
})(Primitives || (Primitives = {}));
const Primitive = () => fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), Primitives.Function(), Primitives.Bytes(), Primitives.String(), Primitives.Tuple());
const Type = fc.memo(n => n === 0
    ? Primitive()
    : // we cap this at 3 so that fast-check doesn't blow the stack
        fc.oneof(Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n)));
const ArrayFixed = fc.memo(n => fc
    .tuple(Type(n - 1), fc.integer({ min: 1, max: 256 }))
    .map(([type, length]) => `${type}[${length}]`));
const ArrayDynamic = fc.memo(n => Type(n - 1).map(type => `${type}[]`));
const reservedWords = new Set([
    "Error",
    "Panic",
    "_",
    "abi",
    "abstract",
    "addmod",
    "address",
    "after",
    "alias",
    "anonymous",
    "apply",
    "as",
    "assembly",
    "assert",
    "auto",
    "block",
    "blockhash",
    "bool",
    "break",
    "byte",
    "bytes",
    "calldata",
    "case",
    "catch",
    "constant",
    "constructor",
    "continue",
    "contract",
    "copyof",
    "days",
    "default",
    "define",
    "delete",
    "ecrecover",
    "else",
    "emit",
    "enum",
    "error",
    "ether",
    "event",
    "external",
    "fallback",
    "false",
    "final",
    "finney",
    "fixed",
    "for",
    "from",
    "function",
    "gasleft",
    "gwei",
    "hours",
    "if",
    "immutable",
    "implements",
    "import",
    "in",
    "indexed",
    "inline",
    "int",
    "interface",
    "internal",
    "is",
    "keccak256",
    "let",
    "library",
    "log0",
    "log1",
    "log2",
    "log3",
    "log4",
    "macro",
    "mapping",
    "match",
    "memory",
    "minutes",
    "modifier",
    "msg",
    "mulmod",
    "mutable",
    "new",
    "now",
    "null",
    "of",
    "override",
    "partial",
    "payable",
    "pragma",
    "private",
    "promise",
    "public",
    "pure",
    "receive",
    "reference",
    "relocatable",
    "require",
    "return",
    "returns",
    "revert",
    "ripemd160",
    "sealed",
    "seconds",
    "selfdestruct",
    "sha256",
    "sha3",
    "sizeof",
    "static",
    "storage",
    "string",
    "struct",
    "suicide",
    "super",
    "supports",
    "switch",
    "szabo",
    "this",
    "throw",
    "true",
    "try",
    "tx",
    "type",
    "typedef",
    "typeof",
    "ufixed",
    "uint",
    "unchecked",
    "using",
    "var",
    "view",
    "virtual",
    "weeks",
    "wei",
    "while",
    "years"
]);
const Name = (wordTypes = ["noun"], transform = change_case_1.camelCase) => {
    const wordArbitraries = wordTypes.map(wordType => fc.constantFrom(...wordLists_1.default[wordType]));
    const wordsArbitrary = fc.tuple(...wordArbitraries);
    const nameArbitrary = wordsArbitrary.map(words => transform(words.join(" ")));
    return nameArbitrary.filter(word => !reservedWords.has(word));
};
const ParameterName = () => fc.oneof({ arbitrary: Name(["noun"]), weight: 9 }, { arbitrary: fc.constant(""), weight: 1 });
const EventName = () => Name(["verb", "noun"], change_case_1.pascalCase);
const ErrorName = () => Name(["noun", "noun"], change_case_1.pascalCase);
const FunctionName = () => Name(["verb", "noun"]);
const TypeRecord = () => Type().chain(type => type.startsWith("tuple")
    ? fc.record({
        type: fc.constant(type),
        components: fc
            .array((0, exports.Parameter)().filter(({ name }) => name !== ""), { minLength: 1, maxLength: 5 })
            .filter(items => {
            const names = items
                .map(({ name }) => name)
                .filter(name => name !== "");
            return names.length === new Set(names).size;
        })
    })
    : fc.record({
        type: fc.constant(type)
    }));
//# sourceMappingURL=arbitrary.js.map

/***/ }),

/***/ 7651:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Arbitrary = void 0;
__exportStar(__webpack_require__(51931), exports);
__exportStar(__webpack_require__(57794), exports);
__exportStar(__webpack_require__(14230), exports);
__exportStar(__webpack_require__(4924), exports);
const Arbitrary = __importStar(__webpack_require__(90670));
exports.Arbitrary = Arbitrary;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57794:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeEntry = exports.normalize = void 0;
const normalize = (looseAbi) => looseAbi.map(exports.normalizeEntry);
exports.normalize = normalize;
const normalizeEntry = (looseEntry) => {
    if (looseEntry.type === "event" || looseEntry.type === "error") {
        // nothing gets normalized for events or errors right now
        return looseEntry;
    }
    const entry = Object.assign(Object.assign(Object.assign({}, looseEntry), normalizeStateMutability(looseEntry)), { type: looseEntry.type || "function" });
    if (entry.type === "function") {
        entry.outputs = entry.outputs || [];
    }
    delete entry.payable;
    delete entry.constant;
    return entry;
};
exports.normalizeEntry = normalizeEntry;
const normalizeStateMutability = ({ stateMutability, payable, constant }) => {
    if (stateMutability) {
        return { stateMutability };
    }
    return {
        stateMutability: payable ? "payable" : constant ? "view" : "nonpayable"
    };
};
//# sourceMappingURL=normalize.js.map

/***/ }),

/***/ 4924:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseParameterList = exports.parseSignature = exports.parseEventSignature = exports.parseErrorSignature = exports.parseFunctionSignature = void 0;
function parseFunctionSignature(signature) {
    const { name, inputs } = parseSignature(signature);
    return {
        type: "function",
        name,
        inputs,
        outputs: [],
        stateMutability: "nonpayable"
    };
}
exports.parseFunctionSignature = parseFunctionSignature;
function parseErrorSignature(signature) {
    const { name, inputs } = parseSignature(signature);
    return {
        type: "error",
        name,
        inputs
    };
}
exports.parseErrorSignature = parseErrorSignature;
function parseEventSignature(signature) {
    const { name, inputs } = parseSignature(signature);
    return {
        type: "event",
        name,
        inputs: inputs.map(parameter => (Object.assign(Object.assign({}, parameter), { indexed: false }))),
        anonymous: false
    };
}
exports.parseEventSignature = parseEventSignature;
function parseSignature(signature) {
    let openParenIndex = signature.indexOf("(");
    if (openParenIndex === -1) {
        openParenIndex = signature.length; //set to end of string if not found
    }
    const parameterList = signature.slice(openParenIndex);
    const name = signature.slice(0, openParenIndex);
    const inputs = parseParameterList(parameterList);
    return {
        name,
        inputs
    };
}
exports.parseSignature = parseSignature;
function parseParameterList(parameterList) {
    const { parameters, remaining } = parseParameterListWithRemainder(parameterList);
    if (remaining !== "") {
        throw new Error(`Parameter list had extra text ${remaining} afterwards`);
    }
    return parameters;
}
exports.parseParameterList = parseParameterList;
function parseParameterListWithRemainder(parameterList) {
    if (parameterList === "") {
        throw new Error("Parameter list is missing");
    }
    if (parameterList[0] !== "(") {
        throw new Error(`Parameter list ${parameterList} doesn't begin with parenthesis"`);
    }
    if (parameterList[1] === ")") {
        //due to the appraoch we take below, we need to handle the case of an empty
        //parameter list as a special case.  a more proper parser wouldn't need to do
        //this, but, this is easier. :P
        return { parameters: [], remaining: parameterList.slice(2) };
    }
    let remaining = parameterList.slice(1); //cut off opening parenthesis
    let parameters = [];
    //now: we process parameters one by one.  note we CANNOT split on comma!!
    //that approach will break down if there are any tuples.
    while (true) {
        if (remaining[0] === "(") {
            //tuple or tuple array case
            let components;
            ({ parameters: components, remaining } =
                parseParameterListWithRemainder(remaining));
            //now we have the components, but there might be an array suffix
            //copypaste warning, this is copypasted from the simple case below!
            const match = remaining.match(/[,)]/); //find next comma or close paren
            const nextTerminatorIndex = match === null || match === void 0 ? void 0 : match.index;
            if (nextTerminatorIndex === undefined) {
                //if there is none, throw
                throw new Error("Unmatched open parenthesis");
            }
            const final = remaining[nextTerminatorIndex] === ")";
            const arraySuffix = remaining.slice(0, nextTerminatorIndex);
            if (!arraySuffix.match(/(\[\d*\])*/)) {
                //here at least it's pretty straightforward to check whether the array
                //suffix is valid or not
                throw new Error(`Invalid array suffix ${arraySuffix}`);
            }
            parameters.push({
                name: "",
                type: "tuple" + arraySuffix,
                components
            });
            remaining = remaining.slice(nextTerminatorIndex + 1);
            if (final) {
                //if we hit a ")", close this group
                return { parameters, remaining };
            }
        }
        else {
            //simple case (including arrays w/o tuples)
            const match = remaining.match(/[,)]/); //find next comma or close paren
            const nextTerminatorIndex = match === null || match === void 0 ? void 0 : match.index;
            if (nextTerminatorIndex === undefined) {
                //if there is none, throw
                throw new Error("Unmatched open parenthesis");
            }
            const final = remaining[nextTerminatorIndex] === ")";
            const parameterString = remaining.slice(0, nextTerminatorIndex);
            if (!parameterString.match(/[a-zA-Z]([a-zA-Z\d])*(\[\d*\])*/)) {
                //we're not going to try to fully validate the type here...
                //we're just going to check that it looks vaguely correct, sorry
                throw new Error(`Malformed type ${parameterString}`);
            }
            parameters.push({
                name: "",
                type: parameterString
            });
            remaining = remaining.slice(nextTerminatorIndex + 1);
            if (final) {
                //if we hit a ")", close this group
                return { parameters, remaining };
            }
        }
    }
}
//# sourceMappingURL=parse.js.map

/***/ }),

/***/ 14230:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abiSelector = exports.abiTypeSignature = exports.abiTupleSignature = exports.abiSignature = exports.ShortSelectorSize = void 0;
const web3_utils_1 = __webpack_require__(18269);
exports.ShortSelectorSize = 4;
//NOTE: this function returns the written out SIGNATURE, not the SELECTOR
function abiSignature(abiEntry) {
    return abiEntry.name + abiTupleSignature(abiEntry.inputs);
}
exports.abiSignature = abiSignature;
function abiTupleSignature(parameters) {
    const components = parameters.map(abiTypeSignature);
    return "(" + components.join(",") + ")";
}
exports.abiTupleSignature = abiTupleSignature;
function abiTypeSignature(parameter) {
    const tupleMatch = parameter.type.match(/^tuple(.*)/);
    if (tupleMatch === null) {
        //does not start with "tuple"
        return parameter.type;
    }
    else {
        const tail = tupleMatch[1]; //everything after "tuple"
        const tupleSignature = abiTupleSignature(parameter.components); //it won't be undefined
        return tupleSignature + tail;
    }
}
exports.abiTypeSignature = abiTypeSignature;
function abiSelector(abiEntry) {
    const signature = abiSignature(abiEntry);
    //NOTE: web3's soliditySha3 has a problem if the empty
    //string is passed in.  Fortunately, that should never happen here.
    const hash = (0, web3_utils_1.soliditySha3)({ type: "string", value: signature });
    switch (abiEntry.type) {
        case "event":
            return hash;
        case "function":
        case "error":
            return hash.slice(0, 2 + 2 * exports.ShortSelectorSize); //arithmetic to account for hex string
    }
}
exports.abiSelector = abiSelector;
//# sourceMappingURL=signature.js.map

/***/ }),

/***/ 51931:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 94147:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports["default"] = {
    noun: [
        "driver",
        "protocol",
        "bandwidth",
        "panel",
        "microchip",
        "program",
        "port",
        "card",
        "array",
        "interface",
        "system",
        "sensor",
        "firewall",
        "pixel",
        "alarm",
        "feed",
        "monitor",
        "application",
        "transmitter",
        "bus",
        "circuit",
        "capacitor",
        "matrix"
    ],
    verb: [
        "bypass",
        "hack",
        "override",
        "compress",
        "copy",
        "navigate",
        "index",
        "connect",
        "generate",
        "quantify",
        "calculate",
        "synthesize",
        "input",
        "transmit",
        "program",
        "reboot",
        "parse",
        "handle",
        "circumvent",
        "cross",
        "fumble",
        "tweak",
        "swap"
    ]
};
//# sourceMappingURL=wordLists.js.map

/***/ }),

/***/ 51325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abi-data:allocate");
exports.Utils = __importStar(__webpack_require__(65700));
const Import = __importStar(__webpack_require__(53137));
const AbiDataUtils = __importStar(__webpack_require__(85941));
const web3_utils_1 = __importDefault(__webpack_require__(18269));
const Evm = __importStar(__webpack_require__(49218));
const Common = __importStar(__webpack_require__(99987));
const Conversion = __importStar(__webpack_require__(52714));
const Ast = __importStar(__webpack_require__(14442));
const import_1 = __webpack_require__(60013);
const Format = __importStar(__webpack_require__(29965));
const partition_1 = __importDefault(__webpack_require__(43174));
exports.FallbackOutputAllocation = {
    kind: "returnmessage",
    selector: new Uint8Array(),
    allocationMode: "full"
};
function getAbiAllocations(userDefinedTypes) {
    let allocations = {};
    for (const dataType of Object.values(userDefinedTypes)) {
        if (dataType.typeClass === "struct") {
            try {
                allocations = allocateStruct(dataType, userDefinedTypes, allocations);
            }
            catch (_) {
                //if allocation fails... oh well, allocation fails, we do nothing and just move on :P
                //note: a better way of handling this would probably be to *mark* it
                //as failed rather than throwing an exception as that would lead to less
                //recomputation, but this is simpler and I don't think the recomputation
                //should really be a problem
            }
        }
    }
    return allocations;
}
exports.getAbiAllocations = getAbiAllocations;
function allocateStruct(dataType, userDefinedTypes, existingAllocations) {
    //NOTE: dataType here should be a *stored* type!
    //it is up to the caller to take care of this
    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);
}
//note: we will still allocate circular structs, even though they're not allowed in the abi, because it's
//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)
function allocateMembers(parentId, members, userDefinedTypes, existingAllocations, start = 0) {
    let dynamic = false;
    //note that we will mutate the start argument also!
    //don't allocate things that have already been allocated
    if (parentId in existingAllocations) {
        return existingAllocations;
    }
    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone
    let memberAllocations = [];
    for (const member of members) {
        let length;
        let dynamicMember;
        ({
            size: length,
            dynamic: dynamicMember,
            allocations
        } = abiSizeAndAllocate(member.type, userDefinedTypes, allocations));
        //vomit on illegal types in calldata -- note the short-circuit!
        if (length === undefined) {
            allocations[parentId] = null;
            return allocations;
        }
        let pointer = {
            location: "abi",
            start,
            length
        };
        memberAllocations.push({
            name: member.name,
            type: member.type,
            pointer
        });
        start += length;
        dynamic = dynamic || dynamicMember;
    }
    allocations[parentId] = {
        members: memberAllocations,
        length: dynamic ? Evm.Utils.WORD_SIZE : start,
        dynamic
    };
    return allocations;
}
//first return value is the actual size.
//second return value is whether the type is dynamic
//both will be undefined if type is a mapping or internal function
//third return value is resulting allocations, INCLUDING the ones passed in
function abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {
    switch (dataType.typeClass) {
        case "bool":
        case "address":
        case "contract":
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
        case "enum":
        case "userDefinedValueType":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: false,
                allocations: existingAllocations
            };
        case "string":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: true,
                allocations: existingAllocations
            };
        case "bytes":
            return {
                size: Evm.Utils.WORD_SIZE,
                dynamic: dataType.kind === "dynamic",
                allocations: existingAllocations
            };
        case "mapping":
            return {
                allocations: existingAllocations
            };
        case "function":
            switch (dataType.visibility) {
                case "external":
                    return {
                        size: Evm.Utils.WORD_SIZE,
                        dynamic: false,
                        allocations: existingAllocations
                    };
                case "internal":
                    return {
                        allocations: existingAllocations
                    };
            }
        case "array": {
            switch (dataType.kind) {
                case "dynamic":
                    return {
                        size: Evm.Utils.WORD_SIZE,
                        dynamic: true,
                        allocations: existingAllocations
                    };
                case "static":
                    if (dataType.length.isZero()) {
                        //arrays of length 0 are static regardless of base type
                        return {
                            size: 0,
                            dynamic: false,
                            allocations: existingAllocations
                        };
                    }
                    const { size: baseSize, dynamic, allocations } = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);
                    return {
                        //WARNING!  The use of toNumber() here may throw an exception!
                        //I'm judging this OK since if you have arrays that large we have bigger problems :P
                        size: dataType.length.toNumber() * baseSize,
                        dynamic,
                        allocations
                    };
            }
        }
        case "struct": {
            let allocations = existingAllocations;
            let allocation = allocations[dataType.id];
            if (allocation === undefined) {
                //if we don't find an allocation, we'll have to do the allocation ourselves
                const storedType = (userDefinedTypes[dataType.id]);
                if (!storedType) {
                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
                }
                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);
                allocation = allocations[storedType.id];
            }
            //having found our allocation, if it's not null, we can just look up its size and dynamicity
            if (allocation !== null) {
                return {
                    size: allocation.length,
                    dynamic: allocation.dynamic,
                    allocations
                };
            }
            //if it is null, this type doesn't go in the abi
            else {
                return {
                    allocations
                };
            }
        }
        case "tuple": {
            //Warning! Yucky wasteful recomputation here!
            let size = 0;
            let dynamic = false;
            //note that we don't just invoke allocateStruct here!
            //why not? because it has no ID to store the result in!
            //and we can't use a fake like -1 because there might be a recursive call to it,
            //and then the results would overwrite each other
            //I mean, we could do some hashing thing or something, but I think it's easier to just
            //copy the logic in this one case (sorry)
            for (let member of dataType.memberTypes) {
                let { size: memberSize, dynamic: memberDynamic } = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations);
                size += memberSize;
                dynamic = dynamic || memberDynamic;
            }
            return { size, dynamic, allocations: existingAllocations };
        }
    }
}
//assumes you've already done allocation! don't use if you haven't!
/**
 * @protected
 */
function abiSizeInfo(dataType, allocations) {
    let { size, dynamic } = abiSizeAndAllocate(dataType, null, allocations);
    //the above line should work fine... as long as allocation is already done!
    //the middle argument, userDefinedTypes, is only needed during allocation
    //again, this function is only for use if allocation is done, so it's safe to pass null here
    return { size, dynamic };
}
exports.abiSizeInfo = abiSizeInfo;
//allocates an external call
//NOTE: returns just a single allocation; assumes primary allocation is already complete!
//NOTE: returns undefined if attempting to allocate a constructor but we don't have the
//bytecode for the constructor
function allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {
    //first: determine the corresponding function node
    //(simultaneously: determine the offset)
    let node = undefined;
    let inputParametersFull;
    let outputParametersFull;
    let inputParametersAbi;
    let outputParametersAbi;
    let offset; //refers to INPUT offset; output offset is always 0
    debug("allocating calldata and returndata");
    switch (abiEntry.type) {
        case "constructor":
            if (!constructorContext) {
                return undefined;
            }
            let rawLength = constructorContext.binary.length;
            offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring
            //for a constructor, we only want to search the particular contract
            if (contractNode) {
                node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi(
                //note this needn't actually be a function node, but then it will
                //return false (well, unless it's a getter node!)
                abiEntry, functionNode, referenceDeclarations));
            }
            //if we can't find it, we'll handle this below
            break;
        case "function":
            offset = Evm.Utils.SELECTOR_SIZE;
            //search through base contracts, from most derived (left) to most base (right)
            if (contractNode) {
                const linearizedBaseContracts = contractNode.linearizedBaseContracts;
                debug("linearized: %O", linearizedBaseContracts);
                node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!
                debug("found node: %o", Boolean(node));
            }
            break;
    }
    //now: get the parameters (both full-mode & ABI)
    if (node) {
        switch (node.nodeType) {
            case "FunctionDefinition":
                //normal case
                inputParametersFull = node.parameters.parameters;
                outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!
                break;
            case "VariableDeclaration":
                //getter case
                ({ inputs: inputParametersFull, outputs: outputParametersFull } =
                    Ast.Utils.getterParameters(node, referenceDeclarations));
                break;
        }
    }
    else {
        inputParametersFull = undefined;
        outputParametersFull = undefined;
    }
    inputParametersAbi = abiEntry.inputs;
    switch (abiEntry.type) {
        case "function":
            outputParametersAbi = abiEntry.outputs;
            break;
        case "constructor":
            //we just leave this empty for constructors
            outputParametersAbi = [];
            break;
    }
    //now: do the allocation!
    let { allocation: abiAllocationInput, mode: inputMode } = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset);
    let { allocation: abiAllocationOutput, mode: outputMode } = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler
    //note no offset
    );
    debug("modes: %s in, %s out", inputMode, outputMode);
    //finally: transform the allocation appropriately
    let inputArgumentsAllocation = abiAllocationInput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "calldata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    let outputArgumentsAllocation = abiAllocationOutput.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "returndata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    let inputsAllocation = {
        abi: abiEntry,
        offset,
        arguments: inputArgumentsAllocation,
        allocationMode: inputMode
    };
    let outputsAllocation;
    switch (abiEntry.type) {
        case "function":
            outputsAllocation = {
                selector: new Uint8Array(),
                arguments: outputArgumentsAllocation,
                allocationMode: outputMode,
                kind: "return"
            };
            break;
        case "constructor":
            outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);
            break;
    }
    return {
        input: inputsAllocation,
        output: outputsAllocation
    }; //TS chokes on this for some reason
}
//note: allocateEvent doesn't use this because it needs additional
//handling for indexed parameters (maybe these can be unified in
//the future though?)
function allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler, offset = 0) {
    let allocationMode = fullModeParameters ? "full" : "abi"; //can degrade
    let parameterTypes;
    let abiAllocation;
    if (allocationMode === "full") {
        let id = "-1"; //fake ID that doesn't matter
        parameterTypes = fullModeParameters.map(parameter => ({
            name: parameter.name,
            type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!
        }));
        debug("parameterTypes: %O", parameterTypes);
        //now: perform the allocation!
        try {
            abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];
        }
        catch (_a) {
            //if something goes wrong, switch to ABI mdoe
            debug("falling back to ABI due to exception!");
            allocationMode = "abi";
        }
    }
    if (allocationMode === "abi") {
        //THIS IS DELIBERATELY NOT AN ELSE
        //this is the ABI case.  we end up here EITHER
        //if node doesn't exist, OR if something went wrong
        //during allocation
        let id = "-1"; //fake irrelevant ID
        parameterTypes = abiParameters.map(parameter => ({
            name: parameter.name,
            type: Import.abiParameterToType(parameter)
        }));
        abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];
    }
    return { allocation: abiAllocation, mode: allocationMode };
}
//allocates an event
//NOTE: returns just a single allocation; assumes primary allocation is already complete!
function allocateEvent(abiEntry, eventNode, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let parameterTypes;
    let nodeId;
    let id;
    //first: determine the corresponding event node
    //if we're doing inheritance processing, we search through base contracts,
    //from most derived (right) to most base (left)
    //if we're not doing inheritance processing (i.e. if eventNode was passed),
    //we search through *all* contracts, plus the top level!  even though we
    //know the event node already, we still need to know where it's defined
    let node = undefined;
    let definedInNode = undefined;
    let definedIn = undefined;
    let allocationMode = "full"; //degrade to abi as needed
    debug("allocating ABI: %O", abiEntry);
    if (contractNode) {
        if (eventNode) {
            node = eventNode; //we already know this one!
            //note: we don't use findNodeAndContract here because it's meant for searching
            //through a list of base contracts, that's not really what's going on here
            //(we don't need all its code here anyway)
            definedInNode = Object.values(referenceDeclarations).find(possibleContractNode => possibleContractNode.nodeType === "ContractDefinition" &&
                possibleContractNode.nodes.some((possibleEventNode) => possibleEventNode.id === node.id));
            if (definedInNode &&
                definedInNode.contractKind === "library" &&
                definedInNode.id !== contractNode.id) {
                //skip library events!  (unless this is the library they're from)
                //those are always considered in-play no matter what,
                //so we don't want to handle them here or we'd end up with them appearing twice
                return undefined;
            }
            //if we failed to find what it's in... presumably it was defined at the file level.
            //leave definedInNode undefined; it'll be handled below.
        }
        else {
            //first: check same contract for the event
            node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi(
            //note this needn't actually be an event node, but then it will
            //return false
            abiEntry, eventNode, referenceDeclarations));
            //if we found the node, great!  If not...
            if (node) {
                definedInNode = contractNode;
            }
            else {
                debug("didn't find node in base contract...");
                //let's search for the node among the base contracts.
                //but if we find it...
                //[note: the following code is overcomplicated; it was used
                //when we were trying to get the actual node, it's overcomplicated
                //now that we're just determining its presence.  oh well]
                let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();
                linearizedBaseContractsMinusSelf.shift(); //remove self
                debug("checking contracts: %o", linearizedBaseContractsMinusSelf);
                node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi(
                //note this needn't actually be a event node, but then it will return false
                abiEntry, eventNode, referenceDeclarations)
                //don't pass deriveContractNode here, we're not checking the contract itself
                ).node; //may be undefined! that's OK!
                if (node) {
                    //...if we find the node in an ancestor, we
                    //deliberately *don't* allocate!  instead such cases
                    //will be handled during a later combination step
                    debug("bailing out for later handling!");
                    debug("ABI: %O", abiEntry);
                    return undefined;
                }
            }
        }
    }
    //otherwise, leave node undefined
    if (node) {
        debug("found node");
        //if we found the node, let's also turn it into a type
        if (definedInNode) {
            definedIn = (Ast.Import.definitionToStoredType(definedInNode, compilationId, compiler)); //can skip reference declarations argument here
        }
        else {
            definedIn = null; //for file-level events, once they exist
        }
        //...and set the ID
        id = (0, import_1.makeTypeId)(node.id, compilationId);
    }
    else {
        //if no node, have to fall back into ABI mode
        debug("falling back to ABI because no node");
        allocationMode = "abi";
    }
    //now: construct the list of parameter types, attaching indexedness info
    //and overall position (for later reconstruction)
    let indexed;
    let nonIndexed;
    let abiAllocation; //the untransformed allocation for the non-indexed parameters
    if (allocationMode === "full") {
        nodeId = node.id.toString();
        let parameters = node.parameters.parameters;
        parameterTypes = parameters.map(definition => ({
            //note: if node is defined, compiler had better be defined, too!
            type: Ast.Import.definitionToType(definition, compilationId, compiler),
            name: definition.name,
            indexed: definition.indexed
        }));
        //now: split the list of parameters into indexed and non-indexed
        [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, (parameter) => parameter.indexed);
        try {
            //now: perform the allocation for the non-indexed parameters!
            abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair
        }
        catch (_a) {
            allocationMode = "abi";
        }
    }
    if (allocationMode === "abi") {
        //THIS IS DELIBERATELY NOT AN ELSE
        nodeId = "-1"; //fake irrelevant ID
        parameterTypes = abiEntry.inputs.map(abiParameter => ({
            type: Import.abiParameterToType(abiParameter),
            name: abiParameter.name,
            indexed: abiParameter.indexed
        }));
        //now: split the list of parameters into indexed and non-indexed
        [indexed, nonIndexed] = (0, partition_1.default)(parameterTypes, (parameter) => parameter.indexed);
        //now: perform the allocation for the non-indexed parameters!
        abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair
    }
    //now: transform the result appropriately
    const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "eventdata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    //now: allocate the indexed parameters
    const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0
    const indexedArgumentsAllocation = indexed.map(({ type, name }, position) => ({
        type,
        name,
        pointer: {
            location: "eventtopic",
            topic: startingTopic + position
        }
    }));
    //finally: weave these back together
    let argumentsAllocation = [];
    for (let parameter of parameterTypes) {
        let arrayToGrabFrom = parameter.indexed
            ? indexedArgumentsAllocation
            : nonIndexedArgumentsAllocation;
        argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!
    }
    //...and return
    return {
        abi: abiEntry,
        contextHash: undefined,
        definedIn,
        id,
        arguments: argumentsAllocation,
        allocationMode,
        anonymous: abiEntry.anonymous
    };
}
function allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    //first: if we got passed just a node & no abi entry,
    let id = undefined;
    let definedIn = undefined;
    let parametersFull = undefined;
    const parametersAbi = abiEntry.inputs;
    if (errorNode) {
        //first, set parametersFull
        parametersFull = errorNode.parameters.parameters;
        //now, set id
        id = (0, import_1.makeTypeId)(errorNode.id, compilationId);
        //now, set definedIn
        let contractNode = null;
        for (const node of Object.values(referenceDeclarations)) {
            if (node.nodeType === "ContractDefinition") {
                if (node.nodes.some((subNode) => subNode.id === errorNode.id)) {
                    contractNode = node;
                    break;
                }
            }
            //if we didn't find it, then contractNode is null
            //(and thus so will be definedIn)
        }
        if (contractNode === null) {
            definedIn = null;
        }
        else {
            definedIn = (Ast.Import.definitionToStoredType(contractNode, compilationId, compiler));
        }
    }
    //otherwise, leave parametersFull, id, and definedIn undefined
    const { allocation: abiAllocation, mode: allocationMode } = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector
    );
    //finally: transform the allocation appropriately
    const argumentsAllocation = abiAllocation.members.map(member => (Object.assign(Object.assign({}, member), { pointer: {
            location: "returndata",
            start: member.pointer.start,
            length: member.pointer.length
        } })));
    const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));
    return {
        kind: "revert",
        selector,
        abi: abiEntry,
        id,
        definedIn,
        arguments: argumentsAllocation,
        allocationMode
    };
}
function getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let allocations = {
        constructorAllocation: undefined,
        //(if it doesn't then it will remain as default)
        functionAllocations: {}
    };
    if (!abi) {
        //if no ABI, can't do much!
        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);
        return allocations;
    }
    for (let abiEntry of abi) {
        if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) ||
            AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {
            //the first of these conditions is a hack workaround for a Solidity bug.
            //the second of these is because... seriously? we're not handling these
            //(at least not for now!) (these only exist prior to Solidity 0.5.6,
            //thankfully)
            continue;
        }
        switch (abiEntry.type) {
            case "constructor":
                allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);
                debug("constructor alloc: %O", allocations.constructorAllocation);
                break;
            case "function":
                allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);
                break;
            default:
                //skip over fallback, error, and event
                break;
        }
    }
    if (!allocations.constructorAllocation) {
        //set a default constructor allocation if we haven't allocated one yet
        allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);
        debug("default constructor alloc: %O", allocations.constructorAllocation);
    }
    return allocations;
}
function defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {
    if (!constructorContext) {
        return undefined;
    }
    const rawLength = constructorContext.binary.length;
    const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring
    const input = {
        offset,
        abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,
        arguments: [],
        allocationMode: "full"
    };
    const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, "full"); //assume full, degrade as necessary
    return { input, output };
}
//note: context should be deployed context!
function constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {
    if (!context) {
        //just return a default abi mode result
        return {
            selector: new Uint8Array(),
            allocationMode: "abi",
            kind: "bytecode",
            delegatecallGuard: false
        };
    }
    const { immutableReferences, compilationId, compiler, contractKind, binary } = context;
    let immutables;
    if (allocationMode === "full" && immutableReferences) {
        if (contractNode) {
            debug("allocating immutables");
            immutables = [];
            for (const [id, references] of Object.entries(immutableReferences)) {
                if (references.length === 0) {
                    continue; //don't allocate immutables that don't exist
                }
                const astId = parseInt(id);
                //get the corresponding variable node; potentially fail
                const { node: definition, contract: definedIn } = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode);
                if (!definition || definition.nodeType !== "VariableDeclaration") {
                    debug("didn't find definition for %d!", astId);
                    allocationMode = "abi";
                    immutables = undefined;
                    break;
                }
                const definedInClass = (Ast.Import.definitionToStoredType(definedIn, compilationId, compiler)); //can skip reference declarations argument here
                const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);
                immutables.push({
                    name: definition.name,
                    definedIn: definedInClass,
                    type: dataType,
                    pointer: {
                        location: "returndata",
                        start: references[0].start,
                        length: references[0].length
                    }
                });
            }
        }
        else if (Object.entries(immutableReferences).length > 0) {
            //if there are immutables, but no contract mode, go to abi mode
            debug("immutables but no node!");
            allocationMode = "abi";
        }
    }
    else {
        debug("no immutables");
    }
    //now, is there a delegatecall guard?
    let delegatecallGuard = false;
    if (contractKind === "library") {
        //note: I am relying on this being present!
        //(also this part is a bit HACKy)
        const pushAddressInstruction = (0x5f + Evm.Utils.ADDRESS_SIZE).toString(16); //"73"
        const delegateCallGuardString = "0x" + pushAddressInstruction + "..".repeat(Evm.Utils.ADDRESS_SIZE);
        if (binary.startsWith(delegateCallGuardString)) {
            delegatecallGuard = true;
        }
    }
    return {
        selector: new Uint8Array(),
        allocationMode,
        kind: "bytecode",
        immutables,
        delegatecallGuard
    };
}
function getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {
    let allocations = {
        constructorAllocations: {},
        functionAllocations: {}
    };
    for (let contract of contracts) {
        const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);
        if (contract.constructorContext) {
            allocations.constructorAllocations[contract.constructorContext.context] =
                contractAllocations.constructorAllocation;
        }
        if (contract.deployedContext) {
            allocations.functionAllocations[contract.deployedContext.context] =
                contractAllocations.functionAllocations;
            //set this up under both constructor *and* deployed! this is to handle
            //constructor returndata decoding
            allocations.constructorAllocations[contract.deployedContext.context] =
                contractAllocations.constructorAllocation;
        }
    }
    return allocations;
}
exports.getCalldataAllocations = getCalldataAllocations;
function getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let useAst = Boolean(contractNode && contractNode.usedErrors);
    if (useAst) {
        const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);
        let abis;
        try {
            abis = errorNodes.map(errorNode => (Ast.Utils.definitionToAbi(errorNode, referenceDeclarations)));
        }
        catch (_a) {
            useAst = false;
        }
        if (useAst) {
            //i.e. if the above operation succeeded
            return contractNode.usedErrors
                .map(errorNodeId => referenceDeclarations[errorNodeId])
                .map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));
        }
    }
    if (!useAst && abi) {
        //deliberately *not* an else!
        return abi
            .filter((abiEntry) => abiEntry.type === "error")
            .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround
            .map((abiEntry) => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));
    }
    //otherwise just return nothing
    return [];
}
function getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {
    let allContexts = []
        .concat(...contracts.map(({ deployedContext, constructorContext }) => [
        deployedContext,
        constructorContext
    ]))
        .filter(x => x) //filter out nonexistent contexts
        .map(context => context.context);
    allContexts.push(""); //HACK: add fictional empty-string context to represent no-context
    //holds allocations for a given context
    let selfAllocations = {};
    //holds allocations for *other* contexts
    let additionalAllocations = {};
    //now: process the allocations for each contract. we'll add each contract's
    //allocations to *its* entries in allocations, and to every *other* entry
    //in additionalAllocations.
    for (const contract of contracts) {
        const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);
        const contexts = [
            //contexts for this contract
            contract.deployedContext,
            contract.constructorContext
        ]
            .filter(x => x) //filter out nonexistent contexts
            .map(context => context.context);
        const otherContexts = allContexts.filter(
        //contexts for all other contracts
        contextHash => !contexts.includes(contextHash));
        //add them to selfAllocations
        for (const contextHash of contexts) {
            selfAllocations[contextHash] = contractAllocations;
        }
        //add them to additionalAllocations
        for (const contextHash of otherContexts) {
            if (additionalAllocations[contextHash] === undefined) {
                additionalAllocations[contextHash] = [];
            }
            additionalAllocations[contextHash] =
                additionalAllocations[contextHash].concat(contractAllocations);
        }
    }
    let allocations = Object.assign({}, ...allContexts.map(contextHash => ({ [contextHash]: {} })));
    //now: perform coalescense!
    for (const contract of contracts) {
        //we're setting up contexts again, sorry >_>
        const contexts = [
            //contexts for this contract
            contract.deployedContext,
            contract.constructorContext
        ]
            .filter(x => x) //filter out nonexistent contexts
            .map(context => context.context);
        for (const contextHash of contexts) {
            allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);
            debug("allocations: %O", allocations[contextHash]);
        }
    }
    //...also coalesce the fake "" context
    allocations[""] = coalesceReturndataAllocations([], additionalAllocations[""] || []);
    debug("error allocations: %O", allocations);
    return allocations;
}
exports.getReturndataAllocations = getReturndataAllocations;
function coalesceReturndataAllocations(selfAllocations, additionalAllocations) {
    let bySelector = {};
    //start with the additional allocations; we want to process
    //the self allocations last, due to special handling of no-ID allocations there
    for (const allocation of additionalAllocations) {
        const signature = AbiDataUtils.abiSignature(allocation.abi);
        const selector = web3_utils_1.default.soliditySha3({
            type: "string",
            value: signature
        }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string
        if (bySelector[selector]) {
            //note: at this point, for any given signature, there should only be a
            //no-ID allocation for that signature if it's the only one
            if (allocation.id !== undefined) {
                //delete anything with that signature but w/o an ID, or with this same ID
                bySelector[selector] = bySelector[selector].filter(({ abi, id }) => !(AbiDataUtils.abiSignature(abi) === signature &&
                    (id === undefined || id === allocation.id)));
                //add this allocation
                bySelector[selector].push(allocation);
            }
            else if (!bySelector[selector].some(({ abi }) => AbiDataUtils.abiSignature(abi) === signature)) {
                //only add ID-less ones if there isn't anything of that signature already
                bySelector[selector].push(allocation);
            }
        }
        else {
            //if there's nothing there thus far, add it
            bySelector[selector] = [allocation];
        }
    }
    //now we're going to perform a modified version of this procedure for the self allocations:
    //1. we're going to add to the front, not the back
    //2. we can add an ID-less one even if there are already ones with IDs there
    //(sorry for the copypaste)
    for (const allocation of selfAllocations) {
        const signature = AbiDataUtils.abiSignature(allocation.abi);
        const selector = web3_utils_1.default.soliditySha3({
            type: "string",
            value: signature
        }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string
        if (bySelector[selector]) {
            //delete anything with that signature but w/o an ID, or with this same ID
            //(if this alloc has no ID, this will only delete ID-less ones :) )
            bySelector[selector] = bySelector[selector].filter(({ abi, id }) => !(AbiDataUtils.abiSignature(abi) === signature &&
                (id === undefined || id === allocation.id)));
            //add this allocation to front, not back!
            bySelector[selector].unshift(allocation);
        }
        else {
            //if there's nothing there thus far, add it
            bySelector[selector] = [allocation];
        }
    }
    return bySelector;
}
function getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {
    let useAst = Boolean(contractNode && contractNode.usedEvents);
    if (useAst) {
        const eventNodes = contractNode.usedEvents.map(eventNodeId => referenceDeclarations[eventNodeId]);
        let abis;
        try {
            abis = eventNodes.map(eventNode => (Ast.Utils.definitionToAbi(eventNode, referenceDeclarations)));
        }
        catch (_a) {
            useAst = false;
        }
        if (useAst) {
            //i.e. if the above operation succeeded
            return contractNode.usedEvents
                .map(eventNodeId => referenceDeclarations[eventNodeId])
                .map((eventNode, index) => ({
                selector: AbiDataUtils.abiSelector(abis[index]),
                anonymous: abis[index].anonymous,
                topics: AbiDataUtils.topicsCount(abis[index]),
                allocation: allocateEvent(abis[index], eventNode, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)
            }))
                .filter(allocationTemporary => allocationTemporary.allocation !== undefined);
            //filter out library events
        }
    }
    if (!useAst && abi) {
        return abi
            .filter((abiEntry) => abiEntry.type === "event")
            .filter((abiEntry) => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround
            .map((abiEntry) => ({
            selector: AbiDataUtils.abiSelector(abiEntry),
            anonymous: abiEntry.anonymous,
            topics: AbiDataUtils.topicsCount(abiEntry),
            allocation: allocateEvent(abiEntry, undefined, //we don't know the event node
            contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)
            //note we do *not* filter out undefined allocations; we need these as placeholders
        }));
    }
    //otherwise just return nothing
    return [];
}
//WARNING: this function is full of hacks... sorry
function getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations, allowConstructorEvents = false) {
    //first: do allocations for individual contracts
    let individualAllocations = {};
    let groupedAllocations = {};
    let contextSwapMap = {}; //maps deployed to constructor & vice versa
    let allocations = {};
    for (const { abi, deployedContext, constructorContext, contractNode, compilationId, compiler } of contracts) {
        if (!deployedContext && !constructorContext && !contractNode) {
            //we'll need *one* of these at least
            continue;
        }
        const contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);
        const key = makeContractKey(deployedContext || constructorContext, contractNode ? contractNode.id : undefined, compilationId);
        if (individualAllocations[key] === undefined) {
            individualAllocations[key] = {};
        }
        for (const allocationTemporary of contractAllocations) {
            //we'll use selector *even for anonymous* here, because it's just
            //for determining what overrides what at this point
            individualAllocations[key][allocationTemporary.selector] = {
                context: deployedContext || constructorContext,
                contractNode,
                allocationTemporary,
                compilationId
            };
        }
        //also: set up the swap map
        if (deployedContext && constructorContext) {
            contextSwapMap[deployedContext.context] = constructorContext.context;
            contextSwapMap[constructorContext.context] = deployedContext.context;
        }
    }
    //now: put things together for inheritance
    //note how we always put things in order from most derived to most base
    for (let contextOrId in individualAllocations) {
        groupedAllocations[contextOrId] = {};
        for (let selector in individualAllocations[contextOrId]) {
            let { context, contractNode, allocationTemporary, compilationId } = individualAllocations[contextOrId][selector];
            debug("allocationTemporary: %O", allocationTemporary);
            let allocationsTemporary = allocationTemporary.allocation
                ? [allocationTemporary]
                : []; //filter out undefined allocations
            //first, copy from individual allocations
            groupedAllocations[contextOrId][selector] = {
                context,
                contractNode,
                allocationsTemporary
            };
            //if no contract node, or if we're dealing with a contract node that
            //lists it's used events for us, that's all.  but otherwise...
            if (contractNode && contractNode.usedEvents === undefined) {
                //...we have to do inheritance processing
                debug("contract Id: %d", contractNode.id);
                debug("base contracts: %o", contractNode.linearizedBaseContracts);
                let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();
                linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors
                for (let baseId of linearizedBaseContractsMinusSelf) {
                    debug("checking baseId: %d", baseId);
                    let baseNode = referenceDeclarations[compilationId][baseId];
                    if (!baseNode || baseNode.nodeType !== "ContractDefinition") {
                        debug("failed to find node for baseId: %d", baseId);
                        break; //not a continue!
                        //if we can't find the base node, it's better to stop the loop,
                        //rather than continue to potentially erroneous things
                    }
                    //note: we're not actually going to *use* the baseNode here.
                    //we're just checking for whether we can *find* it
                    //why? because if we couldn't find it, that means that events defined in
                    //base contracts *weren't* skipped earlier, and so we shouldn't now add them in
                    let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId &&
                        contractAllocationInfo.contractNode &&
                        contractAllocationInfo.contractNode.id === baseId);
                    if (!baseContractInfo) {
                        //similar to above... this failure case can happen when there are
                        //two contracts with the same name and you attempt to use the
                        //artifacts; say you have contracts A, B, and B', where A inherits
                        //from B, and B and B' have the same name, and B' is the one that
                        //gets the artifact; B will end up in reference declarations and so
                        //get found above, but it won't appear in contracts, causing the
                        //problem here.  Unfortunately I don't know any great way to handle this,
                        //so, uh, we treat it as a failure same as above.
                        debug("failed to find contract info for baseId: %d", baseId);
                        break;
                    }
                    let baseContext = baseContractInfo.deployedContext ||
                        baseContractInfo.constructorContext;
                    let baseKey = makeContractKey(baseContext, baseId, compilationId);
                    if (individualAllocations[baseKey][selector] !== undefined) {
                        let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;
                        debug("(probably) pushing inherited alloc from baseId: %d", baseId);
                        if (baseAllocation.allocation) {
                            //don't push undefined!
                            groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);
                        }
                    }
                }
            }
        }
    }
    //finally: transform into final form & return,
    //filtering out things w/o a context
    for (let contractKey in groupedAllocations) {
        if (!hasContext(contractKey)) {
            continue;
            //(this filters out ones that had no context and therefore were
            //given by ID; we needed these at the previous stage but from
            //here on they're irrelevant)
        }
        let contextHash = contextHashForKey(contractKey);
        for (let selector in groupedAllocations[contextHash]) {
            let { allocationsTemporary, context } = groupedAllocations[contextHash][selector];
            for (let { anonymous, topics, allocation } of allocationsTemporary) {
                let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK
                if (contractKind !== "library") {
                    contractKind = "contract"; //round off interfaces to being contracts for our purposes :P
                }
                allocation = Object.assign(Object.assign({}, allocation), { contextHash }); //the allocation's context hash at this point depends on where it was defined, but
                //that's not what we want going in the final allocation table!
                if (allocations[topics] === undefined) {
                    allocations[topics] = {
                        bySelector: {},
                        anonymous: { contract: {}, library: {} }
                    };
                }
                if (!anonymous) {
                    if (allocations[topics].bySelector[selector] === undefined) {
                        allocations[topics].bySelector[selector] = {
                            contract: {},
                            library: {}
                        };
                    }
                    //push the allocation (non-anonymous case)
                    if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {
                        allocations[topics].bySelector[selector][contractKind][contextHash] = [];
                    }
                    allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);
                    //...and push it in the swapped context too if that exists
                    //HACK: don't do this for libraries! library events are already
                    //considered always in play, so including them *twice* would cause
                    //problems... fortunately library constructors don't emit events!
                    if (allowConstructorEvents &&
                        contextHash in contextSwapMap &&
                        contractKind !== "library") {
                        const swappedHash = contextSwapMap[contextHash];
                        if (allocations[topics].bySelector[selector][contractKind][swappedHash] === undefined) {
                            allocations[topics].bySelector[selector][contractKind][swappedHash] = [];
                        }
                        allocations[topics].bySelector[selector][contractKind][swappedHash].push(allocation);
                    }
                }
                else {
                    //push the allocation (anonymous case)
                    if (allocations[topics].anonymous[contractKind][contextHash] ===
                        undefined) {
                        allocations[topics].anonymous[contractKind][contextHash] = [];
                    }
                    allocations[topics].anonymous[contractKind][contextHash].push(allocation);
                    //...and push it in the swapped context too if that exists
                    //(and it's not a library, see above)
                    if (allowConstructorEvents &&
                        contextHash in contextSwapMap &&
                        contractKind !== "library") {
                        const swappedHash = contextSwapMap[contextHash];
                        if (allocations[topics].anonymous[contractKind][swappedHash] ===
                            undefined) {
                            allocations[topics].anonymous[contractKind][swappedHash] = [];
                        }
                        allocations[topics].anonymous[contractKind][swappedHash].push(allocation);
                    }
                }
            }
        }
    }
    return allocations;
}
exports.getEventAllocations = getEventAllocations;
//if derivedContractNode is passed, we check that before referenceDeclarations
function findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {
    const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {
        if (foundNodeAndContract !== undefined) {
            return foundNodeAndContract; //once we've found something, we don't need to keep looking
        }
        debug("searching contract %d", baseContractId);
        let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id
            ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision
            : referenceDeclarations[baseContractId];
        if (baseContractNode === undefined ||
            baseContractNode.nodeType !== "ContractDefinition") {
            debug("bad contract node!");
            return null; //return null rather than undefined so that this will propagate through
            //(i.e. by returning null here we give up the search)
            //(we don't want to continue due to possibility of grabbing the wrong override)
        }
        const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!
        if (node) {
            debug("found node: %o", node);
            return {
                node,
                contract: baseContractNode
            };
        }
        else {
            return undefined;
        }
    }, undefined //start with no node found
    );
    return searchResult || { node: undefined, contract: undefined };
}
function makeContractKey(context, id, compilationId) {
    return context ? context.context : id + ":" + compilationId; //HACK!
}
function hasContext(key) {
    return key.startsWith("0x"); //HACK!
}
function contextHashForKey(key) {
    return hasContext(key)
        ? key //HACK!
        : undefined;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 65700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.collectAllocationInfo = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abi-data:allocate:utils");
const Compilations = __importStar(__webpack_require__(44894));
const compile_common_1 = __webpack_require__(29833);
const Contexts = __importStar(__webpack_require__(97938));
const Abi = __importStar(__webpack_require__(7651));
function collectAllocationInfo(compilations) {
    let contexts = {};
    let deployedContexts = {};
    let contractsAndContexts = [];
    for (const compilation of compilations) {
        for (const contract of compilation.contracts) {
            const node = Compilations.Utils.getContractNode(contract, compilation);
            let deployedContext = undefined;
            let constructorContext = undefined;
            const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);
            const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);
            if (deployedBytecode && deployedBytecode !== "0x") {
                deployedContext = Contexts.Utils.makeContext(contract, node, compilation);
                contexts[deployedContext.context] = deployedContext;
                //note that we don't set up deployedContexts until after normalization!
            }
            if (bytecode && bytecode !== "0x") {
                constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);
                contexts[constructorContext.context] = constructorContext;
            }
            contractsAndContexts.push({
                contract,
                node,
                deployedContext,
                constructorContext,
                compilationId: compilation.id
            });
        }
    }
    debug("known contexts: %o", Object.keys(contexts));
    contexts = Contexts.Utils.normalizeContexts(contexts);
    deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? { [context.context]: context } : {}));
    for (const contractAndContexts of contractsAndContexts) {
        //change everything to normalized version
        if (contractAndContexts.deployedContext) {
            contractAndContexts.deployedContext =
                contexts[contractAndContexts.deployedContext.context]; //get normalized version
        }
        if (contractAndContexts.constructorContext) {
            contractAndContexts.constructorContext =
                contexts[contractAndContexts.constructorContext.context]; //get normalized version
        }
    }
    const allocationInfo = contractsAndContexts.map(({ contract: { abi, compiler, immutableReferences }, compilationId, node, deployedContext, constructorContext }) => ({
        abi: Abi.normalize(abi),
        compilationId,
        compiler,
        contractNode: node,
        deployedContext,
        constructorContext,
        immutableReferences
    }));
    return {
        contexts,
        deployedContexts,
        contractsAndContexts,
        allocationInfo
    };
}
exports.collectAllocationInfo = collectAllocationInfo;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 7343:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abi-data:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Conversion = __importStar(__webpack_require__(52714));
const Basic = __importStar(__webpack_require__(53928));
const Bytes = __importStar(__webpack_require__(67689));
const Format = __importStar(__webpack_require__(29965));
const Evm = __importStar(__webpack_require__(49218));
const allocate_1 = __webpack_require__(51325);
const errors_1 = __webpack_require__(72325);
function* decodeAbi(dataType, pointer, info, options = {}) {
    if (Format.Types.isReferenceType(dataType) ||
        dataType.typeClass === "tuple") {
        //I don't want tuples to be considered a reference type, but it makes sense
        //to group them for this purpose
        let dynamic;
        try {
            dynamic = (0, allocate_1.abiSizeInfo)(dataType, info.allocations.abi).dynamic;
        }
        catch (error) {
            return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);
        }
        if (dynamic) {
            return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);
        }
        else {
            return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);
        }
    }
    else {
        debug("pointer %o", pointer);
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);
    }
}
exports.decodeAbi = decodeAbi;
function* decodeAbiReferenceByAddress(dataType, pointer, info, options = {}) {
    let { strictAbiMode: strict, abiPointerBase: base, lengthOverride } = options;
    base = base || 0; //in case base was undefined
    const { allocations: { abi: allocations }, state } = info;
    debug("pointer %o", pointer);
    //this variable holds the location we should look to *next*
    //stack pointers point to calldata; other pointers point to same location
    const location = pointer.location === "stack" || pointer.location === "stackliteral"
        ? "calldata"
        : pointer.location;
    if (pointer.location !== "stack" && pointer.location !== "stackliteral") {
        //length overrides are only applicable when you're decoding a pointer
        //from the stack!  otherwise they must be ignored!
        lengthOverride = undefined;
    }
    let rawValue;
    try {
        rawValue = yield* (0, read_1.default)(pointer, state);
    }
    catch (error) {
        return (0, errors_1.handleDecodingError)(dataType, error, strict);
    }
    let rawValueAsBN = Conversion.toBN(rawValue);
    debug("rawValue: %O", rawValue);
    debug("rawValueAsBN: %O", rawValueAsBN);
    let rawValueAsNumber;
    try {
        rawValueAsNumber = rawValueAsBN.toNumber();
    }
    catch (_a) {
        let error = {
            kind: "OverlargePointersNotImplementedError",
            pointerAsBN: rawValueAsBN
        };
        if (strict) {
            throw new errors_1.StopDecodingError(error);
        }
        return {
            //again with the TS failures...
            type: dataType,
            kind: "error",
            error
        };
    }
    let startPosition = rawValueAsNumber + base;
    debug("startPosition %d", startPosition);
    let dynamic;
    let size;
    try {
        ({ dynamic, size } = (0, allocate_1.abiSizeInfo)(dataType, allocations));
    }
    catch (error) {
        return (0, errors_1.handleDecodingError)(dataType, error, strict);
    }
    if (!dynamic) {
        //this will only come up when called from stack.ts
        let staticPointer = {
            location,
            start: startPosition,
            length: size
        };
        return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);
    }
    let length;
    let lengthAsBN;
    let rawLength;
    switch (dataType.typeClass) {
        case "bytes":
        case "string":
            //initial word contains length (unless an override was given)
            if (lengthOverride !== undefined) {
                lengthAsBN = lengthOverride;
                //note in this case we do *not* increment start position;
                //if a length override is given, that means the given start
                //position skips over the length word!
            }
            else {
                try {
                    rawLength = yield* (0, read_1.default)({
                        location,
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state);
                }
                catch (error) {
                    return (0, errors_1.handleDecodingError)(dataType, error, strict);
                }
                lengthAsBN = Conversion.toBN(rawLength);
                startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length
                //so it'll be set up to read the data
            }
            if (strict && lengthAsBN.gtn(state[location].length)) {
                //you may notice that the comparison is a bit crude; that's OK, this is
                //just to prevent huge numbers from DOSing us, other errors will still
                //be caught regardless
                throw new errors_1.StopDecodingError({
                    kind: "OverlongArrayOrStringStrictModeError",
                    lengthAsBN,
                    dataLength: state[location].length
                });
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_b) {
                //note: if we're in this situation, we can assume we're not in strict mode,
                //as the strict case was handled above
                return {
                    //again with the TS failures...
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            let childPointer = {
                location,
                start: startPosition,
                length
            };
            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);
        case "array":
            if (dataType.kind === "static") {
                //static-length array
                lengthAsBN = dataType.length;
                //note we don't increment start position; static arrays don't
                //include a length word!
            }
            else if (lengthOverride !== undefined) {
                debug("override: %o", lengthOverride);
                //dynamic-length array, but with length override
                lengthAsBN = lengthOverride;
                //we don't increment start position; if a length override was
                //given, that means the pointer skipped the length word!
            }
            else {
                //dynamic-length array, read length from data
                //initial word contains array length
                try {
                    rawLength = yield* (0, read_1.default)({
                        location,
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state);
                }
                catch (error) {
                    return (0, errors_1.handleDecodingError)(dataType, error, strict);
                }
                lengthAsBN = Conversion.toBN(rawLength);
                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition
                //to next word, as first word was used for length
            }
            if (strict && lengthAsBN.gtn(state[location].length)) {
                //you may notice that the comparison is a bit crude; that's OK, this is
                //just to prevent huge numbers from DOSing us, other errors will still
                //be caught regardless
                throw new errors_1.StopDecodingError({
                    kind: "OverlongArraysAndStringsNotImplementedError",
                    lengthAsBN,
                    dataLength: state[location].length
                });
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_c) {
                //again, if we get here, we can assume we're not in strict mode
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            //note: I've written this fairly generically, but it is worth noting that
            //since this array is of dynamic type, we know that if it's static length
            //then size must be EVM.WORD_SIZE
            let baseSize;
            try {
                baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, allocations).size;
            }
            catch (error) {
                return (0, errors_1.handleDecodingError)(dataType, error, strict);
            }
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeAbi(dataType.baseType, {
                    location,
                    start: startPosition + index * baseSize,
                    length: baseSize
                }, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))); //pointer base is always start of list, never the length
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren,
                interpretations: {}
            };
        case "struct":
            return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);
        case "tuple":
            return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);
    }
}
exports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;
function* decodeAbiReferenceStatic(dataType, pointer, info, options = {}) {
    debug("static");
    debug("pointer %o", pointer);
    const location = pointer.location;
    switch (dataType.typeClass) {
        case "array":
            //we're in the static case, so we know the array must be statically sized
            const lengthAsBN = dataType.length;
            let length;
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_a) {
                //note: since this is the static case, we don't bother including the stronger
                //strict-mode guard against getting DOSed by large array sizes, since in this
                //case we're not reading the size from the input; if there's a huge static size
                //array, well, we'll just have to deal with it
                let error = {
                    kind: "OverlongArraysAndStringsNotImplementedError",
                    lengthAsBN
                };
                if (options.strictAbiMode) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            let baseSize;
            try {
                baseSize = (0, allocate_1.abiSizeInfo)(dataType.baseType, info.allocations.abi).size;
            }
            catch (error) {
                return (0, errors_1.handleDecodingError)(dataType, error, options.strictAbiMode);
            }
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeAbi(dataType.baseType, {
                    location,
                    start: pointer.start + index * baseSize,
                    length: baseSize
                }, info, options));
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren,
                interpretations: {}
            };
        case "struct":
            return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);
        case "tuple":
            return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);
    }
}
exports.decodeAbiReferenceStatic = decodeAbiReferenceStatic;
//note that this function takes the start position as a *number*; it does not take a pointer
function* decodeAbiStructByPosition(dataType, location, startPosition, info, options = {}) {
    const { allocations: { abi: allocations } } = info;
    const typeLocation = location === "calldata" ? "calldata" : null; //other abi locations are not valid type locations
    const typeId = dataType.id;
    const structAllocation = allocations[typeId];
    if (!structAllocation) {
        let error = {
            kind: "UserDefinedTypeNotFoundError",
            type: dataType
        };
        if (options.strictAbiMode || options.allowRetry) {
            throw new errors_1.StopDecodingError(error, true);
            //note that we allow a retry if we couldn't locate the allocation!
        }
        return {
            type: dataType,
            kind: "error",
            error
        };
    }
    let decodedMembers = [];
    for (let index = 0; index < structAllocation.members.length; index++) {
        const memberAllocation = structAllocation.members[index];
        const memberPointer = memberAllocation.pointer;
        const childPointer = {
            location,
            start: startPosition + memberPointer.start,
            length: memberPointer.length
        };
        let memberName = memberAllocation.name;
        let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);
        decodedMembers.push({
            name: memberName,
            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))
            //note that the base option is only needed in the dynamic case, but we're being indiscriminate
        });
    }
    return {
        type: dataType,
        kind: "value",
        value: decodedMembers,
        interpretations: {}
    };
}
//note that this function takes the start position as a *number*; it does not take a pointer
function* decodeAbiTupleByPosition(dataType, location, startPosition, info, options = {}) {
    //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!
    //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder
    //However it may be worth revisiting this in the future if performance turns out to be a problem
    //(changing this may be pretty hard though)
    let decodedMembers = [];
    let position = startPosition;
    for (const { name, type: memberType } of dataType.memberTypes) {
        const memberSize = (0, allocate_1.abiSizeInfo)(memberType, info.allocations.abi).size;
        const childPointer = {
            location,
            start: position,
            length: memberSize
        };
        decodedMembers.push({
            name,
            value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), { abiPointerBase: startPosition }))
            //note that the base option is only needed in the dynamic case, but we're being indiscriminate
        });
        position += memberSize;
    }
    return {
        type: dataType,
        kind: "value",
        value: decodedMembers,
        interpretations: {}
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 54840:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeTupleAbiWithSelector = exports.encodeTupleAbi = exports.encodeAbi = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abi-data:encode");
const Conversion = __importStar(__webpack_require__(52714));
const Basic = __importStar(__webpack_require__(53928));
const Bytes = __importStar(__webpack_require__(67689));
const Evm = __importStar(__webpack_require__(49218));
const allocate_1 = __webpack_require__(51325);
const sum_1 = __importDefault(__webpack_require__(12297));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * @Category Encoding (low-level)
 */
function encodeAbi(input, allocations) {
    //errors can't be encoded
    if (input.kind === "error") {
        return undefined;
    }
    let bytes;
    //TypeScript can at least infer in the rest of this that we're looking
    //at a value, not an error!  But that's hardly enough...
    switch (input.type.typeClass) {
        case "mapping":
        case "magic":
        case "type":
            //none of these can go in the ABI
            return undefined;
        case "bytes":
            switch (input.type.kind) {
                case "static":
                    return Basic.Encode.encodeBasic(input);
                case "dynamic":
                    bytes = Bytes.Encode.encodeBytes(input);
                    return padAndPrependLength(bytes);
            }
        case "string":
            bytes = Bytes.Encode.encodeBytes(input);
            return padAndPrependLength(bytes);
        case "function": {
            switch (input.type.visibility) {
                case "internal":
                    return undefined; //internal functions can't go in the ABI!
                //Yes, technically we could defer to encodeBasic here, but,
                //c'mon, that's not how the function's supposed to be used
                case "external":
                    return Basic.Encode.encodeBasic(input);
            }
        }
        //now for the serious cases
        case "array": {
            let coercedInput = (input);
            if (coercedInput.reference !== undefined) {
                return undefined; //circular values can't be encoded
            }
            let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);
            switch (input.type.kind) {
                case "static":
                    return staticEncoding;
                case "dynamic":
                    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length
                    encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand
                    let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);
                    encoded.set(lengthBytes); //and now we set the length
                    return encoded;
            }
        }
        case "struct": {
            let coercedInput = (input);
            if (coercedInput.reference !== undefined) {
                return undefined; //circular values can't be encoded
            }
            return encodeTupleAbi(coercedInput.value.map(({ value }) => value), allocations);
        }
        case "tuple":
            //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!
            //(That may not be apparent from this one line, but it's true)
            //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder
            //However it may be worth revisiting this in the future if performance turns out to be a problem
            return encodeTupleAbi(input.value.map(({ value }) => value), allocations);
        default:
            return Basic.Encode.encodeBasic(input);
    }
}
exports.encodeAbi = encodeAbi;
/**
 * @Category Encoding (low-level)
 */
function padAndPrependLength(bytes) {
    let length = bytes.length;
    let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);
    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);
    encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand
    let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);
    encoded.set(lengthBytes); //and now we set the length
    return encoded;
}
/**
 * @Category Encoding (low-level)
 */
function encodeTupleAbi(tuple, allocations) {
    let elementEncodings = tuple.map(element => encodeAbi(element, allocations));
    if (elementEncodings.some(element => element === undefined)) {
        return undefined;
    }
    let elementSizeInfo = tuple.map(element => (0, allocate_1.abiSizeInfo)(element.type, allocations));
    //heads and tails here are as discussed in the ABI docs;
    //for a static type the head is the encoding and the tail is empty,
    //for a dynamic type the head is the pointer and the tail is the encoding
    let heads = [];
    let tails = [];
    //but first, we need to figure out where the first tail will start,
    //by adding up the sizes of all the heads (we can easily do this in
    //advance via elementSizeInfo, without needing to know the particular
    //values of the heads)
    let startOfNextTail = (0, sum_1.default)(elementSizeInfo.map(elementInfo => elementInfo.size));
    for (let i = 0; i < tuple.length; i++) {
        let head;
        let tail;
        if (!elementSizeInfo[i].dynamic) {
            //static case
            head = elementEncodings[i];
            tail = new Uint8Array(); //empty array
        }
        else {
            //dynamic case
            head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);
            tail = elementEncodings[i];
        }
        heads.push(head);
        tails.push(tail);
        startOfNextTail += tail.length;
    }
    //finally, we need to concatenate everything together!
    //since we're dealing with Uint8Arrays, we have to do this manually
    let totalSize = startOfNextTail;
    let encoded = new Uint8Array(totalSize);
    let position = 0;
    for (let head of heads) {
        encoded.set(head, position);
        position += head.length;
    }
    for (let tail of tails) {
        encoded.set(tail, position);
        position += tail.length;
    }
    return encoded;
}
exports.encodeTupleAbi = encodeTupleAbi;
/**
 * @Category Encoding (low-level)
 */
function encodeTupleAbiWithSelector(tuple, selector, allocations) {
    const encodedTuple = encodeTupleAbi(tuple, allocations);
    if (!encodedTuple) {
        return undefined;
    }
    const encoded = new Uint8Array(selector.length + encodedTuple.length);
    encoded.set(selector);
    encoded.set(encodedTuple, selector.length);
    return encoded;
}
exports.encodeTupleAbiWithSelector = encodeTupleAbiWithSelector;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 53137:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abiParameterToType = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abi-data:import");
const bn_js_1 = __importDefault(__webpack_require__(13550));
function abiParameterToType(abi) {
    let typeName = abi.type;
    let typeHint = abi.internalType;
    //first: is it an array?
    let arrayMatch = typeName.match(/(.*)\[(\d*)\]$/);
    if (arrayMatch) {
        let baseTypeName = arrayMatch[1];
        let lengthAsString = arrayMatch[2]; //may be empty!
        let baseAbi = Object.assign(Object.assign({}, abi), { type: baseTypeName });
        let baseType = abiParameterToType(baseAbi);
        if (lengthAsString === "") {
            return {
                typeClass: "array",
                kind: "dynamic",
                baseType,
                typeHint
            };
        }
        else {
            let length = new bn_js_1.default(lengthAsString);
            return {
                typeClass: "array",
                kind: "static",
                length,
                baseType,
                typeHint
            };
        }
    }
    //otherwise, here are the simple cases
    let typeClass = typeName.match(/^([^0-9]+)/)[1];
    switch (typeClass) {
        case "uint":
        case "int": {
            let bits = typeName.match(/^u?int([0-9]+)/)[1];
            return {
                typeClass,
                bits: parseInt(bits),
                typeHint
            };
        }
        case "bytes":
            let length = typeName.match(/^bytes([0-9]*)/)[1];
            if (length === "") {
                return {
                    typeClass,
                    kind: "dynamic",
                    typeHint
                };
            }
            else {
                return {
                    typeClass,
                    kind: "static",
                    length: parseInt(length),
                    typeHint
                };
            }
        case "address":
            return {
                typeClass,
                kind: "general",
                typeHint
            };
        case "string":
        case "bool":
            return {
                typeClass,
                typeHint
            };
        case "fixed":
        case "ufixed": {
            let [_, bits, places] = typeName.match(/^u?fixed([0-9]+)x([0-9]+)/);
            return {
                typeClass,
                bits: parseInt(bits),
                places: parseInt(places),
                typeHint
            };
        }
        case "function":
            return {
                typeClass,
                visibility: "external",
                kind: "general",
                typeHint
            };
        case "tuple":
            let memberTypes = abi.components.map(component => ({
                name: component.name || undefined,
                type: abiParameterToType(component)
            }));
            return {
                typeClass,
                memberTypes,
                typeHint
            };
    }
}
exports.abiParameterToType = abiParameterToType;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20907:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For allocation, encoding, and decoding of locations related to the ABI
 * (calldata in Solidity, events, etc.)
 *
 * @category ABI data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Import = exports.Decode = exports.Encode = exports.Allocate = void 0;
const Allocate = __importStar(__webpack_require__(51325));
exports.Allocate = Allocate;
const Encode = __importStar(__webpack_require__(54840));
exports.Encode = Encode;
const Decode = __importStar(__webpack_require__(7343));
exports.Decode = Decode;
const Import = __importStar(__webpack_require__(53137));
exports.Import = Import;
__exportStar(__webpack_require__(26365), exports); //can't do 'export type *'
const Utils = __importStar(__webpack_require__(85941));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 26365:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 85941:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = exports.abiSelector = exports.abiTupleSignature = exports.abiTypeSignature = exports.abiSignature = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abi-data:utils");
const Ast = __importStar(__webpack_require__(14442));
const abi_utils_1 = __webpack_require__(7651);
Object.defineProperty(exports, "abiSignature", ({ enumerable: true, get: function () { return abi_utils_1.abiSignature; } }));
Object.defineProperty(exports, "abiTypeSignature", ({ enumerable: true, get: function () { return abi_utils_1.abiTypeSignature; } }));
Object.defineProperty(exports, "abiTupleSignature", ({ enumerable: true, get: function () { return abi_utils_1.abiTupleSignature; } }));
Object.defineProperty(exports, "abiSelector", ({ enumerable: true, get: function () { return abi_utils_1.abiSelector; } }));
exports.DEFAULT_CONSTRUCTOR_ABI = {
    type: "constructor",
    inputs: [],
    stateMutability: "nonpayable"
};
//note the return value only includes functions!
function computeSelectors(abi) {
    if (abi === undefined) {
        return undefined;
    }
    return Object.assign({}, ...abi
        .filter((abiEntry) => abiEntry.type === "function")
        .map((abiEntry) => ({
        [(0, abi_utils_1.abiSelector)(abiEntry)]: abiEntry
    })));
}
exports.computeSelectors = computeSelectors;
//does this ABI have a payable fallback (or receive) function?
function abiHasPayableFallback(abi) {
    if (abi === undefined) {
        return undefined;
    }
    return abi.some(abiEntry => (abiEntry.type === "fallback" || abiEntry.type === "receive") &&
        abiEntry.stateMutability === "payable");
}
exports.abiHasPayableFallback = abiHasPayableFallback;
//note: undefined does not match itself :P
function abisMatch(entry1, entry2) {
    //we'll consider two abi entries to match if they have the same
    //type, name (if applicable), and inputs (if applicable).
    //since there's already a signature function, we can just use that.
    if (!entry1 || !entry2) {
        return false;
    }
    if (entry1.type !== entry2.type) {
        return false;
    }
    switch (entry1.type) {
        case "function":
        case "event":
        case "error":
            return ((0, abi_utils_1.abiSignature)(entry1) ===
                (0, abi_utils_1.abiSignature)(entry2));
        case "constructor":
            return ((0, abi_utils_1.abiTupleSignature)(entry1.inputs) ===
                (0, abi_utils_1.abiTupleSignature)(entry2.inputs));
        case "fallback":
        case "receive":
            return true;
    }
}
exports.abisMatch = abisMatch;
function definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {
    try {
        return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));
    }
    catch (_) {
        return false; //if an exception occurs, well, that's not a match!
    }
}
exports.definitionMatchesAbi = definitionMatchesAbi;
function topicsCount(abiEntry) {
    let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector
    return (abiEntry.inputs.filter(({ indexed }) => indexed).length + selectorCount);
}
exports.topicsCount = topicsCount;
function abiEntryIsObviouslyIllTyped(abiEntry) {
    switch (abiEntry.type) {
        case "fallback":
        case "receive":
            return false;
        case "constructor":
        case "event":
        case "error":
            return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);
        case "function":
            return (abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) ||
                abiEntry.outputs.some(abiParameterIsObviouslyIllTyped));
    }
}
exports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;
function abiParameterIsObviouslyIllTyped(abiParameter) {
    const legalBaseTypeClasses = [
        "uint",
        "int",
        "fixed",
        "ufixed",
        "bool",
        "address",
        "bytes",
        "string",
        "function",
        "tuple"
    ];
    const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];
    const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);
    if (abiParameter.components) {
        return (abiParameter.components.some(abiParameterIsObviouslyIllTyped) ||
            baseTypeClassIsObviouslyWrong);
    }
    else {
        return baseTypeClassIsObviouslyWrong;
    }
}
function abiEntryHasStorageParameters(abiEntry) {
    const isStorage = (parameter) => parameter.type.endsWith(" storage");
    return (abiEntry.type === "function" &&
        (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)));
    //Note the lack of recursion!  Storage parameters can only occur at
    //top level so there's no need to recurse here
    //(they can also only occur for functions)
}
exports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 57320:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:abify");
const Format = __importStar(__webpack_require__(29965));
const Common = __importStar(__webpack_require__(99987));
const Conversion = __importStar(__webpack_require__(52714));
/** @category ABIfication */
function abifyType(dataType, userDefinedTypes) {
    switch (dataType.typeClass) {
        //we only need to specially handle types that don't go in
        //the ABI, or that have some information loss when going
        //in the ABI
        //note that we do need to handle arrays, due to recursion!
        //First: types that do not go in the ABI
        case "mapping":
        case "magic":
        case "type":
        case "options":
            return undefined;
        //Next: address & contract, these can get handled together
        case "address":
        case "contract":
            return {
                typeClass: "address",
                kind: "general",
                typeHint: Format.Types.typeString(dataType)
            };
        case "function":
            switch (dataType.visibility) {
                case "external":
                    return {
                        typeClass: "function",
                        visibility: "external",
                        kind: "general",
                        typeHint: Format.Types.typeString(dataType)
                    };
                case "internal": //these don't go in the ABI
                    return undefined;
            }
            break; //to satisfy TypeScript
        //the complex cases: struct & enum
        case "struct": {
            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));
            if (!fullType.memberTypes) {
                let typeToDisplay = Format.Types.typeString(dataType);
                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);
            }
            const memberTypes = fullType.memberTypes.map(({ name, type: memberType }) => ({
                name,
                type: abifyType(memberType, userDefinedTypes)
            }));
            return {
                typeClass: "tuple",
                typeHint: Format.Types.typeString(fullType),
                memberTypes
            };
        }
        case "enum": {
            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));
            if (!fullType.options) {
                let typeToDisplay = Format.Types.typeString(dataType);
                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);
            }
            let numOptions = fullType.options.length;
            let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);
            return {
                typeClass: "uint",
                bits,
                typeHint: Format.Types.typeString(fullType)
            };
        }
        case "userDefinedValueType": {
            const fullType = (Format.Types.fullType(dataType, userDefinedTypes));
            if (!fullType.underlyingType) {
                let typeToDisplay = Format.Types.typeString(dataType);
                throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);
            }
            const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);
            return Object.assign(Object.assign({}, abifiedUnderlying), { typeHint: Format.Types.typeStringWithoutLocation(dataType) });
        }
        //finally: arrays
        case "array":
            return Object.assign(Object.assign({}, dataType), { typeHint: Format.Types.typeString(dataType), baseType: abifyType(dataType.baseType, userDefinedTypes) });
        //default case: just leave as-is
        default:
            return dataType;
    }
}
exports.abifyType = abifyType;
/** @category ABIfication */
function abifyResult(result, userDefinedTypes) {
    switch (result.type.typeClass) {
        case "mapping": //doesn't go in ABI
        case "magic": //doesn't go in ABI
        case "type": //doesn't go in ABI
            return undefined;
        case "address":
            //abify the type but leave the value alone
            return Object.assign(Object.assign({}, result), { type: abifyType(result.type, userDefinedTypes) });
        case "contract": {
            let coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    return {
                        type: (abifyType(result.type, userDefinedTypes)),
                        kind: "value",
                        value: {
                            asAddress: coercedResult.value.address,
                            rawAsHex: coercedResult.value.rawAddress
                        },
                        interpretations: coercedResult.interpretations
                    };
                case "error":
                    switch (coercedResult.error.kind) {
                        case "ContractPaddingError":
                            return {
                                type: (abifyType(result.type, userDefinedTypes)),
                                kind: "error",
                                error: {
                                    kind: "AddressPaddingError",
                                    paddingType: coercedResult.error.paddingType,
                                    raw: coercedResult.error.raw
                                }
                            };
                        default:
                            //other contract errors are generic errors!
                            //but TS doesn't know this so we coerce
                            return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });
                    }
            }
            break; //to satisfy typescript
        }
        case "function":
            switch (result.type.visibility) {
                case "external": {
                    let coercedResult = result;
                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });
                }
                case "internal": //these don't go in the ABI
                    return undefined;
            }
            break; //to satisfy TypeScript
        case "struct": {
            let coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    if (coercedResult.reference !== undefined) {
                        return undefined; //no circular values in the ABI!
                    }
                    let abifiedMembers = coercedResult.value.map(({ name, value: member }) => ({
                        name,
                        value: abifyResult(member, userDefinedTypes)
                    }));
                    return {
                        kind: "value",
                        type: (abifyType(result.type, userDefinedTypes)),
                        value: abifiedMembers,
                        interpretations: coercedResult.interpretations
                    };
                case "error":
                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) //note: may throw exception
                     });
            }
        }
        case "userDefinedValueType": {
            const coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    return abifyResult(coercedResult.value, userDefinedTypes);
                case "error":
                    return Object.assign(Object.assign({}, coercedResult), { type: abifyType(result.type, userDefinedTypes) });
            }
            break; //to satisfy TS :P
        }
        case "enum": {
            //NOTE: this is the one case where errors are converted to non-error values!!
            //(other than recursively, I mean)
            //be aware!
            let coercedResult = result;
            let uintType = (abifyType(result.type, userDefinedTypes)); //may throw exception
            switch (coercedResult.kind) {
                case "value":
                    return {
                        type: uintType,
                        kind: "value",
                        value: {
                            asBN: coercedResult.value.numericAsBN.clone()
                        },
                        interpretations: coercedResult.interpretations
                    };
                case "error":
                    switch (coercedResult.error.kind) {
                        case "EnumOutOfRangeError":
                            return {
                                type: uintType,
                                kind: "value",
                                value: {
                                    asBN: coercedResult.error.rawAsBN.clone()
                                },
                                interpretations: {}
                            };
                        case "EnumPaddingError":
                            return {
                                type: uintType,
                                kind: "error",
                                error: {
                                    kind: "UintPaddingError",
                                    paddingType: coercedResult.error.paddingType,
                                    raw: coercedResult.error.raw
                                }
                            };
                        case "EnumNotFoundDecodingError":
                            let numericValue = coercedResult.error.rawAsBN.clone();
                            if (numericValue.bitLength() <= uintType.bits) {
                                return {
                                    type: uintType,
                                    kind: "value",
                                    value: {
                                        asBN: numericValue
                                    },
                                    interpretations: {}
                                };
                            }
                            else {
                                return {
                                    type: uintType,
                                    kind: "error",
                                    error: {
                                        kind: "UintPaddingError",
                                        paddingType: "left",
                                        raw: Conversion.toHexString(numericValue)
                                    }
                                };
                            }
                        default:
                            return {
                                type: uintType,
                                kind: "error",
                                error: coercedResult.error
                            };
                    }
            }
        }
        case "array": {
            let coercedResult = result;
            switch (coercedResult.kind) {
                case "value":
                    if (coercedResult.reference !== undefined) {
                        return undefined; //no circular values in the ABI!
                    }
                    let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));
                    return {
                        kind: "value",
                        type: (abifyType(result.type, userDefinedTypes)),
                        value: abifiedMembers,
                        interpretations: coercedResult.interpretations
                    };
                case "error":
                    return Object.assign(Object.assign({}, coercedResult), { type: (abifyType(result.type, userDefinedTypes)) });
            }
        }
        default:
            return result; //just coerce :-/
    }
}
exports.abifyResult = abifyResult;
/** @category ABIfication */
function abifyCalldataDecoding(decoding, userDefinedTypes) {
    if (decoding.decodingMode === "abi") {
        return decoding;
    }
    switch (decoding.kind) {
        case "function":
        case "constructor":
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });
        default:
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi" });
    }
}
exports.abifyCalldataDecoding = abifyCalldataDecoding;
/** @category ABIfication */
function abifyLogDecoding(decoding, userDefinedTypes) {
    if (decoding.decodingMode === "abi") {
        return decoding;
    }
    return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });
}
exports.abifyLogDecoding = abifyLogDecoding;
/** @category ABIfication */
function abifyReturndataDecoding(decoding, userDefinedTypes) {
    if (decoding.decodingMode === "abi") {
        return decoding;
    }
    switch (decoding.kind) {
        case "return":
        case "revert":
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", arguments: decoding.arguments.map(argument => (Object.assign(Object.assign({}, argument), { value: abifyResult(argument.value, userDefinedTypes) }))) });
        case "bytecode":
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi", immutables: undefined });
        default:
            return Object.assign(Object.assign({}, decoding), { decodingMode: "abi" });
    }
}
exports.abifyReturndataDecoding = abifyReturndataDecoding;
//# sourceMappingURL=abify.js.map

/***/ }),

/***/ 75511:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeConstant = void 0;
/**
 * @protected
 *
 * @packageDocumentation
 */
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:ast:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Conversion = __importStar(__webpack_require__(52714));
const Basic = __importStar(__webpack_require__(53928));
const Bytes = __importStar(__webpack_require__(67689));
const errors_1 = __webpack_require__(72325);
function* decodeConstant(dataType, pointer, info) {
    debug("pointer %o", pointer);
    //normally, we just dispatch to decodeBasic or decodeBytes.
    //for statically-sized bytes, however, we need to make a special case.
    //you see, decodeBasic expects to find the bytes at the *beginning*
    //of the word, but readDefinition will put them at the *end* of the
    //word.  So we'll have to adjust things ourselves.
    //(if the constant is a string constant, it'll be *just* the bytes, so
    //we have to pad it...)
    if (dataType.typeClass === "bytes" && dataType.kind === "static") {
        const size = dataType.length;
        let word;
        try {
            word = yield* (0, read_1.default)(pointer, info.state);
        }
        catch (error) {
            return (0, errors_1.handleDecodingError)(dataType, error);
        }
        debug("got word: %O", word);
        //not bothering to check padding; shouldn't be necessary
        const bytes = word.slice(-size); //isolate the bytes we want (works in both cases, even if string literal is short)
        return {
            type: dataType,
            kind: "value",
            value: {
                asHex: Conversion.toHexString(bytes, size, true) //padding in case of short string literal
            },
            interpretations: {}
        }; //we'll skip including a raw value, as that would be meaningless
    }
    //otherwise, as mentioned, just dispatch to decodeBasic or decodeBytes
    debug("not a static bytes");
    if (dataType.typeClass === "bytes" || dataType.typeClass === "string") {
        return yield* Bytes.Decode.decodeBytes(dataType, pointer, info);
    }
    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);
}
exports.decodeConstant = decodeConstant;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88132:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For reading/decoding constants expressed as AST nodes
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decode = exports.Read = void 0;
const Read = __importStar(__webpack_require__(38130));
exports.Read = Read;
const Decode = __importStar(__webpack_require__(75511));
exports.Decode = Decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 38130:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readDefinition = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:ast:read");
const Conversion = __importStar(__webpack_require__(52714));
const Evm = __importStar(__webpack_require__(49218));
const Ast = __importStar(__webpack_require__(14442));
const errors_1 = __webpack_require__(72325);
function readDefinition(pointer) {
    const definition = pointer.definition;
    debug("definition %o", definition);
    switch (Ast.Utils.typeClass(definition)) {
        case "rational":
            let numericalValue = Ast.Utils.rationalValue(definition);
            return Conversion.toBytes(numericalValue, Evm.Utils.WORD_SIZE);
        //you may be wondering, why do we not just use definition.value here,
        //like we do below? answer: because if this isn't a literal, that may not
        //exist
        case "stringliteral":
            return Conversion.toBytes(definition.hexValue);
        default:
            //unfortunately, other types of constants are just too complicated to
            //handle right now.  sorry.
            debug("unsupported constant definition type");
            throw new errors_1.DecodingError({
                kind: "UnsupportedConstantError",
                definition
            });
    }
}
exports.readDefinition = readDefinition;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 49965:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.definitionToStoredType = exports.definitionToType = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:ast:import");
const bn_js_1 = __importDefault(__webpack_require__(13550));
const Compiler = __importStar(__webpack_require__(84159));
const Utils = __importStar(__webpack_require__(7656));
const import_1 = __webpack_require__(60013);
//NOTE: the following function will *not* work for arbitrary nodes! It will,
//however, work well enough for what we need.  I.e., it will:
//1. work when given the actual variable definition as the node,
//2. work when given an elementary type as the node,
//3. work when given a user-defined type as the node,
//4. produce something of the correct size in all cases.
//Use beyond that is at your own risk!
//NOTE: set forceLocation to *null* to force no location. leave it undefined
//to not force a location.
function definitionToType(definition, compilationId, compiler, forceLocation) {
    let typeClass = Utils.typeClass(definition);
    let typeHint = Utils.typeStringWithoutLocation(definition);
    switch (typeClass) {
        case "bool":
            return {
                typeClass,
                typeHint
            };
        case "address": {
            switch (Compiler.Utils.solidityFamily(compiler)) {
                case "unknown": //I guess?
                case "pre-0.5.0":
                    return {
                        typeClass,
                        kind: "general",
                        typeHint
                    };
                default:
                    return {
                        typeClass,
                        kind: "specific",
                        payable: Utils.typeIdentifier(definition) === "t_address_payable"
                    };
            }
            break; //to satisfy typescript
        }
        case "uint": {
            let bytes = Utils.specifiedSize(definition);
            return {
                typeClass,
                bits: bytes * 8,
                typeHint
            };
        }
        case "int": {
            //typeScript won't let me group these for some reason
            let bytes = Utils.specifiedSize(definition);
            return {
                typeClass,
                bits: bytes * 8,
                typeHint
            };
        }
        case "fixed": {
            //typeScript won't let me group these for some reason
            let bytes = Utils.specifiedSize(definition);
            let places = Utils.decimalPlaces(definition);
            return {
                typeClass,
                bits: bytes * 8,
                places,
                typeHint
            };
        }
        case "ufixed": {
            let bytes = Utils.specifiedSize(definition);
            let places = Utils.decimalPlaces(definition);
            return {
                typeClass,
                bits: bytes * 8,
                places,
                typeHint
            };
        }
        case "string": {
            if (forceLocation === null) {
                return {
                    typeClass,
                    typeHint
                };
            }
            let location = forceLocation || Utils.referenceType(definition);
            return {
                typeClass,
                location,
                typeHint
            };
        }
        case "bytes": {
            let length = Utils.specifiedSize(definition);
            if (length !== null) {
                return {
                    typeClass,
                    kind: "static",
                    length,
                    typeHint
                };
            }
            else {
                if (forceLocation === null) {
                    return {
                        typeClass,
                        kind: "dynamic",
                        typeHint
                    };
                }
                let location = forceLocation || Utils.referenceType(definition);
                return {
                    typeClass,
                    kind: "dynamic",
                    location,
                    typeHint
                };
            }
        }
        case "array": {
            let baseDefinition = Utils.baseDefinition(definition);
            let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);
            let location = forceLocation || Utils.referenceType(definition);
            if (Utils.isDynamicArray(definition)) {
                if (forceLocation !== null) {
                    return {
                        typeClass,
                        baseType,
                        kind: "dynamic",
                        location,
                        typeHint
                    };
                }
                else {
                    return {
                        typeClass,
                        baseType,
                        kind: "dynamic",
                        typeHint
                    };
                }
            }
            else {
                let length = new bn_js_1.default(Utils.staticLengthAsString(definition));
                if (forceLocation !== null) {
                    return {
                        typeClass,
                        baseType,
                        kind: "static",
                        length,
                        location,
                        typeHint
                    };
                }
                else {
                    return {
                        typeClass,
                        baseType,
                        kind: "static",
                        length,
                        typeHint
                    };
                }
            }
        }
        case "mapping": {
            let keyDefinition = Utils.keyDefinition(definition);
            //note that we can skip the scopes argument here! that's only needed when
            //a general node, rather than a declaration, is being passed in
            let keyType = (definitionToType(keyDefinition, compilationId, compiler, null));
            //suppress the location on the key type (it'll be given as memory but
            //this is meaningless)
            //also, we have to tell TypeScript ourselves that this will be an elementary
            //type; it has no way of knowing that
            debug("definition: %O", definition);
            let valueDefinition = Utils.valueDefinition(definition);
            let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);
            if (forceLocation === null) {
                return {
                    typeClass,
                    keyType,
                    valueType
                };
            }
            return {
                typeClass,
                keyType,
                valueType,
                location: "storage"
            };
        }
        case "function": {
            //WARNING! This case will not work unless given the actual
            //definition!  It should return something *roughly* usable, though.
            let visibility = Utils.visibility(definition); //undefined if bad node
            let mutability = Utils.mutability(definition); //undefined if bad node
            let [inputParameters, outputParameters] = Utils.parameters(definition) || [[], []]; //HACK
            //note: don't force a location on these! use the listed location!
            let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));
            let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));
            switch (visibility) {
                case "internal":
                    return {
                        typeClass,
                        visibility,
                        mutability,
                        inputParameterTypes,
                        outputParameterTypes
                    };
                case "external":
                    return {
                        typeClass,
                        visibility,
                        kind: "specific",
                        mutability,
                        inputParameterTypes,
                        outputParameterTypes
                    };
            }
            break; //to satisfy typescript
        }
        case "struct": {
            let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);
            let qualifiedName = typeHint.match(/struct (.*)/)[1];
            let definingContractName;
            let typeName;
            if (qualifiedName.includes(".")) {
                [definingContractName, typeName] = qualifiedName.split(".");
            }
            else {
                typeName = qualifiedName;
                //leave definingContractName undefined
            }
            if (forceLocation === null) {
                if (definingContractName) {
                    return {
                        typeClass,
                        kind: "local",
                        id,
                        typeName,
                        definingContractName
                    };
                }
                else {
                    return {
                        typeClass,
                        kind: "global",
                        id,
                        typeName
                    };
                }
            }
            let location = forceLocation || Utils.referenceType(definition);
            if (definingContractName) {
                return {
                    typeClass,
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    location
                };
            }
            else {
                return {
                    typeClass,
                    kind: "global",
                    id,
                    typeName,
                    location
                };
            }
        }
        case "enum": {
            let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);
            let qualifiedName = typeHint.match(/enum (.*)/)[1];
            let definingContractName;
            let typeName;
            if (qualifiedName.includes(".")) {
                [definingContractName, typeName] = qualifiedName.split(".");
            }
            else {
                typeName = qualifiedName;
                //leave definingContractName undefined
            }
            if (definingContractName) {
                return {
                    typeClass,
                    kind: "local",
                    id,
                    typeName,
                    definingContractName
                };
            }
            else {
                return {
                    typeClass,
                    kind: "global",
                    id,
                    typeName
                };
            }
        }
        case "userDefinedValueType": {
            let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);
            let definingContractName;
            let typeName;
            if (typeHint.includes(".")) {
                [definingContractName, typeName] = typeHint.split(".");
            }
            else {
                typeName = typeHint;
                //leave definingContractName undefined
            }
            if (definingContractName) {
                return {
                    typeClass,
                    kind: "local",
                    id,
                    typeName,
                    definingContractName
                };
            }
            else {
                return {
                    typeClass,
                    kind: "global",
                    id,
                    typeName
                };
            }
        }
        case "contract": {
            let id = (0, import_1.makeTypeId)(Utils.typeId(definition), compilationId);
            let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2];
            //note: we use the type string rather than the type identifier
            //in order to avoid having to deal with the underscore problem
            let contractKind = Utils.contractKind(definition);
            return {
                typeClass,
                kind: "native",
                id,
                typeName,
                contractKind
            };
        }
        case "magic": {
            let typeIdentifier = Utils.typeIdentifier(definition);
            let variable = (typeIdentifier.match(/^t_magic_(.*)$/)[1]);
            return {
                typeClass,
                variable
            };
        }
    }
}
exports.definitionToType = definitionToType;
//whereas the above takes variable definitions, this takes the actual type
//definition
function definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {
    switch (definition.nodeType) {
        case "StructDefinition": {
            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);
            const memberTypes = definition.members.map(member => ({
                name: member.name,
                type: definitionToType(member, compilationId, compiler, null)
            }));
            if (definingContract) {
                return {
                    typeClass: "struct",
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    definingContract,
                    memberTypes
                };
            }
            else {
                return {
                    typeClass: "struct",
                    kind: "global",
                    id,
                    typeName,
                    memberTypes
                };
            }
        }
        case "EnumDefinition": {
            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);
            const options = definition.members.map(member => member.name);
            if (definingContract) {
                return {
                    typeClass: "enum",
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    definingContract,
                    options
                };
            }
            else {
                return {
                    typeClass: "enum",
                    kind: "global",
                    id,
                    typeName,
                    options
                };
            }
        }
        case "UserDefinedValueTypeDefinition": {
            const { id, typeName, definingContractName, definingContract } = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations);
            let underlyingType = //we know it's that, TS doesn't
            definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here
            if (definingContract) {
                return {
                    typeClass: "userDefinedValueType",
                    kind: "local",
                    id,
                    typeName,
                    definingContractName,
                    definingContract,
                    underlyingType
                };
            }
            else {
                return {
                    typeClass: "userDefinedValueType",
                    kind: "global",
                    id,
                    typeName,
                    underlyingType
                };
            }
        }
        case "ContractDefinition": {
            let id = (0, import_1.makeTypeId)(definition.id, compilationId);
            let typeName = definition.name;
            let contractKind = definition.contractKind;
            let payable = Utils.isContractPayable(definition);
            return {
                typeClass: "contract",
                kind: "native",
                id,
                typeName,
                contractKind,
                payable
            };
        }
    }
}
exports.definitionToStoredType = definitionToStoredType;
function getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {
    const id = (0, import_1.makeTypeId)(definition.id, compilationId);
    let definingContractName;
    let typeName;
    if (definition.canonicalName) {
        if (definition.canonicalName.includes(".")) {
            [definingContractName, typeName] = definition.canonicalName.split(".");
        }
        else {
            typeName = definition.canonicalName;
        }
    }
    else {
        //due to a bug, in 0.8.8 UDVTs lack a canonicalName.
        //so we'll set typeName based on name instead of canonicalName,
        //and set definingContractName below based on definingContract.
        //(this does mean that we'll mess up a bit if referenceDeclarations
        //is not passed... but realistically that shouldn't come up?  really the
        //same kind of hapepns for every type)
        typeName = definition.name;
    }
    let definingContract = undefined;
    ;
    if (referenceDeclarations) {
        let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === "ContractDefinition" &&
            node.nodes.some((subNode) => (0, import_1.makeTypeId)(subNode.id, compilationId) === id));
        if (contractDefinition) {
            definingContract = (definitionToStoredType(contractDefinition, compilationId, compiler)); //can skip reference declarations
            if (!definingContractName) {
                definingContractName = contractDefinition.name;
            }
        }
    }
    return {
        definingContract,
        definingContractName,
        typeName,
        id
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 14442:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = exports.Utils = void 0;
__exportStar(__webpack_require__(65786), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(7656));
exports.Utils = Utils;
const Import = __importStar(__webpack_require__(49965));
exports.Import = Import;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 65786:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 7656:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionClass = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:ast:utils");
const Common = __importStar(__webpack_require__(99987));
const bn_js_1 = __importDefault(__webpack_require__(13550));
const cloneDeep_1 = __importDefault(__webpack_require__(50361));
/** @category Definition Reading */
function typeIdentifier(definition) {
    return definition.typeDescriptions.typeIdentifier;
}
exports.typeIdentifier = typeIdentifier;
/** @category Definition Reading */
function typeString(definition) {
    return definition.typeDescriptions.typeString;
}
exports.typeString = typeString;
/**
 * Returns the type string, but with location (if any) stripped off the end
 * @category Definition Reading
 */
function typeStringWithoutLocation(definition) {
    if (definition.nodeType === "YulTypedName") {
        //for handling Yul variables
        return "bytes32";
    }
    return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, "");
}
exports.typeStringWithoutLocation = typeStringWithoutLocation;
/**
 * returns basic type class for a variable definition node
 * e.g.:
 *  `t_uint256` becomes `uint`
 *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`
 * @category Definition Reading
 */
function typeClass(definition) {
    if (definition.nodeType === "YulTypedName") {
        //for handling Yul variables
        return "bytes";
    }
    return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];
}
exports.typeClass = typeClass;
/**
 * similar to typeClass, but includes any numeric qualifiers
 * e.g.:
 * `t_uint256` becomes `uint256`
 * @category Definition Reading
 */
function typeClassLongForm(definition) {
    return typeIdentifier(definition).match(/t_([^$_]+)/)[1];
}
exports.typeClassLongForm = typeClassLongForm;
/**
 * for user-defined types -- structs, enums, contracts
 * often you can get these from referencedDeclaration, but not
 * always
 * @category Definition Reading
 */
function typeId(definition) {
    debug("definition %O", definition);
    return parseInt(typeIdentifier(definition).match(/\$(\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);
}
exports.typeId = typeId;
/**
 * For function types; returns internal or external
 * (not for use on other types! will cause an error!)
 * should only return "internal" or "external"
 * @category Definition Reading
 */
function visibility(definition) {
    return ((definition.typeName
        ? definition.typeName.visibility
        : definition.visibility));
}
exports.visibility = visibility;
/**
 * e.g. uint48 -> 6
 * @return size in bytes for explicit type size, or `null` if not stated
 * @category Definition Reading
 */
function specifiedSize(definition) {
    if (definition.nodeType === "YulTypedName") {
        return 32; //for handling Yul variables
    }
    let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);
    if (!specified) {
        return null;
    }
    let num = parseInt(specified[1]);
    switch (typeClass(definition)) {
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
            return num / 8;
        case "bytes":
            return num;
        default:
            debug("Unknown type for size specification: %s", typeIdentifier(definition));
    }
}
exports.specifiedSize = specifiedSize;
/**
 * for fixed-point types, obviously
 * @category Definition Reading
 */
function decimalPlaces(definition) {
    return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);
}
exports.decimalPlaces = decimalPlaces;
/** @category Definition Reading */
function isArray(definition) {
    return typeIdentifier(definition).match(/^t_array/) != null;
}
exports.isArray = isArray;
/** @category Definition Reading */
function isDynamicArray(definition) {
    return (isArray(definition) &&
        //NOTE: we do this by parsing the type identifier, rather than by just
        //checking the length field, because we might be using this on a faked-up
        //definition
        typeIdentifier(definition).match(/\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null);
}
exports.isDynamicArray = isDynamicArray;
/**
 * length of a statically sized array -- please only use for arrays
 * already verified to be static!
 * @category Definition Reading
 */
function staticLength(definition) {
    //NOTE: we do this by parsing the type identifier, rather than by just
    //checking the length field, because we might be using this on a faked-up
    //definition
    return parseInt(staticLengthAsString(definition));
}
exports.staticLength = staticLength;
/**
 * see staticLength for explanation
 * @category Definition Reading
 */
function staticLengthAsString(definition) {
    return typeIdentifier(definition).match(/\$(\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];
}
exports.staticLengthAsString = staticLengthAsString;
/** @category Definition Reading */
function isStruct(definition) {
    return typeIdentifier(definition).match(/^t_struct/) != null;
}
exports.isStruct = isStruct;
/** @category Definition Reading */
function isMapping(definition) {
    return typeIdentifier(definition).match(/^t_mapping/) != null;
}
exports.isMapping = isMapping;
/** @category Definition Reading */
function isEnum(definition) {
    return typeIdentifier(definition).match(/^t_enum/) != null;
}
exports.isEnum = isEnum;
/** @category Definition Reading */
function isReference(definition) {
    return (typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null);
}
exports.isReference = isReference;
/**
 * note: only use this on things already verified to be references
 * @category Definition Reading
 */
function referenceType(definition) {
    return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];
}
exports.referenceType = referenceType;
/**
 * only for contract types, obviously! will yield nonsense otherwise!
 * @category Definition Reading
 */
function contractKind(definition) {
    return typeString(definition).split(" ")[0];
}
exports.contractKind = contractKind;
/**
 * stack size, in words, of a given type
 * note: this function assumes that UDVTs only ever take up
 * a single word, which is currently true
 * @category Definition Reading
 */
function stackSize(definition) {
    if (typeClass(definition) === "function" &&
        visibility(definition) === "external") {
        return 2;
    }
    if (isReference(definition) && referenceType(definition) === "calldata") {
        if (typeClass(definition) === "string" ||
            typeClass(definition) === "bytes") {
            return 2;
        }
        if (isDynamicArray(definition)) {
            return 2;
        }
    }
    return 1;
}
exports.stackSize = stackSize;
/** @category Definition Reading */
function isSimpleConstant(definition) {
    const types = ["stringliteral", "rational"];
    return types.includes(typeClass(definition));
}
exports.isSimpleConstant = isSimpleConstant;
/**
 * definition: a storage reference definition
 * location: the location you want it to refer to instead
 * @category Definition Reading
 */
function spliceLocation(definition, location) {
    debug("definition %O", definition);
    return Object.assign(Object.assign({}, definition), { typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), { typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, "_" + location) }) });
}
exports.spliceLocation = spliceLocation;
/**
 * adds "_ptr" on to the end of type identifiers that might need it; note that
 * this operates on identifiers, not definitions
 * @category Definition Reading
 */
function regularizeTypeIdentifier(identifier) {
    return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, "$1_ptr" //this used to use lookbehind for clarity, but Firefox...
    //(see: https://github.com/trufflesuite/truffle/issues/3068 )
    );
}
exports.regularizeTypeIdentifier = regularizeTypeIdentifier;
/**
 * extract the actual numerical value from a node of type rational.
 * currently assumes result will be integer (currently returns BN)
 * @category Definition Reading
 */
function rationalValue(definition) {
    let identifier = typeIdentifier(definition);
    let absoluteValue = identifier.match(/_(\d+)_by_1$/)[1];
    let isNegative = identifier.match(/_minus_/) != null;
    return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);
}
exports.rationalValue = rationalValue;
/** @category Definition Reading */
function baseDefinition(definition) {
    if (definition.typeName && definition.typeName.baseType) {
        return definition.typeName.baseType;
    }
    if (definition.baseType) {
        return definition.baseType;
    }
    //otherwise, we'll have to spoof it up ourselves
    let baseIdentifier = typeIdentifier(definition).match(/^t_array\$_(.*)_\$/)[1];
    //greedy match to extract everything from first to last dollar sign
    // HACK - internal types for memory or storage also seem to be pointers
    baseIdentifier = regularizeTypeIdentifier(baseIdentifier);
    // another HACK - we get away with it because we're only using that one property
    let result = (0, cloneDeep_1.default)(definition);
    result.typeDescriptions.typeIdentifier = baseIdentifier;
    return result;
    //WARNING -- these hacks do *not* correctly handle all cases!
    //they do, however, handle the cases we currently need.
}
exports.baseDefinition = baseDefinition;
/**
 * for use for mappings and arrays only!
 * for arrays, fakes up a uint definition
 * @category Definition Reading
 */
function keyDefinition(definition, scopes) {
    let result;
    switch (typeClass(definition)) {
        case "mapping":
            //first: is there a key type already there? if so just use that
            if (definition.keyType) {
                return definition.keyType;
            }
            if (definition.typeName && definition.typeName.keyType) {
                return definition.typeName.keyType;
            }
            //otherwise: is there a referencedDeclaration? if so try using that
            let baseDeclarationId = definition.referencedDeclaration;
            debug("baseDeclarationId %d", baseDeclarationId);
            //if there's a referencedDeclaration, we'll use that
            if (baseDeclarationId !== undefined) {
                let baseDeclaration = scopes[baseDeclarationId].definition;
                return baseDeclaration.keyType || baseDeclaration.typeName.keyType;
            }
            //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;
            //we'll have to spoof it up ourselves
            let keyIdentifier = typeIdentifier(definition).match(/^t_mapping\$_(.*?)_\$_/)[1];
            //use *non*-greedy match; note that if the key type could include
            //the sequence "_$_", this could cause a problem, but they can't; the only
            //valid key types that include dollar signs at all are user-defined types,
            //which contain both "$_" and "_$" but never "_$_".
            // HACK - internal types for memory or storage also seem to be pointers
            keyIdentifier = regularizeTypeIdentifier(keyIdentifier);
            let keyString = typeString(definition).match(/mapping\((.*?) => .*\)( storage)?$/)[1];
            //use *non*-greedy match; note that if the key type could include
            //"=>", this could cause a problem, but mappings are not allowed as key
            //types, so this can't come up
            // another HACK - we get away with it because we're only using that one property
            result = (0, cloneDeep_1.default)(definition);
            result.typeDescriptions = {
                typeIdentifier: keyIdentifier,
                typeString: keyString
            };
            return result;
        case "array":
            //HACK -- again we should get away with it because for a uint256 we don't
            //really need to inspect the other properties
            result = (0, cloneDeep_1.default)(definition);
            result.typeDescriptions = {
                typeIdentifier: "t_uint256",
                typeString: "uint256"
            };
            return result;
        default:
            debug("unrecognized index access!");
    }
}
exports.keyDefinition = keyDefinition;
/**
 * for use for mappings only!
 * @category Definition Reading
 */
function valueDefinition(definition, scopes) {
    let result;
    //first: is there a value type already there? if so just use that
    if (definition.valueType) {
        return definition.valueType;
    }
    if (definition.typeName && definition.typeName.valueType) {
        return definition.typeName.valueType;
    }
    //otherwise: is there a referencedDeclaration? if so try using that
    let baseDeclarationId = definition.referencedDeclaration;
    debug("baseDeclarationId %d", baseDeclarationId);
    //if there's a referencedDeclaration, we'll use that
    if (baseDeclarationId !== undefined) {
        let baseDeclaration = scopes[baseDeclarationId].definition;
        return baseDeclaration.valueType || baseDeclaration.typeName.valueType;
    }
    //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;
    //we'll have to spoof it up ourselves
    let valueIdentifier = typeIdentifier(definition).match(/^t_mapping\$_.*?_\$_(.*)_\$/)[1];
    //use *non*-greedy match on the key; note that if the key type could include
    //the sequence "_$_", this could cause a problem, but they can't; the only
    //valid key types that include dollar signs at all are user-defined types,
    //which contain both "$_" and "_$" but never "_$_".
    // HACK - internal types for memory or storage also seem to be pointers
    valueIdentifier = regularizeTypeIdentifier(valueIdentifier);
    let valueString = typeString(definition).match(/mapping\(.*? => (.*)\)( storage)?$/)[1];
    //use *non*-greedy match; note that if the key type could include
    //"=>", this could cause a problem, but mappings are not allowed as key
    //types, so this can't come up
    // another HACK - we get away with it because we're only using that one property
    result = (0, cloneDeep_1.default)(definition);
    result.typeDescriptions = {
        typeIdentifier: valueIdentifier,
        typeString: valueString
    };
    return result;
}
exports.valueDefinition = valueDefinition;
/**
 * returns input parameters, then output parameters
 * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE
 * NOT FOR FUNCTION DEFINITIONS
 * @category Definition Reading
 */
function parameters(definition) {
    let typeObject = definition.typeName || definition;
    if (typeObject.parameterTypes && typeObject.returnParameterTypes) {
        return [
            typeObject.parameterTypes.parameters,
            typeObject.returnParameterTypes.parameters
        ];
    }
    else {
        return undefined;
    }
}
exports.parameters = parameters;
/**
 * compatibility function, since pre-0.5.0 functions don't have node.kind
 * returns undefined if you don't put in a function node
 * @category Definition Reading
 */
function functionKind(node) {
    if (node.nodeType !== "FunctionDefinition") {
        return undefined;
    }
    if (node.kind !== undefined) {
        //if we're dealing with 0.5.x, we can just read node.kind
        return node.kind;
    }
    //otherwise, we need this little shim
    if (node.isConstructor) {
        return "constructor";
    }
    return node.name === "" ? "fallback" : "function";
}
exports.functionKind = functionKind;
//this is kind of a weird one, it exposes some Solidity internals.
//for internal functions it'll return "internal".
//for external functions it'll return "external".
//for library functions it'll return "delegatecall".
//and for builtin functions, it'll return an internal name for
//that particular builtin function.
//(there are more possibilities but I'm not going to list them all here)
function functionClass(node) {
    const match = typeIdentifier(node).match(/^t_function_([^_]+)_/);
    return match ? match[1] : undefined;
}
exports.functionClass = functionClass;
/**
 * similar compatibility function for mutability for pre-0.4.16 versions
 * returns undefined if you don't give it a FunctionDefinition or
 * VariableDeclaration
 * @category Definition Reading
 */
function mutability(node) {
    node = node.typeName || node;
    if (node.nodeType !== "FunctionDefinition" &&
        node.nodeType !== "FunctionTypeName") {
        return undefined;
    }
    if (node.stateMutability !== undefined) {
        //if we're dealing with 0.4.16 or later, we can just read node.stateMutability
        return node.stateMutability;
    }
    //otherwise, we need this little shim
    if (node.payable) {
        return "payable";
    }
    if (node.constant) {
        //yes, it means "view" even if you're looking at a variable declaration!
        //old Solidity was weird!
        return "view";
    }
    return "nonpayable";
}
exports.mutability = mutability;
/**
 * takes a contract definition and asks, does it have a payable fallback
 * function?
 * @category Definition Reading
 */
function isContractPayable(definition) {
    return definition.nodes.some(node => node.nodeType === "FunctionDefinition" &&
        (functionKind(node) === "fallback" || functionKind(node) === "receive") &&
        mutability(node) === "payable");
}
exports.isContractPayable = isContractPayable;
/**
 * the main function. just does some dispatch.
 * returns undefined on bad input
 */
function definitionToAbi(node, referenceDeclarations) {
    switch (node.nodeType) {
        case "FunctionDefinition":
            if (node.visibility === "public" || node.visibility === "external") {
                return functionDefinitionToAbi(node, referenceDeclarations);
            }
            else {
                return undefined;
            }
        case "EventDefinition":
            return eventDefinitionToAbi(node, referenceDeclarations);
        case "ErrorDefinition":
            return errorDefinitionToAbi(node, referenceDeclarations);
        case "VariableDeclaration":
            if (node.visibility === "public") {
                return getterDefinitionToAbi(node, referenceDeclarations);
            }
            else {
                return undefined;
            }
        default:
            return undefined;
    }
}
exports.definitionToAbi = definitionToAbi;
//note: not for FunctionTypeNames or VariableDeclarations
function functionDefinitionToAbi(node, referenceDeclarations) {
    let kind = functionKind(node);
    let stateMutability = mutability(node);
    let payable = stateMutability === "payable";
    let inputs;
    switch (kind) {
        case "function":
            let name = node.name;
            let outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);
            inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
            return {
                type: "function",
                name,
                inputs,
                outputs,
                stateMutability
            };
        case "constructor":
            inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
            //note: need to coerce because of mutability restrictions
            return {
                type: "constructor",
                inputs,
                stateMutability,
                payable
            };
        case "fallback":
            //note: need to coerce because of mutability restrictions
            return {
                type: "fallback",
                stateMutability,
                payable
            };
        case "receive":
            //note: need to coerce because of mutability restrictions
            return {
                type: "receive",
                stateMutability,
                payable
            };
    }
}
function eventDefinitionToAbi(node, referenceDeclarations) {
    let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
    let name = node.name;
    let anonymous = node.anonymous;
    return {
        type: "event",
        inputs,
        name,
        anonymous
    };
}
function errorDefinitionToAbi(node, referenceDeclarations) {
    let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);
    let name = node.name;
    return {
        type: "error",
        inputs,
        name
    };
}
function parametersToAbi(nodes, referenceDeclarations) {
    return nodes.map(node => parameterToAbi(node, referenceDeclarations));
}
//NOTE: This function is only for types that could potentially go in the ABI!
//(otherwise it could, say, loop infinitely)
//currently it will only ever be called on those because it's only called from
//definitionToAbi, which filters out any definitions that are not for
//this that *actually* go in the ABI
//if you want to expand it to handle those (by throwing an exception, say),
//you'll need to give it a way to detect circularities
function parameterToAbi(node, referenceDeclarations) {
    let name = node.name; //may be the empty string... or even undefined for a base type
    let components;
    let internalType = typeStringWithoutLocation(node);
    //is this an array? if so use separate logic
    if (typeClass(node) === "array") {
        let baseType = node.typeName ? node.typeName.baseType : node.baseType;
        let baseAbi = parameterToAbi(baseType, referenceDeclarations);
        let arraySuffix = isDynamicArray(node) ? `[]` : `[${staticLength(node)}]`;
        const parameter = {
            name,
            type: baseAbi.type + arraySuffix,
            components: baseAbi.components,
            internalType
        };
        if ("indexed" in node) {
            return Object.assign(Object.assign({}, parameter), { indexed: node.indexed });
        }
        else {
            return parameter;
        }
    }
    let abiTypeString = toAbiType(node, referenceDeclarations);
    //otherwise... is it a struct? if so we need to populate components
    if (typeClass(node) === "struct") {
        let id = typeId(node);
        let referenceDeclaration = referenceDeclarations[id];
        if (referenceDeclaration === undefined) {
            let typeToDisplay = typeString(node);
            throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);
        }
        components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);
    }
    const parameter = {
        name,
        type: abiTypeString,
        components,
        internalType
    };
    if ("indexed" in node) {
        return Object.assign(Object.assign({}, parameter), { indexed: node.indexed });
    }
    else {
        return parameter;
    }
}
//note: this is only meant for non-array types that can go in the ABI
//it returns how that type is notated in the ABI -- just the string,
//to be clear, not components of tuples
//again, NOT FOR ARRAYS
function toAbiType(node, referenceDeclarations) {
    let basicType = typeClassLongForm(node); //get that whole first segment!
    switch (basicType) {
        case "contract":
            return "address";
        case "struct":
            return "tuple"; //the more detailed checking will be handled elsewhere
        case "enum": {
            const referenceId = typeId(node);
            const referenceDeclaration = referenceDeclarations[referenceId];
            if (referenceDeclaration === undefined) {
                const typeToDisplay = typeString(node);
                throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);
            }
            const numOptions = referenceDeclaration.members.length;
            const bits = 8 * Math.ceil(Math.log2(numOptions) / 8);
            return `uint${bits}`;
        }
        case "userDefinedValueType": {
            const referenceId = typeId(node);
            const referenceDeclaration = referenceDeclarations[referenceId];
            if (referenceDeclaration === undefined) {
                const typeToDisplay = typeString(node);
                throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);
            }
            const underlyingType = referenceDeclaration.underlyingType;
            return toAbiType(underlyingType, referenceDeclarations);
        }
        default:
            return basicType;
        //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;
        //address will have "payable" left off;
        //external functions will be reduced to "function" (and internal functions shouldn't
        //be passed in!)
        //(mappings shouldn't be passed in either obviously)
        //(nor arrays :P )
    }
}
function getterDefinitionToAbi(node, referenceDeclarations) {
    debug("getter node: %O", node);
    let name = node.name;
    let { inputs, outputs } = getterParameters(node, referenceDeclarations);
    let inputsAbi = parametersToAbi(inputs, referenceDeclarations);
    let outputsAbi = parametersToAbi(outputs, referenceDeclarations);
    return {
        type: "function",
        name,
        inputs: inputsAbi,
        outputs: outputsAbi,
        stateMutability: "view"
    };
}
//how getter parameters work:
//INPUT:
//types other than arrays and mappings take no input.
//array getters take uint256 input. mapping getters take input of their key type.
//if arrays, mappings, stacked, then takes multiple inputs, in order from outside
//to in.
//These parameters are unnamed.
//OUTPUT:
//if base type (beneath mappings & arrays) is not a struct, returns that.
//(This return parameter has no name -- it is *not* named for the variable!)
//if it is a struct, returns multiple outputs, one for each member of the struct,
//*except* arrays and mappings.  (And they have names, the names of the members.)
//important note: inner structs within a struct are just returned, not
//partially destructured like the outermost struct!  Yes, this is confusing.
function getterParameters(node, referenceDeclarations) {
    let baseNode = node.typeName || node;
    let inputs = [];
    while (typeClass(baseNode) === "array" || typeClass(baseNode) === "mapping") {
        let keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition
        inputs.push(Object.assign(Object.assign({}, keyNode), { name: "" })); //again, getter input params have no name
        switch (typeClass(baseNode)) {
            case "array":
                baseNode = baseNode.baseType;
                break;
            case "mapping":
                baseNode = baseNode.valueType;
                break;
        }
    }
    //at this point, baseNode should hold the base type
    //now we face the question: is it a struct?
    if (typeClass(baseNode) === "struct") {
        let id = typeId(baseNode);
        let referenceDeclaration = referenceDeclarations[id];
        if (referenceDeclaration === undefined) {
            let typeToDisplay = typeString(baseNode);
            throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);
        }
        let outputs = referenceDeclaration.members.filter(member => typeClass(member) !== "array" && typeClass(member) !== "mapping");
        return { inputs, outputs }; //no need to wash name!
    }
    else {
        //only one output; it's just the base node, with its name washed
        return { inputs, outputs: [Object.assign(Object.assign({}, baseNode), { name: "" })] };
    }
}
exports.getterParameters = getterParameters;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 49107:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.byteLength = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:basic:allocate");
const Common = __importStar(__webpack_require__(99987));
const Evm = __importStar(__webpack_require__(49218));
const Format = __importStar(__webpack_require__(29965));
//only for direct types!
function byteLength(dataType, userDefinedTypes) {
    switch (dataType.typeClass) {
        case "bool":
            return 1;
        case "address":
        case "contract":
            return Evm.Utils.ADDRESS_SIZE;
        case "int":
        case "uint":
        case "fixed":
        case "ufixed":
            return dataType.bits / 8;
        case "function":
            switch (dataType.visibility) {
                case "internal":
                    return Evm.Utils.PC_SIZE * 2;
                case "external":
                    return Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE;
            }
        case "bytes": //we assume we're in the static case
            return dataType.length;
        case "enum": {
            const storedType = userDefinedTypes[dataType.id];
            if (!storedType || !storedType.options) {
                throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
            }
            const numValues = storedType.options.length;
            return Math.ceil(Math.log2(numValues) / 8);
        }
        case "userDefinedValueType": {
            const storedType = userDefinedTypes[dataType.id];
            if (!storedType || !storedType.underlyingType) {
                throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
            }
            const { underlyingType } = storedType;
            return byteLength(underlyingType, userDefinedTypes);
        }
    }
}
exports.byteLength = byteLength;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 57939:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:basic:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Conversion = __importStar(__webpack_require__(52714));
const Format = __importStar(__webpack_require__(29965));
const Contexts = __importStar(__webpack_require__(97938));
const Evm = __importStar(__webpack_require__(49218));
const errors_1 = __webpack_require__(72325);
const allocate_1 = __webpack_require__(49107);
const decode_1 = __webpack_require__(59495);
function* decodeBasic(dataType, pointer, info, options = {}) {
    const { state } = info;
    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so it's OK
    const paddingMode = options.paddingMode || "default";
    let bytes;
    let rawBytes;
    try {
        bytes = yield* (0, read_1.default)(pointer, state);
    }
    catch (error) {
        debug("segfault, pointer %o, state: %O", pointer, state);
        return (0, errors_1.handleDecodingError)(dataType, error, strict);
    }
    rawBytes = bytes;
    debug("type %O", dataType);
    debug("pointer %o", pointer);
    switch (dataType.typeClass) {
        case "userDefinedValueType": {
            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));
            if (!fullType.underlyingType) {
                const error = {
                    kind: "UserDefinedTypeNotFoundError",
                    type: fullType
                };
                if (strict || options.allowRetry) {
                    throw new errors_1.StopDecodingError(error, true);
                    //note that we allow a retry if we couldn't locate the underlying type!
                }
                return {
                    type: fullType,
                    kind: "error",
                    error
                };
            }
            const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);
            switch (underlyingResult.kind //yes this switch is a little unnecessary :P
            ) {
                case "value":
                    //wrap the value and return
                    return {
                        //no idea why need coercion here
                        type: fullType,
                        kind: "value",
                        value: underlyingResult,
                        interpretations: {}
                    };
                case "error":
                    //wrap the error and return an error result!
                    //this is inconsistent with how we handle other container types
                    //(structs, arrays, mappings), where having an error in one element
                    //does not cause an error in the whole thing, but to do that here
                    //would cause problems for the type system :-/
                    //so we'll just be inconsistent
                    return {
                        //TS is being bad again :-/
                        type: fullType,
                        kind: "error",
                        error: {
                            kind: "WrappedError",
                            error: underlyingResult
                        }
                    };
            }
            break; //to satisfy TS :P
        }
        case "bool": {
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "BoolPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePadding(bytes, dataType, paddingMode);
            //note: the use of the BN is a little silly here,
            //but, kind of stuck with it for now
            const numeric = Conversion.toBN(bytes);
            if (numeric.eqn(0)) {
                return {
                    type: dataType,
                    kind: "value",
                    value: { asBoolean: false },
                    interpretations: {}
                };
            }
            else if (numeric.eqn(1)) {
                return {
                    type: dataType,
                    kind: "value",
                    value: { asBoolean: true },
                    interpretations: {}
                };
            }
            else {
                let error = {
                    kind: "BoolOutOfRangeError",
                    rawAsBN: numeric
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
        }
        case "uint":
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "UintPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN: Conversion.toBN(bytes),
                    rawAsBN: Conversion.toBN(rawBytes)
                },
                interpretations: {}
            };
        case "int":
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "IntPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length (keeping the bytes on the right)
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN: Conversion.toSignedBN(bytes),
                    rawAsBN: Conversion.toSignedBN(rawBytes)
                },
                interpretations: {}
            };
        case "address": {
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "AddressPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePadding(bytes, dataType, paddingMode);
            const address = Evm.Utils.toAddress(bytes);
            let decoded = {
                type: dataType,
                kind: "value",
                value: {
                    asAddress: address,
                    rawAsHex: Conversion.toHexString(rawBytes)
                },
                interpretations: {}
            };
            //now: attach interpretations
            const ensName = yield* reverseEnsResolve(address);
            if (ensName !== null) {
                decoded.interpretations.ensName = ensName;
            }
            //yes, this makes the contract/address distinction a little silly
            const contractValueInfo = yield* decodeContract(bytes, info);
            if (contractValueInfo.kind === "known") {
                decoded.interpretations.contractClass = contractValueInfo.class;
            }
            return decoded;
        }
        case "contract": {
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "ContractPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePadding(bytes, dataType, paddingMode);
            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));
            const contractValueInfo = yield* decodeContract(bytes, info);
            let decoded = {
                type: fullType,
                kind: "value",
                value: contractValueInfo,
                interpretations: {}
            };
            //now: attach interpretations
            const ensName = yield* reverseEnsResolve(contractValueInfo.address);
            if (ensName !== null) {
                decoded.interpretations = { ensName };
            }
            return decoded;
        }
        case "bytes":
            //NOTE: we assume this is a *static* bytestring,
            //because this is decodeBasic! dynamic ones should
            //go to decodeBytes!
            let coercedDataType = dataType;
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "BytesPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: coercedDataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length
            bytes = removePadding(bytes, dataType, paddingMode);
            return {
                type: coercedDataType,
                kind: "value",
                value: {
                    asHex: Conversion.toHexString(bytes),
                    rawAsHex: Conversion.toHexString(rawBytes)
                },
                interpretations: {}
            };
        case "function":
            switch (dataType.visibility) {
                case "external":
                    if (!checkPadding(bytes, dataType, paddingMode)) {
                        const error = {
                            kind: "FunctionExternalNonStackPaddingError",
                            paddingType: getPaddingType(dataType, paddingMode),
                            raw: Conversion.toHexString(bytes)
                        };
                        if (strict) {
                            throw new errors_1.StopDecodingError(error);
                        }
                        return {
                            type: dataType,
                            kind: "error",
                            error
                        };
                    }
                    bytes = removePadding(bytes, dataType, paddingMode);
                    const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);
                    const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);
                    const valueInfo = yield* decodeExternalFunction(address, selector, info);
                    let decoded = {
                        type: dataType,
                        kind: "value",
                        value: valueInfo,
                        interpretations: {}
                    };
                    //now: attach interpretations
                    const contractEnsName = yield* reverseEnsResolve(valueInfo.contract.address);
                    if (contractEnsName !== null) {
                        decoded.interpretations = { contractEnsName };
                    }
                    return decoded;
                case "internal":
                    //note: we used to error if we hit this point with strict === true,
                    //since internal function pointers don't go in the ABI, and strict
                    //mode is intended for ABI decoding.  however, there are times when
                    //we want to use strict mode to decode immutables, and immutables can
                    //include internal function pointers.  so now we allow this.  yes,
                    //this is a bit of an abuse of strict mode, which was after all meant
                    //for ABI decoding, but oh well.
                    if (!checkPadding(bytes, dataType, paddingMode)) {
                        const error = {
                            kind: "FunctionInternalPaddingError",
                            paddingType: getPaddingType(dataType, paddingMode),
                            raw: Conversion.toHexString(bytes)
                        };
                        if (strict) {
                            throw new errors_1.StopDecodingError(error);
                        }
                        return {
                            type: dataType,
                            kind: "error",
                            error
                        };
                    }
                    bytes = removePadding(bytes, dataType, paddingMode);
                    return decodeInternalFunction(dataType, bytes, info, strict);
            }
            break; //to satisfy TypeScript
        case "enum": {
            let numeric = Conversion.toBN(bytes);
            const fullType = (Format.Types.fullType(dataType, info.userDefinedTypes));
            if (!fullType.options) {
                let error = {
                    kind: "EnumNotFoundDecodingError",
                    type: fullType,
                    rawAsBN: numeric
                };
                if (strict || options.allowRetry) {
                    throw new errors_1.StopDecodingError(error, true);
                    //note that we allow a retry if we couldn't locate the enum type!
                }
                return {
                    type: fullType,
                    kind: "error",
                    error
                };
            }
            //note: I'm doing the padding checks a little more manually on this one
            //so that we can have the right type of error
            const numOptions = fullType.options.length;
            const numBytes = Math.ceil(Math.log2(numOptions) / 8);
            const paddingType = getPaddingType(dataType, paddingMode);
            if (!checkPaddingDirect(bytes, numBytes, paddingType)) {
                let error = {
                    kind: "EnumPaddingError",
                    type: fullType,
                    paddingType,
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            bytes = removePaddingDirect(bytes, numBytes, paddingType);
            numeric = Conversion.toBN(bytes); //alter numeric!
            if (numeric.ltn(numOptions)) {
                const name = fullType.options[numeric.toNumber()];
                //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an
                //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have
                //an enum with that many options in the first place, we have bigger problems!
                return {
                    type: fullType,
                    kind: "value",
                    value: {
                        name,
                        numericAsBN: numeric
                    },
                    interpretations: {}
                };
            }
            else {
                let error = {
                    kind: "EnumOutOfRangeError",
                    type: fullType,
                    rawAsBN: numeric
                };
                if (strict) {
                    //note:
                    //if the enum is merely out of range rather than out of the ABI range,
                    //we do NOT throw an error here!  instead we simply return an error value,
                    //which we normally avoid doing in strict mode.  (the error will be caught
                    //later at the re-encoding step instead.)  why?  because we might be running
                    //in ABI mode, so we may need to abify this "value" rather than just throwing
                    //it out.
                    throw new errors_1.StopDecodingError(error);
                    //note that we do NOT allow a retry here!
                    //if we *can* find the enum type but the value is out of range,
                    //we *know* that it is invalid!
                }
                return {
                    type: fullType,
                    kind: "error",
                    error
                };
            }
        }
        case "fixed": {
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "FixedPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length (keeping the bytes on the right)
            bytes = removePadding(bytes, dataType, paddingMode);
            let asBN = Conversion.toSignedBN(bytes);
            let rawAsBN = Conversion.toSignedBN(rawBytes);
            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);
            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBig,
                    rawAsBig
                },
                interpretations: {}
            };
        }
        case "ufixed": {
            //first, check padding (if needed)
            if (!checkPadding(bytes, dataType, paddingMode)) {
                let error = {
                    kind: "UfixedPaddingError",
                    paddingType: getPaddingType(dataType, paddingMode),
                    raw: Conversion.toHexString(bytes)
                };
                if (strict) {
                    throw new errors_1.StopDecodingError(error);
                }
                return {
                    type: dataType,
                    kind: "error",
                    error
                };
            }
            //now, truncate to appropriate length (keeping the bytes on the right)
            bytes = removePadding(bytes, dataType, paddingMode);
            let asBN = Conversion.toBN(bytes);
            let rawAsBN = Conversion.toBN(rawBytes);
            let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);
            let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBig,
                    rawAsBig
                },
                interpretations: {}
            };
        }
    }
}
exports.decodeBasic = decodeBasic;
//NOTE that this function returns a ContractValueInfo, not a ContractResult
function* decodeContract(addressBytes, info) {
    return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;
}
exports.decodeContract = decodeContract;
function* decodeContractAndContext(addressBytes, info) {
    let address = Evm.Utils.toAddress(addressBytes);
    let rawAddress = Conversion.toHexString(addressBytes);
    let codeBytes = yield {
        type: "code",
        address
    };
    let code = Conversion.toHexString(codeBytes);
    let context = Contexts.Utils.findContext(info.contexts, code);
    if (context !== null) {
        return {
            context,
            contractInfo: {
                kind: "known",
                address,
                rawAddress,
                class: Contexts.Import.contextToType(context)
            }
        };
    }
    else {
        return {
            context,
            contractInfo: {
                kind: "unknown",
                address,
                rawAddress
            }
        };
    }
}
//note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes
//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult
function* decodeExternalFunction(addressBytes, selectorBytes, info) {
    let { contractInfo: contract, context } = yield* decodeContractAndContext(addressBytes, info);
    let selector = Conversion.toHexString(selectorBytes);
    if (contract.kind === "unknown") {
        return {
            kind: "unknown",
            contract,
            selector
        };
    }
    let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;
    if (abiEntry === undefined) {
        return {
            kind: "invalid",
            contract,
            selector
        };
    }
    return {
        kind: "known",
        contract,
        selector,
        abi: abiEntry
    };
}
exports.decodeExternalFunction = decodeExternalFunction;
//this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult
function decodeInternalFunction(dataType, bytes, info, strict) {
    const rawInfoFormat = info.internalFunctionsTableKind || "index";
    //we'll default to "index" if it's not specified, not because that's
    //a reasonable default (we want to avoid ever hitting a default here,
    //debugger/decoder will set their own defaults as appropriate), but because
    //index doesn't attempt to, like, parse things, so it's better for reporting
    //errors if we have no clue what's going on
    let raw;
    switch (rawInfoFormat) {
        case "pcpair":
            const deployedPcBytes = bytes.slice(-Evm.Utils.PC_SIZE);
            const constructorPcBytes = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);
            const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();
            const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();
            raw = {
                kind: "pcpair",
                deployedProgramCounter: deployedPc,
                constructorProgramCounter: constructorPc
            };
            break;
        case "index":
            const index = Conversion.toBN(bytes).toNumber();
            raw = {
                kind: "index",
                functionIndex: index
            };
            break;
    }
    const context = Contexts.Import.contextToType(info.currentContext);
    //before anything else: do we even have an internal functions table?
    //if not, we'll just return the info we have without really attemting to decode
    if (!info.internalFunctionsTable || !info.internalFunctionsTableKind) {
        //note we end up here if the table kind wasn't set; the "index" default above
        //is *only* for error handling
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "unknown",
                context,
                rawInformation: raw
            },
            interpretations: {}
        };
    }
    //this switch block handles exceptional cases that are only relevant in the pcpair case
    if (raw.kind === "pcpair") {
        //defining these for convenience
        const { deployedProgramCounter: deployedPc, constructorProgramCounter: constructorPc } = raw;
        //also before we continue: is the PC zero? if so let's just return that
        if (deployedPc === 0 && constructorPc === 0) {
            return {
                type: dataType,
                kind: "value",
                value: {
                    kind: "exception",
                    context,
                    rawInformation: raw
                },
                interpretations: {}
            };
        }
        //another check: is only the deployed PC zero?
        if (deployedPc === 0 && constructorPc !== 0) {
            const error = {
                kind: "MalformedInternalFunctionError",
                context,
                rawInformation: raw
            };
            if (strict) {
                throw new errors_1.StopDecodingError(error);
            }
            return {
                type: dataType,
                kind: "error",
                error
            };
        }
        //one last pre-check: is this a deployed-format pointer in a constructor?
        if (info.currentContext.isConstructor && constructorPc === 0) {
            const error = {
                kind: "DeployedFunctionInConstructorError",
                context,
                rawInformation: raw
            };
            if (strict) {
                throw new errors_1.StopDecodingError(error);
            }
            return {
                type: dataType,
                kind: "error",
                error
            };
        }
    }
    //if we didn't hit any of those exceptional cases, we now attempt to look
    //up the function in the table
    let functionEntry;
    switch (raw.kind) {
        case "pcpair":
            const pc = info.currentContext.isConstructor
                ? raw.constructorProgramCounter
                : raw.deployedProgramCounter;
            functionEntry = info.internalFunctionsTable[pc];
            break;
        case "index":
            functionEntry = info.internalFunctionsTable[raw.functionIndex];
            break;
    }
    if (!functionEntry) {
        //If we didn't find an entry, this is an error
        const error = {
            kind: "NoSuchInternalFunctionError",
            context,
            rawInformation: raw
        };
        if (strict) {
            throw new errors_1.StopDecodingError(error);
        }
        return {
            type: dataType,
            kind: "error",
            error
        };
    }
    //finally, the rest of this handles the case where we did find an entry,
    //and doesn't need to switch on the raw info type anymore :)
    if (functionEntry.isDesignatedInvalid) {
        return {
            type: dataType,
            kind: "value",
            value: {
                kind: "exception",
                context,
                rawInformation: raw
            },
            interpretations: {}
        };
    }
    const name = functionEntry.name;
    const mutability = functionEntry.mutability;
    const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null
    const id = Evm.Import.makeInternalFunctionId(functionEntry);
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "function",
            context,
            rawInformation: raw,
            name,
            id,
            definedIn,
            mutability
        },
        interpretations: {}
    };
}
function checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {
    const length = (0, allocate_1.byteLength)(dataType, userDefinedTypes);
    const paddingType = getPaddingType(dataType, paddingMode);
    if (paddingMode === "permissive") {
        switch (dataType.typeClass) {
            case "bool":
            case "enum":
            case "function":
                //these three types are checked even in permissive mode
                return checkPaddingDirect(bytes, length, paddingType);
            default:
                return true;
        }
    }
    else {
        return checkPaddingDirect(bytes, length, paddingType);
    }
}
function removePadding(bytes, dataType, paddingMode, userDefinedTypes) {
    const length = (0, allocate_1.byteLength)(dataType, userDefinedTypes);
    const paddingType = getPaddingType(dataType, paddingMode);
    return removePaddingDirect(bytes, length, paddingType);
}
function removePaddingDirect(bytes, length, paddingType) {
    switch (paddingType) {
        case "right":
            return bytes.slice(0, length);
        default:
            return bytes.slice(-length);
    }
}
function checkPaddingDirect(bytes, length, paddingType) {
    switch (paddingType) {
        case "left":
            return checkPaddingLeft(bytes, length);
        case "right":
            return checkPaddingRight(bytes, length);
        case "signed":
            return checkPaddingSigned(bytes, length);
        case "signedOrLeft":
            return (checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length));
    }
}
function getPaddingType(dataType, paddingMode) {
    switch (paddingMode) {
        case "right":
            return "right";
        case "default":
        case "permissive":
            return defaultPaddingType(dataType);
        case "zero": {
            const defaultType = defaultPaddingType(dataType);
            return defaultType === "signed" ? "left" : defaultType;
        }
        case "defaultOrZero": {
            const defaultType = defaultPaddingType(dataType);
            return defaultType === "signed" ? "signedOrLeft" : defaultType;
        }
    }
}
function defaultPaddingType(dataType) {
    switch (dataType.typeClass) {
        case "bytes":
            return "right";
        case "int":
        case "fixed":
            return "signed";
        case "function":
            if (dataType.visibility === "external") {
                return "right";
            }
        //otherwise, fall through to default
        default:
            return "left";
    }
}
function checkPaddingRight(bytes, length) {
    let padding = bytes.slice(length); //cut off the first length bytes
    return padding.every(paddingByte => paddingByte === 0);
}
//exporting this one for use in stack.ts
function checkPaddingLeft(bytes, length) {
    let padding = bytes.slice(0, -length); //cut off the last length bytes
    return padding.every(paddingByte => paddingByte === 0);
}
exports.checkPaddingLeft = checkPaddingLeft;
function checkPaddingSigned(bytes, length) {
    let padding = bytes.slice(0, -length); //padding is all but the last length bytes
    let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes
    let signByte = value[0] & 0x80 ? 0xff : 0x00;
    return padding.every(paddingByte => paddingByte === signByte);
}
function* reverseEnsResolve(address) {
    const nameAsBytes = yield { type: "ens-primary-name", address };
    return nameAsBytes !== null ? (0, decode_1.decodeString)(nameAsBytes) : null;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 51561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeBasic = void 0;
const Conversion = __importStar(__webpack_require__(52714));
const Evm = __importStar(__webpack_require__(49218));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * Handles encoding of basic types; yes the input type is broader than
 * it should be but it's hard to fix this without causing other problems,
 * sorry!
 * @Category Encoding (low-level)
 */
function encodeBasic(input) {
    let bytes;
    switch (input.type.typeClass) {
        case "userDefinedValueType":
            return encodeBasic(input.value);
        case "uint":
        case "int":
            return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);
        case "enum":
            return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);
        case "bool": {
            bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes
            if (input.value.asBoolean) {
                bytes[Evm.Utils.WORD_SIZE - 1] = 1;
            }
            return bytes;
        }
        case "bytes":
            switch (input.type.kind) {
                //deliberately not handling dynamic case!
                case "static":
                    bytes = Conversion.toBytes(input.value.asHex);
                    let padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes
                    padded.set(bytes);
                    return padded;
            }
        case "address":
            return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);
        case "contract":
            return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);
        case "function": {
            switch (input.type.visibility) {
                //for our purposes here, we will NOT count internal functions as a
                //basic type!  so no handling of internal case
                case "external":
                    let coercedInput = input;
                    let encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s
                    let addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length
                    let selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length
                    encoded.set(addressBytes);
                    encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address
                    return encoded;
            }
            break; //to satisfy TS
        }
        case "fixed":
        case "ufixed":
            let bigValue = (input).value.asBig;
            let shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);
            return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);
    }
}
exports.encodeBasic = encodeBasic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 53928:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For decoding of primitives and constants
 *
 * @protected
 *
 * @packageDocumentation
 */
//Category: Common data location
//[NOT making this an actual category for now
//since there's nothing public in it]
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Allocate = exports.Encode = exports.Decode = void 0;
const Decode = __importStar(__webpack_require__(57939));
exports.Decode = Decode;
const Encode = __importStar(__webpack_require__(51561));
exports.Encode = Encode;
const Allocate = __importStar(__webpack_require__(49107));
exports.Allocate = Allocate;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 59495:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeString = exports.decodeBytes = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:bytes:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Conversion = __importStar(__webpack_require__(52714));
const errors_1 = __webpack_require__(72325);
const utf8_1 = __importDefault(__webpack_require__(57458));
function* decodeBytes(dataType, pointer, info, options = {}) {
    const { state } = info;
    const { strictAbiMode: strict } = options; //if this is undefined it'll still be falsy so OK
    let bytes;
    try {
        bytes = yield* (0, read_1.default)(pointer, state);
    }
    catch (error) {
        debug("segfault, pointer %o, state: %O", pointer, state);
        return (0, errors_1.handleDecodingError)(dataType, error, strict);
    }
    debug("type %O", dataType);
    debug("pointer %o", pointer);
    //note: this function does not check padding
    switch (dataType.typeClass) {
        case "bytes":
            //we assume this is a dynamic bytestring!
            //static ones should go to decodeBasic!
            return {
                type: dataType,
                kind: "value",
                value: {
                    asHex: Conversion.toHexString(bytes)
                },
                interpretations: {}
            };
        case "string":
            return {
                type: dataType,
                kind: "value",
                value: decodeString(bytes),
                interpretations: {}
            };
    }
}
exports.decodeBytes = decodeBytes;
function decodeString(bytes) {
    //the following line takes our UTF-8 string... and interprets each byte
    //as a UTF-16 bytepair.  Yikes!  Fortunately, we have a library to repair that.
    let badlyEncodedString = String.fromCharCode.apply(undefined, bytes);
    try {
        //this will throw an error if we have malformed UTF-8
        let correctlyEncodedString = utf8_1.default.decode(badlyEncodedString);
        //NOTE: we don't use node's builtin Buffer class to do the UTF-8 decoding
        //here, because that handles malformed UTF-8 by means of replacement characters
        //(U+FFFD).  That loses information.  So we use the utf8 package instead,
        //and... well, see the catch block below.
        return {
            kind: "valid",
            asString: correctlyEncodedString
        };
    }
    catch (_a) {
        //we're going to ignore the precise error and just assume it's because
        //the string was malformed (what else could it be?)
        let hexString = Conversion.toHexString(bytes);
        return {
            kind: "malformed",
            asHex: hexString
        };
    }
}
exports.decodeString = decodeString;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 53951:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeBytes = void 0;
const Conversion = __importStar(__webpack_require__(52714));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * Encodes without padding, length, etc!
 *
 * @Category Encoding (low-level)
 */
function encodeBytes(input) {
    switch (input.type.typeClass) {
        case "bytes":
            return Conversion.toBytes(input.value.asHex);
        case "string": {
            let coercedInput = (input);
            switch (coercedInput.value.kind) {
                case "valid":
                    return Conversion.stringToBytes(coercedInput.value.asString);
                case "malformed":
                    return Conversion.toBytes(coercedInput.value.asHex);
            }
        }
    }
}
exports.encodeBytes = encodeBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 67689:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * Contains functions for dealing with raw bytestrings
 * @protected
 *
 * @packageDocumentation
 */
//Category: Common data location
//[NOT making this an actual category for now
//since there's nothing public in it]
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Encode = exports.Decode = exports.Read = void 0;
const Read = __importStar(__webpack_require__(20281));
exports.Read = Read;
const Decode = __importStar(__webpack_require__(59495));
exports.Decode = Decode;
const Encode = __importStar(__webpack_require__(53951));
exports.Encode = Encode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 20281:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readBytes = exports.readCode = void 0;
const Evm = __importStar(__webpack_require__(49218));
const errors_1 = __webpack_require__(72325);
function* readCode(pointer, state) {
    let code = state.code;
    if (!code) {
        const address = Evm.Utils.toAddress(state.specials.this);
        code = yield {
            type: "code",
            address
        };
        if (code === null) {
            //check for null as a way to deliberately indicate an error
            throw new errors_1.DecodingError({
                kind: "CodeNotSuppliedError",
                address
            });
        }
    }
    return readBytes(pointer, Object.assign(Object.assign({}, state), { code }));
}
exports.readCode = readCode;
function readBytes(pointer, state) {
    let sourceBytes = state[pointer.location];
    const { start: offset, length } = pointer;
    if (!Number.isSafeInteger(offset + length)) {
        throw new errors_1.DecodingError({
            kind: "ReadErrorBytes",
            location: pointer.location,
            start: offset,
            length
        });
    }
    // grab `length` bytes no matter what, here fill this array
    var bytes = new Uint8Array(length);
    bytes.fill(0); //fill it wil zeroes to start
    //if the start is beyond the end of the source, just return those 0s
    if (offset >= sourceBytes.length) {
        return bytes;
    }
    // if we're reading past the end of the source, truncate the length to read
    let excess = offset + length - sourceBytes.length;
    let readLength;
    if (excess > 0) {
        readLength = sourceBytes.length - offset;
    }
    else {
        readLength = length;
    }
    //get the (truncated) bytes
    let existing = new Uint8Array(sourceBytes.buffer, offset, readLength);
    //copy it into our buffer
    bytes.set(existing);
    return bytes;
}
exports.readBytes = readBytes;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99987:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(99147), exports); //can't do 'export type *' :-/
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 99147:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownUserDefinedTypeError = void 0;
/**
 * This error indicates that the decoder was unable to locate a user-defined
 * type (struct, enum, or contract type) via its ID.  Unfortunately, we can't
 * always avoid this at the moment; we're hoping to make this more robust in
 * the future with Truffle DB.  In the meantime, it is at least worth noting that
 * you should not encounter this error if your entire project was written in
 * Solidity and all compiled at once.  Sorry.
 *
 * @Category Errors
 */
class UnknownUserDefinedTypeError extends Error {
    constructor(id, typeString) {
        const message = `Cannot locate definition for ${typeString} (ID ${id})`;
        super(message);
        this.name = "UnknownUserDefinedTypeError";
        this.id = id;
        this.typeString = typeString;
    }
}
exports.UnknownUserDefinedTypeError = UnknownUserDefinedTypeError;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 44894:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
__exportStar(__webpack_require__(9612), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(72972));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9612:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 72972:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.findRepeatCompilationIds = exports.infoToCompilations = exports.findCompilationAndContract = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:compilations:utils");
const Ast = __importStar(__webpack_require__(14442));
const compile_common_1 = __webpack_require__(29833);
const Format = __importStar(__webpack_require__(29965));
const errors_1 = __webpack_require__(72325);
function shimCompilations(inputCompilations, shimmedCompilationIdPrefix = "shimmedcompilation") {
    return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, `${shimmedCompilationIdPrefix}Number(${compilationIndex})`));
}
exports.shimCompilations = shimCompilations;
function shimCompilation(inputCompilation, shimmedCompilationId = "shimmedcompilation") {
    return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {
        files: inputCompilation.sourceIndexes,
        sources: inputCompilation.sources,
        shimmedCompilationId,
        compiler: inputCompilation.compiler
    })), { compiler: inputCompilation.compiler });
}
exports.shimCompilation = shimCompilation;
/**
 * wrapper around shimContracts that just returns
 * the result in a one-element array (keeping the old name
 * shimArtifacts for compatibility)
 */
function shimArtifacts(artifacts, files, shimmedCompilationId = "shimmedcompilation") {
    return [shimContracts(artifacts, { files, shimmedCompilationId })];
}
exports.shimArtifacts = shimArtifacts;
/**
 * shims a bunch of contracts ("artifacts", though not necessarily)
 * to a compilation.  usually used via one of the above functions.
 * Note: if you pass in options.sources, options.files will be ignored.
 * Note: if you pass in options.sources, sources will not have
 * compiler set unless you also pass in options.compiler; in this case
 * you should set that up separately, as in shimCompilation().
 */
function shimContracts(artifacts, options = {}) {
    const { files, sources: inputSources } = options;
    const shimmedCompilationId = options.shimmedCompilationId || "shimmedcompilation";
    let contracts = [];
    let sources = [];
    let unreliableSourceOrder = false;
    for (let artifact of artifacts) {
        let { contractName, bytecode, sourceMap, deployedBytecode, deployedSourceMap, immutableReferences, sourcePath, source, ast, abi, compiler, generatedSources, deployedGeneratedSources, metadata } = artifact;
        if (artifact.contract_name) {
            //just in case
            contractName = artifact.contract_name;
            //dunno what's up w/ the type of contract_name, but it needs coercing
        }
        debug("contractName: %s", contractName);
        let contractObject = {
            contractName,
            bytecode,
            sourceMap,
            deployedBytecode,
            deployedSourceMap,
            immutableReferences,
            abi,
            generatedSources: normalizeGeneratedSources(generatedSources, compiler),
            deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),
            compiler
        };
        let sourceObject = {
            sourcePath,
            source,
            ast: ast,
            compiler,
            language: inferLanguage(ast, compiler, sourcePath)
        };
        //ast needs to be coerced because schema doesn't quite match our types here...
        if (metadata) {
            try {
                const parsedMetadata = JSON.parse(metadata); //sorry
                const settings = parsedMetadata.settings;
                const viaIR = settings.viaIR;
                contractObject.settings = { viaIR };
                sourceObject.settings = { viaIR };
            }
            catch (_a) {
                //if metadata doesn't parse, or we hit undefineds, ignore it
            }
        }
        //if files or sources was passed, trust that to determine the source index
        //(assuming we have a sourcePath! currently it will be absent when dealing with
        //Solidity versions <0.4.9; presumably we will fix this if we ever properly
        //support versions that old, but for now this is necessary to get debug -x to work)
        if ((files || inputSources) && sourcePath) {
            //note: we never set the unreliableSourceOrder flag in this branch;
            //we just trust files/sources.  If this info is bad, then, uh, too bad.
            debug("inputSources: %O", inputSources);
            debug("files: %O", files);
            debug("sourcePath: %O", sourcePath);
            const index = inputSources
                ? inputSources.findIndex(source => source.sourcePath === sourcePath)
                : files.indexOf(sourcePath);
            if (!inputSources) {
                //if inputSources was passed, we'll handle this separately below
                sourceObject.id = index.toString(); //HACK
                sources[index] = sourceObject;
            }
            debug("files || inputSources; index: %d", index);
            contractObject.primarySourceId = index.toString(); //HACK
        }
        else {
            //if neither was passed, attempt to determine it from the ast
            let index;
            let needsAdding;
            if (sourceObject.ast) {
                //note: this works for both Solidity and Vyper
                index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons
            }
            else if (compiler && compiler.name === "vyper") {
                index = 0; //if it's Vyper but there's no AST, we can
                //assume that it was compiled alone and therefore has index 0
            }
            //if that didn't work, try the source map
            if (index === undefined && (sourceMap || deployedSourceMap)) {
                const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);
                index = extractPrimarySource(sourceMapString);
            }
            //else leave undefined for now
            ({ index, needsAdding, unreliableSourceOrder } = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder));
            if (needsAdding) {
                //if we're in this case, inputSources was not passed
                sourceObject.id = index.toString(); //HACK
                sources[index] = sourceObject;
                debug("else; index: %d", index);
            }
            //whether needed adding or not, set the source ID on the contract object
            contractObject.primarySourceId = index.toString(); //HACK
            debug("(no index unless mentioned)");
        }
        contracts.push(contractObject);
    }
    //now: check for id overlap with internal sources
    //(don't bother if inputSources or files was passed)
    if (!inputSources && !files) {
        for (let contract of contracts) {
            const { generatedSources, deployedGeneratedSources } = contract;
            for (let index in generatedSources) {
                if (index in sources) {
                    unreliableSourceOrder = true;
                }
            }
            for (let index in deployedGeneratedSources) {
                if (index in sources) {
                    unreliableSourceOrder = true;
                }
            }
        }
    }
    let compiler;
    if (options.compiler) {
        compiler = options.compiler;
    }
    else if (!unreliableSourceOrder && contracts.length > 0) {
        //if things were actually compiled together, we should just be able
        //to pick an arbitrary one
        compiler = contracts[0].compiler;
    }
    let settings; //we'll do the same thing with settings
    if (options.settings) {
        settings = options.settings;
    }
    else if (!unreliableSourceOrder && contracts.length > 0) {
        //if things were actually compiled together, we should just be able
        //to pick an arbitrary one
        settings = contracts[0].settings;
    }
    //if input sources was passed, set up the sources object directly :)
    if (inputSources) {
        sources = inputSources.map(({ sourcePath, contents: source, ast, language }, index) => ({
            sourcePath,
            source,
            ast: ast,
            language,
            id: index.toString(),
            compiler //redundant but let's include it
        }));
    }
    return {
        id: shimmedCompilationId,
        unreliableSourceOrder,
        sources,
        contracts,
        compiler,
        settings
    };
}
exports.shimContracts = shimContracts;
//note: this works for Vyper too!
function sourceIndexForAst(ast) {
    if (Array.isArray(ast)) {
        //special handling for old Vyper versions
        ast = ast[0];
    }
    if (!ast) {
        return undefined;
    }
    if (ast.nodeType === "YulObject") {
        //Yul needs some special handling...
        ast = ast.code.block;
    }
    return parseInt(ast.src.split(":")[2]);
    //src is given as start:length:file.
    //we want just the file.
}
function getContractNode(contract, compilation) {
    const { contractName, sourceMap, deployedSourceMap, primarySourceId } = contract;
    const { unreliableSourceOrder, sources } = compilation;
    let sourcesToCheck;
    //we will attempt to locate the primary source;
    //if we can't find it, we'll just check every source in this
    //compilation.
    if (primarySourceId !== undefined) {
        sourcesToCheck = [
            sources.find(source => source && source.id === primarySourceId)
        ];
    }
    else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {
        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);
        let sourceId = extractPrimarySource(sourceMapString);
        sourcesToCheck = [sources[sourceId]];
    }
    else {
        //WARNING: if we end up in this case, we could get the wrong contract!
        //(but we shouldn't end up here)
        sourcesToCheck = sources;
    }
    return sourcesToCheck.reduce((foundNode, source) => {
        if (foundNode || !source) {
            return foundNode;
        }
        if (!source.ast || source.language !== "Solidity") {
            //ignore non-Solidity ASTs for now, we don't support them yet
            return undefined;
        }
        return source.ast.nodes.find(node => node.nodeType === "ContractDefinition" && node.name === contractName);
    }, undefined);
}
exports.getContractNode = getContractNode;
/**
 * extract the primary source from a source map
 * (i.e., the source for the first instruction, found
 * between the second and third colons)
 */
function extractPrimarySource(sourceMap) {
    if (!sourceMap) {
        //HACK?
        return 0; //in this case (e.g. a Vyper contract with an old-style
        //source map) we infer that it was compiled by itself
    }
    return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || "0");
}
function normalizeGeneratedSources(generatedSources, compiler) {
    if (!generatedSources) {
        return [];
    }
    if (!isGeneratedSources(generatedSources)) {
        return generatedSources; //if already normalizeed, leave alone
    }
    let sources = []; //output
    for (let source of generatedSources) {
        sources[source.id] = {
            id: source.id.toString(),
            sourcePath: source.name,
            source: source.contents,
            //ast needs to be coerced because schema doesn't quite match our types here...
            ast: source.ast,
            compiler: compiler,
            language: source.language
        };
    }
    return sources;
}
//HACK
function isGeneratedSources(sources) {
    //note: for some reason arr.includes(undefined) returns true on sparse arrays
    //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization
    return (sources.length > 0 &&
        !sources.includes(undefined) &&
        (sources[0].contents !== undefined ||
            sources[0].name !== undefined));
}
//HACK, maybe?
function inferLanguage(ast, compiler, sourcePath) {
    if (ast) {
        if (ast.nodeType === "SourceUnit") {
            return "Solidity";
        }
        else if (ast.nodeType && ast.nodeType.startsWith("Yul")) {
            //Every Yul source I've seen has YulBlock as the root, but
            //I'm not sure that that's *always* the case
            return "Yul";
        }
        else if (Array.isArray(ast) || ast.ast_type === "Module") {
            return "Vyper";
        }
    }
    else if (compiler) {
        if (compiler.name === "vyper") {
            return "Vyper";
        }
        else if (compiler.name === "solc") {
            //assuming sources compiled with solc without sourcePath are Solidity
            if (sourcePath && sourcePath.endsWith(".yul")) {
                return "Yul";
            }
            else {
                return "Solidity";
            }
        }
        else {
            return undefined;
        }
    }
    else {
        return undefined;
    }
}
function getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {
    debug("sourcePath: %s", sourceObject.sourcePath);
    debug("given index: %d", index);
    debug("sources: %o", sources.map(source => source.sourcePath));
    //first: is this already there? only add it if it's not.
    //(we determine this by sourcePath if present, and the actual source
    //contents if not)
    const existingIndex = sources.findIndex(existingSource => existingSource && //findIndex treats absent as undefined, so we need this guard
        // (array may be sparse)
        (existingSource.sourcePath === sourceObject.sourcePath ||
            (!sourceObject.sourcePath &&
                !existingSource.sourcePath &&
                existingSource.source === sourceObject.source)));
    if (existingIndex === -1) {
        //it's not already there, let's add it
        if (unreliableSourceOrder || index === undefined || index in sources) {
            //if we can't add it at the correct spot, set the
            //unreliable source order flag
            debug("collision!");
            unreliableSourceOrder = true;
        }
        if (unreliableSourceOrder) {
            //in case of unreliable source order, we'll ignore what indices
            //things are *supposed* to have and just append things to the end
            index = sources.length;
        }
        //otherwise, just leave things alone
        return {
            index,
            needsAdding: true,
            unreliableSourceOrder
        };
    }
    else {
        debug("already present, not adding");
        return {
            index: existingIndex,
            needsAdding: false,
            unreliableSourceOrder
        };
    }
}
/**
 * convert Vyper source maps to solidity ones
 * (note we won't bother handling the case where the compressed
 * version doesn't exist; that will have to wait for a later version)
 */
function simpleShimSourceMap(sourceMap) {
    if (sourceMap === undefined) {
        return undefined; //undefined case
    }
    else if (typeof sourceMap === "object") {
        return sourceMap.pc_pos_map_compressed; //Vyper object case
    }
    else {
        try {
            return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case
        }
        catch (_) {
            return sourceMap; //Solidity case
        }
    }
}
exports.simpleShimSourceMap = simpleShimSourceMap;
/**
 * collects user defined types & tagged outputs for a given set of compilations,
 * returning both the definition nodes and (for the types) the type objects
 *
 * "Tagged outputs" means user-defined things that are output by a contract
 * (not input to a contract), and which are distinguished by (potentially
 * ambiguous) selectors.  So, events and custom errors are tagged outputs.
 * Function arguments are not tagged outputs (they're not outputs).
 * Return values are not tagged outputs (they don't have a selector).
 * Built-in errors (Error(string) and Panic(uint))... OK I guess those could
 * be considered tagged outputs, but we're only looking at user-defined ones
 * here.
 */
function collectUserDefinedTypesAndTaggedOutputs(compilations) {
    let references = {};
    let types = {};
    for (const compilation of compilations) {
        references[compilation.id] = {};
        types[compilation.id] = {
            compiler: compilation.compiler,
            types: {}
        };
        for (const source of compilation.sources) {
            if (!source) {
                continue; //remember, sources could be empty if shimmed!
            }
            const { ast, compiler, language } = source;
            if (language === "Solidity" && ast) {
                //don't check Yul or Vyper sources!
                for (const node of ast.nodes) {
                    if (node.nodeType === "StructDefinition" ||
                        node.nodeType === "EnumDefinition" ||
                        node.nodeType === "UserDefinedValueTypeDefinition" ||
                        node.nodeType === "ContractDefinition") {
                        references[compilation.id][node.id] = node;
                        //we don't have all the references yet, but we actually don't need them :)
                        const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);
                        types[compilation.id].types[dataType.id] = dataType;
                    }
                    else if (node.nodeType === "EventDefinition" ||
                        node.nodeType === "ErrorDefinition") {
                        references[compilation.id][node.id] = node;
                    }
                    if (node.nodeType === "ContractDefinition") {
                        for (const subNode of node.nodes) {
                            if (subNode.nodeType === "StructDefinition" ||
                                subNode.nodeType === "EnumDefinition" ||
                                subNode.nodeType === "UserDefinedValueTypeDefinition") {
                                references[compilation.id][subNode.id] = subNode;
                                //we don't have all the references yet, but we only need the
                                //reference to the defining contract, which we just added above!
                                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);
                                types[compilation.id].types[dataType.id] = dataType;
                            }
                            else if (subNode.nodeType === "EventDefinition" ||
                                subNode.nodeType === "ErrorDefinition") {
                                references[compilation.id][subNode.id] = subNode;
                            }
                        }
                    }
                }
            }
        }
    }
    return {
        definitions: references,
        typesByCompilation: types,
        types: Format.Types.forgetCompilations(types)
    };
}
exports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;
/**
 * Given a list of compilations, and an artifact appearing in one
 * of those compilations, finds the compilation and the corresponding
 * contract object
 * (these may be undefined if they can't be found)
 */
function findCompilationAndContract(compilations, artifact) {
    const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.deployedBytecode);
    const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(artifact.bytecode);
    let firstNameMatch;
    let multipleNameMatches = false;
    for (const compilation of compilations) {
        for (const contract of compilation.contracts) {
            const nameMatches = contract.contractName ===
                (artifact.contractName || artifact.contract_name);
            if (nameMatches) {
                if (bytecode) {
                    if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode) === bytecode) {
                        return { compilation, contract };
                    }
                }
                else if (deployedBytecode) {
                    if (compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode) ===
                        deployedBytecode) {
                        return { compilation, contract };
                    }
                }
                else if (!firstNameMatch) {
                    //if we have a name match, but no bytecode to go by, record this one.
                    //if it turns out to be the only one, we'll return it later.
                    firstNameMatch = { compilation, contract };
                }
                else if (!multipleNameMatches) {
                    //on the other hand, if there *is* an existing name match already,
                    //record that we've got multiple.
                    multipleNameMatches = true;
                }
            }
        }
    }
    //once the loop is done, if we haven't returned a bytecode match,
    //check if we've got a unique name match, and return it if so
    if (firstNameMatch && !multipleNameMatches) {
        return firstNameMatch;
    }
    //otherwise, if there's no bytecode match, and either no name match
    //or multiple name matches, just return a default fallback
    const defaultContract = {
        contractName: artifact.contractName || artifact.contract_name,
        abi: artifact.abi
    };
    const defaultCompilation = {
        id: "defaultCompilation",
        sources: [],
        contracts: [defaultContract]
    };
    return {
        compilation: defaultCompilation,
        contract: defaultContract
    };
}
exports.findCompilationAndContract = findCompilationAndContract;
function projectInfoIsCodecStyle(info) {
    return Boolean(info.compilations);
}
function projectInfoIsCommonStyle(info) {
    return Boolean(info.commonCompilations);
}
function projectInfoIsArtifacts(info) {
    return Boolean(info.artifacts);
}
function infoToCompilations(projectInfo, nonceString) {
    if (!projectInfo) {
        throw new errors_1.NoProjectInfoError();
    }
    if (projectInfoIsCodecStyle(projectInfo)) {
        return projectInfo.compilations;
    }
    else if (projectInfoIsCommonStyle(projectInfo)) {
        return shimCompilations(projectInfo.commonCompilations, nonceString);
    }
    else if (projectInfoIsArtifacts(projectInfo)) {
        return shimArtifacts(projectInfo.artifacts, undefined, nonceString);
    }
}
exports.infoToCompilations = infoToCompilations;
function findRepeatCompilationIds(compilations) {
    let repeats = new Set();
    for (let i = 0; i < compilations.length; i++) {
        for (let j = i + 1; j < compilations.length; j++) {
            if (compilations[i].id === compilations[j].id) {
                repeats.add(compilations[i].id);
            }
        }
    }
    return repeats;
}
exports.findRepeatCompilationIds = findRepeatCompilationIds;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 84159:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = void 0;
__exportStar(__webpack_require__(16041), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(19228));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 16041:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 19228:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.solidityFamily = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:compiler:utils");
const semver_1 = __importDefault(__webpack_require__(81249));
function solidityFamily(compiler) {
    if (!compiler || compiler.name !== "solc") {
        return "unknown";
    }
    if (semver_1.default.satisfies(compiler.version, ">=0.8.18", {
        includePrerelease: true
    })) {
        return "0.8.18+";
    }
    else if (semver_1.default.satisfies(compiler.version, ">=0.8.9", {
        includePrerelease: true
    })) {
        return "0.8.9+";
    }
    else if (semver_1.default.satisfies(compiler.version, ">=0.8.7", {
        includePrerelease: true
    })) {
        return "0.8.7+";
    }
    else if (
    //see comment below about the weird-looking condition
    semver_1.default.satisfies(compiler.version, "~0.8 || >=0.8.0", {
        includePrerelease: true
    })) {
        return "0.8.x";
    }
    else if (semver_1.default.satisfies(compiler.version, "~0.5 || >=0.5.0", {
        includePrerelease: true
    })) {
        //what's with this weird-looking condition?  Well, I want to be sure to include
        //prerelease versions of 0.5.0.  But isn't that what the includePrerelease option
        //does?  No!  That just makes it so that prerelease versions can be included at
        //all; without that, all prereleases of *any* version of Solidity can be excluded.
        //A prerelease version of 0.5.0 still wouldn't satisfy >=0.5.0, so I added in ~0.5
        //as well, which they do satisfy.
        return "0.5.x";
    }
    else {
        return "pre-0.5.0";
    }
}
exports.solidityFamily = solidityFamily;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 60013:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeTypeId = exports.contextToType = void 0;
function contextToType(context) {
    if (context.contractId !== undefined) {
        return {
            typeClass: "contract",
            kind: "native",
            id: makeTypeId(context.contractId, context.compilationId),
            typeName: context.contractName,
            contractKind: context.contractKind,
            payable: context.payable
        };
    }
    else {
        return {
            typeClass: "contract",
            kind: "foreign",
            typeName: context.contractName,
            contractKind: context.contractKind,
            payable: context.payable
        };
    }
}
exports.contextToType = contextToType;
//NOTE: I am exporting this for use in other import functions, but please don't
//use this elsewhere!
//If you have to make a type ID, instead make the type and then
//take its ID.
function makeTypeId(astId, compilationId) {
    return `${compilationId}:${astId}`;
}
exports.makeTypeId = makeTypeId;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 97938:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Import = void 0;
__exportStar(__webpack_require__(42986), exports); //'export type *' is not allowed
const Import = __importStar(__webpack_require__(60013));
exports.Import = Import;
const Utils = __importStar(__webpack_require__(81099));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 42986:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 81099:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeContext = exports.normalizeContexts = exports.matchContext = exports.findContext = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:contexts:utils");
const Evm = __importStar(__webpack_require__(49218));
const Conversion = __importStar(__webpack_require__(52714));
const escapeRegExp_1 = __importDefault(__webpack_require__(3522));
const cbor = __importStar(__webpack_require__(82141));
const compile_common_1 = __webpack_require__(29833);
const Abi = __importStar(__webpack_require__(7651));
const AbiDataUtils = __importStar(__webpack_require__(85941));
function findContext(contexts, binary) {
    const matchingContexts = Object.values(contexts).filter(context => matchContext(context, binary));
    //rather than just pick an arbitrary matching context, we're going
    //to pick one that isn't a descendant of any of the others.
    //(if there are multiple of *those*, then yeah it's arbitrary.)
    const context = matchingContexts.find(descendant => !matchingContexts.some(ancestor => descendant.compilationId === ancestor.compilationId &&
        descendant.linearizedBaseContracts &&
        ancestor.contractId !== undefined &&
        descendant.linearizedBaseContracts
            .slice(1)
            .includes(ancestor.contractId)
    //we do slice one because everything is an an ancestor of itself; we only
    //care about *proper* ancestors
    ));
    return context || null;
}
exports.findContext = findContext;
function matchContext(context, givenBinary) {
    const { binary, compiler, isConstructor } = context;
    const lengthDifference = givenBinary.length - binary.length;
    //first: if it's not a constructor, and it's not Vyper,
    //they'd better be equal in length.
    //if it is a constructor, or is Vyper,
    //the given binary must be at least as long,
    //and the difference must be a multiple of 32 bytes (64 hex digits)
    const additionalAllowed = isConstructor || (compiler != undefined && compiler.name === "vyper");
    if ((!additionalAllowed && lengthDifference !== 0) ||
        lengthDifference < 0 ||
        lengthDifference % (2 * Evm.Utils.WORD_SIZE) !== 0) {
        return false;
    }
    for (let i = 0; i < binary.length; i++) {
        //note: using strings like arrays is kind of dangerous in general in JS,
        //but everything here is ASCII so it's fine
        //note that we need to compare case-insensitive, since Solidity will
        //put addresses in checksum case in the compiled source
        //(we don't actually need that second toLowerCase(), but whatever)
        if (binary[i] !== "." &&
            binary[i].toLowerCase() !== givenBinary[i].toLowerCase()) {
            return false;
        }
    }
    return true;
}
exports.matchContext = matchContext;
function normalizeContexts(contexts) {
    //unfortunately, due to our current link references format, we can't
    //really use the binary from the artifact directly -- neither for purposes
    //of matching, nor for purposes of decoding internal functions.  So, we
    //need to perform this normalization step on our contexts before using
    //them.  Once we have truffle-db, this step should largely go away.
    debug("normalizing contexts");
    //first, let's clone the input
    //(let's do a 2-deep clone because we'll be altering binary & compiler)
    let newContexts = Object.assign({}, ...Object.entries(contexts).map(([contextHash, context]) => ({
        [contextHash]: Object.assign({}, context)
    })));
    debug("contexts cloned");
    //next, we get all the library names and sort them descending by length.
    //We're going to want to go in descending order of length so that we
    //don't run into problems when one name is a substring of another.
    //For simplicity, we'll exclude names of length <38, because we can
    //handle these with our more general check for link references at the end
    const fillerLength = 2 * Evm.Utils.ADDRESS_SIZE;
    let names = Object.values(newContexts)
        .filter(context => context.contractKind === "library")
        .map(context => context.contractName)
        .filter(name => name.length >= fillerLength - 3)
        //the -3 is for 2 leading underscores and 1 trailing
        .sort((name1, name2) => name2.length - name1.length);
    debug("names sorted");
    //now, we need to turn all these names into regular expressions, because,
    //unfortunately, str.replace() will only replace all if you use a /g regexp;
    //note that because names may contain '$', we need to escape them
    //(also we prepend "__" because that's the placeholder format)
    let regexps = names.map(name => new RegExp((0, escapeRegExp_1.default)("__" + name), "g"));
    debug("regexps prepared");
    //having done so, we can do the replace for these names!
    const replacement = ".".repeat(fillerLength);
    for (let regexp of regexps) {
        for (let context of Object.values(newContexts)) {
            context.binary = context.binary.replace(regexp, replacement);
        }
    }
    debug("long replacements complete");
    //now we can do a generic replace that will catch all names of length
    //<40, while also catching the Solidity compiler's link reference format
    //as well as Truffle's.  Hooray!
    const genericRegexp = new RegExp("_.{" + (fillerLength - 2) + "}_", "g");
    //we're constructing the regexp /_.{38}_/g, but I didn't want to use a
    //literal 38 :P
    for (let context of Object.values(newContexts)) {
        context.binary = context.binary.replace(genericRegexp, replacement);
    }
    debug("short replacements complete");
    //now we must handle the delegatecall guard -- libraries' deployedBytecode will include
    //0s in place of their own address instead of a link reference at the
    //beginning, so we need to account for that too
    const pushAddressInstruction = (0x5f + Evm.Utils.ADDRESS_SIZE).toString(16); //"73"
    for (let context of Object.values(newContexts)) {
        if (context.contractKind === "library" && !context.isConstructor) {
            context.binary = context.binary.replace("0x" + pushAddressInstruction + "00".repeat(Evm.Utils.ADDRESS_SIZE), "0x" + pushAddressInstruction + replacement);
        }
    }
    debug("extra library replacements complete");
    //now let's handle immutable references
    //(these are much nicer than link references due to not having to deal with the old format)
    for (let context of Object.values(newContexts)) {
        if (context.immutableReferences) {
            for (let variable of Object.values(context.immutableReferences)) {
                for (let { start, length } of (variable)) {
                    //Goddammit TS
                    let lowerStringIndex = 2 + 2 * start;
                    let upperStringIndex = 2 + 2 * (start + length);
                    context.binary =
                        context.binary.slice(0, lowerStringIndex) +
                            "..".repeat(length) +
                            context.binary.slice(upperStringIndex);
                }
            }
        }
    }
    debug("immutables complete");
    //now: extract & decode all the cbor's.  we're going to use these for
    //two different purposes, so let's just get them all upfront.
    let cborInfos = {};
    let decodedCbors = {};
    //note: invalid cbor will be indicated in decodedCbors by the lack of an entry,
    //*not* by undefined or null, since there exists cbor for those :P
    for (const [contextHash, context] of Object.entries(newContexts)) {
        const cborInfo = extractCborInfo(context.binary);
        cborInfos[contextHash] = cborInfo;
        if (cborInfo) {
            try {
                //note this *will* throw if there's data left over,
                //which is what we want it to do
                const decoded = cbor.decodeFirstSync(cborInfo.cbor);
                decodedCbors[contextHash] = decoded;
            }
            catch (_a) {
                //just don't add it
            }
        }
    }
    debug("intial cbor processing complete");
    //now: if a context lacks a compiler, but a version can be found in the
    //cbor, add it.
    for (let [contextHash, context] of Object.entries(newContexts)) {
        if (!context.compiler && contextHash in decodedCbors) {
            context.compiler = detectCompilerInfo(decodedCbors[contextHash]);
        }
    }
    debug("versions complete");
    //one last step: where there's CBOR with a metadata hash, we'll allow the
    //CBOR to vary, aside from the length (note: ideally here we would *only*
    //dot-out the metadata hash part of the CBOR, but, well, it's not worth the
    //trouble to detect that; doing that could potentially get pretty involved)
    //note that if the code isn't Solidity, that's fine -- we just won't get
    //valid CBOR and will not end up adding to our list of regular expressions
    const externalCborInfos = Object.entries(cborInfos)
        .filter(([contextHash, _cborInfo]) => contextHash in decodedCbors &&
        isObjectWithHash(decodedCbors[contextHash]))
        .map(([_contextHash, cborInfo]) => cborInfo);
    const cborRegexps = externalCborInfos.map(cborInfo => ({
        input: new RegExp(cborInfo.cborSegment, "g"),
        output: "..".repeat(cborInfo.cborLength) + cborInfo.cborLengthHex
    }));
    //HACK: we will replace *every* occurrence of *every* external CBOR occurring
    //in *every* context, in order to cover created contracts (including if there
    //are multiple or recursive ones)
    for (let context of Object.values(newContexts)) {
        for (let { input, output } of cborRegexps) {
            context.binary = context.binary.replace(input, output);
        }
    }
    debug("external wildcards complete");
    //finally, return this mess!
    return newContexts;
}
exports.normalizeContexts = normalizeContexts;
//returns cbor info if cbor section is found, null if it is not.
//note that it does not account for Vyper 0.3.4's idiosyncratic format
//and so will return null on that.  but that's OK, because Vyper 0.3.4's
//CBOR section is always fixed, so there isn't a need to normalize it here
function extractCborInfo(binary) {
    debug("extracting cbor segement of %s", binary);
    const lastTwoBytes = binary.slice(2).slice(-2 * 2); //2 bytes * 2 for hex
    //the slice(2) there may seem unnecessary; it's to handle the possibility that the contract
    //has less than two bytes in its bytecode (that won't happen with Solidity, but let's be
    //certain)
    if (lastTwoBytes.length < 2 * 2) {
        return null; //don't try to handle this case!
    }
    const cborLength = parseInt(lastTwoBytes, 16);
    const cborEnd = binary.length - 2 * 2;
    const cborStart = cborEnd - cborLength * 2;
    //sanity check
    if (cborStart < 2) {
        //"0x"
        return null; //don't try to handle this case!
    }
    const cbor = binary.slice(cborStart, cborEnd);
    return {
        cborStart,
        cborLength,
        cborEnd,
        cborLengthHex: lastTwoBytes,
        cbor,
        cborSegment: cbor + lastTwoBytes
    };
}
function isObjectWithHash(decoded) {
    if (typeof decoded !== "object" || decoded === null) {
        return false;
    }
    //cbor sometimes returns maps and sometimes objects,
    //so let's make things consistent by converting to a map
    //(actually, is this true? borc did this, I think cbor
    //does too, but I haven't checked recently)
    if (!(decoded instanceof Map)) {
        decoded = new Map(Object.entries(decoded));
    }
    const hashKeys = ["bzzr0", "bzzr1", "ipfs"];
    return hashKeys.some(key => decoded.has(key));
}
//returns undefined if no valid compiler info detected
//(if it detects solc but no version, it will not return
//a partial result, just undefined)
function detectCompilerInfo(decoded) {
    if (typeof decoded !== "object" || decoded === null) {
        return undefined;
    }
    //cbor sometimes returns maps and sometimes objects,
    //so let's make things consistent by converting to a map
    //(although see note above?)
    if (!(decoded instanceof Map)) {
        decoded = new Map(Object.entries(decoded));
    }
    if (!decoded.has("solc")) {
        //return undefined if the solc version field is not present
        //(this occurs if version <0.5.9)
        //currently no other language attaches cbor info, so, yeah
        return undefined;
    }
    const rawVersion = decoded.get("solc");
    if (typeof rawVersion === "string") {
        //for prerelease versions, the version is stored as a string.
        return {
            name: "solc",
            version: rawVersion
        };
    }
    else if (rawVersion instanceof Uint8Array && rawVersion.length === 3) {
        //for release versions, it's stored as a bytestring of length 3, with the
        //bytes being major, minor, patch. so we just join them with "." to form
        //a version string (although it's missing precise commit & etc).
        return {
            name: "solc",
            version: rawVersion.join(".")
        };
    }
    else {
        //return undefined on anything else
        return undefined;
    }
}
function makeContext(contract, node, compilation, isConstructor = false) {
    const abi = Abi.normalize(contract.abi);
    const bytecode = isConstructor
        ? contract.bytecode
        : contract.deployedBytecode;
    const binary = compile_common_1.Shims.NewToLegacy.forBytecode(bytecode);
    const hash = Conversion.toHexString(Evm.Utils.keccak256({
        type: "string",
        value: binary
    }));
    debug("hash: %s", hash);
    const fallback = abi.find(abiEntry => abiEntry.type === "fallback") ||
        null; //TS is failing at inference here
    const receive = abi.find(abiEntry => abiEntry.type === "receive") || null; //and here
    return {
        context: hash,
        contractName: contract.contractName,
        binary,
        contractId: node ? node.id : undefined,
        linearizedBaseContracts: node ? node.linearizedBaseContracts : undefined,
        contractKind: contractKind(contract, node),
        immutableReferences: isConstructor
            ? undefined
            : contract.immutableReferences,
        isConstructor,
        abi: AbiDataUtils.computeSelectors(abi),
        payable: AbiDataUtils.abiHasPayableFallback(abi),
        fallbackAbi: { fallback, receive },
        compiler: compilation.compiler || contract.compiler,
        compilationId: compilation.id
    };
}
exports.makeContext = makeContext;
//attempts to determine if the given contract is a library or not
function contractKind(contract, node) {
    //first: if we have a node, use its listed contract kind
    if (node) {
        return node.contractKind;
    }
    //next: check the contract kind field on the contract object itself, if it exists.
    //however this isn't implemented yet so we'll skip it.
    //next: if we have no direct info on the contract kind, but we do
    //have the deployed bytecode, we'll use a HACK:
    //we'll assume it's an ordinary contract, UNLESS its deployed bytecode begins with
    //PUSH20 followed by 20 0s, in which case we'll assume it's a library
    //(note: this will fail to detect libraries from before Solidity 0.4.20)
    if (contract.deployedBytecode) {
        const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);
        const pushAddressInstruction = (0x5f + Evm.Utils.ADDRESS_SIZE).toString(16); //"73"
        const libraryString = "0x" + pushAddressInstruction + "00".repeat(Evm.Utils.ADDRESS_SIZE);
        return deployedBytecode.startsWith(libraryString) ? "library" : "contract";
    }
    //finally, in the absence of anything to go on, we'll assume it's an ordinary contract
    return "contract";
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 52714:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.stringToBytes = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.isBig = exports.toBN = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:conversion");
const bn_js_1 = __importDefault(__webpack_require__(13550));
const big_js_1 = __importDefault(__webpack_require__(13012));
const utf8_1 = __importDefault(__webpack_require__(57458));
/**
 * @param bytes - undefined | string | number | BN | Uint8Array | Big
 * @return {BN}
 */
function toBN(bytes) {
    if (bytes === undefined) {
        return undefined;
    }
    else if (typeof bytes === "string") {
        return new bn_js_1.default(bytes, 16);
    }
    else if (typeof bytes === "bigint") {
        return new bn_js_1.default(bytes.toString(16), 16);
    }
    else if (typeof bytes == "number" || bn_js_1.default.isBN(bytes)) {
        return new bn_js_1.default(bytes);
    }
    else if (isBig(bytes)) {
        return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!
        //note: going through string may seem silly but it's actually not terrible here,
        //since BN is binary-based and Big is decimal-based
        //[toFixed is like toString except it guarantees scientific notation is not used]
    }
    else if (typeof bytes.reduce === "function") {
        return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));
    }
}
exports.toBN = toBN;
//Big doesnt provide this function, so we'll make one ourselves
//HACK
function isBig(input) {
    return (typeof input === "object" &&
        input !== null &&
        (input.s === 1 || input.s === -1) &&
        typeof input.e === "number" &&
        Array.isArray(input.c) &&
        //we want to be sure this is *not* a BigNumber instead,
        //but we can't use isBigNumber here because we don't want
        //to import that library here, so, HACK, we'll check that
        //it lacks a particular BigNumber method that would be meaningless
        //for Bigs
        !input.isFinite);
    //(BigNumbers have this method because it supports Infinity and NaN,
    //but Big doesn't, so this method doesn't exist, because it would
    //be pointless)
}
exports.isBig = isBig;
/**
 * @param bytes - Uint8Array
 * @return {BN}
 */
function toSignedBN(bytes) {
    if (bytes[0] < 0x80) {
        // if first bit is 0
        return toBN(bytes);
    }
    else {
        return toBN(bytes.map(b => 0xff - b))
            .addn(1)
            .neg();
    }
}
exports.toSignedBN = toSignedBN;
function toBigInt(value) {
    //BN is binary-based, so we convert by means of a hex string in order
    //to avoid having to do a binary-decimal conversion and back :P
    return !value.isNeg()
        ? BigInt("0x" + value.toString(16))
        : -BigInt("0x" + value.neg().toString(16)); //can't directly make negative BigInt from hex string
}
exports.toBigInt = toBigInt;
function toBig(value) {
    //note: going through string may seem silly but it's actually not terrible here,
    //since BN (& number) is binary-based and Big is decimal-based
    return new big_js_1.default(value.toString());
}
exports.toBig = toBig;
/**
 * @param bytes - Uint8Array | BN | bigint
 * @param padLength - number - minimum desired byte length (left-pad with zeroes)
 * @param padRight - boolean - causes padding to occur on right instead of left
 * @return {string}
 */
function toHexString(bytes, padLength = 0, padRight = false) {
    if (bn_js_1.default.isBN(bytes) ||
        typeof bytes === "bigint" ||
        typeof bytes === "number" ||
        isBig(bytes)) {
        bytes = toBytes(bytes);
    }
    const pad = (s) => `${"00".slice(0, 2 - s.length)}${s}`;
    //                                          0  1  2  3  4
    //                                 0  1  2  3  4  5  6  7
    // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )
    // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )
    //                                `--.---'
    //                                     offset 3
    if (bytes.length < padLength) {
        let prior = bytes;
        bytes = new Uint8Array(padLength);
        if (padRight) {
            //unusual case: pad on right
            bytes.set(prior);
        }
        else {
            //usual case
            bytes.set(prior, padLength - prior.length);
        }
    }
    debug("bytes: %o", bytes);
    let string = bytes.reduce((str, byte) => `${str}${pad(byte.toString(16))}`, "");
    return `0x${string}`;
}
exports.toHexString = toHexString;
function toBytes(data, length = 0) {
    //note that length is a minimum output length
    //strings will be 0-padded on left
    //numbers/BNs will be sign-padded on left
    //NOTE: if a number/BN is passed in that is too big for the given length,
    //you will get an error!
    //(note that strings passed in should be hex strings; this is not for converting
    //generic strings to hex)
    if (typeof data === "bigint") {
        data = data.toString(16);
    }
    if (typeof data === "string") {
        let hex = data; //renaming for clarity
        if (hex.startsWith("0x")) {
            hex = hex.slice(2);
        }
        if (hex === "") {
            //this special case is necessary because the match below will return null,
            //not an empty array, when given an empty string
            return new Uint8Array(0);
        }
        if (hex.length % 2 == 1) {
            hex = `0${hex}`;
        }
        let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));
        if (bytes.length < length) {
            let prior = bytes;
            bytes = new Uint8Array(length);
            bytes.set(prior, length - prior.length);
        }
        return bytes;
    }
    else {
        // BN/Big/number case
        if (typeof data === "number") {
            data = new bn_js_1.default(data);
        }
        else if (isBig(data)) {
            //note: going through string may seem silly but it's actually not terrible here,
            //since BN is binary-based and Big is decimal-based
            data = new bn_js_1.default(data.toFixed());
            //[toFixed is like toString except it guarantees scientific notation is not used]
        }
        //note that the argument for toTwos is given in bits
        return data.toTwos(length * 8).toArrayLike(Uint8Array, "be", length);
        //big-endian
    }
}
exports.toBytes = toBytes;
function stringToBytes(input) {
    input = utf8_1.default.encode(input);
    let bytes = new Uint8Array(input.length);
    for (let i = 0; i < input.length; i++) {
        bytes[i] = input.charCodeAt(i);
    }
    return bytes;
    //NOTE: this will throw an error if the string contained malformed UTF-16!
    //but, well, it shouldn't contain that...
}
exports.stringToBytes = stringToBytes;
//computes value * 10**decimalPlaces
function shiftBigUp(value, decimalPlaces) {
    let newValue = new big_js_1.default(value);
    newValue.e += decimalPlaces;
    return newValue;
}
exports.shiftBigUp = shiftBigUp;
//computes value * 10**-decimalPlaces
function shiftBigDown(value, decimalPlaces) {
    let newValue = new big_js_1.default(value);
    newValue.e -= decimalPlaces;
    return newValue;
}
exports.shiftBigDown = shiftBigDown;
function countDecimalPlaces(value) {
    return Math.max(0, value.c.length - value.e - 1);
}
exports.countDecimalPlaces = countDecimalPlaces;
//converts out of range booleans to true; something of a HACK
//NOTE: does NOT do this recursively inside structs, arrays, etc!
//I mean, those aren't elementary and therefore aren't in the domain
//anyway, but still
function cleanBool(result) {
    switch (result.kind) {
        case "value":
            return result;
        case "error":
            switch (result.error.kind) {
                case "BoolOutOfRangeError":
                    //return true
                    return {
                        type: result.type,
                        kind: "value",
                        value: {
                            asBoolean: true
                        },
                        interpretations: {}
                    };
                default:
                    return result;
            }
    }
}
exports.cleanBool = cleanBool;
//# sourceMappingURL=conversion.js.map

/***/ }),

/***/ 32561:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:core");
const Ast = __importStar(__webpack_require__(14442));
const AbiData = __importStar(__webpack_require__(20907));
const Topic = __importStar(__webpack_require__(63196));
const Evm = __importStar(__webpack_require__(49218));
const Contexts = __importStar(__webpack_require__(97938));
const abify_1 = __webpack_require__(57320);
const Conversion = __importStar(__webpack_require__(52714));
const errors_1 = __webpack_require__(72325);
const read_1 = __importDefault(__webpack_require__(87534));
const decode_1 = __importDefault(__webpack_require__(37478));
const web3_utils_1 = __importDefault(__webpack_require__(18269));
/**
 * @Category Decoding
 */
function* decodeVariable(definition, pointer, info, compilationId) {
    let compiler = info.currentContext.compiler;
    let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);
    return yield* (0, decode_1.default)(dataType, pointer, info); //no need to pass an offset
}
exports.decodeVariable = decodeVariable;
/**
 * @Category Decoding
 */
function* decodeCalldata(info, isConstructor, //ignored if context! trust context instead if have
strictAbiMode //used for selector-based decoding. has two effects:
//1. sets the strictAbiMode option when calling decode(), causing it to throw
//if it encounters a problem rather than returning an ErrorResult;
//2. performs a re-encoding check at the end (like decodeEvevent and decodeReturndata)
//and throws if it fails
) {
    const context = info.currentContext;
    if (context === null) {
        //if we don't know the contract ID, we can't decode
        if (isConstructor) {
            return {
                kind: "create",
                decodingMode: "full",
                bytecode: Conversion.toHexString(info.state.calldata),
                interpretations: {}
            };
        }
        else {
            return {
                kind: "unknown",
                decodingMode: "full",
                data: Conversion.toHexString(info.state.calldata),
                interpretations: {}
            };
        }
    }
    const contextHash = context.context;
    const contractType = Contexts.Import.contextToType(context);
    isConstructor = context.isConstructor;
    const allocations = info.allocations.calldata;
    let allocation;
    let selector;
    //first: is this a creation call?
    if (isConstructor) {
        allocation = (allocations.constructorAllocations[contextHash] || { input: undefined }).input;
    }
    else {
        //skipping any error-handling on this read, as a calldata read can't throw anyway
        let rawSelector = yield* (0, read_1.default)({
            location: "calldata",
            start: 0,
            length: Evm.Utils.SELECTOR_SIZE
        }, info.state);
        selector = Conversion.toHexString(rawSelector);
        allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {
            input: undefined
        }).input;
    }
    if (allocation === undefined) {
        let abiEntry = null;
        if (info.state.calldata.length === 0) {
            //to hell with reads, let's just be direct
            abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;
        }
        else {
            abiEntry = context.fallbackAbi.fallback;
        }
        return {
            kind: "message",
            class: contractType,
            abi: abiEntry,
            data: Conversion.toHexString(info.state.calldata),
            decodingMode: "full",
            interpretations: {}
        };
    }
    let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary
    debug("calldata decoding mode: %s", decodingMode);
    //you can't map with a generator, so we have to do this map manually
    let decodedArguments = [];
    for (const argumentAllocation of allocation.arguments) {
        let value;
        let dataType = decodingMode === "full"
            ? argumentAllocation.type
            : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);
        try {
            value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {
                abiPointerBase: allocation.offset,
                allowRetry: decodingMode === "full",
                strictAbiMode
            });
        }
        catch (error) {
            if (error instanceof errors_1.StopDecodingError &&
                error.allowRetry &&
                decodingMode === "full") {
                debug("problem! retrying as ABI");
                debug("error: %O", error);
                //if a retry happens, we've got to do several things in order to switch to ABI mode:
                //1. mark that we're switching to ABI mode;
                decodingMode = "abi";
                //2. abify all previously decoded values;
                decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes) })));
                //3. retry this particular decode in ABI mode.
                //(no try/catch on this one because we can't actually handle errors here!
                //not that they should be occurring)
                value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                argumentAllocation.pointer, info, {
                    abiPointerBase: allocation.offset,
                    strictAbiMode
                });
                //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),
                //so we don't need to do anything special there.
            }
            else {
                //we shouldn't be getting other exceptions, but if we do, we don't know
                //how to handle them, so uhhhh just rethrow I guess??
                throw error;
            }
        }
        const name = argumentAllocation.name;
        decodedArguments.push(name //deliberate general falsiness test
            ? { name, value }
            : { value });
    }
    //if we're in strict mode, do a re-encoding check
    if (strictAbiMode) {
        const decodedArgumentValues = decodedArguments.map(argument => argument.value);
        const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);
        const selectorLength = isConstructor
            ? (context.binary.length - 2) / 2 //for a constructor, the bytecode acts as the "selector"
            : //note we have to account for the fact that it's a hex string
                Evm.Utils.SELECTOR_SIZE;
        const encodedData = info.state.calldata.subarray(selectorLength); //slice off the selector
        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {
            //if not, this allocation doesn't work
            debug("rejected due to mismatch");
            throw new errors_1.StopDecodingError({
                kind: "ReEncodingMismatchError",
                data: encodedData,
                reEncodedData
            });
        }
    }
    if (isConstructor) {
        return {
            kind: "constructor",
            class: contractType,
            arguments: decodedArguments,
            abi: allocation.abi,
            bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),
            decodingMode,
            interpretations: {}
        };
    }
    else {
        return {
            kind: "function",
            class: contractType,
            abi: allocation.abi,
            arguments: decodedArguments,
            selector,
            decodingMode,
            interpretations: {}
        };
    }
}
exports.decodeCalldata = decodeCalldata;
/**
 * @Category Decoding
 */
function* decodeEvent(info, address, //if null is passed, must pass currentContext in info
options = {}) {
    const allocations = info.allocations.event;
    const extras = options.extras || "off";
    let rawSelector;
    let selector;
    let contractAllocations; //for non-anonymous events
    let libraryAllocations; //similar
    let contractAnonymousAllocations;
    let libraryAnonymousAllocations;
    const topicsCount = info.state.eventtopics.length;
    //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?
    if (allocations[topicsCount]) {
        if (topicsCount > 0) {
            rawSelector = yield* (0, read_1.default)({
                location: "eventtopic",
                topic: 0
            }, info.state);
            selector = Conversion.toHexString(rawSelector);
            if (allocations[topicsCount].bySelector[selector]) {
                ({ contract: contractAllocations, library: libraryAllocations } =
                    allocations[topicsCount].bySelector[selector]);
            }
            else {
                debug("no allocations for that selector!");
                contractAllocations = {};
                libraryAllocations = {};
            }
        }
        else {
            //if we don't have a selector, it means we don't have any non-anonymous events
            contractAllocations = {};
            libraryAllocations = {};
        }
        //now: let's get our allocations for anonymous events
        ({
            contract: contractAnonymousAllocations,
            library: libraryAnonymousAllocations
        } = allocations[topicsCount].anonymous);
    }
    else {
        //if there's not even an allocation for the topics count, we can't
        //decode; we could do this the honest way of setting all four allocation
        //objects to {}, but let's just short circuit
        debug("no allocations for that topic count!");
        return [];
    }
    let contractContext;
    if (address !== null) {
        //now: what contract are we (probably) dealing with? let's get its code to find out
        const codeBytes = yield {
            type: "code",
            address
        };
        const codeAsHex = Conversion.toHexString(codeBytes);
        contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);
    }
    else {
        contractContext = info.currentContext;
    }
    let possibleContractAllocations; //excludes anonymous events
    let possibleContractAnonymousAllocations;
    let possibleExtraAllocations; //excludes anonymous events
    let possibleExtraAnonymousAllocations;
    const emittingContextHash = (contractContext || { context: undefined })
        .context;
    if (emittingContextHash) {
        //if we found the contract, maybe it's from that contract
        const contractAllocation = contractAllocations[emittingContextHash];
        const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];
        possibleContractAllocations = contractAllocation || [];
        possibleContractAnonymousAllocations = contractAnonymousAllocation || [];
        //also, we need to set up the extras (everything that's from a
        //non-library contract but *not* this one)
        possibleExtraAllocations = [].concat(...Object.entries(contractAllocations)
            .filter(([key, _]) => key !== emittingContextHash)
            .map(([_, value]) => value));
        possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations)
            .filter(([key, _]) => key !== emittingContextHash)
            .map(([_, value]) => value));
    }
    else {
        //if we couldn't determine the contract, well, we have to assume it's from a library
        debug("couldn't find context");
        possibleContractAllocations = [];
        possibleContractAnonymousAllocations = [];
        //or it's an extra, which could be any of the contracts
        possibleExtraAllocations = [].concat(...Object.values(contractAllocations));
        possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));
    }
    //now we get all the library allocations!
    const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));
    const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations));
    //now we put it all together!
    const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);
    const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);
    const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations);
    //...and also there's the extras
    const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);
    const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras
    possibleExtraAllocationsTotal);
    //whew!
    let decodings = [];
    allocationAttempts: for (const allocation of possibleAllocationsTotal) {
        debug("trying allocation: %O", allocation);
        //first: check for our sentinel value for extras (yeah, kind of HACKy)
        if (allocation === null) {
            switch (extras) {
                case "on":
                    continue allocationAttempts; //ignore the sentinel and continue
                case "off":
                    break allocationAttempts; //don't include extras; stop here
                case "necessary":
                    //stop on the sentinel and exclude extras *unless* there are no decodings yet
                    if (decodings.length > 0) {
                        break allocationAttempts;
                    }
                    else {
                        continue allocationAttempts;
                    }
            }
        }
        //second: do a name check so we can skip decoding if name is wrong
        //(this will likely be a more detailed check in the future)
        if (options.name !== undefined && allocation.abi.name !== options.name) {
            continue;
        }
        //now: the main part!
        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary
        const contextHash = allocation.contextHash;
        const attemptContext = info.contexts[contextHash];
        const emittingContractType = Contexts.Import.contextToType(attemptContext);
        const contractType = allocation.definedIn;
        //you can't map with a generator, so we have to do this map manually
        let decodedArguments = [];
        for (const argumentAllocation of allocation.arguments) {
            let value;
            //if in full mode, use the allocation's listed data type.
            //if in ABI mode, abify it before use.
            let dataType = decodingMode === "full"
                ? argumentAllocation.type
                : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);
            try {
                value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {
                    strictAbiMode: true,
                    allowRetry: decodingMode === "full" //this option is unnecessary but including for clarity
                });
            }
            catch (error) {
                if (error instanceof errors_1.StopDecodingError &&
                    error.allowRetry &&
                    decodingMode === "full") {
                    //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;
                    decodingMode = "abi";
                    //2. abify all previously decoded values;
                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes) })));
                    //3. retry this particular decode in ABI mode.
                    try {
                        value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown
                            //retries no longer allowed, not that this has an effect
                        });
                    }
                    catch (_) {
                        //if an error occurred on the retry, this isn't a valid decoding!
                        debug("rejected due to exception on retry");
                        continue allocationAttempts;
                    }
                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),
                    //so we don't need to do anything special there.
                }
                else {
                    //if any other sort of error occurred, this isn't a valid decoding!
                    debug("rejected due to exception on first try: %O", error);
                    continue allocationAttempts;
                }
            }
            const name = argumentAllocation.name;
            const indexed = argumentAllocation.pointer.location === "eventtopic";
            decodedArguments.push(name //deliberate general falsiness test
                ? { name, indexed, value }
                : { indexed, value });
        }
        if (!options.disableChecks) {
            //OK, so, having decoded the result, the question is: does it reencode to the original?
            //NOTE: we skip this check if disableChecks is passed! (it shouldn't be passed :P )
            //first, we have to filter out the indexed arguments, and also get rid of the name information
            const nonIndexedValues = decodedArguments
                .filter(argument => !argument.indexed)
                .map(argument => argument.value);
            //now, we can encode!
            const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);
            const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well
            //are they equal?
            if (!Evm.Utils.equalData(reEncodedData, encodedData)) {
                //if not, this allocation doesn't work
                debug("rejected due to [non-indexed] mismatch");
                continue;
            }
        }
        //one last check -- let's check that the indexed arguments match up, too
        //(we won't skip this even if disableChecks was passed)
        const indexedValues = decodedArguments
            .filter(argument => argument.indexed)
            .map(argument => argument.value);
        const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);
        const encodedTopics = info.state.eventtopics;
        //now: do *these* match?
        const selectorAdjustment = allocation.anonymous ? 0 : 1;
        for (let i = 0; i < reEncodedTopics.length; i++) {
            if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {
                debug("rejected due to indexed mismatch");
                continue allocationAttempts;
            }
        }
        //if we've made it here, the allocation works!  hooray!
        debug("allocation accepted!");
        let decoding;
        if (allocation.abi.anonymous) {
            decoding = {
                kind: "anonymous",
                definedIn: contractType,
                class: emittingContractType,
                abi: allocation.abi,
                arguments: decodedArguments,
                decodingMode,
                interpretations: {}
            };
        }
        else {
            decoding = {
                kind: "event",
                definedIn: contractType,
                class: emittingContractType,
                abi: allocation.abi,
                arguments: decodedArguments,
                selector,
                decodingMode,
                interpretations: {}
            };
        }
        decodings.push(decoding);
        //if we've made this far (so this allocation works), and we were passed an
        //ID, and it matches this ID, bail out & return this as the *only* decoding
        if (options.id && allocation.id === options.id) {
            return [decoding];
        }
    }
    return decodings;
}
exports.decodeEvent = decodeEvent;
const errorSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({
    type: "string",
    value: "Error(string)"
})).subarray(0, Evm.Utils.SELECTOR_SIZE);
const panicSelector = Conversion.toBytes(web3_utils_1.default.soliditySha3({
    type: "string",
    value: "Panic(uint256)"
})).subarray(0, Evm.Utils.SELECTOR_SIZE);
const defaultRevertAllocations = [
    {
        kind: "revert",
        allocationMode: "full",
        selector: errorSelector,
        abi: {
            name: "Error",
            type: "error",
            inputs: [
                {
                    name: "",
                    type: "string",
                    internalType: "string"
                }
            ]
        },
        definedIn: null,
        arguments: [
            {
                name: "",
                pointer: {
                    location: "returndata",
                    start: errorSelector.length,
                    length: Evm.Utils.WORD_SIZE
                },
                type: {
                    typeClass: "string",
                    typeHint: "string"
                }
            }
        ]
    },
    {
        kind: "revert",
        allocationMode: "full",
        selector: panicSelector,
        abi: {
            name: "Panic",
            type: "error",
            inputs: [
                {
                    name: "",
                    type: "uint256",
                    internalType: "uint256"
                }
            ]
        },
        definedIn: null,
        arguments: [
            {
                name: "",
                pointer: {
                    location: "returndata",
                    start: panicSelector.length,
                    length: Evm.Utils.WORD_SIZE
                },
                type: {
                    typeClass: "uint",
                    bits: Evm.Utils.WORD_SIZE * 8,
                    typeHint: "uint256"
                }
            }
        ]
    }
];
const defaultEmptyAllocations = [
    {
        kind: "failure",
        allocationMode: "full",
        selector: new Uint8Array(),
        arguments: []
    },
    {
        kind: "selfdestruct",
        allocationMode: "full",
        selector: new Uint8Array(),
        arguments: []
    }
];
/**
 * If there are multiple possibilities, they're always returned in
 * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode
 * Moreover, within "revert", builtin ones are put above custom ones
 * @Category Decoding
 */
function* decodeReturndata(info, successAllocation, //null here must be explicit
status, //you can pass this to indicate that you know the status,
id //useful when status = false
) {
    let possibleAllocations;
    const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));
    const contextHash = (info.currentContext || { context: "" }).context; //HACK: "" is used to represent no context
    const customRevertAllocations = ((info.allocations.returndata || { [contextHash]: {} })[contextHash] || {
        [selector]: []
    })[selector] || [];
    if (successAllocation === null) {
        possibleAllocations = [
            ...defaultRevertAllocations,
            ...customRevertAllocations,
            ...defaultEmptyAllocations
        ];
    }
    else {
        switch (successAllocation.kind) {
            case "return":
                possibleAllocations = [
                    successAllocation,
                    ...defaultRevertAllocations,
                    ...customRevertAllocations,
                    ...defaultEmptyAllocations
                ];
                break;
            case "bytecode":
                possibleAllocations = [
                    ...defaultRevertAllocations,
                    ...customRevertAllocations,
                    ...defaultEmptyAllocations,
                    successAllocation
                ];
                break;
            case "returnmessage":
                possibleAllocations = [
                    ...defaultRevertAllocations,
                    ...customRevertAllocations,
                    successAllocation,
                    ...defaultEmptyAllocations
                ];
                break;
            //Other cases shouldn't happen so I'm leaving them to cause errors!
        }
    }
    let decodings = [];
    allocationAttempts: for (const allocation of possibleAllocations) {
        debug("trying allocation: %O", allocation);
        //before we attempt to use this allocation, we check: does the selector match?
        let encodedData = info.state.returndata; //again, not great to read this directly, but oh well
        const encodedPrefix = encodedData.subarray(0, allocation.selector.length);
        if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {
            continue;
        }
        encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later
        //also we check, does the status match?
        if (status !== undefined) {
            const successKinds = [
                "return",
                "selfdestruct",
                "bytecode",
                "returnmessage"
            ];
            const failKinds = ["failure", "revert"];
            if (status) {
                if (!successKinds.includes(allocation.kind)) {
                    continue;
                }
            }
            else {
                if (!failKinds.includes(allocation.kind)) {
                    continue;
                }
            }
        }
        if (allocation.kind === "bytecode") {
            //bytecode is special and can't really be integrated with the other cases.
            //so it gets its own function.
            const decoding = yield* decodeBytecode(info);
            if (decoding) {
                decodings.push(decoding);
            }
            continue;
        }
        if (allocation.kind === "returnmessage") {
            //this kind is also special, though thankfully it's easier
            const decoding = {
                kind: "returnmessage",
                status: true,
                data: Conversion.toHexString(info.state.returndata),
                decodingMode: allocation.allocationMode,
                interpretations: {}
            };
            decodings.push(decoding);
            continue;
        }
        let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary
        //you can't map with a generator, so we have to do this map manually
        let decodedArguments = [];
        for (const argumentAllocation of allocation.arguments) {
            let value;
            //if in full mode, use the allocation's listed data type.
            //if in ABI mode, abify it before use.
            let dataType = decodingMode === "full"
                ? argumentAllocation.type
                : (0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes);
            //now, let's decode!
            try {
                value = yield* (0, decode_1.default)(dataType, argumentAllocation.pointer, info, {
                    abiPointerBase: allocation.selector.length,
                    strictAbiMode: true,
                    allowRetry: decodingMode === "full" //this option is unnecessary but including for clarity
                });
                debug("value on first try: %O", value);
            }
            catch (error) {
                if (error instanceof errors_1.StopDecodingError &&
                    error.allowRetry &&
                    decodingMode === "full") {
                    debug("retry!");
                    //if a retry happens, we've got to do several things in order to switch to ABI mode:
                    //1. mark that we're switching to ABI mode;
                    decodingMode = "abi";
                    //2. abify all previously decoded values;
                    decodedArguments = decodedArguments.map(argumentDecoding => (Object.assign(Object.assign({}, argumentDecoding), { value: (0, abify_1.abifyResult)(argumentDecoding.value, info.userDefinedTypes) })));
                    //3. retry this particular decode in ABI mode.
                    try {
                        value = yield* (0, decode_1.default)((0, abify_1.abifyType)(argumentAllocation.type, info.userDefinedTypes), //type is now abified!
                        argumentAllocation.pointer, info, {
                            abiPointerBase: allocation.selector.length,
                            strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown
                            //retries no longer allowed, not that this has an effect
                        });
                        debug("value on retry: %O", value);
                    }
                    catch (_) {
                        //if an error occurred on the retry, this isn't a valid decoding!
                        debug("rejected due to exception on retry");
                        continue allocationAttempts;
                    }
                    //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),
                    //so we don't need to do anything special there.
                }
                else {
                    //if any other sort of error occurred, this isn't a valid decoding!
                    debug("rejected due to exception on first try: %O", error);
                    continue allocationAttempts;
                }
            }
            const name = argumentAllocation.name;
            decodedArguments.push(name //deliberate general falsiness test
                ? { name, value }
                : { value });
        }
        //OK, so, having decoded the result, the question is: does it reencode to the original?
        //first, we have to filter out the indexed arguments, and also get rid of the name information
        debug("decodedArguments: %O", decodedArguments);
        const decodedArgumentValues = decodedArguments.map(argument => argument.value);
        const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi);
        //are they equal? note the selector has been stripped off encodedData!
        if (!Evm.Utils.equalData(reEncodedData, encodedData)) {
            //if not, this allocation doesn't work
            debug("rejected due to mismatch");
            continue;
        }
        //if we've made it here, the allocation works!  hooray!
        debug("allocation accepted!");
        let decoding;
        switch (allocation.kind) {
            case "return":
                decoding = {
                    kind: "return",
                    status: true,
                    arguments: decodedArguments,
                    decodingMode,
                    interpretations: {}
                };
                break;
            case "revert":
                decoding = {
                    kind: "revert",
                    abi: allocation.abi,
                    definedIn: allocation.definedIn,
                    status: false,
                    arguments: decodedArguments,
                    decodingMode,
                    interpretations: {}
                };
                break;
            case "selfdestruct":
                decoding = {
                    kind: "selfdestruct",
                    status: true,
                    decodingMode,
                    interpretations: {}
                };
                break;
            case "failure":
                decoding = {
                    kind: "failure",
                    status: false,
                    decodingMode,
                    interpretations: {}
                };
                break;
        }
        decodings.push(decoding);
        //if we've made this far (so this allocation works), and we were passed an
        //ID, and it matches this ID, bail out & return this as the *only* decoding
        if (id && allocation.kind === "revert" && allocation.id === id) {
            return [decoding];
        }
    }
    return decodings;
}
exports.decodeReturndata = decodeReturndata;
//note: requires the bytecode to be in returndata, not code
function* decodeBytecode(info) {
    let decodingMode = "full"; //as always, degrade as necessary
    const bytecode = Conversion.toHexString(info.state.returndata);
    const context = Contexts.Utils.findContext(info.contexts, bytecode);
    if (!context) {
        return {
            kind: "unknownbytecode",
            status: true,
            decodingMode: "full",
            bytecode,
            interpretations: {}
        };
    }
    const contractType = Contexts.Import.contextToType(context);
    //now: ignore original allocation (which we didn't even pass :) )
    //and lookup allocation by context
    const allocation = info.allocations.calldata.constructorAllocations[context.context].output;
    debug("bytecode allocation: %O", allocation);
    //now: add immutables if applicable
    let immutables;
    if (allocation.immutables) {
        immutables = [];
        //NOTE: if we're in here, we can assume decodingMode === "full"
        for (const variable of allocation.immutables) {
            const dataType = variable.type; //we don't conditioning on decodingMode here because we know it
            let value;
            try {
                value = yield* (0, decode_1.default)(dataType, variable.pointer, info, {
                    allowRetry: true,
                    strictAbiMode: true,
                    paddingMode: "defaultOrZero"
                });
            }
            catch (error) {
                if (error instanceof errors_1.StopDecodingError && error.allowRetry) {
                    //we "retry" by... not bothering with immutables :P
                    //(but we do set the mode to ABI)
                    decodingMode = "abi";
                    immutables = undefined;
                    break;
                }
                else {
                    //otherwise, this isn't a valid decoding I guess
                    return null;
                }
            }
            immutables.push({
                name: variable.name,
                class: variable.definedIn,
                value
            });
        }
    }
    let decoding = {
        kind: "bytecode",
        status: true,
        decodingMode,
        bytecode,
        immutables,
        class: contractType,
        interpretations: {}
    };
    //finally: add address if applicable
    if (allocation.delegatecallGuard) {
        decoding.address = web3_utils_1.default.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = "0x73".length
        );
    }
    return decoding;
}
/**
 * Decodes the return data from a failed call.
 *
 * @param returndata The returned data, as a Uint8Array.
 * @return An array of possible decodings.  At the moment it's
 *   impossible for there to be more than one.  (If the call didn't actually
 *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)
 *
 *   Decodings can either be decodings of revert messages, or decodings
 *   indicating that there was no revert message.  If somehow both were to be
 *   possible, they'd go in that order, although as mentioned, there (at least
 *   currently) isn't any way for that to occur.
 * @Category Decoding convenience
 */
function decodeRevert(returndata) {
    //coercing because TS doesn't know it'll finish in one go
    return decodeReturndata({
        allocations: {},
        state: {
            storage: {},
            returndata
        }
    }, null, false).next().value;
}
exports.decodeRevert = decodeRevert;
//# sourceMappingURL=core.js.map

/***/ }),

/***/ 37478:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:decode");
const AstConstant = __importStar(__webpack_require__(88132));
const AbiData = __importStar(__webpack_require__(20907));
const Compiler = __importStar(__webpack_require__(84159));
const Format = __importStar(__webpack_require__(29965));
const Basic = __importStar(__webpack_require__(53928));
const Memory = __importStar(__webpack_require__(71614));
const Special = __importStar(__webpack_require__(97859));
const Stack = __importStar(__webpack_require__(15385));
const Storage = __importStar(__webpack_require__(81037));
const Topic = __importStar(__webpack_require__(63196));
function* decode(dataType, pointer, info, options = {}) {
    return Format.Utils.Circularity.tie(yield* decodeDispatch(dataType, pointer, info, options));
}
exports["default"] = decode;
function* decodeDispatch(dataType, pointer, info, options = {}) {
    debug("type %O", dataType);
    debug("pointer %O", pointer);
    switch (pointer.location) {
        case "storage":
            return yield* Storage.Decode.decodeStorage(dataType, pointer, info);
        case "stack":
            return yield* Stack.Decode.decodeStack(dataType, pointer, info);
        case "stackliteral":
            return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);
        case "definition":
            return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);
        case "special":
            return yield* Special.Decode.decodeSpecial(dataType, pointer, info);
        case "calldata":
        case "eventdata":
        case "returndata":
            return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);
        case "eventtopic":
            return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);
        case "code":
        case "nowhere":
            //currently only basic types can go in code, so we'll dispatch directly to decodeBasic
            //(if it's a nowhere pointer, this will return an error result, of course)
            //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,
            //so we have to set the padding mode appropriately to allow for this)
            return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), { paddingMode: "defaultOrZero" }));
        case "memory":
            //this case -- decoding something that resides *directly* in memory,
            //rather than located via a pointer -- only comes up when decoding immutables
            //in a constructor.  thus, we turn on the forceRightPadding option on Solidity
            //versions prior to 0.8.9, because before then all immutables would be right-padded
            //while in memory
            switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {
                case "0.5.x":
                case "0.8.x":
                case "0.8.7+":
                    return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), { paddingMode: "right" }));
                default:
                    return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);
            }
    }
}
//# sourceMappingURL=decode.js.map

/***/ }),

/***/ 72325:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RepeatCompilationIdError = exports.NoProjectInfoError = exports.handleDecodingError = exports.StopDecodingError = exports.DecodingError = void 0;
const Format = __importStar(__webpack_require__(29965));
//For when we need to throw an error, here's a wrapper class that extends Error.
//Apologies about the confusing name, but I wanted something that would make
//sense should it not be caught and thus accidentally exposed to the outside.
/**
 * @hidden
 */
class DecodingError extends Error {
    constructor(error) {
        super(Format.Utils.Exception.message(error));
        this.error = error;
        this.name = "DecodingError";
    }
}
exports.DecodingError = DecodingError;
//used to stop decoding; like DecodingError, but used in contexts
//where I don't expect it to be caught
//NOTE: currently we don't actually check the type of a thrown error,
//we just rely on context.  still, I think it makes sense to be a separate
//type.
/**
 * @hidden
 */
class StopDecodingError extends Error {
    //when decoding in full mode, we allow an ABI-mode retry.  (if we were already in
    //ABI mode, we give up.)
    constructor(error, allowRetry) {
        const message = `Stopping decoding: ${error.kind}`; //sorry about the bare-bones message,
        //but again, users shouldn't actually see this, so I think this should suffice for now
        super(message);
        this.error = error;
        this.allowRetry = Boolean(allowRetry);
    }
}
exports.StopDecodingError = StopDecodingError;
/**
 * @hidden
 */
function handleDecodingError(dataType, error, strict = false) {
    if (error instanceof DecodingError) {
        //expected error
        if (strict) {
            //strict mode -- stop decoding on errors
            throw new StopDecodingError(error.error);
        }
        else {
            //nonstrict mode -- return an error result
            return {
                //I don't know why TS's inference is failing here and needs the coercion
                type: dataType,
                kind: "error",
                error: error.error
            };
        }
    }
    else {
        //if it's *not* an expected error, we better not swallow it -- rethrow!
        throw error;
    }
}
exports.handleDecodingError = handleDecodingError;
/**
 * This error indicates that the user attempted to instantiate a decoder
 * with no project information (by explicitly overriding the default).
 * @category Exception
 */
class NoProjectInfoError extends Error {
    constructor() {
        super("No project information specified.");
        this.name = "NoProjectInfoError";
    }
}
exports.NoProjectInfoError = NoProjectInfoError;
/**
 * This error indicates there was an attempt to add multiple compilations
 * with the same ID, or a compilation whose ID was already in use.
 */
class RepeatCompilationIdError extends Error {
    constructor(ids) {
        super(`Compilation id(s) ${ids.join(", ")} repeated or already in use.`);
        this.ids = ids;
        this.name = "RepeatCompilationIdError";
    }
}
exports.RepeatCompilationIdError = RepeatCompilationIdError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 27634:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.makeInternalFunctionId = exports.functionTableEntryToType = void 0;
const import_1 = __webpack_require__(60013);
//creates a type object for the contract the function was defined in
function functionTableEntryToType(functionEntry) {
    if (functionEntry.contractNode === null) {
        //for free functions
        return null;
    }
    return {
        typeClass: "contract",
        kind: "native",
        id: (0, import_1.makeTypeId)(functionEntry.contractId, functionEntry.compilationId),
        typeName: functionEntry.contractName,
        contractKind: functionEntry.contractKind,
        payable: functionEntry.contractPayable
    };
}
exports.functionTableEntryToType = functionTableEntryToType;
function makeInternalFunctionId(functionEntry) {
    return `${functionEntry.compilationId}:${functionEntry.id}`;
}
exports.makeInternalFunctionId = makeInternalFunctionId;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 49218:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = exports.Utils = void 0;
__exportStar(__webpack_require__(93311), exports); //'export type *' is not allowed
const Utils = __importStar(__webpack_require__(59901));
exports.Utils = Utils;
const Import = __importStar(__webpack_require__(27634));
exports.Import = Import;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 93311:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 59901:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.toAddress = exports.equalData = exports.keccak256 = exports.ZERO_ADDRESS = exports.MAX_WORD = exports.PC_SIZE = exports.SELECTOR_SIZE = exports.ADDRESS_SIZE = exports.WORD_SIZE = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:evm:utils");
const bn_js_1 = __importDefault(__webpack_require__(13550));
const web3_utils_1 = __importDefault(__webpack_require__(18269));
const Conversion = __importStar(__webpack_require__(52714));
const abi_utils_1 = __webpack_require__(7651);
exports.WORD_SIZE = 0x20;
exports.ADDRESS_SIZE = 20;
exports.SELECTOR_SIZE = abi_utils_1.ShortSelectorSize; //equals 4; function & error selectors, not event selectors
exports.PC_SIZE = 4;
exports.MAX_WORD = new bn_js_1.default(-1).toTwos(exports.WORD_SIZE * 8);
exports.ZERO_ADDRESS = "0x" + "00".repeat(exports.ADDRESS_SIZE);
//beware of using this for generic strings! (it's fine for bytestrings, or
//strings representing numbers) if you want to use this on a generic string,
//you should pass in {type: "string", value: theString} instead of the string
//itself.
//(maybe I should add a rawKeccak256 function, using sha3 instead of
//soliditysha3?  not seeing the need atm though)
function keccak256(...args) {
    // debug("args %o", args);
    const rawSha = web3_utils_1.default.soliditySha3(...args);
    debug("rawSha %o", rawSha);
    let sha;
    if (rawSha === null) {
        sha = ""; //HACK, I guess?
    }
    else {
        sha = rawSha.replace(/0x/, "");
    }
    return Conversion.toBN(sha);
}
exports.keccak256 = keccak256;
//checks if two bytearrays (which may be undefined) are equal.
//does not consider undefined to be equal to itself.
function equalData(bytes1, bytes2) {
    if (!bytes1 || !bytes2) {
        return false;
    }
    if (bytes1.length !== bytes2.length) {
        return false;
    }
    for (let i = 0; i < bytes1.length; i++) {
        if (bytes1[i] !== bytes2[i]) {
            return false;
        }
    }
    return true;
}
exports.equalData = equalData;
function toAddress(bytes) {
    if (typeof bytes === "string") {
        //in this case, we can do some simple string manipulation and
        //then pass to web3
        let hex = bytes; //just renaming for clarity
        if (hex.startsWith("0x")) {
            hex = hex.slice(2);
        }
        if (hex.length < 2 * exports.ADDRESS_SIZE) {
            hex = hex.padStart(2 * exports.ADDRESS_SIZE, "0");
        }
        if (hex.length > 2 * exports.ADDRESS_SIZE) {
            hex = "0x" + hex.slice(hex.length - 2 * exports.ADDRESS_SIZE);
        }
        return web3_utils_1.default.toChecksumAddress(hex);
    }
    //otherwise, we're in the Uint8Array case, which we can't fully handle ourself
    //truncate *on left* to 20 bytes
    if (bytes.length > exports.ADDRESS_SIZE) {
        bytes = bytes.slice(bytes.length - exports.ADDRESS_SIZE, bytes.length);
    }
    //now, convert to hex string and apply checksum case that second argument
    //(which ensures it's padded to 20 bytes) shouldn't actually ever be
    //needed, but I'll be safe and include it
    return web3_utils_1.default.toChecksumAddress(Conversion.toHexString(bytes, exports.ADDRESS_SIZE));
}
exports.toAddress = toAddress;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 15103:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.formatFunctionLike = exports.ReturndataDecodingInspector = exports.LogDecodingInspector = exports.containsDeliberateReadError = exports.CalldataDecodingInspector = exports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.stringValueInfoToStringLossy = exports.nativizeAccessList = exports.unsafeNativizeVariables = exports.unsafeNativize = exports.ResultInspector = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:export");
const os_1 = __importDefault(__webpack_require__(22037));
const util_1 = __importDefault(__webpack_require__(73837));
const Format = __importStar(__webpack_require__(29965));
const Conversion = __importStar(__webpack_require__(52714));
const inspect_1 = __webpack_require__(49290);
Object.defineProperty(exports, "ResultInspector", ({ enumerable: true, get: function () { return inspect_1.ResultInspector; } }));
Object.defineProperty(exports, "unsafeNativize", ({ enumerable: true, get: function () { return inspect_1.unsafeNativize; } }));
Object.defineProperty(exports, "unsafeNativizeVariables", ({ enumerable: true, get: function () { return inspect_1.unsafeNativizeVariables; } }));
Object.defineProperty(exports, "nativizeAccessList", ({ enumerable: true, get: function () { return inspect_1.nativizeAccessList; } }));
Object.defineProperty(exports, "stringValueInfoToStringLossy", ({ enumerable: true, get: function () { return inspect_1.stringValueInfoToStringLossy; } }));
/**
 * This function is similar to
 * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to
 * be safe, and also allows for different output formats.  The only currently
 * supported format is "ethers", which is intended to match the way that
 * Truffle Contract currently returns values (based on the Ethers decoder).  As
 * such, it only handles ABI types, and in addition does not handle the types
 * fixed, ufixed, or function.  Note that in these cases it returns `undefined`
 * rather than throwing, as we want this function to be used in contexts where
 * it had better not throw.  It also does not handle circularities, for similar
 * reasons.
 *
 * To handle numeric types, this function takes an optional numberFormatter
 * option that tells it how to handle numbers; this function should take a
 * BigInt as input.  By default, this function will be the identity, and so
 * numbers will be represented as BigInts.
 *
 * Note that this function begins by calling abify, so out-of-range enums (that
 * aren't so out-of-range as to be padding errors) will not return `undefined`.
 * Out-of-range booleans similarly will return true rather than `undefined`.
 * However, other range errors may return `undefined`; this may technically be a
 * slight incompatibility with existing behavior, but should not be relevant
 * except in quite unusual cases.
 *
 * In order to match the behavior for tuples, tuples will be transformed into
 * arrays, but named entries will additionally be keyed by name.  Moreover,
 * indexed variables of reference type will be nativized to an undecoded hex
 * string.
 */
function nativize(result, options = {}) {
    const numberFormatter = options.numberFormatter || (x => x);
    const format = options.format || "ethers";
    switch (format) {
        case "ethers":
            return ethersCompatibleNativize(result, numberFormatter);
    }
}
exports.nativize = nativize;
function ethersCompatibleNativize(result, numberFormatter = x => x) {
    //note: the original version of this function began by calling abify,
    //but we don't do that here because abify requires a userDefinedTypes
    //parameter and we don't want that.
    //However, it only needs that to handle getting the types right.  Since
    //we don't care about that here, we instead do away with abify and handle
    //such matters ourselves (which is less convenient, yeah).
    switch (result.kind) {
        case "error":
            switch (result.error.kind) {
                case "IndexedReferenceTypeError":
                    //strictly speaking for arrays ethers will fail to decode
                    //rather than do this, but, eh
                    return result.error.raw;
                case "EnumOutOfRangeError":
                    return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));
                default:
                    return undefined;
            }
        case "value":
            switch (result.type.typeClass) {
                case "uint":
                case "int":
                    const asBN = (result).value.asBN;
                    return numberFormatter(Conversion.toBigInt(asBN));
                case "enum":
                    const numericAsBN = result.value
                        .numericAsBN;
                    return numberFormatter(Conversion.toBigInt(numericAsBN));
                case "bool":
                    return result.value.asBoolean;
                case "bytes":
                    const asHex = result.value.asHex;
                    return asHex !== "0x" ? asHex : null;
                case "address":
                    return result.value.asAddress;
                case "contract":
                    return result.value.address;
                case "string":
                    return (0, inspect_1.stringValueInfoToStringLossy)(result.value);
                case "userDefinedValueType":
                    return ethersCompatibleNativize(result.value, numberFormatter);
                case "array":
                    return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));
                case "tuple":
                case "struct":
                    //in this case, we need the result to be an array, but also
                    //to have the field names (where extant) as keys
                    const nativized = [];
                    const pairs = (result).value;
                    for (const { name, value } of pairs) {
                        const nativizedValue = ethersCompatibleNativize(value, numberFormatter);
                        nativized.push(nativizedValue);
                        if (name) {
                            nativized[name] = nativizedValue;
                        }
                    }
                    return nativized;
                case "function":
                    switch (result.type.visibility) {
                        case "external":
                            const coercedResult = result;
                            //ethers per se doesn't handle this, but web3's hacked version will
                            //sometimes decode these as just a bytes24, so let's do that
                            return (coercedResult.value.contract.address.toLowerCase() +
                                coercedResult.value.selector.slice(2));
                        case "internal":
                            return undefined;
                    }
                case "fixed":
                case "ufixed":
                default:
                    return undefined;
            }
    }
}
/**
 * This function is similar to [[nativize]], but takes
 * a [[ReturndataDecoding]].  If there's only one returned value, it
 * will be run through compatibleNativize but otherwise unaltered;
 * otherwise the results will be put in an object.
 *
 * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],
 * this will just return `undefined`.
 */
function nativizeReturn(decoding, options = {}) {
    const numberFormatter = options.numberFormatter || (x => x);
    const format = options.format || "ethers";
    switch (format) {
        case "ethers":
            return ethersCompatibleNativizeReturn(decoding, numberFormatter);
    }
}
exports.nativizeReturn = nativizeReturn;
function ethersCompatibleNativizeReturn(decoding, numberFormatter = x => x) {
    if (decoding.kind !== "return") {
        return undefined;
    }
    if (decoding.arguments.length === 1) {
        return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);
    }
    const result = {};
    for (let i = 0; i < decoding.arguments.length; i++) {
        const { name, value } = decoding.arguments[i];
        const nativized = ethersCompatibleNativize(value, numberFormatter);
        result[i] = nativized;
        if (name) {
            result[name] = nativized;
        }
    }
    return result;
}
/**
 * This function is similar to [[compatibleNativize]], but takes
 * a [[LogDecoding]], and puts the results in an object.  Note
 * that this does not return the entire event info, but just the
 * `args` for the event.
 */
function nativizeEventArgs(decoding, options = {}) {
    const numberFormatter = options.numberFormatter || (x => x);
    const format = options.format || "ethers";
    switch (format) {
        case "ethers":
            return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);
    }
}
exports.nativizeEventArgs = nativizeEventArgs;
function ethersCompatibleNativizeEventArgs(decoding, numberFormatter = x => x) {
    const result = {};
    for (let i = 0; i < decoding.arguments.length; i++) {
        const { name, value } = decoding.arguments[i];
        const nativized = ethersCompatibleNativize(value, numberFormatter);
        result[i] = nativized;
        if (name) {
            result[name] = nativized;
        }
    }
    //note: if you have an argument named __length__, what ethers
    //actually does is... weird.  we're just going to do this instead,
    //which is simpler and probably more useful, even if it's not strictly
    //the same (I *seriously* doubt anyone was relying on the old behavior,
    //because it's, uh, not very useful)
    result.__length__ = decoding.arguments.length;
    return result;
}
/**
 * Similar to [[ResultInspector]], but for a [[CalldataDecoding]].
 * See [[ResultInspector]] for more information.
 */
class CalldataDecodingInspector {
    constructor(decoding, options) {
        this.decoding = decoding;
        this.options = options || {};
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.decoding.kind) {
            case "function":
                const fullName = `${this.decoding.class.typeName}.${this.decoding.abi.name}`;
                if (this.decoding.interpretations.multicall) {
                    return formatMulticall(fullName, this.decoding.interpretations.multicall, options, this.options);
                }
                else if (this.decoding.interpretations.aggregate) {
                    return formatAggregate(fullName, this.decoding.interpretations.aggregate, options, this.options);
                }
                else if (this.decoding.interpretations.tryAggregate) {
                    const { requireSuccess, calls } = this.decoding.interpretations.tryAggregate;
                    return formatAggregate(fullName, calls, options, this.options, "requireSuccess", options.stylize(requireSuccess.toString(), "number"), true //including try here would be redundant, so suppress it
                    );
                }
                else if (this.decoding.interpretations.tryAggregate) {
                    const { requireSuccess, calls } = this.decoding.interpretations.tryAggregate;
                    return formatAggregate(fullName, calls, options, this.options, "requireSuccess", options.stylize(requireSuccess.toString(), "number"));
                }
                else if (this.decoding.interpretations.deadlinedMulticall) {
                    const { deadline, calls: decodings } = this.decoding.interpretations.deadlinedMulticall;
                    return formatMulticall(fullName, decodings, options, this.options, "deadline", options.stylize(deadline.toString(), "number"));
                }
                else if (this.decoding.interpretations.specifiedBlockhashMulticall) {
                    const { specifiedBlockhash, calls: decodings } = this.decoding.interpretations.specifiedBlockhashMulticall;
                    return formatMulticall(fullName, decodings, options, this.options, "previousBlockhash", options.stylize(specifiedBlockhash, "number"));
                }
                return formatFunctionLike(fullName, this.decoding.arguments, options, this.options);
            case "constructor":
                return formatFunctionLike(`new ${this.decoding.class.typeName}`, this.decoding.arguments, options, this.options);
            case "message":
                const { data, abi } = this.decoding;
                //we'll set up a value and inspect that :)
                const codecValue = {
                    kind: "value",
                    type: {
                        typeClass: "bytes",
                        kind: "dynamic"
                    },
                    value: {
                        asHex: data
                    },
                    interpretations: {}
                };
                if (abi) {
                    return formatFunctionLike(`${this.decoding.class.typeName}.${abi.type}`, [{ value: codecValue }], options, this.options, true // we don't need to see the type here!
                    );
                }
                else {
                    return `Sent raw data to ${this.decoding.class.typeName}: ${util_1.default.inspect(new inspect_1.ResultInspector(codecValue, this.options), options)}`;
                }
            case "unknown":
                return "Receiving contract could not be identified.";
            case "create":
                return "Created contract could not be identified.";
        }
    }
}
exports.CalldataDecodingInspector = CalldataDecodingInspector;
function containsDeliberateReadError(result) {
    switch (result.kind) {
        case "value":
            switch (result.type.typeClass) {
                case "struct":
                    //this is currently only intended for use with storage variables, so I
                    //won't bother with handling tuple, magic, options
                    return result.value.some(({ value }) => containsDeliberateReadError(value));
                case "array":
                    return result.value.some(containsDeliberateReadError);
                case "mapping":
                    return result.value.some(({ value }) => containsDeliberateReadError(value));
                default:
                    return false;
            }
        case "error":
            switch (result.error.kind) {
                case "StorageNotSuppliedError":
                case "CodeNotSuppliedError":
                    return true;
                default:
                    return false;
            }
    }
}
exports.containsDeliberateReadError = containsDeliberateReadError;
/**
 * Similar to [[ResultInspector]], but for a [[LogDecoding]].
 * See [[ResultInspector]] for more information.
 */
class LogDecodingInspector {
    constructor(decoding, options) {
        this.decoding = decoding;
        this.options = options || {};
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        const eventName = this.decoding.abi.name;
        let fullName;
        if (this.decoding.definedIn) {
            fullName = `${this.decoding.definedIn}.${eventName}`;
        }
        else if (this.decoding.definedIn === null) {
            //file-level event
            fullName = eventName;
        }
        else {
            //event of unknown definition location
            fullName = `${this.decoding.class.typeName}.${eventName}`;
        }
        switch (this.decoding.kind) {
            case "event":
                return formatFunctionLike(fullName, this.decoding.arguments, options, this.options);
            case "anonymous":
                return formatFunctionLike(`<anonymous> ${fullName}`, this.decoding.arguments, options, this.options);
        }
    }
}
exports.LogDecodingInspector = LogDecodingInspector;
/**
 * Similar to [[ResultInspector]], but for a [[ReturndataDecoding]].
 * See [[ResultInspector]] for more information.
 */
class ReturndataDecodingInspector {
    constructor(decoding, options) {
        this.decoding = decoding;
        this.options = options || {};
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.decoding.kind) {
            case "return":
                return formatFunctionLike("Returned values: ", this.decoding.arguments, options, this.options);
            case "returnmessage":
                const { data } = this.decoding;
                //we'll just set up a value and inspect that :)
                const codecValue = {
                    kind: "value",
                    type: {
                        typeClass: "bytes",
                        kind: "dynamic"
                    },
                    value: {
                        asHex: data
                    },
                    interpretations: {}
                };
                const dataString = util_1.default.inspect(new inspect_1.ResultInspector(codecValue, this.options), options);
                return `Returned raw data: ${dataString}`;
            case "selfdestruct":
                return "The contract self-destructed.";
            case "failure":
                return "The transaction reverted without a message.";
            case "revert":
                const name = this.decoding.definedIn
                    ? `${this.decoding.definedIn.typeName}.${this.decoding.abi.name}`
                    : this.decoding.abi.name;
                return formatFunctionLike(`Error thrown:${os_1.default.EOL}${name}`, this.decoding.arguments, options, this.options);
            case "bytecode":
                //this one gets custom handling :P
                const contractKind = this.decoding.class.contractKind || "contract";
                const firstLine = this.decoding.address !== undefined
                    ? `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName} at ${this.decoding.address}.`
                    : `Returned bytecode for a ${contractKind} ${this.decoding.class.typeName}.`;
                if (this.decoding.immutables && this.decoding.immutables.length > 0) {
                    const prefixes = this.decoding.immutables.map(({ name, class: { typeName } }) => `${typeName}.${name}: `);
                    const maxLength = Math.max(...prefixes.map(prefix => prefix.length));
                    const paddedPrefixes = prefixes.map(prefix => prefix.padStart(maxLength));
                    const formattedValues = this.decoding.immutables.map((value, index) => {
                        const prefix = paddedPrefixes[index];
                        const formatted = indentExcludingFirstLine(util_1.default.inspect(new inspect_1.ResultInspector(value.value, this.options), options), maxLength);
                        return prefix + formatted;
                    });
                    return `Immutable values:${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}`;
                }
                else {
                    return firstLine;
                }
            case "unknownbytecode":
                return "Bytecode was returned, but it could not be identified.";
        }
    }
}
exports.ReturndataDecodingInspector = ReturndataDecodingInspector;
//copied from TestRunner, but simplified for our purposes :)
function indentArray(input, indentation) {
    return input.map(line => " ".repeat(indentation) + line);
}
function indentExcludingFirstLine(input, indentation) {
    const lines = input.split(/\r?\n/);
    return [lines[0], ...indentArray(lines.slice(1), indentation)].join(os_1.default.EOL);
}
function indentMiddleLines(input, indentation) {
    const lines = input.split(/\r?\n/);
    if (lines.length < 2) {
        return input;
    }
    return [
        lines[0],
        ...indentArray(lines.slice(1, -1), indentation),
        lines[lines.length - 1]
    ].join(os_1.default.EOL);
}
//used for formatting things that look like function calls:
//events (including anonymous events), identifiable transactions,
//and revert messages
//"header" param should include everything before the initial parenthesis
/**
 * @hidden
 */
function formatFunctionLike(header, values, options, inspectorOptions, suppressType = false, indent = 2 //for use by debug-utils
) {
    if (values.length === 0) {
        return `${header}()`;
    }
    let formattedValues = values.map(({ name, indexed, value }, index) => {
        const namePrefix = name ? `${name}: ` : "";
        const indexedPrefix = indexed ? "<indexed> " : "";
        const prefix = namePrefix + indexedPrefix;
        const displayValue = util_1.default.inspect(new inspect_1.ResultInspector(value, inspectorOptions), options);
        const typeString = suppressType
            ? ""
            : ` (type: ${Format.Types.typeStringWithoutLocation(value.type)})`;
        return indentMiddleLines(prefix +
            displayValue +
            typeString +
            (index < values.length - 1 ? "," : ""), indent);
    });
    return indentMiddleLines(`${header}(${os_1.default.EOL}${formattedValues.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);
}
exports.formatFunctionLike = formatFunctionLike;
function formatMulticall(fullName, decodings, options, inspectorOptions, additionalParameterName, additionalParameterValue) {
    if (decodings.length === 0) {
        return `${fullName}()`;
    }
    const indent = 2;
    let formattedDecodings = decodings.map((decoding, index) => {
        const formattedDecoding = decoding === null
            ? "<decoding error>"
            : util_1.default.inspect(new CalldataDecodingInspector(decoding, inspectorOptions), options);
        return formattedDecoding + (index < decodings.length - 1 ? "," : "");
    });
    if (additionalParameterName) {
        formattedDecodings.unshift(`${additionalParameterName}: ${additionalParameterValue},`);
    }
    return indentMiddleLines(`${fullName}(${os_1.default.EOL}${formattedDecodings.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);
}
function formatAggregate(fullName, calls, options, inspectorOptions, additionalParameterName, additionalParameterValue, suppressTry = false) {
    if (calls.length === 0) {
        return `${fullName}()`;
    }
    const indent = 2;
    let formattedCalls = calls.map(({ address, allowFailure, value, decoding }, index) => {
        let formattedCall = decoding === null
            ? "<decoding error>"
            : util_1.default.inspect(new CalldataDecodingInspector(decoding, inspectorOptions), options);
        if (value !== null && value.gtn(0)) {
            formattedCall = formattedCall.replace(".", `{value: ${options.stylize(value.toString(), "number")}}.` //HACK: splice in the value
            );
        }
        if (address !== null) {
            formattedCall = formattedCall.replace(".", `(${options.stylize(address, "number")}).`); //HACK: splice in the address
        }
        if (allowFailure && !suppressTry && decoding !== null) {
            formattedCall = "[try] " + formattedCall;
        }
        return formattedCall + (index < calls.length - 1 ? "," : "");
    });
    if (additionalParameterName) {
        formattedCalls.unshift(`${additionalParameterName}: ${additionalParameterValue},`);
    }
    return indentMiddleLines(`${fullName}(${os_1.default.EOL}${formattedCalls.join(os_1.default.EOL)}${os_1.default.EOL})`, indent);
}
//# sourceMappingURL=export.js.map

/***/ }),

/***/ 73440:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Types = void 0;
const Types = __importStar(__webpack_require__(54075));
exports.Types = Types;
//# sourceMappingURL=common.js.map

/***/ }),

/***/ 29965:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Utils = exports.Types = void 0;
/**
 * # Codec Output Format
 *
 * ## Module information
 *
 * This module primarily defines TypeScript types for the output format
 * used in results provided by packages
 * `@truffle/decoder@>=4.0.0` and `@truffle/codec@>=0.1.0`.
 *
 * See below for complete listing or continue reading
 * [Format information](#format-information) to learn about this format.
 *
 * ### How to import
 *
 * Import either as part of Codec or by itself:
 *
 * ```typescript
 * // when importing entire Codec, use Codec.Format.*:
 * import * as Codec from "@truffle/codec";
 *
 * // or import Format directly:
 * import { Format } from "@truffle/codec";
 * ```
 *
 * ![Example struct decoding](media://example-struct-decoding.png)
 *
 * ## Format information
 *
 * This format is intended for use in smart contract and dapp development
 * tools and libraries, and for use in display contexts, such as when
 * building on-screen components to show transaction and smart contract
 * state information.
 *
 * This format seeks to provide an exhaustive schema for JavaScript
 * objects to encode **lossless**, **machine-readable** representations of
 * all possible Solidity and ABI data types and all possible values of those
 * types.
 *
 * This format targets types and values understood by the
 * [Solidity programming language](https://docs.soliditylang.org/) and
 * the [Contract ABI specification](https://docs.soliditylang.org/en/v0.8.19/abi-spec.html),
 * within the context of the [Ethereum Virtual Machine](https://ethereum.github.io/yellowpaper/paper.pdf)
 * (EVM) and in raw data for transactions and logs according to the
 * [Ethereum JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC).
 *
 * Objects in this format may be deeply nested and/or contain circular
 * dependencies. As such, **do not** serialize objects in this format or
 * otherwise attempt to display them in full without considering potential
 * risk. **Objects in this format are for the machine to read, not humans!**
 * This module provides utilities for inspecting objects in this format,
 * including the **safe** [[Format.Utils.Inspect.ResultInspector]] wrapper
 * (for [util.inspect](https://nodejs.org/api/util.html#util_util_inspect_object_options)),
 * and the **unsafe** [[Format.Utils.Inspect.unsafeNativize]] function. For more
 * information, please see the documentation for those utilities.
 *
 * ### Specification
 *
 * Individual decoded values are represented by objects of the type
 * [[Format.Values.Result]], which contain the following fields:
 *   1. `type`: This is a [[Format.Types.Type|`Type`]] object describing the value's
 *     type.  Each `Type` has a `typeClass` field describing the overall broad type,
 *     such as `"uint"` or `"bytes"`, together with additional information that gives
 *     the specific type.  For full detail, see [[Format.Types]].
 *
 *   2. `kind`: This is either `"value"`, in which case the `Result` is a
 *     [[Format.Values.Value|`Value`]], or `"error"`, in which case the `Result` is an
 *     [[Format.Errors.ErrorResult|`ErrorResult`]].  In the former case, there will be
 *     a `value` field containin the decoded value.  In the latter case, there will be
 *     an `error` field indicating what went wrong.  *Warning*: When decoding a
 *     complex type, such as an array, mapping, or array, getting a kind of `"value"`
 *     does not necessarily mean the individual elements were decoded successfully.
 *     Even if the `Result` for the array (mapping, struct) as a whole has kind
 *     `"value"`, the elements might still have kind `"error"`.
 *
 *   3. `value`: As mentioned, this is included when `kind` is equal to `"value"`.
 *     It contains information about the actual decoded value.  See
 *     [[Format.Values|`Format.Values`]] for more information.
 *
 *   4. `error`: The alternative to `value`.  Generally includes information about
 *     the raw data that led to the error.  See [[Format.Errors|`Format.Errors`]] for
 *     more information.
 *
 *   5. `interpretations`: This field will also be present when `kind` is equal
 *     to `"value"`; it is an object that may contain additional information
 *     about the decoded value beyond what is found in `value`.  (All fields in
 *     `interpretations` are always optional and will be included only when
 *     applicable.)  You may wonder, what is the difference between `value`
 *     and `interpretations`?  The answer is that the distinction is largely
 *     historical; `interpretations` was not originally part of the format, and
 *     it was added so that there would be a place to put new additional
 *     information we wanted to include without having to expand `value`.  See
 *     [[Format.Values|`Format.Values`]] for more information.
 *
 *   6. `reference`: This field is a debugger-only feature and does not
 *      apply to results returned by  @truffle/decoder, so it won't be documented here.
 *
 * ### Values vs. errors
 *
 * It's worth taking a moment here to answer the question: What counts as a value,
 * and what counts as an error?
 *
 * In general, the answer is that anything that can be generated via Solidity
 * alone (i.e. no assembly), with correctly-encoded inputs, and without making use
 * of compiler bugs, is a value, not an error.  That means that, for instance, the
 * following things are values, not errors:
 *   - A variable of contract type whose address does not actually hold a
 *     contract of that type;
 *   - An external function pointer that does not correspond to a valid
 *     function;
 *   - A string containing invalid UTF-8;
 *   - ..., etc.
 *
 * By contrast, the following *are* errors:
 *   - A `bool` which is neither `false` (0) nor `true` (1);
 *   - An `enum` which is out of range;
 *   - ..., etc.
 *
 * (You may be wondering about the enum case here, because if you go sufficiently
 * far back, to Solidity 0.4.4 or earlier, it *was* possible to generate
 * out-of-range enums without resorting to assembly or compiler bugs.  However,
 * enums are only supported in full mode (see
 * [Notes on decoding modes](../#decoding-modes)),
 * which only supports 0.4.12 and later, so
 * we consider out-of-range enums an error.  There are also additional technical
 * reasons why supporting out-of-range enums as a value would be difficult.)
 *
 * There are three special cases here that are likely worthy of note.
 *
 * Firstly, internal function pointers currently can't be meaningfully
 * decoded via @truffle/decoder.  However, they decode to a bare-bones value,
 * not an error, as it is (in a sense) our own fault that we can't decode
 * these, so it doesn't make sense to report an error, which would mean that
 * something is wrong with the encoded data itself.  This value that it
 * decodes to will give the program counter values it corresponds to, but
 * will not include the function name or defining class, as @truffle/decoder
 * is not presently capable of that.  For now, full decoding of internal
 * function pointers remains a debugger-only feature.  (But limited support for
 * this via @truffle/decoder is planned for the future.)
 *
 * (When using the debugger, an invalid internal function pointer will decode to an
 * error.  However, when using @truffle/decoder, we have no way of discerning whether
 * the pointer is valid or not, so internal function pointers will always decode to
 * a value, if an uninformative one.)
 *
 * Secondly, when decoding events, it is impossible to decode indexed parameters
 * of reference type.  Thus, these decode to an error
 * (`IndexedReferenceTypeError`, which see) rather than to a value.
 *
 * Thirdly, the decoder is currently limited when it comes to decoding state
 * variables that are declared constant, and not all such variables are yet
 * supported in decoding; attempting to decode one of these that is not currently
 * supported will yield an error.
 *
 * Similarly, there are various things that decode to errors for technical reasons.
 * Objects with encoded length fields larger than what fits in a JavaScript safe
 * integer, or pointed to by pointers with values larger than what fits in a
 * JavaScript safe integer, will decode to errors, even if they may technically be
 * legal.  Such cases are impractical to handle and should never come up in real
 * use so we decode them to errors.  Errors may also be returned in case of an
 * error in attempting to read the data to be decoded.
 *
 * Finally, except when decoding events, we do not return an error if the pointers
 * in an ABI-encoded array or tuple are arranged in a nonstandard way, or if
 * strings or bytestrings are incorrectly padded, because it is not worth the
 * trouble to detect these conditions.
 *
 *
 * ## Notes on this documentation
 *
 * Most of this doesn't have explanatory documentation
 * because it's largely self-explanatory, but particularly
 * non-obvious parts have been documented for clarity.
 *
 * A note on optional fields: A number of types or values
 * have optional fields.  These contain helpful
 * but non-essential information, or information which
 * for technical reasons we can't guarantee we can determine.
 *
 * @category Data
 *
 * @packageDocumentation
 */
const common_1 = __webpack_require__(73440);
Object.defineProperty(exports, "Types", ({ enumerable: true, get: function () { return common_1.Types; } }));
const Utils = __importStar(__webpack_require__(46776));
exports.Utils = Utils;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 54075:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * Contains the types for type objects, and some
 * functions for working with them.
 *
 * @category Main Format
 *
 * @packageDocumentation
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:format:types");
function forgetCompilations(typesByCompilation) {
    return Object.assign({}, ...Object.values(typesByCompilation).map(({ types }) => types));
}
exports.forgetCompilations = forgetCompilations;
function isUserDefinedType(anyType) {
    const userDefinedTypes = [
        "contract",
        "enum",
        "struct",
        "userDefinedValueType"
    ];
    return userDefinedTypes.includes(anyType.typeClass);
}
function isReferenceType(anyType) {
    const alwaysReferenceTypes = ["array", "mapping", "struct", "string"];
    if (alwaysReferenceTypes.includes(anyType.typeClass)) {
        return true;
    }
    else if (anyType.typeClass === "bytes") {
        return anyType.kind === "dynamic";
    }
    else {
        return false;
    }
}
exports.isReferenceType = isReferenceType;
//one could define a counterpart function that stripped all unnecessary information
//from the type object, but at the moment I see no need for that
function fullType(basicType, userDefinedTypes) {
    if (!isUserDefinedType(basicType)) {
        return basicType;
    }
    let id = basicType.id;
    let storedType = userDefinedTypes[id];
    if (!storedType) {
        return basicType;
    }
    let returnType = Object.assign(Object.assign({}, basicType), storedType);
    if (isReferenceType(basicType) && basicType.location !== undefined) {
        returnType = specifyLocation(returnType, basicType.location);
    }
    return returnType;
}
exports.fullType = fullType;
//the location argument here always forces, so passing undefined *will* force undefined
function specifyLocation(dataType, location) {
    if (isReferenceType(dataType)) {
        switch (dataType.typeClass) {
            case "string":
            case "bytes":
                return Object.assign(Object.assign({}, dataType), { location });
            case "array":
                return Object.assign(Object.assign({}, dataType), { location, baseType: specifyLocation(dataType.baseType, location) });
            case "mapping":
                let newLocation = location === "storage" ? "storage" : undefined;
                return Object.assign(Object.assign({}, dataType), { location: newLocation, valueType: specifyLocation(dataType.valueType, newLocation) });
            case "struct":
                let returnType = Object.assign(Object.assign({}, dataType), { location });
                if (returnType.memberTypes) {
                    returnType.memberTypes = returnType.memberTypes.map(({ name: memberName, type: memberType }) => ({
                        name: memberName,
                        type: specifyLocation(memberType, location)
                    }));
                }
                return returnType;
        }
    }
    else {
        return dataType;
    }
}
exports.specifyLocation = specifyLocation;
//NOTE: the following two functions might not be exactly right for weird internal stuff,
//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things
//are pointers or not??  we don't track that so we can't recreate that)
//But what can you do.
function typeString(dataType) {
    let baseString = typeStringWithoutLocation(dataType);
    if (isReferenceType(dataType) && dataType.location) {
        return baseString + " " + dataType.location;
    }
    else {
        return baseString;
    }
}
exports.typeString = typeString;
function typeStringWithoutLocation(dataType) {
    switch (dataType.typeClass) {
        case "uint":
            return dataType.typeHint || `uint${dataType.bits}`;
        case "int":
            return dataType.typeHint || `int${dataType.bits}`;
        case "bool":
            return dataType.typeHint || "bool";
        case "bytes":
            if (dataType.typeHint) {
                return dataType.typeHint;
            }
            switch (dataType.kind) {
                case "dynamic":
                    return "bytes";
                case "static":
                    return `bytes${dataType.length}`;
            }
        case "address":
            switch (dataType.kind) {
                case "general":
                    return dataType.typeHint || "address"; //I guess?
                case "specific":
                    return dataType.payable ? "address payable" : "address";
            }
        case "string":
            return dataType.typeHint || "string";
        case "fixed":
            return dataType.typeHint || `fixed${dataType.bits}x${dataType.places}`;
        case "ufixed":
            return dataType.typeHint || `ufixed${dataType.bits}x${dataType.places}`;
        case "array":
            if (dataType.typeHint) {
                return dataType.typeHint;
            }
            switch (dataType.kind) {
                case "dynamic":
                    return `${typeStringWithoutLocation(dataType.baseType)}[]`;
                case "static":
                    return `${typeStringWithoutLocation(dataType.baseType)}[${dataType.length}]`;
            }
        case "mapping":
            return `mapping(${typeStringWithoutLocation(dataType.keyType)} => ${typeStringWithoutLocation(dataType.valueType)})`;
        case "struct":
        case "enum":
            //combining these cases for simplicity
            switch (dataType.kind) {
                case "local":
                    return `${dataType.typeClass} ${dataType.definingContractName}.${dataType.typeName}`;
                case "global":
                    return `${dataType.typeClass} ${dataType.typeName}`;
            }
            break; //to satisfy TS :P
        case "userDefinedValueType":
            //differs from struct & enum in that typeClass is omitted
            switch (dataType.kind) {
                case "local":
                    return `${dataType.definingContractName}.${dataType.typeName}`;
                case "global":
                    return `${dataType.typeName}`;
            }
            break; //to satisfy TS :P
        case "tuple":
            return (dataType.typeHint ||
                "tuple(" +
                    dataType.memberTypes
                        .map(memberType => typeString(memberType.type))
                        .join(",") +
                    ")"); //note that we do include location and do not put spaces
        case "contract":
            return dataType.contractKind + " " + dataType.typeName;
        case "magic":
            //no, this is not transposed!
            const variableNames = {
                message: "msg",
                transaction: "tx",
                block: "block"
            };
            return variableNames[dataType.variable];
        case "type":
            return `type(${typeString(dataType.type)})`;
        case "function":
            let visibilityString;
            switch (dataType.visibility) {
                case "external":
                    if (dataType.kind === "general") {
                        if (dataType.typeHint) {
                            return dataType.typeHint;
                        }
                        else {
                            return "function external"; //I guess???
                        }
                    }
                    visibilityString = " external"; //note the deliberate space!
                    break;
                case "internal":
                    visibilityString = "";
                    break;
            }
            let mutabilityString = dataType.mutability === "nonpayable" ? "" : " " + dataType.mutability; //again, note the deliberate space
            let inputList = dataType.inputParameterTypes.map(typeString).join(","); //note that we do include location, and do not put spaces
            let outputList = dataType.outputParameterTypes.map(typeString).join(",");
            let inputString = `function(${inputList})`;
            let outputString = outputList === "" ? "" : ` returns (${outputList})`; //again, note the deliberate space
            return inputString + mutabilityString + visibilityString + outputString;
        case "options":
            //note: not a real Solidity type! just for error messaging!
            return "options";
    }
}
exports.typeStringWithoutLocation = typeStringWithoutLocation;
function isContractDefinedType(anyType) {
    const contractDefinedTypes = ["enum", "struct", "userDefinedValueType"];
    return (contractDefinedTypes.includes(anyType.typeClass) &&
        anyType.kind === "local");
}
exports.isContractDefinedType = isContractDefinedType;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 9898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.tie = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:format:utils:circularity");
function tie(untied) {
    return tieWithTable(untied, []);
}
exports.tie = tie;
function tieWithTable(untied, seenSoFar) {
    if (untied.kind === "error") {
        return untied;
    }
    let reference;
    switch (untied.type.typeClass) {
        case "array":
            const untiedAsArray = untied; //dammit TS
            reference = untiedAsArray.reference;
            if (reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                let tied = Object.assign(Object.assign({}, untiedAsArray), { value: [...untiedAsArray.value] });
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* value, not replace it with a new object
                //note: this used to be a for-in loop, changed to avoid problems with VSCode
                for (let index = 0; index < tied.value.length; index++) {
                    tied.value[index] = tieWithTable(tied.value[index], [
                        tied,
                        ...seenSoFar
                    ]);
                }
                return tied;
            }
            else {
                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), { reference });
            }
        case "struct":
            const untiedAsStruct = untied; //dammit TS
            reference = untiedAsStruct.reference;
            if (reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                let tied = Object.assign(Object.assign({}, untiedAsStruct), { value: untiedAsStruct.value.map(component => (Object.assign({}, component))) });
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* value, not replace it with a new object
                //note: this used to be a for-in loop, changed to avoid problems with VSCode
                for (let index = 0; index < tied.value.length; index++) {
                    tied.value[index] = Object.assign(Object.assign({}, tied.value[index]), { value: tieWithTable(tied.value[index].value, [tied, ...seenSoFar]) });
                }
                return tied;
            }
            else {
                return Object.assign(Object.assign({}, seenSoFar[reference - 1]), { reference });
            }
        case "tuple": //currently there are no memory tuples, but may as well
            //can't be circular, just recurse
            //note we can just recurse with a straight tie here; don't need tieWithTable
            const untiedAsTuple = untied; //dammit TS
            //we need to do some pointer stuff here, so let's first create our new
            //object we'll be pointing to
            let tied = Object.assign({}, untiedAsTuple);
            tied.value = tied.value.map(component => (Object.assign(Object.assign({}, component), { value: tie(component.value) })));
            return tied;
        default:
            //other types either:
            //1. aren't containers and so need no recursion
            //2. are containers but can't go in or contain memory things
            //and so still need no recursion
            //(or, in the case of mappings, can't contain *nontrivial* memory
            //things)
            return untied;
    }
}
//# sourceMappingURL=circularity.js.map

/***/ }),

/***/ 65086:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.message = void 0;
/**
 * @protected
 *
 * @packageDocumentation
 */
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:format:utils:exception");
const Format = __importStar(__webpack_require__(73440));
const AstUtils = __importStar(__webpack_require__(7656));
//this function gives an error message
//for those errors that are meant to possibly
//be wrapped in a DecodingError and thrown
function message(error) {
    switch (error.kind) {
        case "UserDefinedTypeNotFoundError":
            let typeName = Format.Types.isContractDefinedType(error.type)
                ? error.type.definingContractName + "." + error.type.typeName
                : error.type.typeName;
            return `Unknown ${error.type.typeClass} type ${typeName} of id ${error.type.id}`;
        case "UnsupportedConstantError":
            return `Unsupported constant type ${AstUtils.typeClass(error.definition)}`;
        case "UnusedImmutableError":
            return "Cannot read unused immutable";
        case "ReadErrorStack":
            return `Can't read stack from position ${error.from} to ${error.to}`;
        case "ReadErrorBytes":
            return `Can't read ${error.length} bytes from ${error.location} starting at ${error.start}`;
        case "ReadErrorStorage":
            if (error.range.length) {
                return `Can't read ${error.range.length} bytes from storage starting at index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)}`;
            }
            else {
                return `Can't read storage from index ${error.range.from.index} in ${slotAddressPrintout(error.range.from.slot)} to index ${error.range.to.index} in ${slotAddressPrintout(error.range.to.slot)}`;
            }
        case "StorageNotSuppliedError":
            return `Unknown storage at slot ${error.slot.toString()}`; //note: not actually used at present
        case "CodeNotSuppliedError":
            return `Unknown code for address ${error.address}`; //note: not actually used at present
    }
}
exports.message = message;
function slotAddressPrintout(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        let { type: keyEncoding, value: keyValue } = keyInfoForPrinting(slot.key);
        return ("keccak(" +
            keyValue +
            " as " +
            keyEncoding +
            ", " +
            slotAddressPrintout(slot.path) +
            ") + " +
            slot.offset.toString());
    }
    else if (slot.path !== undefined) {
        const pathAddressPrintout = slotAddressPrintout(slot.path);
        return slot.hashPath
            ? "keccak(" + pathAddressPrintout + ")" + slot.offset.toString()
            : pathAddressPrintout + slot.offset.toString();
    }
    else {
        return slot.offset.toString();
    }
}
//this is like the old toSoliditySha3Input, but for debugging purposes ONLY
//it will NOT produce correct input to soliditySha3
//please use mappingKeyAsHex instead if you wish to encode a mapping key.
function keyInfoForPrinting(input) {
    switch (input.type.typeClass) {
        case "uint":
            return {
                type: "uint",
                value: input.value.asBN.toString()
            };
        case "int":
            return {
                type: "int",
                value: input.value.asBN.toString()
            };
        case "fixed":
            return {
                type: `fixed256x${input.type.places}`,
                value: input.value.asBig.toString()
            };
        case "ufixed":
            return {
                type: `ufixed256x${input.type.places}`,
                value: input.value.asBig.toString()
            };
        case "bool":
            //this is the case that won't work as valid input to soliditySha3 :)
            return {
                type: "uint",
                value: input.value.asBoolean.toString()
            };
        case "bytes":
            switch (input.type.kind) {
                case "static":
                    return {
                        type: "bytes32",
                        value: input.value.asHex
                    };
                case "dynamic":
                    return {
                        type: "bytes",
                        value: input.value.asHex
                    };
            }
        case "address":
            return {
                type: "address",
                value: input.value.asAddress
            };
        case "string":
            let coercedInput = (input);
            switch (coercedInput.value.kind) {
                case "valid":
                    return {
                        type: "string",
                        value: coercedInput.value.asString
                    };
                case "malformed":
                    return {
                        type: "bytes",
                        value: coercedInput.value.asHex
                    };
            }
        //fixed and ufixed are skipped for now
    }
}
//# sourceMappingURL=exception.js.map

/***/ }),

/***/ 46776:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Circularity = exports.Inspect = exports.Exception = void 0;
const Exception = __importStar(__webpack_require__(65086));
exports.Exception = Exception;
const Inspect = __importStar(__webpack_require__(49290));
exports.Inspect = Inspect;
const Circularity = __importStar(__webpack_require__(9898));
exports.Circularity = Circularity;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 49290:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringValueInfoToStringLossy = exports.nativizeAccessList = exports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:format:utils:inspect");
const util_1 = __importDefault(__webpack_require__(73837));
const Format = __importStar(__webpack_require__(73440));
const Conversion = __importStar(__webpack_require__(52714));
const EvmUtils = __importStar(__webpack_require__(59901));
const Exception = __importStar(__webpack_require__(65086));
//HACK?
function cleanStylize(options) {
    const clonedOptions = Object.assign({}, options);
    delete clonedOptions.stylize;
    return clonedOptions;
}
/**
 * This class is meant to be used with Node's
 * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)
 * function.  Given a [[Format.Values.Result]] `value`, one can use
 * `new ResultInspector(value)` to create a ResultInspector for that value,
 * which can be used with util.inspect() to create a human-readable string
 * representing the value.
 *
 * @example
 * Suppose `value` is a Result.  In Node, the following would print to the
 * console a human-readable representation of `value`, with colors enabled,
 * no maximum depth, and no maximum array length, and lines (usually) no
 * longer than 80 characters:
 * ```javascript
 * console.log(
 *   util.inspect(
 *     new ResultInspector(value),
 *     {
 *       colors: true,
 *       depth: null,
 *       maxArrayLength: null,
 *       breakLength: 80
 *     }
 *   )
 * );
 * ```
 * Of course, there are many other ways to use util.inspect; see Node's
 * documentation, linked above, for more.
 */
class ResultInspector {
    constructor(result, options) {
        this.result = result;
        this.options = options || {};
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        switch (this.result.kind) {
            case "value":
                switch (this.result.type.typeClass) {
                    case "uint":
                    case "int":
                        return options.stylize((this.result).value.asBN.toString(), "number");
                    case "fixed":
                    case "ufixed":
                        //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;
                        //we'll trust those to their defaults
                        return options.stylize((this.result).value.asBig.toString(), "number");
                    case "bool":
                        return util_1.default.inspect(this.result.value.asBoolean, options);
                    case "bytes":
                        let hex = this.result.value.asHex;
                        switch (this.result.type.kind) {
                            case "static":
                                return options.stylize(hex, "number");
                            case "dynamic":
                                return options.stylize(`hex'${hex.slice(2)}'`, "string");
                        }
                    case "address": {
                        const coercedValue = this.result;
                        //the address/contract distinction has gotten pretty silly!
                        //so we're just going to convert to the contract case and
                        //use the existing code there.
                        const contractValueInfo = coercedValue.interpretations.contractClass
                            ? {
                                kind: "known",
                                address: coercedValue.value.asAddress,
                                class: coercedValue.interpretations.contractClass
                            }
                            : {
                                kind: "unknown",
                                address: coercedValue.value.asAddress
                            };
                        return util_1.default.inspect(new ContractInfoInspector(contractValueInfo, coercedValue.interpretations.ensName, this.options), options);
                    }
                    case "string":
                        return util_1.default.inspect(stringValueInfoToStringLossy(this.result.value), options);
                    case "array": {
                        let coercedResult = this.result;
                        if (coercedResult.reference !== undefined) {
                            return formatCircular(coercedResult.reference, options);
                        }
                        return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element, this.options)), options);
                    }
                    case "mapping":
                        if (!this.options.renderMappingsViaObjects) {
                            //normal case
                            return util_1.default.inspect(new Map(this.result.value.map(({ key, value }) => [
                                new ResultInspector(key, this.options),
                                new ResultInspector(value, this.options)
                            ])), options);
                        }
                        else {
                            //compatibility case
                            return util_1.default.inspect(Object.assign({}, ...this.result.value.map(({ key, value }) => ({
                                //need to stringify key
                                [util_1.default.inspect(new ResultInspector(key, this.options), options)]: new ResultInspector(value, this.options)
                            }))), options);
                        }
                    case "struct": {
                        let coercedResult = this.result;
                        if (coercedResult.reference !== undefined) {
                            return formatCircular(coercedResult.reference, options);
                        }
                        return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({ name, value }) => ({
                            [name]: new ResultInspector(value, this.options)
                        }))), options);
                    }
                    case "userDefinedValueType": {
                        const typeName = Format.Types.typeStringWithoutLocation(this.result.type);
                        const coercedResult = (this.result);
                        const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value, this.options), options);
                        return `${typeName}.wrap(${inspectOfUnderlying})`; //note only the underlying part is stylized
                    }
                    case "tuple": {
                        let coercedResult = this.result;
                        //if everything is named, do same as with struct.
                        //if not, just do an array.
                        //(good behavior in the mixed case is hard, unfortunately)
                        if (coercedResult.value.every(({ name }) => name)) {
                            return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({ name, value }) => ({
                                [name]: new ResultInspector(value, this.options)
                            }))), options);
                        }
                        else {
                            return util_1.default.inspect(coercedResult.value.map(({ value }) => new ResultInspector(value, this.options)), options);
                        }
                    }
                    case "type": {
                        switch (this.result.type.type.typeClass) {
                            case "contract":
                                //same as struct case but w/o circularity check
                                return util_1.default.inspect(Object.assign({}, ...this.result.value.map(({ name, value }) => ({
                                    [name]: new ResultInspector(value, this.options)
                                }))), options);
                            case "enum": {
                                return enumTypeName(this.result.type.type);
                            }
                        }
                    }
                    case "magic":
                        return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(([key, value]) => ({
                            [key]: new ResultInspector(value, this.options)
                        }))), options);
                    case "enum": {
                        return enumFullName(this.result); //not stylized
                    }
                    case "contract": {
                        const coercedValue = this.result;
                        return util_1.default.inspect(new ContractInfoInspector(coercedValue.value, coercedValue.interpretations.ensName, this.options), options);
                    }
                    case "function":
                        switch (this.result.type.visibility) {
                            case "external": {
                                const coercedResult = this
                                    .result;
                                const contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract, coercedResult.interpretations.contractEnsName, this.options), Object.assign(Object.assign({}, cleanStylize(options)), { colors: false }));
                                let firstLine;
                                switch (coercedResult.value.kind) {
                                    case "known":
                                        firstLine = `[Function: ${coercedResult.value.abi.name} of`;
                                        break;
                                    case "invalid":
                                    case "unknown":
                                        firstLine = `[Function: Unknown selector ${coercedResult.value.selector} of`;
                                        break;
                                }
                                let secondLine = `${contractString}]`;
                                let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength
                                    ? "\n"
                                    : " ";
                                //now, put it together
                                return options.stylize(firstLine + breakingSpace + secondLine, "special");
                            }
                            case "internal": {
                                let coercedResult = (this.result);
                                switch (coercedResult.value.kind) {
                                    case "function":
                                        if (coercedResult.value.definedIn) {
                                            return options.stylize(`[Function: ${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}]`, "special");
                                        }
                                        else {
                                            return options.stylize(`[Function: ${coercedResult.value.name}]`, "special");
                                        }
                                    case "exception":
                                        switch (coercedResult.value.rawInformation.kind) {
                                            case "index":
                                                return options.stylize(`[Function: <uninitialized>]`, "special");
                                            case "pcpair":
                                                //see above for discussion of this distinction
                                                return coercedResult.value.rawInformation
                                                    .deployedProgramCounter === 0
                                                    ? options.stylize(`[Function: <zero>]`, "special")
                                                    : options.stylize(`[Function: <uninitialized>]`, "special");
                                        }
                                    case "unknown":
                                        let firstLine = `[Function: could not decode (raw info:`;
                                        let secondLine = `${formatInternalFunctionRawInfo(coercedResult.value.rawInformation)})]`;
                                        let breakingSpace = firstLine.length + secondLine.length + 1 >
                                            options.breakLength
                                            ? "\n"
                                            : " ";
                                        //now, put it together
                                        return options.stylize(firstLine + breakingSpace + secondLine, "special");
                                }
                            }
                        }
                }
            case "error": {
                debug("this.result: %O", this.result);
                let errorResult = this.result; //the hell?? why couldn't it make this inference??
                switch (errorResult.error.kind) {
                    case "WrappedError":
                        return util_1.default.inspect(new ResultInspector(errorResult.error.error, this.options), options);
                    case "UintPaddingError":
                        return `Uint has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "IntPaddingError":
                        return `Int has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "UintPaddingError":
                        return `Ufixed has (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "FixedPaddingError":
                        return `Fixed has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "BoolOutOfRangeError":
                        return `Invalid boolean (numeric value ${errorResult.error.rawAsBN.toString()})`;
                    case "BoolPaddingError":
                        return `Boolean has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "BytesPaddingError":
                        return `Bytestring has extra trailing bytes (padding error) (raw value ${errorResult.error.raw})`;
                    case "AddressPaddingError":
                        return `Address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "EnumOutOfRangeError":
                        return `Invalid ${enumTypeName(errorResult.error.type)} (numeric value ${errorResult.error.rawAsBN.toString()})`;
                    case "EnumPaddingError":
                        return `Enum ${enumTypeName(errorResult.error.type)} has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "EnumNotFoundDecodingError":
                        return `Unknown enum type ${enumTypeName(errorResult.error.type)} of id ${errorResult.error.type.id} (numeric value ${errorResult.error.rawAsBN.toString()})`;
                    case "ContractPaddingError":
                        return `Contract address has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "FunctionExternalNonStackPaddingError":
                        return `External function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "FunctionExternalStackPaddingError":
                        return `External function address or selector has extra leading bytes (padding error) (raw address ${errorResult.error.rawAddress}, raw selector ${errorResult.error.rawSelector})`;
                    case "FunctionInternalPaddingError":
                        return `Internal function has incorrect padding (expected padding: ${errorResult.error.paddingType}) (raw value ${errorResult.error.raw})`;
                    case "NoSuchInternalFunctionError":
                        return `Invalid function (${formatInternalFunctionRawInfo(errorResult.error.rawInformation)}) of contract ${errorResult.error.context.typeName}`;
                    case "DeployedFunctionInConstructorError":
                        return `Deployed-style function (PC=${errorResult.error.rawInformation.deployedProgramCounter}) in constructor`;
                    case "MalformedInternalFunctionError":
                        return `Malformed internal function w/constructor PC only (value: ${errorResult.error.rawInformation.constructorProgramCounter})`;
                    case "IndexedReferenceTypeError": //for this one we'll bother with some line-wrapping
                        let firstLine = `Cannot decode indexed parameter of reference type ${errorResult.error.type.typeClass}`;
                        let secondLine = `(raw value ${errorResult.error.raw})`;
                        let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength
                            ? "\n"
                            : " ";
                        return firstLine + breakingSpace + secondLine;
                    case "OverlongArraysAndStringsNotImplementedError":
                        return `Array or string is too long (length ${errorResult.error.lengthAsBN.toString()}); decoding is not supported`;
                    case "OverlargePointersNotImplementedError":
                        return `Pointer is too large (value ${errorResult.error.pointerAsBN.toString()}); decoding is not supported`;
                    case "UserDefinedTypeNotFoundError":
                    case "UnsupportedConstantError":
                    case "UnusedImmutableError":
                    case "ReadErrorStack":
                    case "ReadErrorStorage":
                    case "ReadErrorBytes":
                        return Exception.message(errorResult.error); //yay, these five are already defined!
                    case "StorageNotSuppliedError":
                    case "CodeNotSuppliedError": //this latter one is not used at present
                        //these ones have a message, but we're going to special-case it
                        return options.stylize("?", "undefined");
                }
            }
        }
    }
}
exports.ResultInspector = ResultInspector;
//these get their own class to deal with a minor complication
class ContractInfoInspector {
    constructor(value, ensName, options) {
        this.value = value;
        this.ensName = ensName;
        this.options = options || {};
    }
    /**
     * @dev non-standard alternative interface name used by browser-util-inspect
     *      package
     */
    inspect(depth, options) {
        return this[util_1.default.inspect.custom].bind(this)(depth, options);
    }
    [util_1.default.inspect.custom](depth, options) {
        const { noHideAddress } = this.options;
        const addressString = options.stylize(this.value.address, "number");
        let mainIdentifier = addressString;
        if (this.ensName) {
            //replace address with name
            mainIdentifier = options.stylize(stringValueInfoToStringLossy(this.ensName), "special");
        }
        let withClass;
        switch (this.value.kind) {
            case "known":
                withClass = `${mainIdentifier} (${this.value.class.typeName})`;
                break;
            case "unknown":
                withClass = `${mainIdentifier} of unknown class`;
                break;
        }
        if (this.ensName && noHideAddress) {
            //this might get a bit long, so let's break it up if needed
            const breakingSpace = withClass.length + addressString.length + 3 > options.breakLength
                ? "\n"
                : " ";
            return `${withClass}${breakingSpace}[${addressString}]`;
        }
        else {
            return withClass;
        }
    }
}
function enumTypeName(enumType) {
    return ((enumType.kind === "local" ? enumType.definingContractName + "." : "") +
        enumType.typeName);
}
function formatInternalFunctionRawInfo(info) {
    switch (info.kind) {
        case "pcpair":
            return `Deployed PC=${info.deployedProgramCounter}, Constructor PC=${info.constructorProgramCounter}`;
        case "index":
            return `Index=${info.functionIndex}`;
    }
}
//this function will be used in the future for displaying circular
//structures
function formatCircular(loopLength, options) {
    return options.stylize(`[Circular (=up ${loopLength})]`, "special");
}
function enumFullName(value) {
    switch (value.type.kind) {
        case "local":
            return `${value.type.definingContractName}.${value.type.typeName}.${value.value.name}`;
        case "global":
            return `${value.type.typeName}.${value.value.name}`;
    }
}
/**
 * WARNING! Do NOT use this function in real code unless you
 * absolutely have to!  Using it in controlled tests is fine,
 * but do NOT use it in real code if you have any better option!
 * See [[unsafeNativize]] for why!
 */
function unsafeNativizeVariables(variables) {
    return Object.assign({}, ...Object.entries(variables).map(([name, value]) => {
        try {
            return { [name]: unsafeNativize(value) };
        }
        catch (_) {
            return undefined; //I guess??
        }
    }));
}
exports.unsafeNativizeVariables = unsafeNativizeVariables;
//HACK! Avoid using!
/**
 * WARNING! Do NOT use this function in real code unless you absolutely have
 * to!  Using it in controlled tests is fine, but do NOT use it in real code if
 * you have any better option!
 *
 * This function is a giant hack.  It will throw exceptions on numbers that
 * don't fit in a Javascript number.  It loses various information.  It was
 * only ever written to support our hacked-together watch expression system,
 * and later repurposed to make testing easier.
 *
 * If you are not doing something as horrible as evaluating user-inputted
 * Javascript expressions meant to operate upon Solidity variables, then you
 * probably have a better option than using this in real code!
 *
 * (For instance, if you just want to nicely print individual values, without
 * attempting to first operate on them via Javascript expressions, we have the
 * [[ResultInspector]] class, which can be used with Node's
 * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)
 * to do exactly that.)
 *
 * Remember, the decoder output format was made to be machine-readable.  It
 * shouldn't be too hard for you to process.  If it comes to it, copy-paste
 * this code and dehackify it for your use case, which hopefully is more
 * manageable than the one that caused us to write this.
 */
function unsafeNativize(result) {
    return unsafeNativizeWithTable(result, []);
}
exports.unsafeNativize = unsafeNativize;
function unsafeNativizeWithTable(result, seenSoFar) {
    if (result.kind === "error") {
        debug("ErrorResult: %O", result);
        switch (result.error.kind) {
            case "BoolOutOfRangeError":
                return true;
            default:
                return undefined;
        }
    }
    //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;
    //other containers will just call unsafeNativize because they can get away with it
    //(only things that can *be* circular need unsafeNativizeWithTable, not things that
    //can merely *contain* circularities)
    switch (result.type.typeClass) {
        case "uint":
        case "int":
            return (result).value.asBN.toNumber(); //WARNING
        case "bool":
            return result.value.asBoolean;
        case "bytes":
            return result.value.asHex;
        case "address":
            return result.value.asAddress;
        case "string":
            return stringValueInfoToStringLossy(result.value);
        case "fixed":
        case "ufixed":
            //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number
            //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of
            //notation shouldn't affect the result (can you believe I have to write this? @_@)
            return Number((result).value.asBig.toString()); //WARNING
        case "array": {
            let coercedResult = result;
            if (coercedResult.reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                //[we don't want to alter the original accidentally so let's clone a bit]
                let output = [...coercedResult.value];
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* output, not replace it with a new object
                for (let index = 0; index < output.length; index++) {
                    output[index] = unsafeNativizeWithTable(output[index], [
                        output,
                        ...seenSoFar
                    ]);
                }
                return output;
            }
            else {
                return seenSoFar[coercedResult.reference - 1];
            }
        }
        case "userDefinedValueType": {
            return unsafeNativize(result.value);
        }
        case "mapping":
            return Object.assign({}, ...result.value.map(({ key, value }) => ({
                [unsafeNativize(key).toString()]: unsafeNativize(value)
            })));
        case "struct": {
            let coercedResult = result;
            if (coercedResult.reference === undefined) {
                //we need to do some pointer stuff here, so let's first create our new
                //object we'll be pointing to
                let output = Object.assign({}, ...result.value.map(({ name, value }) => ({
                    [name]: value //we *don't* nativize yet!
                })));
                //now, we can't use a map here, or we'll screw things up!
                //we want to *mutate* output, not replace it with a new object
                for (let name in output) {
                    output[name] = unsafeNativizeWithTable(output[name], [
                        output,
                        ...seenSoFar
                    ]);
                }
                return output;
            }
            else {
                return seenSoFar[coercedResult.reference - 1];
            }
        }
        case "type":
            switch (result.type.type.typeClass) {
                case "contract":
                    return Object.assign({}, ...result.value.map(({ name, value }) => ({
                        [name]: unsafeNativize(value)
                    })));
                case "enum":
                    return Object.assign({}, ...result.value.map(enumValue => ({
                        [enumValue.value.name]: unsafeNativize(enumValue)
                    })));
            }
        case "tuple":
            return result.value.map(({ value }) => unsafeNativize(value));
        case "magic":
            return Object.assign({}, ...Object.entries(result.value).map(([key, value]) => ({ [key]: unsafeNativize(value) })));
        case "enum":
            return enumFullName(result);
        case "contract":
            return result.value.address; //we no longer include additional info
        case "function":
            switch (result.type.visibility) {
                case "external": {
                    let coercedResult = result;
                    switch (coercedResult.value.kind) {
                        case "known":
                            return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).${coercedResult.value.abi.name}`;
                        case "invalid":
                            return `${coercedResult.value.contract.class.typeName}(${coercedResult.value.contract.address}).call(${coercedResult.value.selector}...)`;
                        case "unknown":
                            return `${coercedResult.value.contract.address}.call(${coercedResult.value.selector}...)`;
                    }
                }
                case "internal": {
                    let coercedResult = result;
                    switch (coercedResult.value.kind) {
                        case "function":
                            if (coercedResult.value.definedIn) {
                                return `${coercedResult.value.definedIn.typeName}.${coercedResult.value.name}`;
                            }
                            else {
                                return coercedResult.value.name;
                            }
                        case "exception":
                            switch (coercedResult.value.rawInformation.kind) {
                                case "index":
                                    return `<uninitialized>`;
                                case "pcpair":
                                    //in this case, we'll distinguish between "zero" and "uninitialized",
                                    //on the basis that uninitialized internal function pointers in non-storage
                                    //locations are not zero.  in the index case this distinction doesn't come up.
                                    return coercedResult.value.rawInformation
                                        .deployedProgramCounter === 0
                                        ? `<zero>`
                                        : `<uninitialized>`;
                            }
                        case "unknown":
                            return `<could not decode>`;
                    }
                }
            }
    }
}
/**
 * Turns a wrapped access list into a usable form.
 * Will fail if the input is not a wrapped access list!
 * Note that the storage keys must be given as uint256, not bytes32.
 * Primarily meant for internal use.
 */
function nativizeAccessList(wrappedAccessList //this should really be a more specific type
) {
    return wrappedAccessList.value.map(wrappedAccessListForAddress => {
        //HACK: we're just going to coerce all over the place here
        const addressStorageKeysPair = (wrappedAccessListForAddress.value);
        const wrappedAddress = (addressStorageKeysPair[0].value);
        const wrappedStorageKeys = (addressStorageKeysPair[1].value);
        const wrappedStorageKeysArray = (wrappedStorageKeys.value);
        return {
            address: wrappedAddress.value.asAddress,
            storageKeys: wrappedStorageKeysArray.map(wrappedStorageKey => Conversion.toHexString(wrappedStorageKey.value.asBN, EvmUtils.WORD_SIZE))
        };
    });
}
exports.nativizeAccessList = nativizeAccessList;
//turns a StringValueInfo into a string in a lossy fashion,
//by turning malformed utf-8 into replacement characters (U+FFFD)
function stringValueInfoToStringLossy(info) {
    switch (info.kind) {
        case "valid":
            return info.asString;
        case "malformed":
            return Buffer.from(info.asHex.slice(2), // note we need to cut off the 0x prefix
            "hex").toString();
    }
}
exports.stringValueInfoToStringLossy = stringValueInfoToStringLossy;
//# sourceMappingURL=inspect.js.map

/***/ }),

/***/ 20102:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * # Truffle Codec
 *
 * This module provides low-level decoding and encoding functionality for
 * Solidity and the Solidity ABI.  Many parts of this module are intended
 * primarily for internal use by Truffle and so remain largely undocumented,
 * but some of its types are also output by @truffle/decoder, which provides
 * a higher-level interface to much of this module's functionality.
 *
 * ## If you're here from Truffle Decoder or Truffle Encoder
 *
 * If you're coming here from [[@truffle/decoder]] or [[@truffle/encoder]],
 * you probably just want to know about the parts that are relevant to you.
 * These are:
 *
 * * The "data" category (specifically [[Format]])
 * * The "output" and "enumerations" categories ([[CalldataDecoding]], [[LogDecoding]], et al., see below)
 * * The "errors" category (specifically [[UnknownUserDefinedTypeError]])
 *
 * Note that the data category is largely scarce in
 * documentation, although that's because it's largely self-explanatory.
 *
 * If you're not just here from Truffle Decoder or Encoder, but are actually
 * interested in the lower-level workings, read on.
 *
 * ## How this module differs from Truffle Decoder and Encoder
 *
 * Unlike Truffle Decoder and Encoder, this library makes no network connections
 * and avoids dependencies that do.  Instead, its decoding functionality
 * is generator-based; calling one of the decoding functions returns a
 * generator.  This generator's `next()` function may return a finished
 * result, or it may return a request for more information.  It is up to
 * the caller to fulfill these requests -- say, by making a network
 * connection of its own.  This is how @truffle/decoder and @truffle/encoder
 * work; @truffle/codec makes requests, while Decoder and Encoder fulfill them by
 * looking up the necessary information on the blockchain.
 *
 * This library also provides additional functionality beyond what's used by
 * Truffle Decoder and Encoder.  In particular, this library also exists to
 * support Truffle Debugger, and so it provides decoding functionality not just
 * for transactions, logs, and state variables, but also for Solidity variables
 * during transaction execution, including circularity detection for memroy
 * structures.  It includes functionality for decoding Solidity's internal
 * function pointers, which the debugger uses, but which Truffle Decoder
 * currently does not (although this is planned for the future).
 *
 * There is also functionality for decoding return values and revert messages
 * that goes beyond what's currently available in @truffle/decoder; this may get
 * a better interface in the future.
 *
 * ## How to use
 *
 * You should probably use [[@truffle/decoder]] or [[@truffle/encoder]]
 * instead, if your use case doesn't preclude it.  This module has little
 * documentation, where it has any at all, and it's likely that parts of its
 * interface may change (particularly regarding allocation).  That said, if you
 * truly need the functionality here, Truffle Decoder and Truffle Encoder can
 * perhaps serve as something of a reference implementation (and perhaps
 * Truffle Debugger as well, though that code is much harder to read or copy).
 *
 * @module @truffle/codec
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wrap = exports.Export = exports.Evm = exports.Conversion = exports.Contexts = exports.Compilations = exports.Compiler = exports.Ast = exports.AstConstant = exports.Storage = exports.Stack = exports.Special = exports.Memory = exports.MappingKey = exports.Topic = exports.AbiData = exports.Bytes = exports.Basic = exports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.RepeatCompilationIdError = exports.NoProjectInfoError = exports.StopDecodingError = exports.DecodingError = exports.decodeRevert = exports.decodeReturndata = exports.decodeCalldata = exports.decodeEvent = exports.decodeVariable = exports.Format = void 0;
//So, what shall codec export...?
//First: export the data format
const Format = __importStar(__webpack_require__(29965));
exports.Format = Format;
//now... various low-level stuff we want to export!
//the actual decoding functions and related errors
var core_1 = __webpack_require__(32561);
Object.defineProperty(exports, "decodeVariable", ({ enumerable: true, get: function () { return core_1.decodeVariable; } }));
Object.defineProperty(exports, "decodeEvent", ({ enumerable: true, get: function () { return core_1.decodeEvent; } }));
Object.defineProperty(exports, "decodeCalldata", ({ enumerable: true, get: function () { return core_1.decodeCalldata; } }));
Object.defineProperty(exports, "decodeReturndata", ({ enumerable: true, get: function () { return core_1.decodeReturndata; } }));
Object.defineProperty(exports, "decodeRevert", ({ enumerable: true, get: function () { return core_1.decodeRevert; } }));
var errors_1 = __webpack_require__(72325);
Object.defineProperty(exports, "DecodingError", ({ enumerable: true, get: function () { return errors_1.DecodingError; } }));
Object.defineProperty(exports, "StopDecodingError", ({ enumerable: true, get: function () { return errors_1.StopDecodingError; } }));
Object.defineProperty(exports, "NoProjectInfoError", ({ enumerable: true, get: function () { return errors_1.NoProjectInfoError; } }));
Object.defineProperty(exports, "RepeatCompilationIdError", ({ enumerable: true, get: function () { return errors_1.RepeatCompilationIdError; } }));
__exportStar(__webpack_require__(99987), exports);
var abify_1 = __webpack_require__(57320);
Object.defineProperty(exports, "abifyCalldataDecoding", ({ enumerable: true, get: function () { return abify_1.abifyCalldataDecoding; } }));
Object.defineProperty(exports, "abifyLogDecoding", ({ enumerable: true, get: function () { return abify_1.abifyLogDecoding; } }));
Object.defineProperty(exports, "abifyReturndataDecoding", ({ enumerable: true, get: function () { return abify_1.abifyReturndataDecoding; } }));
// data locations - common
const Basic = __importStar(__webpack_require__(53928));
exports.Basic = Basic;
const Bytes = __importStar(__webpack_require__(67689));
exports.Bytes = Bytes;
// data locations - abi
const AbiData = __importStar(__webpack_require__(20907));
exports.AbiData = AbiData;
const Topic = __importStar(__webpack_require__(63196));
exports.Topic = Topic;
// data locations - solidity
const MappingKey = __importStar(__webpack_require__(14817));
exports.MappingKey = MappingKey;
const Memory = __importStar(__webpack_require__(71614));
exports.Memory = Memory;
const Special = __importStar(__webpack_require__(97859));
exports.Special = Special;
const Stack = __importStar(__webpack_require__(15385));
exports.Stack = Stack;
const Storage = __importStar(__webpack_require__(81037));
exports.Storage = Storage;
const AstConstant = __importStar(__webpack_require__(88132));
exports.AstConstant = AstConstant;
const Ast = __importStar(__webpack_require__(14442));
exports.Ast = Ast;
const Compiler = __importStar(__webpack_require__(84159));
exports.Compiler = Compiler;
const Compilations = __importStar(__webpack_require__(44894));
exports.Compilations = Compilations;
const Contexts = __importStar(__webpack_require__(97938));
exports.Contexts = Contexts;
const Conversion = __importStar(__webpack_require__(52714));
exports.Conversion = Conversion;
const Evm = __importStar(__webpack_require__(49218));
exports.Evm = Evm;
const Export = __importStar(__webpack_require__(15103));
exports.Export = Export;
const Wrap = __importStar(__webpack_require__(18479));
exports.Wrap = Wrap;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 10245:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mappingKeyAsHex = exports.encodeMappingKey = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:mapping-key:encode");
const Conversion = __importStar(__webpack_require__(52714));
const BasicEncode = __importStar(__webpack_require__(51561));
const BytesEncode = __importStar(__webpack_require__(53951));
//UGH -- it turns out TypeScript can't handle nested tagged unions
//see: https://github.com/microsoft/TypeScript/issues/18758
//so, I'm just going to have to throw in a bunch of type coercions >_>
/**
 * @Category Encoding (low-level)
 */
function encodeMappingKey(input) {
    if (input.type.typeClass === "string" ||
        (input.type.typeClass === "bytes" && input.type.kind === "dynamic")) {
        return BytesEncode.encodeBytes(input);
    }
    else {
        return BasicEncode.encodeBasic(input);
    }
}
exports.encodeMappingKey = encodeMappingKey;
/**
 * @Category Encoding (low-level)
 */
function mappingKeyAsHex(input) {
    return Conversion.toHexString(encodeMappingKey(input));
}
exports.mappingKeyAsHex = mappingKeyAsHex;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 14817:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For encoding mapping keys
 *
 * @protected
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Encode = void 0;
const Encode = __importStar(__webpack_require__(10245));
exports.Encode = Encode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 59046:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isSkippedInMemoryStructs = exports.getMemoryAllocations = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:memory:allocate");
const Evm = __importStar(__webpack_require__(49218));
function getMemoryAllocations(userDefinedTypes) {
    let allocations = {};
    for (const dataType of Object.values(userDefinedTypes)) {
        if (dataType.typeClass === "struct") {
            allocations[dataType.id] = allocateStruct(dataType);
        }
    }
    return allocations;
}
exports.getMemoryAllocations = getMemoryAllocations;
function isSkippedInMemoryStructs(dataType) {
    if (dataType.typeClass === "mapping") {
        return true;
    }
    else if (dataType.typeClass === "array") {
        return isSkippedInMemoryStructs(dataType.baseType);
    }
    else {
        return false;
    }
}
exports.isSkippedInMemoryStructs = isSkippedInMemoryStructs;
//unlike in storage and calldata, we'll just return the one allocation, nothing fancy
//that's because allocating one struct can never necessitate allocating another
function allocateStruct(dataType) {
    let memberAllocations = [];
    let position = 0;
    for (const { name, type: memberType } of dataType.memberTypes) {
        const length = isSkippedInMemoryStructs(memberType)
            ? 0
            : Evm.Utils.WORD_SIZE;
        memberAllocations.push({
            name,
            type: memberType,
            pointer: {
                location: "memory",
                start: position,
                length
            }
        });
        position += length;
    }
    return {
        members: memberAllocations
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 63540:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeMemoryReferenceByAddress = exports.decodeMemory = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:memory:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Conversion = __importStar(__webpack_require__(52714));
const Format = __importStar(__webpack_require__(29965));
const Basic = __importStar(__webpack_require__(53928));
const Bytes = __importStar(__webpack_require__(67689));
const Evm = __importStar(__webpack_require__(49218));
const allocate_1 = __webpack_require__(59046);
const errors_1 = __webpack_require__(72325);
function* decodeMemory(dataType, pointer, info, options = {}) {
    if (Format.Types.isReferenceType(dataType)) {
        if ((0, allocate_1.isSkippedInMemoryStructs)(dataType)) {
            //special case; these types are always empty in memory
            return decodeMemorySkippedType(dataType);
        }
        else {
            return yield* decodeMemoryReferenceByAddress(dataType, pointer, info, options);
        }
    }
    else {
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);
    }
}
exports.decodeMemory = decodeMemory;
function decodeMemorySkippedType(dataType) {
    switch (dataType.typeClass) {
        case "mapping":
            return {
                type: dataType,
                kind: "value",
                value: [],
                interpretations: {}
            };
        case "array":
            return {
                type: dataType,
                kind: "value",
                value: [],
                interpretations: {}
            };
        //other cases should not arise!
    }
}
function* decodeMemoryReferenceByAddress(dataType, pointer, info, options = {}) {
    const { state } = info;
    const memoryVisited = options.memoryVisited || [];
    debug("pointer %o", pointer);
    let rawValue;
    try {
        rawValue = yield* (0, read_1.default)(pointer, state);
    }
    catch (error) {
        return (0, errors_1.handleDecodingError)(dataType, error);
    }
    let startPositionAsBN = Conversion.toBN(rawValue);
    let startPosition;
    try {
        startPosition = startPositionAsBN.toNumber();
    }
    catch (_a) {
        return {
            //again with the TS failures...
            type: dataType,
            kind: "error",
            error: {
                kind: "OverlargePointersNotImplementedError",
                pointerAsBN: startPositionAsBN
            }
        };
    }
    //startPosition may get modified later, so let's save the current
    //value for circularity detection purposes
    const objectPosition = startPosition;
    let rawLength;
    let lengthAsBN;
    let length;
    let seenPreviously;
    switch (dataType.typeClass) {
        case "bytes":
        case "string":
            //initial word contains length
            try {
                rawLength = yield* (0, read_1.default)({
                    location: "memory",
                    start: startPosition,
                    length: Evm.Utils.WORD_SIZE
                }, state);
            }
            catch (error) {
                return (0, errors_1.handleDecodingError)(dataType, error);
            }
            lengthAsBN = Conversion.toBN(rawLength);
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_b) {
                return {
                    //again with the TS failures...
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            let childPointer = {
                location: "memory",
                start: startPosition + Evm.Utils.WORD_SIZE,
                length
            };
            return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info);
        case "array": {
            //first: circularity check!
            seenPreviously = memoryVisited.indexOf(objectPosition);
            if (seenPreviously !== -1) {
                return {
                    type: dataType,
                    kind: "value",
                    reference: seenPreviously + 1,
                    value: [],
                    interpretations: {}
                };
            }
            //otherwise, decode as normal
            if (dataType.kind === "dynamic") {
                //initial word contains array length
                try {
                    rawLength = yield* (0, read_1.default)({
                        location: "memory",
                        start: startPosition,
                        length: Evm.Utils.WORD_SIZE
                    }, state);
                }
                catch (error) {
                    return (0, errors_1.handleDecodingError)(dataType, error);
                }
                lengthAsBN = Conversion.toBN(rawLength);
                startPosition += Evm.Utils.WORD_SIZE; //increment startPosition
                //to next word, as first word was used for length
            }
            else {
                lengthAsBN = dataType.length;
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_c) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            let memoryNowVisited = [objectPosition, ...memoryVisited];
            let baseType = dataType.baseType;
            let decodedChildren = [];
            for (let index = 0; index < length; index++) {
                decodedChildren.push(yield* decodeMemory(baseType, {
                    location: "memory",
                    start: startPosition + index * Evm.Utils.WORD_SIZE,
                    length: Evm.Utils.WORD_SIZE
                }, info, { memoryVisited: memoryNowVisited }));
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren,
                interpretations: {}
            };
        }
        case "struct": {
            //first: circularity check!
            seenPreviously = memoryVisited.indexOf(objectPosition);
            if (seenPreviously !== -1) {
                return {
                    type: dataType,
                    kind: "value",
                    reference: seenPreviously + 1,
                    value: [],
                    interpretations: {}
                };
            }
            //otherwise, decode as normal
            const { allocations: { memory: allocations } } = info;
            const typeId = dataType.id;
            const structAllocation = allocations[typeId];
            if (!structAllocation) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "UserDefinedTypeNotFoundError",
                        type: dataType
                    }
                };
            }
            debug("structAllocation %O", structAllocation);
            let memoryNowVisited = [objectPosition, ...memoryVisited];
            let decodedMembers = [];
            for (let index = 0; index < structAllocation.members.length; index++) {
                const memberAllocation = structAllocation.members[index];
                const memberPointer = memberAllocation.pointer;
                const childPointer = {
                    location: "memory",
                    start: startPosition + memberPointer.start,
                    length: memberPointer.length //always equals WORD_SIZE or 0
                };
                let memberName = memberAllocation.name;
                let memberType = Format.Types.specifyLocation(memberAllocation.type, "memory");
                decodedMembers.push({
                    name: memberName,
                    value: yield* decodeMemory(memberType, childPointer, info, {
                        memoryVisited: memoryNowVisited
                    })
                });
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedMembers,
                interpretations: {}
            };
        }
    }
}
exports.decodeMemoryReferenceByAddress = decodeMemoryReferenceByAddress;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 71614:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For allocation and decoding of memory data
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decode = exports.Allocate = void 0;
const Allocate = __importStar(__webpack_require__(59046));
exports.Allocate = Allocate;
const Decode = __importStar(__webpack_require__(63540));
exports.Decode = Decode;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 87534:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const StorageRead = __importStar(__webpack_require__(65135));
const StackRead = __importStar(__webpack_require__(9940));
const BytesRead = __importStar(__webpack_require__(20281));
const AstConstantRead = __importStar(__webpack_require__(38130));
const TopicRead = __importStar(__webpack_require__(61352));
const SpecialRead = __importStar(__webpack_require__(95884));
const errors_1 = __webpack_require__(72325);
function* read(pointer, state) {
    switch (pointer.location) {
        case "stack":
            return StackRead.readStack(pointer, state);
        case "storage":
            return yield* StorageRead.readStorage(pointer, state);
        case "memory":
        case "calldata":
        case "eventdata":
        case "returndata":
            return BytesRead.readBytes(pointer, state);
        case "code":
            //keeping this separate
            return yield* BytesRead.readCode(pointer, state);
        case "stackliteral":
            return StackRead.readStackLiteral(pointer);
        case "definition":
            return AstConstantRead.readDefinition(pointer);
        case "special":
            return SpecialRead.readSpecial(pointer, state);
        case "eventtopic":
            return TopicRead.readTopic(pointer, state);
        case "nowhere":
            throw new errors_1.DecodingError({
                kind: "UnusedImmutableError"
            });
    }
}
exports["default"] = read;
//# sourceMappingURL=read.js.map

/***/ }),

/***/ 11002:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeMagic = exports.decodeSpecial = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:special:decode");
const Basic = __importStar(__webpack_require__(53928));
const Bytes = __importStar(__webpack_require__(67689));
const Compiler = __importStar(__webpack_require__(84159));
const Evm = __importStar(__webpack_require__(49218));
function* decodeSpecial(dataType, pointer, info) {
    if (dataType.typeClass === "magic") {
        return yield* decodeMagic(dataType, pointer, info);
    }
    else {
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info);
    }
}
exports.decodeSpecial = decodeSpecial;
function* decodeMagic(dataType, pointer, info) {
    let { state } = info;
    switch (pointer.special) {
        case "msg":
            return {
                type: dataType,
                kind: "value",
                value: {
                    data: yield* Bytes.Decode.decodeBytes({
                        typeClass: "bytes",
                        kind: "dynamic",
                        location: "calldata"
                    }, {
                        location: "calldata",
                        start: 0,
                        length: state.calldata.length
                    }, info),
                    sig: yield* Basic.Decode.decodeBasic({
                        typeClass: "bytes",
                        kind: "static",
                        length: Evm.Utils.SELECTOR_SIZE
                    }, {
                        location: "calldata",
                        start: 0,
                        length: Evm.Utils.SELECTOR_SIZE
                    }, info),
                    sender: yield* Basic.Decode.decodeBasic(senderType(info.currentContext.compiler), { location: "special", special: "sender" }, info),
                    value: yield* Basic.Decode.decodeBasic({
                        typeClass: "uint",
                        bits: 256
                    }, { location: "special", special: "value" }, info)
                },
                interpretations: {}
            };
        case "tx":
            return {
                type: dataType,
                kind: "value",
                value: {
                    origin: yield* Basic.Decode.decodeBasic(senderType(info.currentContext.compiler), { location: "special", special: "origin" }, info),
                    gasprice: yield* Basic.Decode.decodeBasic({
                        typeClass: "uint",
                        bits: 256
                    }, { location: "special", special: "gasprice" }, info)
                },
                interpretations: {}
            };
        case "block":
            let block = {
                coinbase: yield* Basic.Decode.decodeBasic(coinbaseType(info.currentContext.compiler), { location: "special", special: "coinbase" }, info)
            };
            //now we handle prevrandao. this one gets special handling
            //because the name isn't equal to the location name (it's an alias of difficulty)
            if (solidityVersionHasPrevrandao(info.currentContext.compiler)) {
                block.prevrandao = yield* Basic.Decode.decodeBasic({
                    typeClass: "uint",
                    bits: 256
                }, { location: "special", special: "difficulty" }, info);
            }
            //the other ones are all uint's and all work the same, so let's handle
            //them all at once; due to the lack of generator arrow functions, we do
            //it by mutating block
            const variables = ["difficulty", "gaslimit", "number", "timestamp"];
            if (solidityVersionHasChainId(info.currentContext.compiler)) {
                variables.push("chainid");
            }
            if (solidityVersionHasBaseFee(info.currentContext.compiler)) {
                variables.push("basefee");
            }
            for (let variable of variables) {
                block[variable] = yield* Basic.Decode.decodeBasic({
                    typeClass: "uint",
                    bits: 256
                }, { location: "special", special: variable }, info);
            }
            return {
                type: dataType,
                kind: "value",
                value: block,
                interpretations: {}
            };
    }
}
exports.decodeMagic = decodeMagic;
function senderType(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
            return {
                typeClass: "address",
                kind: "general"
            };
        case "0.5.x":
            return {
                typeClass: "address",
                kind: "specific",
                payable: true
            };
        default:
            return {
                typeClass: "address",
                kind: "specific",
                payable: false
            };
    }
}
function coinbaseType(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
            return {
                typeClass: "address",
                kind: "general"
            };
        case "0.5.x":
        case "0.8.x":
        case "0.8.7+":
        case "0.8.9+":
        case "0.8.18+":
            return {
                typeClass: "address",
                kind: "specific",
                payable: true
            };
    }
}
function solidityVersionHasChainId(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
        case "0.5.x":
            return false;
        default:
            return true;
    }
}
function solidityVersionHasBaseFee(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
        case "0.5.x":
        case "0.8.x":
            return false;
        default:
            return true;
    }
}
function solidityVersionHasPrevrandao(compiler) {
    switch (Compiler.Utils.solidityFamily(compiler)) {
        case "unknown":
        case "pre-0.5.0":
        case "0.5.x":
        case "0.8.x":
        case "0.8.7+":
        case "0.8.9+":
            return false;
        default:
            return true;
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 97859:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For decoding of special/magic variables
 *
 * @protected
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Decode = void 0;
const Decode = __importStar(__webpack_require__(11002));
exports.Decode = Decode;
const Read = __importStar(__webpack_require__(95884));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 95884:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readSpecial = void 0;
function readSpecial(pointer, state) {
    //not bothering with error handling on this one as I don't expect errors
    return state.specials[pointer.special];
}
exports.readSpecial = readSpecial;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 71013:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeLiteral = exports.decodeStack = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:stack:decode");
const AbiData = __importStar(__webpack_require__(20907));
const Conversion = __importStar(__webpack_require__(52714));
const Format = __importStar(__webpack_require__(29965));
const read_1 = __importDefault(__webpack_require__(87534));
const Basic = __importStar(__webpack_require__(53928));
const Memory = __importStar(__webpack_require__(71614));
const Storage = __importStar(__webpack_require__(81037));
const Evm = __importStar(__webpack_require__(49218));
const errors_1 = __webpack_require__(72325);
function* decodeStack(dataType, pointer, info) {
    let rawValue;
    try {
        rawValue = yield* (0, read_1.default)(pointer, info.state);
    }
    catch (error) {
        return (0, errors_1.handleDecodingError)(dataType, error);
    }
    const literalPointer = {
        location: "stackliteral",
        literal: rawValue
    };
    return yield* decodeLiteral(dataType, literalPointer, info);
}
exports.decodeStack = decodeStack;
function* decodeLiteral(dataType, pointer, info) {
    debug("type %O", dataType);
    debug("pointer %o", pointer);
    if (Format.Types.isReferenceType(dataType)) {
        switch (dataType.location) {
            case "memory":
                //first: do we have a memory pointer? if so we can just dispatch to
                //decodeMemoryReference
                return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);
            case "storage":
                //next: do we have a storage pointer (which may be a mapping)? if so, we can
                //we dispatch to decodeStorageByAddress
                return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);
            case "calldata":
                //next: do we have a calldata pointer?
                //if it's a lookup type, it'll need special handling
                if (dataType.typeClass === "bytes" ||
                    dataType.typeClass === "string" ||
                    (dataType.typeClass === "array" && dataType.kind === "dynamic")) {
                    const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));
                    const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);
                    return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, { location: "stackliteral", literal: locationOnly }, info, {
                        abiPointerBase: 0,
                        lengthOverride: lengthAsBN
                    });
                }
                else {
                    //multivalue case -- this case is straightforward
                    return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {
                        abiPointerBase: 0 //let's be explicit
                    });
                }
        }
    }
    //next: do we have an external function?  these work differently on the stack
    //than elsewhere, so we can't just pass it on to decodeBasic.
    if (dataType.typeClass === "function" && dataType.visibility === "external") {
        let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);
        let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);
        if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) ||
            !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {
            return {
                type: dataType,
                kind: "error",
                error: {
                    kind: "FunctionExternalStackPaddingError",
                    rawAddress: Conversion.toHexString(address),
                    rawSelector: Conversion.toHexString(selectorWord)
                }
            };
        }
        let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);
        return {
            type: dataType,
            kind: "value",
            value: yield* Basic.Decode.decodeExternalFunction(address, selector, info),
            interpretations: {}
        };
    }
    //finally, if none of the above hold, we can just dispatch to decodeBasic.
    //however, note that because we're on the stack, we use the permissive padding
    //option so that errors won't result due to values with bad padding
    //(of numeric or bytesN type, anyway)
    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {
        paddingMode: "permissive"
    });
}
exports.decodeLiteral = decodeLiteral;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 15385:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For decoding stack variables
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Decode = void 0;
const Decode = __importStar(__webpack_require__(71013));
exports.Decode = Decode;
const Read = __importStar(__webpack_require__(9940));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 9940:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readStackLiteral = exports.readStack = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:stack:read");
const Evm = __importStar(__webpack_require__(49218));
const errors_1 = __webpack_require__(72325);
function readStack(pointer, state) {
    let { from, to } = pointer;
    let { stack } = state;
    if (from < 0 || to >= stack.length) {
        throw new errors_1.DecodingError({
            kind: "ReadErrorStack",
            from,
            to
        });
    }
    //unforunately, Uint8Arrays don't support concat; if they did the rest of
    //this would be one line.  Or similarly if they worked with lodash's flatten,
    //but they don't support that either.  But neither of those are the case, so
    //we'll have to concatenate a bit more manually.
    let words = stack.slice(from, to + 1);
    let result = new Uint8Array(words.length * Evm.Utils.WORD_SIZE);
    //shouldn't we total up the lengths? yeah, but each one should have a
    //length of 32, so unless somehting's gone wrong we can just multiply
    for (let index = 0; index < words.length; index++) {
        result.set(words[index], index * Evm.Utils.WORD_SIZE);
    }
    return result;
}
exports.readStack = readStack;
function readStackLiteral(pointer) {
    return pointer.literal;
}
exports.readStackLiteral = readStackLiteral;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 78976:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:storage:allocate");
const Compiler = __importStar(__webpack_require__(84159));
const Common = __importStar(__webpack_require__(99987));
const Basic = __importStar(__webpack_require__(53928));
const Utils = __importStar(__webpack_require__(42526));
const Ast = __importStar(__webpack_require__(14442));
const Evm = __importStar(__webpack_require__(49218));
const Format = __importStar(__webpack_require__(29965));
const bn_js_1 = __importDefault(__webpack_require__(13550));
const partition_1 = __importDefault(__webpack_require__(43174));
class UnknownBaseContractIdError extends Error {
    constructor(derivedId, derivedName, derivedKind, baseId) {
        const message = `Cannot locate base contract ID ${baseId} of ${derivedKind} ${derivedName} (ID ${derivedId})`;
        super(message);
        this.name = "UnknownBaseContractIdError";
        this.derivedId = derivedId;
        this.derivedName = derivedName;
        this.derivedKind = derivedKind;
        this.baseId = baseId;
    }
}
exports.UnknownBaseContractIdError = UnknownBaseContractIdError;
//contracts contains only the contracts to be allocated; any base classes not
//being allocated should just be in referenceDeclarations
function getStorageAllocations(userDefinedTypesByCompilation) {
    let allocations = {};
    for (const compilation of Object.values(userDefinedTypesByCompilation)) {
        const { compiler, types: userDefinedTypes } = compilation;
        for (const dataType of Object.values(compilation.types)) {
            if (dataType.typeClass === "struct") {
                try {
                    allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);
                }
                catch (_a) {
                    //if allocation fails... oh well, allocation fails, we do nothing and just move on :P
                    //note: a better way of handling this would probably be to *mark* it
                    //as failed rather than throwing an exception as that would lead to less
                    //recomputation, but this is simpler and I don't think the recomputation
                    //should really be a problem
                }
            }
        }
    }
    return allocations;
}
exports.getStorageAllocations = getStorageAllocations;
/**
 * This function gets allocations for the state variables of the contracts;
 * this is distinct from getStorageAllocations, which gets allocations for
 * storage structs.
 *
 * While mostly state variables are kept in storage, constant ones are not.
 * And immutable ones, once those are introduced, will be kept in code!
 * (But those don't exist yet so this function doesn't handle them yet.)
 */
function getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {
    let allocations = existingAllocations;
    for (const contractInfo of contracts) {
        let { contractNode: contract, immutableReferences, compiler, compilationId } = contractInfo;
        try {
            allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);
        }
        catch (_a) {
            //we're just going to allow failure here and catch the problem elsewhere
        }
    }
    return allocations;
}
exports.getStateAllocations = getStateAllocations;
function allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {
    //NOTE: dataType here should be a *stored* type!
    //it is up to the caller to take care of this
    return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);
}
function allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {
    let offset = 0; //will convert to BN when placing in slot
    let index = Evm.Utils.WORD_SIZE - 1;
    //don't allocate things that have already been allocated
    if (parentId in existingAllocations) {
        return existingAllocations;
    }
    let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone
    //otherwise, we need to allocate
    let memberAllocations = [];
    for (const member of members) {
        let size;
        ({ size, allocations } = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler));
        //if it's sized in words (and we're not at the start of slot) we need to start on a new slot
        //if it's sized in bytes but there's not enough room, we also need a new slot
        if (Utils.isWordsLength(size)
            ? index < Evm.Utils.WORD_SIZE - 1
            : size.bytes > index + 1) {
            index = Evm.Utils.WORD_SIZE - 1;
            offset += 1;
        }
        //otherwise, we remain in place
        let range;
        if (Utils.isWordsLength(size)) {
            //words case
            range = {
                from: {
                    slot: {
                        offset: new bn_js_1.default(offset) //start at the current slot...
                    },
                    index: 0 //...at the beginning of the word.
                },
                to: {
                    slot: {
                        offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...
                    },
                    index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.
                }
            };
        }
        else {
            //bytes case
            range = {
                from: {
                    slot: {
                        offset: new bn_js_1.default(offset) //start at the current slot...
                    },
                    index: index - (size.bytes - 1) //...early enough to fit what's being allocated.
                },
                to: {
                    slot: {
                        offset: new bn_js_1.default(offset) //end at the current slot...
                    },
                    index: index //...at the current position.
                }
            };
        }
        memberAllocations.push({
            name: member.name,
            type: member.type,
            pointer: {
                location: "storage",
                range
            }
        });
        //finally, adjust the current position.
        //if it was sized in words, move down that many slots and reset position w/in slot
        if (Utils.isWordsLength(size)) {
            offset += size.words;
            index = Evm.Utils.WORD_SIZE - 1;
        }
        //if it was sized in bytes, move down an appropriate number of bytes.
        else {
            index -= size.bytes;
            //but if this puts us into the next word, move to the next word.
            if (index < 0) {
                index = Evm.Utils.WORD_SIZE - 1;
                offset += 1;
            }
        }
    }
    //finally, let's determine the overall siz; we're dealing with a struct, so
    //the size is measured in words
    //it's one plus the last word used, i.e. one plus the current word... unless the
    //current word remains entirely unused, then it's just the current word
    //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how
    //empty structs behave in versions where they're legal)
    let totalSize;
    if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {
        totalSize = { words: offset };
    }
    else {
        totalSize = { words: offset + 1 };
    }
    //having made our allocation, let's add it to allocations!
    allocations[parentId] = {
        members: memberAllocations,
        size: totalSize
    };
    //...and we're done!
    return allocations;
}
function getStateVariables(contractNode) {
    // process for state variables
    return contractNode.nodes.filter((node) => node.nodeType === "VariableDeclaration" && node.stateVariable);
}
function allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {
    //we're going to do a 2-deep clone here
    let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(([compilationId, compilationAllocations]) => ({
        [compilationId]: Object.assign({}, compilationAllocations)
    })));
    if (!immutableReferences) {
        immutableReferences = {}; //also, let's set this up for convenience
    }
    //base contracts are listed from most derived to most base, so we
    //have to reverse before processing, but reverse() is in place, so we
    //clone with slice first
    let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse();
    //first, let's get all the variables under consideration
    let variables = [].concat(...linearizedBaseContractsFromBase.map((id) => {
        let baseNode = referenceDeclarations[id];
        if (baseNode === undefined) {
            throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);
        }
        return getStateVariables(baseNode).map(definition => ({
            definition,
            definedIn: baseNode
        }));
    }));
    //just in case the constant field ever gets removed
    const isConstant = (definition) => definition.constant || definition.mutability === "constant";
    //now: we split the variables into storage, constant, and code
    let [constantVariables, variableVariables] = (0, partition_1.default)(variables, variable => isConstant(variable.definition));
    //why use this function instead of just checking
    //definition.mutability?
    //because of a bug in Solidity 0.6.5 that causes the mutability field
    //not to exist.  So, we also have to check against immutableReferences.
    const isImmutable = (definition) => definition.mutability === "immutable" ||
        definition.id.toString() in immutableReferences;
    let [immutableVariables, storageVariables] = (0, partition_1.default)(variableVariables, variable => isImmutable(variable.definition));
    //transform storage variables into data types
    const storageVariableTypes = storageVariables.map(variable => ({
        name: variable.definition.name,
        type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)
    }));
    //let's allocate the storage variables using a fictitious ID
    const id = "-1";
    const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id];
    //transform to new format
    const storageVariableAllocations = storageVariables.map(({ definition, definedIn }, index) => ({
        definition,
        definedIn,
        compilationId,
        pointer: storageVariableStorageAllocations.members[index].pointer
    }));
    //now let's create allocations for the immutables
    let immutableVariableAllocations = immutableVariables.map(({ definition, definedIn }) => {
        let references = immutableReferences[definition.id.toString()] || [];
        let pointer;
        if (references.length === 0) {
            pointer = {
                location: "nowhere"
            };
        }
        else {
            pointer = {
                location: "code",
                start: references[0].start,
                length: references[0].length
            };
        }
        return {
            definition,
            definedIn,
            compilationId,
            pointer
        };
    });
    //and let's create allocations for the constants
    let constantVariableAllocations = constantVariables.map(({ definition, definedIn }) => ({
        definition,
        definedIn,
        compilationId,
        pointer: {
            location: "definition",
            definition: definition.value
        }
    }));
    //now, reweave the three together
    let contractAllocation = [];
    for (let variable of variables) {
        let arrayToGrabFrom = isConstant(variable.definition)
            ? constantVariableAllocations
            : isImmutable(variable.definition)
                ? immutableVariableAllocations
                : storageVariableAllocations;
        contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!
    }
    //finally, set things and return
    if (!allocations[compilationId]) {
        allocations[compilationId] = {};
    }
    allocations[compilationId][contract.id] = {
        members: contractAllocation
    };
    return allocations;
}
//NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.
//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,
//not to the wrapper, because it may need the allocations returned.
function storageSize(dataType, userDefinedTypes, allocations, compiler) {
    return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;
}
exports.storageSize = storageSize;
function storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {
    //we'll only directly handle reference types here;
    //direct types will be handled by dispatching to Basic.Allocate.byteLength
    //in the default case
    switch (dataType.typeClass) {
        case "bytes": {
            switch (dataType.kind) {
                case "static":
                    //really a basic type :)
                    return {
                        size: {
                            bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)
                        },
                        allocations: existingAllocations
                    };
                case "dynamic":
                    return {
                        size: { words: 1 },
                        allocations: existingAllocations
                    };
            }
        }
        case "string":
        case "mapping":
            return {
                size: { words: 1 },
                allocations: existingAllocations
            };
        case "array": {
            switch (dataType.kind) {
                case "dynamic":
                    return {
                        size: { words: 1 },
                        allocations: existingAllocations
                    };
                case "static":
                    //static array case
                    const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem
                    if (length === 0) {
                        //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word
                        return {
                            size: { words: 1 },
                            allocations: existingAllocations
                        };
                    }
                    let { size: baseSize, allocations } = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations);
                    if (!Utils.isWordsLength(baseSize)) {
                        //bytes case
                        const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);
                        debug("length %o", length);
                        const numWords = Math.ceil(length / perWord);
                        return {
                            size: { words: numWords },
                            allocations
                        };
                    }
                    else {
                        //words case
                        return {
                            size: { words: baseSize.words * length },
                            allocations
                        };
                    }
            }
        }
        case "struct": {
            let allocations = existingAllocations;
            let allocation = allocations[dataType.id]; //may be undefined!
            if (allocation === undefined) {
                //if we don't find an allocation, we'll have to do the allocation ourselves
                const storedType = (userDefinedTypes[dataType.id]);
                if (!storedType) {
                    throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));
                }
                allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);
                allocation = allocations[dataType.id];
            }
            //having found our allocation, we can just look up its size
            return {
                size: allocation.size,
                allocations
            };
        }
        case "userDefinedValueType":
            if (Compiler.Utils.solidityFamily(compiler) === "0.8.7+") {
                //UDVTs were introduced in Solidity 0.8.8.  However, in that version,
                //and that version only, they have a bug where they always take up a
                //full word in storage regardless of the size of the underlying type.
                return {
                    size: { words: 1 },
                    allocations: existingAllocations
                };
            }
        //otherwise, treat them normally
        //DELIBERATE FALL-TRHOUGH
        default:
            //otherwise, it's a direct type
            return {
                size: {
                    bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)
                },
                allocations: existingAllocations
            };
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88569:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:storage:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Conversion = __importStar(__webpack_require__(52714));
const Format = __importStar(__webpack_require__(29965));
const Basic = __importStar(__webpack_require__(53928));
const Bytes = __importStar(__webpack_require__(67689));
const Utils = __importStar(__webpack_require__(42526));
const Evm = __importStar(__webpack_require__(49218));
const allocate_1 = __webpack_require__(78976);
const bn_js_1 = __importDefault(__webpack_require__(13550));
const errors_1 = __webpack_require__(72325);
function* decodeStorage(dataType, pointer, info) {
    if (Format.Types.isReferenceType(dataType)) {
        return yield* decodeStorageReference(dataType, pointer, info);
    }
    else {
        return yield* Basic.Decode.decodeBasic(dataType, pointer, info);
    }
}
exports.decodeStorage = decodeStorage;
//decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.
//NOTE: ONLY for use with pointers to reference types!
//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...
function* decodeStorageReferenceByAddress(dataType, pointer, info) {
    const allocations = info.allocations.storage;
    let rawValue;
    try {
        rawValue = yield* (0, read_1.default)(pointer, info.state);
    }
    catch (error) {
        return (0, errors_1.handleDecodingError)(dataType, error);
    }
    const startOffset = Conversion.toBN(rawValue);
    let rawSize;
    try {
        rawSize = (0, allocate_1.storageSize)(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);
    }
    catch (error) {
        return (0, errors_1.handleDecodingError)(dataType, error);
    }
    //we *know* the type being decoded must be sized in words, because it's a
    //reference type, but TypeScript doesn't, so we'll have to use a type
    //coercion
    const size = rawSize.words;
    //now, construct the storage pointer
    const newPointer = {
        location: "storage",
        range: {
            from: {
                slot: {
                    offset: startOffset
                },
                index: 0
            },
            to: {
                slot: {
                    offset: startOffset.addn(size - 1)
                },
                index: Evm.Utils.WORD_SIZE - 1
            }
        }
    };
    //dispatch to decodeStorageReference
    return yield* decodeStorageReference(dataType, newPointer, info);
}
exports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;
function* decodeStorageReference(dataType, pointer, info) {
    var data;
    var length;
    const { state } = info;
    const allocations = info.allocations.storage;
    switch (dataType.typeClass) {
        case "array": {
            debug("storage array! %o", pointer);
            let lengthAsBN;
            switch (dataType.kind) {
                case "dynamic":
                    debug("dynamic array");
                    debug("type %O", dataType);
                    try {
                        data = yield* (0, read_1.default)(pointer, state);
                    }
                    catch (error) {
                        return (0, errors_1.handleDecodingError)(dataType, error);
                    }
                    lengthAsBN = Conversion.toBN(data);
                    break;
                case "static":
                    debug("static array");
                    lengthAsBN = dataType.length;
                    break;
            }
            try {
                length = lengthAsBN.toNumber();
            }
            catch (_a) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "OverlongArraysAndStringsNotImplementedError",
                        lengthAsBN
                    }
                };
            }
            debug("length %o", length);
            debug("about to determine baseSize");
            let baseSize;
            try {
                baseSize = (0, allocate_1.storageSize)(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);
            }
            catch (error) {
                return (0, errors_1.handleDecodingError)(dataType, error);
            }
            debug("baseSize %o", baseSize);
            //we are going to make a list of child ranges, pushing them one by one onto
            //this list, and then decode them; the first part will vary based on whether
            //we're in the words case or the bytes case, the second will not
            let ranges = [];
            if (Utils.isWordsLength(baseSize)) {
                //currentSlot will point to the start of the entry being decoded
                let currentSlot = {
                    path: pointer.range.from.slot,
                    offset: new bn_js_1.default(0),
                    hashPath: dataType.kind === "dynamic"
                };
                for (let i = 0; i < length; i++) {
                    let childRange = {
                        from: {
                            slot: {
                                path: currentSlot.path,
                                offset: currentSlot.offset.clone(),
                                hashPath: currentSlot.hashPath
                            },
                            index: 0
                        },
                        to: {
                            slot: {
                                path: currentSlot.path,
                                offset: currentSlot.offset.addn(baseSize.words - 1),
                                hashPath: currentSlot.hashPath
                            },
                            index: Evm.Utils.WORD_SIZE - 1
                        }
                    };
                    ranges.push(childRange);
                    currentSlot.offset.iaddn(baseSize.words);
                }
            }
            else {
                const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);
                debug("perWord %d", perWord);
                //currentPosition will point to the start of the entry being decoded
                //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE
                let currentPosition = {
                    slot: {
                        path: pointer.range.from.slot,
                        offset: new bn_js_1.default(0),
                        hashPath: dataType.kind === "dynamic"
                    },
                    index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!
                };
                for (let i = 0; i < length; i++) {
                    let childRange = {
                        from: {
                            slot: {
                                path: currentPosition.slot.path,
                                offset: currentPosition.slot.offset.clone(),
                                hashPath: currentPosition.slot.hashPath
                            },
                            index: currentPosition.index
                        },
                        length: baseSize.bytes
                    };
                    ranges.push(childRange);
                    currentPosition.index -= baseSize.bytes;
                    if (currentPosition.index < 0) {
                        currentPosition.slot.offset.iaddn(1);
                        currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;
                    }
                }
            }
            let decodedChildren = [];
            for (let childRange of ranges) {
                decodedChildren.push(yield* decodeStorage(dataType.baseType, { location: "storage", range: childRange }, info));
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedChildren,
                interpretations: {}
            };
        }
        case "bytes":
        case "string": {
            try {
                data = yield* (0, read_1.default)(pointer, state);
            }
            catch (error) {
                return (0, errors_1.handleDecodingError)(dataType, error);
            }
            let lengthByte = data[Evm.Utils.WORD_SIZE - 1];
            if (lengthByte % 2 == 0) {
                // string lives in word, length is last byte / 2
                length = lengthByte / 2;
                debug("in-word; length %o", length);
                return yield* Bytes.Decode.decodeBytes(dataType, {
                    location: "storage",
                    range: {
                        from: { slot: pointer.range.from.slot, index: 0 },
                        to: { slot: pointer.range.from.slot, index: length - 1 }
                    }
                }, info);
            }
            else {
                let lengthAsBN = Conversion.toBN(data).subn(1).divn(2);
                try {
                    length = lengthAsBN.toNumber();
                }
                catch (_b) {
                    return {
                        //again with the TS failures...
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "OverlongArraysAndStringsNotImplementedError",
                            lengthAsBN
                        }
                    };
                }
                debug("new-word, length %o", length);
                return yield* Bytes.Decode.decodeBytes(dataType, {
                    location: "storage",
                    range: {
                        from: {
                            slot: {
                                path: pointer.range.from.slot,
                                offset: new bn_js_1.default(0),
                                hashPath: true
                            },
                            index: 0
                        },
                        length
                    }
                }, info);
            }
        }
        case "struct": {
            const typeId = dataType.id;
            const structAllocation = allocations[typeId];
            if (!structAllocation) {
                return {
                    type: dataType,
                    kind: "error",
                    error: {
                        kind: "UserDefinedTypeNotFoundError",
                        type: dataType
                    }
                };
            }
            let decodedMembers = [];
            const members = structAllocation.members;
            for (let index = 0; index < members.length; index++) {
                const memberAllocation = members[index];
                const memberPointer = memberAllocation.pointer;
                //the type system thinks memberPointer might also be a constant
                //definition pointer.  However, structs can't contain constants,
                //so *we* know it's not, and can safely coerce it.
                debug("pointer %O", pointer);
                const childRange = {
                    from: {
                        slot: {
                            path: pointer.range.from.slot,
                            offset: memberPointer.range.from.slot.offset.clone()
                            //note that memberPointer should have no path
                        },
                        index: memberPointer.range.from.index
                    },
                    to: {
                        slot: {
                            path: pointer.range.from.slot,
                            offset: memberPointer.range.to.slot.offset.clone()
                            //note that memberPointer should have no path
                        },
                        index: memberPointer.range.to.index
                    }
                };
                let storedType = info.userDefinedTypes[typeId];
                if (!storedType) {
                    return {
                        type: dataType,
                        kind: "error",
                        error: {
                            kind: "UserDefinedTypeNotFoundError",
                            type: dataType
                        }
                    };
                }
                let storedMemberType = storedType.memberTypes[index].type;
                let memberType = Format.Types.specifyLocation(storedMemberType, "storage");
                decodedMembers.push({
                    name: memberAllocation.name,
                    value: yield* decodeStorage(memberType, { location: "storage", range: childRange }, info)
                });
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedMembers,
                interpretations: {}
            };
        }
        case "mapping": {
            debug("decoding mapping");
            const valueType = dataType.valueType;
            let valueSize;
            try {
                valueSize = (0, allocate_1.storageSize)(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);
            }
            catch (error) {
                return (0, errors_1.handleDecodingError)(dataType, error);
            }
            let decodedEntries = [];
            const baseSlot = pointer.range.from.slot;
            debug("baseSlot %o", baseSlot);
            debug("base slot address %o", Utils.slotAddress(baseSlot));
            const keySlots = info.mappingKeys.filter(({ path }) => Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path)));
            for (const { key } of keySlots) {
                let valuePointer;
                if (Utils.isWordsLength(valueSize)) {
                    valuePointer = {
                        location: "storage",
                        range: {
                            from: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(0)
                                },
                                index: 0
                            },
                            to: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(valueSize.words - 1)
                                },
                                index: Evm.Utils.WORD_SIZE - 1
                            }
                        }
                    };
                }
                else {
                    valuePointer = {
                        location: "storage",
                        range: {
                            from: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(0)
                                },
                                index: Evm.Utils.WORD_SIZE - valueSize.bytes
                            },
                            to: {
                                slot: {
                                    key,
                                    path: baseSlot,
                                    offset: new bn_js_1.default(0)
                                },
                                index: Evm.Utils.WORD_SIZE - 1
                            }
                        }
                    };
                }
                decodedEntries.push({
                    key,
                    value: yield* decodeStorage(valueType, valuePointer, info)
                });
            }
            return {
                type: dataType,
                kind: "value",
                value: decodedEntries,
                interpretations: {}
            };
        }
    }
}
exports.decodeStorageReference = decodeStorageReference;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 81037:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * For allocation and decoding of storage variables
 *
 * @category Solidity data location
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Decode = exports.Allocate = exports.Utils = void 0;
__exportStar(__webpack_require__(18020), exports); //can't do 'export type *'
const Utils = __importStar(__webpack_require__(42526));
exports.Utils = Utils;
const Allocate = __importStar(__webpack_require__(78976));
exports.Allocate = Allocate;
const Decode = __importStar(__webpack_require__(88569));
exports.Decode = Decode;
const Read = __importStar(__webpack_require__(65135));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 65135:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * @protected
 *
 * @packageDocumentation
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readStorage = exports.readSlot = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:storage:read");
const Conversion = __importStar(__webpack_require__(52714));
const Utils = __importStar(__webpack_require__(42526));
const Evm = __importStar(__webpack_require__(49218));
const errors_1 = __webpack_require__(72325);
function* readSlot(storage, slot) {
    const address = Utils.slotAddress(slot);
    // debug("reading slot: %o", Conversion.toHexString(address));
    const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);
    let word = storage[hexAddress];
    //if we can't find the word in the map, we place a request to the invoker to supply it
    //(contract-decoder will look it up from the blockchain, while the debugger will just
    //say 0)
    if (word === undefined) {
        word = yield {
            type: "storage",
            slot: address
        };
        if (word === null) {
            //check for null as a way to deliberately indicate an error
            throw new errors_1.DecodingError({
                kind: "StorageNotSuppliedError",
                slot: address
            });
        }
    }
    return word;
}
exports.readSlot = readSlot;
function* readStorage(pointer, state) {
    const { storage } = state;
    const { range } = pointer;
    debug("readRange %o", range);
    let { from, to, length } = range;
    from = {
        slot: from.slot,
        index: from.index || 0
    };
    if (length !== undefined) {
        to = {
            slot: {
                path: from.slot.path || undefined,
                offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))
            },
            index: (from.index + length - 1) % Evm.Utils.WORD_SIZE
        };
    }
    debug("normalized readRange %o", { from, to });
    let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);
    let totalWords;
    try {
        totalWords = totalWordsAsBN.toNumber();
    }
    catch (_) {
        throw new errors_1.DecodingError({
            kind: "ReadErrorStorage",
            range
        });
    }
    let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);
    for (let i = 0; i < totalWords; i++) {
        let offset = from.slot.offset.addn(i);
        const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), { offset }));
        data.set(word, i * Evm.Utils.WORD_SIZE);
    }
    debug("words %o", data);
    data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);
    debug("data: %o", data);
    return data;
}
exports.readStorage = readStorage;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 18020:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 42526:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:storage:utils");
const Evm = __importStar(__webpack_require__(49218));
const MappingKey = __importStar(__webpack_require__(14817));
function isWordsLength(size) {
    return size.words !== undefined;
}
exports.isWordsLength = isWordsLength;
function storageLengthToBytes(size) {
    if (isWordsLength(size)) {
        debug("size.words %d", size.words);
        return size.words * Evm.Utils.WORD_SIZE;
    }
    else {
        return size.bytes;
    }
}
exports.storageLengthToBytes = storageLengthToBytes;
/**
 * convert a slot to a word corresponding to actual storage address
 *
 * if `slot` is an array, return hash of array values.
 * if `slot` array is nested, recurse on sub-arrays
 *
 * @param slot - number or possibly-nested array of numbers
 */
function slotAddress(slot) {
    if (slot.key !== undefined && slot.path !== undefined) {
        // mapping reference
        return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);
    }
    else if (slot.path !== undefined) {
        const pathAddress = slotAddress(slot.path);
        const path = slot.hashPath
            ? Evm.Utils.keccak256(pathAddress)
            : pathAddress;
        return path.add(slot.offset);
    }
    else {
        return slot.offset;
    }
}
exports.slotAddress = slotAddress;
//note: this function compares slots mostly by structure,
//rather than by their numerical value
function equalSlots(slot1, slot2) {
    if (!slot1 || !slot2) {
        return !slot1 && !slot2; //if either is undefined, it's true only if both are
    }
    if (!slot1.offset.eq(slot2.offset)) {
        return false;
    }
    if (slot1.hashPath !== slot2.hashPath) {
        return false;
    }
    if (!equalSlots(slot1.path, slot2.path)) {
        return false;
    }
    //to compare keys, we'll just compare their hex encodings
    //(yes, that leaves some wiggle room, as it could consider different
    //*types* of keys to be equal, but if keys are the only difference then
    //that should determine those types, so it shouldn't be a problem)
    if (!slot1.key || !slot2.key) {
        //first, though, they likely don't *have* keys
        return !slot1.key && !slot2.key;
    }
    //if they do have keys, though...
    return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));
}
exports.equalSlots = equalSlots;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 82243:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decodeTopic = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:topic:decode");
const read_1 = __importDefault(__webpack_require__(87534));
const Basic = __importStar(__webpack_require__(53928));
const Format = __importStar(__webpack_require__(29965));
const Conversion = __importStar(__webpack_require__(52714));
function* decodeTopic(dataType, pointer, info, options = {}) {
    if (Format.Types.isReferenceType(dataType) ||
        dataType.typeClass === "tuple") {
        //we cannot decode reference types "stored" in topics; we have to just return an error
        let bytes = yield* (0, read_1.default)(pointer, info.state);
        let raw = Conversion.toHexString(bytes);
        //NOTE: even in strict mode we want to just return this, not throw an error here
        return {
            //dunno why TS is failing here
            type: dataType,
            kind: "error",
            error: {
                kind: "IndexedReferenceTypeError",
                type: dataType,
                raw
            }
        };
    }
    //otherwise, dispatch to decodeBasic
    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);
}
exports.decodeTopic = decodeTopic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44804:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.encodeTopic = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:topic:encode");
const Conversion = __importStar(__webpack_require__(52714));
const Evm = __importStar(__webpack_require__(49218));
const BasicEncode = __importStar(__webpack_require__(51561));
/**
 * Encodes for event topics (indexed parameters).
 * Warning: This function is not fully implemented yet!
 * @Category Encoding (low-level)
 */
function encodeTopic(input) {
    //errors can't be encoded
    if (input.kind === "error") {
        debug("input: %O", input);
        //...unless it's an IndexedReferenceTypeError, in which
        //case, let's read otu that raw data!
        if (input.error.kind === "IndexedReferenceTypeError") {
            return Conversion.toBytes(input.error.raw, Evm.Utils.WORD_SIZE);
        }
        else {
            return undefined;
        }
    }
    //otherwise, just dispath to encodeBasic
    return BasicEncode.encodeBasic(input);
    //...of course, really here we should be checking
    //whether the input *is* a basic type, and if not, handling
    //that appropriately!  But so far we don't need this, so this
    //part of the function isn't implemented yet
}
exports.encodeTopic = encodeTopic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 63196:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Read = exports.Encode = exports.Decode = void 0;
/**
 * For decoding of event topics
 *
 * @protected
 * @category ABI data location
 *
 * @packageDocumentation
 */
const Decode = __importStar(__webpack_require__(82243));
exports.Decode = Decode;
const Encode = __importStar(__webpack_require__(44804));
exports.Encode = Encode;
const Read = __importStar(__webpack_require__(61352));
exports.Read = Read;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 61352:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.readTopic = void 0;
function readTopic(pointer, state) {
    //not bothering with error handling on this one as I don't expect errors
    return state.eventtopics[pointer.topic];
}
exports.readTopic = readTopic;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 8871:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addressCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:address");
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const Utils = __importStar(__webpack_require__(33272));
const EvmUtils = __importStar(__webpack_require__(59901));
const Messages = __importStar(__webpack_require__(53983));
const web3_utils_1 = __importDefault(__webpack_require__(18269));
//no separate cases for contracts; even with loose turned off,
//we consider these interchangeable
const addressFromStringCases = [
    addressFromHexString,
    addressFromPrefixlessHexString,
    addressFromOtherString //Please put after other string cases! Also, can yield
];
const addressCasesBasic = [
    ...addressFromStringCases,
    addressFromBoxedString,
    addressFromContractInput,
    addressFromCodecAddressLikeValue,
    addressFromCodecUdvtValue,
    addressFailureCase
];
exports.addressCases = [addressFromTypeValueInput, ...addressCasesBasic];
function* addressFromHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isHexString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a 0x-prefixed hex string");
    }
    return validateNormalizeAndWrap(dataType, input, input, wrapOptions.name);
}
function* addressFromPrefixlessHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isPrefixlessHexString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an unprefixed hex string");
    }
    return validateNormalizeAndWrap(dataType, "0x" + input, input, wrapOptions.name);
}
function* addressFromOtherString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const request = { kind: "address", name: input };
    const response = yield request;
    if (response.kind !== "address") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.address === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason);
    }
    //we should be able to skip validation & normalization here
    return wrapAsAppropriateType(dataType, response.address);
}
function* addressFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //unbox and try again
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, addressFromStringCases);
}
function* addressFromContractInput(dataType, input, wrapOptions) {
    if (!Utils.isContractInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a contract-like object");
    }
    return validateNormalizeAndWrap(dataType, input.address, input, wrapOptions.name);
}
function* addressFromCodecAddressLikeValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "address" &&
        input.type.typeClass !== "contract") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    let address;
    switch (input.type.typeClass) {
        case "address":
            address = input.value.asAddress;
            break;
        case "contract":
            address = input.value.address;
            break;
        //other cases are impossible at this point
    }
    //we should be able to skip validation/normalization here
    return wrapAsAppropriateType(dataType, address);
}
function* addressFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* addressFromCodecAddressLikeValue(dataType, input.value, wrapOptions);
}
function* addressFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "address" && input.type !== "contract") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), addressCasesBasic);
}
function* addressFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not recognizable as an address");
}
function validateAndNormalize(asAddress, dataType, //for errors
input, //for errors
name //for errors
) {
    if (!Utils.isByteString(asAddress)) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.notABytestringMessage("Address"));
    }
    if (asAddress.length !== 2 * EvmUtils.ADDRESS_SIZE + 2) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.wrongLengthMessage("address", EvmUtils.ADDRESS_SIZE, (asAddress.length - 2) / 2));
    }
    if (!web3_utils_1.default.isAddress(asAddress)) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 6, //to beat the one from the yield case :P
        Messages.checksumFailedMessage);
    }
    //and normalize
    return web3_utils_1.default.toChecksumAddress(asAddress);
}
function wrapAsAppropriateType(dataType, asAddress) {
    //return address or contract value as appropriate
    switch (dataType.typeClass) {
        case "address":
            return {
                type: dataType,
                kind: "value",
                value: {
                    asAddress
                },
                interpretations: {}
            };
        case "contract":
            return {
                type: dataType,
                kind: "value",
                value: {
                    kind: "unknown",
                    address: asAddress
                },
                interpretations: {}
            };
    }
}
function validateNormalizeAndWrap(dataType, asAddress, input, //for errors
name //for errors
) {
    return wrapAsAppropriateType(dataType, validateAndNormalize(asAddress, dataType, input, name));
}
//# sourceMappingURL=address.js.map

/***/ }),

/***/ 56291:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.boolCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:bool");
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const Utils = __importStar(__webpack_require__(33272));
const Messages = __importStar(__webpack_require__(53983));
const boolCasesBasic = [
    boolFromBoolean,
    boolFromString,
    boolFromBoxedPrimitive,
    boolFromCodecBoolValue,
    boolFromCodecBoolError,
    boolFromCodecUdvtValue,
    boolFromCodecUdvtError,
    boolFromOther //must go last!
];
exports.boolCases = [boolFromTypeValueInput, ...boolCasesBasic];
function* boolFromBoolean(dataType, input, wrapOptions) {
    if (typeof input !== "boolean") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boolean");
    }
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean: input
        },
        interpretations: {}
    };
}
function* boolFromString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const lowerCasedInput = input.toLowerCase();
    if (wrapOptions.strictBooleans &&
        !["true", "false", "1", "0"].includes(lowerCasedInput)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Input was not 'true', 'false', '1', or '0'");
    }
    //strings are true unless they're falsy or the case-insensitive strings "false" or "0"
    const asBoolean = Boolean(input) && !["false", "0"].includes(lowerCasedInput);
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean
        },
        interpretations: {}
    };
}
function* boolFromBoxedPrimitive(dataType, input, wrapOptions) {
    if (!Utils.isBoxedPrimitive(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed primitive");
    }
    //unbox and try again
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, exports.boolCases);
}
function* boolFromCodecBoolValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "bool") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to BoolError case
        Messages.errorResultMessage);
    }
    const asBoolean = input.value.asBoolean;
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean
        },
        interpretations: {}
    };
}
function* boolFromCodecBoolError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "bool") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a value rather than an error");
    }
    //these two error types will be regarded as true
    const allowedErrors = ["BoolOutOfRangeError", "BoolPaddingError"];
    if (!allowedErrors.includes(input.error.kind)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean: true
        },
        interpretations: {}
    };
}
function* boolFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "bool") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, disallowing type/value input
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), boolCasesBasic);
}
function* boolFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* boolFromCodecBoolValue(dataType, input.value, wrapOptions);
}
function* boolFromCodecUdvtError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a value rather than an error");
    }
    //wrapped errors will have to be unwrapped, others can be rejected
    if (input.error.kind !== "WrappedError") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* boolFromCodecBoolError(dataType, input.error.error, wrapOptions);
}
function* boolFromOther(dataType, input, wrapOptions) {
    //fallback case: just go by truthiness/falsiness
    //(this case has to be last because there are various other
    //cases we do not want to go by truthiness/falsiness!)
    if (Utils.isWrappedResult(input)) {
        //...except for these, which may error
        //(note that we do this even when loose is on!)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a wrapped result");
    }
    if (Utils.isTypeValueInput(input)) {
        //...and these, which also may error
        //(note that we do this even when loose is on!)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a type/value pair");
    }
    //...and also we don't do this case if strictBooleans is turned on
    if (wrapOptions.strictBooleans) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was neither a boolean nor a boolean string");
    }
    const asBoolean = Boolean(input);
    return {
        type: dataType,
        kind: "value",
        value: {
            asBoolean
        },
        interpretations: {}
    };
}
//# sourceMappingURL=bool.js.map

/***/ }),

/***/ 62083:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.validateUint8ArrayLike = exports.bytesCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:bytes");
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const Conversion = __importStar(__webpack_require__(52714));
const Utils = __importStar(__webpack_require__(33272));
const Messages = __importStar(__webpack_require__(53983));
const bn_js_1 = __importDefault(__webpack_require__(13550));
const bytesFromStringCases = [
    bytesFromHexString,
    bytesFromIntegerString //dynamic loose mode only; make sure this goes after hex string case!
];
const bytesCasesBasic = [
    ...bytesFromStringCases,
    bytesFromBoxedString,
    bytesFromUint8ArrayLike,
    bytesFromCodecBytesValue,
    bytesFromCodecUdvtValue,
    bytesFromEncodingTextInput,
    bytesFromNumber,
    bytesFromBoxedNumber,
    bytesFromBigint,
    bytesFromBN,
    bytesFromBig,
    bytesFromOther //dynamic loose mode only, is failure case otherwise. Make sure this goes last!
];
exports.bytesCases = [bytesFromTypeValueInput, ...bytesCasesBasic];
function* bytesFromHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const trimmed = Utils.removeUnderscoresHex(input);
    //(but not between individual hex digits)
    if (!Utils.isByteString(trimmed)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage("Input"));
    }
    const asHex = validateAndPad(dataType, trimmed, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromIntegerString(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (input.trim() === "") {
        //bigint accepts this but we shouldn't
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.notABytestringMessage("Input"));
    }
    const trimmed = Utils.removeUnderscoresNumeric(input);
    let asBigInt;
    try {
        //we'll use BigInt to parse integer strings, as it's pretty good at it.
        //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.
        asBigInt = BigInt(trimmed);
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input string was not a byte string or integer string");
    }
    if (asBigInt < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(asBigInt);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //defer to primitive string cases
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, bytesFromStringCases);
}
function* bytesFromUint8ArrayLike(dataType, input, wrapOptions) {
    if (!Utils.isUint8ArrayLike(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Uint8Array-like");
    }
    //the next series of checks is delegated to a helper fn
    validateUint8ArrayLike(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)
    let asHex = Conversion.toHexString(new Uint8Array(input)); //I am surprised TS accepts this!
    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromEncodingTextInput(dataType, input, wrapOptions) {
    if (!Utils.isEncodingTextInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a in encoding/text form");
    }
    if (input.encoding !== "utf8") {
        //(the only allowed encoding :P )
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Unknown or unsupported text encoding ${input.encoding}`);
    }
    let asHex;
    try {
        asHex = Conversion.toHexString(Conversion.stringToBytes(input.text));
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);
    }
    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromCodecBytesValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "bytes") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        !(input.type.kind === "dynamic" && dataType.kind === "dynamic") &&
        !(input.type.kind === "static" &&
            dataType.kind === "static" &&
            input.type.length === dataType.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    let asHex = input.value.asHex;
    asHex = validateAndPad(dataType, asHex, input, wrapOptions.name);
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* bytesFromCodecBytesValue(dataType, input.value, wrapOptions);
}
function* bytesFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (!input.type.match(/^byte(s\d*)?$/)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    debug("input.type: %s", input.type);
    //now: determine the specified length; we use "null" for dynamic
    //note that "byte" is allowed, with a length of 1
    let length = null;
    let match = input.type.match(/^bytes(\d+)$/);
    if (match) {
        length = Number(match[1]); //static case with specified number
    }
    else if (input.type === "byte") {
        //"byte" case; set length to 1
        length = 1;
    }
    //otherwise, it's dynamic, so leave it at the default of null
    debug("length: %o", length);
    //check: does the specified length match the data type length?
    if (!(length === null && dataType.kind === "dynamic") &&
        !(dataType.kind === "static" && length === dataType.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), bytesCasesBasic);
}
function* bytesFromNumber(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (typeof input !== "number") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a number");
    }
    if (!Number.isInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    if (!Number.isSafeInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);
    }
    if (input < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBoxedNumber(dataType, input, wrapOptions) {
    //skipping the wrapOptions.loose check, as that'll get checked
    //in bytesFromNumber
    if (!Utils.isBoxedNumber(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed number");
    }
    //unbox and try again
    return yield* bytesFromNumber(dataType, input.valueOf(), wrapOptions);
}
function* bytesFromBigint(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (typeof input !== "bigint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a bigint");
    }
    if (input < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBN(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (!bn_js_1.default.isBN(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a BN");
    }
    if (input.isNeg()) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromBig(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.looseModeOnlyMessage);
    }
    if (!Conversion.isBig(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Big");
    }
    if (Conversion.countDecimalPlaces(input) !== 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    if (input.lt(0)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(input);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function* bytesFromOther(dataType, input, wrapOptions) {
    if (!wrapOptions.loose || dataType.kind === "static") {
        //outside of the dynamic-loose case, this is just a failure case
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, or wrapped bytestring");
    }
    const request = { kind: "integer", input };
    const response = yield request;
    if (response.kind !== "integer") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.value === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason ||
            "Input was not a hex string, byte-array-alike, encoding/text pair, type/value pair, integer input, or wrapped bytestring");
    }
    if (response.value < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.negativeBytesMessage);
    }
    let asHex = Conversion.toHexString(response.value);
    asHex = adjustZeroNumericInput(asHex);
    //because we're in dynamic case, we can skip validateAndPad
    return {
        //TS is complaining again
        type: dataType,
        kind: "value",
        value: {
            asHex
        }
    };
}
function validateUint8ArrayLike(input, dataType, //for error information
name //for error information
) {
    //this function doesn't return anything, it just throws errors if something
    //goes wrong
    if (input instanceof Uint8Array) {
        return; //honest Uint8Arrays don't need checking
    }
    if (!Number.isSafeInteger(input.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, "Input is byte-array-like, but its length is not a safe integer");
    }
    if (input.length < 0) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, "Input is byte-array-like, but its length is negative");
    }
    //check: is it actually like a Uint8Array?
    for (let index = 0; index < input.length; index++) {
        if (typeof input[index] !== "number" ||
            input[index] < 0 ||
            input[index] >= 256 ||
            !Number.isInteger(input[index])) {
            throw new errors_1.TypeMismatchError(dataType, input, name, 5, `Input is byte-array-like, but byte ${index} is not a 1-byte value (number from 0 to 255)`);
        }
    }
    //otherwise, we didn't throw any errors, so return
}
exports.validateUint8ArrayLike = validateUint8ArrayLike;
function validateAndPad(dataType, asHex, input, //for errors
name //for errors
) {
    asHex = asHex.toLowerCase();
    //if static, validate and pad
    if (dataType.kind === "static") {
        if ((asHex.length - 2) / 2 > dataType.length) {
            throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.overlongMessage(dataType.length, (asHex.length - 2) / 2));
        }
        else {
            asHex = asHex.padEnd(dataType.length * 2 + 2, "00");
        }
    }
    return asHex;
}
//special case for ethers compatibility; represents 0 as 0x00 rather than 0x.
//only for numeric input in loose mode, in dynamic case, for compatibility; not
//for ordinary hex input, where the two are distinct!
function adjustZeroNumericInput(asHex) {
    return asHex === "0x" ? "0x00" : asHex;
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ 36902:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.decimalCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:decimal");
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const Conversion = __importStar(__webpack_require__(52714));
const Utils = __importStar(__webpack_require__(33272));
const Messages = __importStar(__webpack_require__(53983));
const bn_js_1 = __importDefault(__webpack_require__(13550));
const big_js_1 = __importDefault(__webpack_require__(13012));
//note: doesn't include UDVT case,
//or error case
const decimalFromWrappedValueCases = [
    decimalFromCodecDecimalValue,
    decimalFromCodecIntegerValue,
    decimalFromCodecEnumValue
];
const decimalCasesBasic = [
    decimalFromNumber,
    decimalFromString,
    decimalFromBoxedNumber,
    decimalFromBoxedString,
    decimalFromBigint,
    decimalFromBN,
    decimalFromBig,
    ...decimalFromWrappedValueCases,
    decimalFromCodecUdvtValue,
    decimalFromCodecEnumError,
    decimalFromOther //must go last!
];
exports.decimalCases = [decimalFromTypeValueInput, ...decimalCasesBasic];
function* decimalFromBig(dataType, input, wrapOptions) {
    if (!Conversion.isBig(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Big");
    }
    const asBig = input.plus(0); //clone
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromBN(dataType, input, wrapOptions) {
    if (!bn_js_1.default.isBN(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a BN");
    }
    const asBig = Conversion.toBig(input);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromBigint(dataType, input, wrapOptions) {
    if (typeof input !== "bigint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a bigint");
    }
    const asBig = Conversion.toBig(input);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    const trimmed = input.trim(); //allow whitespace
    const stripped = Utils.removeUnderscoresNoHex(trimmed);
    let asBig;
    try {
        asBig = new big_js_1.default(stripped);
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonNumericMessage);
    }
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromNumber(dataType, input, wrapOptions) {
    if (typeof input !== "number") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a number");
    }
    if (!Number.isFinite(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Numeric value is not finite");
    }
    if (!Utils.isSafeNumber(dataType, input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Given number is outside the safe range for this data type (possible loss of precision); use a numeric string, bigint, or big number class instead");
    }
    const asBig = new big_js_1.default(input);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //unbox and try again
    return yield* decimalFromString(dataType, input.valueOf(), wrapOptions);
}
function* decimalFromBoxedNumber(dataType, input, wrapOptions) {
    if (!Utils.isBoxedNumber(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed number");
    }
    //unbox and try again
    return yield* decimalFromNumber(dataType, input.valueOf(), wrapOptions);
}
function* decimalFromCodecDecimalValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "fixed" && input.type.typeClass !== "ufixed") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        (input.type.typeClass !== dataType.typeClass ||
            input.type.bits !== dataType.bits ||
            input.type.places !== dataType.places)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBig = input.value.asBig.plus(0); //clone
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecIntegerValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "int" && input.type.typeClass !== "uint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBig = Conversion.toBig(input.value.asBN);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecEnumValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case
        Messages.errorResultMessage);
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBig = Conversion.toBig(input.value.numericAsBN);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecEnumError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Wrapped result was a value rather than an error");
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const coercedInput = input;
    //only one specific kind of error will be allowed
    if (coercedInput.error.kind !== "EnumOutOfRangeError") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const asBig = Conversion.toBig(coercedInput.error.rawAsBN);
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function* decimalFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, decimalFromWrappedValueCases);
}
function* decimalFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (!input.type.match(/^u?fixed(\d+(x\d+)?)?$/) && input.type !== "decimal") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    let bits, places;
    let typeClass;
    if (input.type === "decimal") {
        //vyper's decimal type corresponds to fixed168x10
        typeClass = "fixed";
        bits = 168;
        places = 10;
    }
    else {
        const [_0, typeClassTemporary, _2, bitsAsString, _4, placesAsString] = input.type.match(/^(u?fixed)((\d+)(x(\d+))?)?$/);
        //not all of the fields in this match are used, so we discard them into _n variables
        bits = bitsAsString ? Number(bitsAsString) : 128; //defaults to 128
        places = placesAsString ? Number(placesAsString) : 18; //defaults to 18
        typeClass = typeClassTemporary;
    }
    if (dataType.typeClass !== typeClass ||
        dataType.bits !== bits ||
        dataType.places !== places) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), decimalCasesBasic);
}
function* decimalFromOther(dataType, input, wrapOptions) {
    const request = { kind: "decimal", input };
    const response = yield request;
    if (response.kind !== "decimal") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.value === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));
    }
    const asBig = response.value.plus(0); //clone
    validate(dataType, asBig, input, wrapOptions.name);
    return {
        //IDK why TS is screwing up here
        type: dataType,
        kind: "value",
        value: {
            asBig
        }
    };
}
function validate(dataType, asBig, input, //just for errors
name //for errors
) {
    if (Conversion.countDecimalPlaces(asBig) > dataType.places) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.tooPreciseMessage(dataType.places, Conversion.countDecimalPlaces(asBig)));
    }
    if (asBig.gt(Utils.maxValue(dataType)) ||
        asBig.lt(Utils.minValue(dataType))) {
        throw new errors_1.TypeMismatchError(dataType, input, name, 5, Messages.outOfRangeMessage);
    }
}
//# sourceMappingURL=decimal.js.map

/***/ }),

/***/ 73898:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrapWithCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:dispatch");
const Format = __importStar(__webpack_require__(29965));
const errors_1 = __webpack_require__(74595);
function* wrapWithCases(dataType, input, wrapOptions, cases) {
    let bestError;
    const specificityFloor = wrapOptions.specificityFloor || 0;
    for (const caseFn of cases) {
        try {
            return yield* caseFn(dataType, input, Object.assign(Object.assign({}, wrapOptions), { specificityFloor: 0 }));
        }
        catch (error) {
            if (!(error instanceof errors_1.TypeMismatchError)) {
                //rethrow unexpected errors
                throw error;
            }
            else if (!bestError || error.specificity > bestError.specificity) {
                bestError = error;
            }
        }
    }
    //if we've made it this far, no case has matched
    if (bestError && bestError.specificity < specificityFloor) {
        bestError.specificity = specificityFloor; //mutating this should be fine, right?
    }
    throw bestError || new errors_1.TypeMismatchError(//last-resort error
    dataType, input, wrapOptions.name, specificityFloor, //it doesn't matter, but we'll make this error lowest specificity
    `Input for ${wrapOptions.name} was not recognizable as type ${Format.Types.typeStringWithoutLocation(dataType)}`);
    //(note: we don't actually want to rely on the last-resort error, we'll
    //instead prefer last-resort cases that just throw an error so we can get
    //more specific messages, but I'm including this anyway just to be certain)
}
exports.wrapWithCases = wrapWithCases;
//# sourceMappingURL=dispatch.js.map

/***/ }),

/***/ 74595:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;
const Format = __importStar(__webpack_require__(29965));
/**
 * This error indicates that no overloads matched when performing
 * overload resolution.  If there was only one plausible match,
 * a [[TypeMismatchError]] will be thrown instead.
 * @category Errors
 */
class NoOverloadsMatchedError extends Error {
    constructor(methods, inputs, userDefinedTypes) {
        const message = "Arguments provided did not match any overload";
        super(message);
        this.methods = methods;
        this.inputs = inputs;
        this.userDefinedTypes = userDefinedTypes;
        this.name = "NoOverloadsMatchedError";
    }
}
exports.NoOverloadsMatchedError = NoOverloadsMatchedError;
/**
 * This error indicates that multiple overloads matched during
 * overload resolution, but none of them was the unique best
 * overload.
 * @category Errors
 */
class NoUniqueBestOverloadError extends Error {
    constructor(resolutions) {
        const message = "Could not determine a unique best overload for the given arguments.  " +
            "Please specify the overload explicitly or give the arguments more explicit types.";
        super(message);
        this.resolutions = resolutions;
        this.name = "NoUniqueBestOverloadError";
    }
}
exports.NoUniqueBestOverloadError = NoUniqueBestOverloadError;
/**
 * This error indicates that the given input could not be recognized as the
 * type it was supposed to be.
 * @category Errors
 */
class TypeMismatchError extends Error {
    constructor(dataType, input, variableName, specificity, reason) {
        const message = `Could not interpret input for ${variableName} as type ${Format.Types.typeString(dataType)}.  Reason: ${reason}`;
        super(message);
        this.variableName = variableName;
        this.dataType = dataType;
        this.input = input;
        this.reason = reason;
        this.specificity = specificity;
        this.name = "TypeMismatchError";
    }
}
exports.TypeMismatchError = TypeMismatchError;
class BadResponseTypeError extends Error {
    constructor(request, response) {
        const message = `Got response type ${response.kind} to request type ${request.kind}`;
        super(message);
        this.request = request;
        this.response = response;
        this.name = "BadResponseTypeError";
    }
}
exports.BadResponseTypeError = BadResponseTypeError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 52181:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.functionExternalCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:function");
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const Messages = __importStar(__webpack_require__(53983));
const Utils = __importStar(__webpack_require__(33272));
const EvmUtils = __importStar(__webpack_require__(59901));
const web3_utils_1 = __importDefault(__webpack_require__(18269));
const address_1 = __webpack_require__(8871);
const bytes_1 = __webpack_require__(62083);
const functionExternalCasesBasic = [
    functionFromFunctionExternalInput,
    functionFromHexString,
    functionFromCodecFunctionExternalValue,
    functionFailureCase
];
exports.functionExternalCases = [functionFromTypeValueInput, ...functionExternalCasesBasic];
function* functionFromFunctionExternalInput(dataType, input, wrapOptions) {
    if (!Utils.isFunctionExternalInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an object with address & selector");
    }
    const wrappedAddress = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: "address", kind: "general" }, input.address, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.address`, specificityFloor: 5 }), address_1.addressCases));
    const address = wrappedAddress.value.asAddress;
    const wrappedSelector = yield* (0, dispatch_1.wrapWithCases)({ typeClass: "bytes", kind: "static", length: 4 }, input.selector, Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.selector`, specificityFloor: 5 }), bytes_1.bytesCases);
    const selector = wrappedSelector.value.asHex;
    //note validation & normalization have already been performed
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        },
        interpretations: {}
    };
}
function* functionFromCodecFunctionExternalValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "function" ||
        input.type.visibility !== "external") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const coercedInput = input;
    const address = coercedInput.value.contract.address;
    const selector = coercedInput.value.selector;
    //we can skip validation & normalization here
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        },
        interpretations: {}
    };
}
function* functionFromHexString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isByteString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, "Input was a string, but not a valid even-length hex string");
    }
    if (input.length !==
        2 + 2 * (EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongLengthMessage("external function was given as a string but", EvmUtils.ADDRESS_SIZE + EvmUtils.SELECTOR_SIZE, (input.length - 2) / 2));
    }
    let address = input
        .slice(0, EvmUtils.ADDRESS_SIZE * 2 + 2)
        .toLowerCase();
    const selector = "0x" + input.slice(EvmUtils.ADDRESS_SIZE * 2 + 2).toLowerCase();
    //address & selector must now have the correct length, and we are deliberately *not*
    //checking the checksum on address in this case.  So, the only thing remaining
    //to do is to normalize address.
    address = web3_utils_1.default.toChecksumAddress(address);
    //...and return
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "unknown",
            contract: {
                kind: "unknown",
                address
            },
            selector
        },
        interpretations: {}
    };
}
function* functionFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "function") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), functionExternalCasesBasic);
}
function* functionFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input should be one of: an object with address and selector; a 24-byte hex string; a type/value pair; or a wrapped external function");
}
//# sourceMappingURL=function.js.map

/***/ }),

/***/ 18479:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.resolveAndWrap = exports.wrapForMethod = exports.wrapMultiple = exports.Messages = exports.wrap = exports.BadResponseTypeError = exports.TypeMismatchError = exports.NoUniqueBestOverloadError = exports.NoOverloadsMatchedError = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap");
const priority_1 = __webpack_require__(62131);
const errors_1 = __webpack_require__(74595);
Object.defineProperty(exports, "NoOverloadsMatchedError", ({ enumerable: true, get: function () { return errors_1.NoOverloadsMatchedError; } }));
Object.defineProperty(exports, "NoUniqueBestOverloadError", ({ enumerable: true, get: function () { return errors_1.NoUniqueBestOverloadError; } }));
Object.defineProperty(exports, "TypeMismatchError", ({ enumerable: true, get: function () { return errors_1.TypeMismatchError; } }));
Object.defineProperty(exports, "BadResponseTypeError", ({ enumerable: true, get: function () { return errors_1.BadResponseTypeError; } }));
__exportStar(__webpack_require__(74595), exports);
const wrap_1 = __webpack_require__(18400);
Object.defineProperty(exports, "wrap", ({ enumerable: true, get: function () { return wrap_1.wrap; } }));
__exportStar(__webpack_require__(10076), exports);
exports.Messages = __importStar(__webpack_require__(53983));
function* wrapMultiple(types, inputs, wrapOptions) {
    //just wrap the types in a tuple and defer to wrap()
    const combinedType = {
        typeClass: "tuple",
        memberTypes: types
    };
    debug("wrapping multiple");
    const wrappedTogether = (yield* (0, wrap_1.wrap)(combinedType, inputs, wrapOptions));
    return wrappedTogether.value.map(({ value }) => value);
}
exports.wrapMultiple = wrapMultiple;
//note: turns on loose
function* wrapForMethod(method, inputs, resolveOptions) {
    const wrapped = yield* wrapForMethodRaw(method, inputs, resolveOptions, true);
    return wrappingToResolution(method, wrapped);
}
exports.wrapForMethod = wrapForMethod;
function wrappingToResolution(method, wrapped) {
    if (wrapped.length > 0 &&
        wrapped[wrapped.length - 1].type.typeClass === "options") {
        //there's options
        const wrappedArguments = wrapped.slice(0, -1); //cut off options
        const options = wrapped[wrapped.length - 1]
            .value;
        return {
            method,
            arguments: wrappedArguments,
            options
        };
    }
    else {
        //no options
        return {
            method,
            arguments: wrapped,
            options: {}
        };
    }
}
//doesn't separate out options from arguments & doesn't turn on loose
function* wrapForMethodRaw(method, inputs, { userDefinedTypes, allowOptions, allowJson, strictBooleans }, loose = false) {
    debug("wrapping for method");
    if (method.inputs.length === inputs.length) {
        //no options case
        debug("no options");
        return yield* wrapMultiple(method.inputs, inputs, {
            userDefinedTypes,
            oldOptionsBehavior: true,
            loose,
            name: "<arguments>",
            allowJson,
            strictBooleans
        });
    }
    else if (allowOptions && method.inputs.length === inputs.length - 1) {
        //options case
        debug("options");
        const inputsWithOptions = [
            ...method.inputs,
            { name: "<options>", type: { typeClass: "options" } }
        ];
        return yield* wrapMultiple(inputsWithOptions, inputs, {
            userDefinedTypes,
            oldOptionsBehavior: true,
            loose,
            name: "<arguments>",
            allowJson,
            strictBooleans
        });
    }
    else {
        //invalid length case
        const orOneMore = allowOptions
            ? ` (or ${method.inputs.length + 1} counting transaction options)`
            : "";
        throw new errors_1.TypeMismatchError({ typeClass: "tuple", memberTypes: method.inputs }, inputs, "<arguments>", 5, `Incorrect number of arguments (expected ${method.inputs.length}${orOneMore}, got ${inputs.length})`);
    }
}
function* resolveAndWrap(methods, inputs, { userDefinedTypes, allowOptions, allowJson, strictBooleans }) {
    //despite us having a good system for overload resolution, we want to
    //use it as little as possible!  That's because using it means we don't
    //get great error messages.  As such, we're going to do a bunch to filter
    //things beforehand, so that we get good error messages.
    if (methods.length === 1) {
        //if there's only one possibility, we just defer to wrapForMethod
        //if we ignore error messages this is silly... but we're not!
        //this is important for good error messages in this case
        return yield* wrapForMethod(methods[0], inputs, {
            userDefinedTypes,
            allowOptions,
            allowJson,
            strictBooleans
        });
    }
    //OK, so, there are multiple possibilities then.  let's try to filter things down by length.
    const possibleMatches = methods.filter(method => method.inputs.length === inputs.length);
    //but, we've also got to account for the possibility of options
    let possibleMatchesWithOptions = [];
    let possibleOptions = {};
    if (allowOptions && inputs.length > 0) {
        //if options are allowed, we'll have to account for that.
        //*however*, in order to minimize the number of possibilities, we won't
        //use these unless the last argument of inputs actually looks like an options!
        const lastInput = inputs[inputs.length - 1];
        let isOptionsPossible = true;
        try {
            const wrappedOptions = (yield* (0, wrap_1.wrap)({ typeClass: "options" }, lastInput, {
                name: "<options>",
                loose: true,
                oldOptionsBehavior: true,
                userDefinedTypes,
                allowJson,
                strictBooleans
            }));
            possibleOptions = wrappedOptions.value;
        }
        catch (error) {
            if (error instanceof errors_1.TypeMismatchError) {
                isOptionsPossible = false;
            }
            else {
                throw error; //rethrow unexpected errors
            }
        }
        if (isOptionsPossible) {
            possibleMatchesWithOptions = methods.filter(method => method.inputs.length === inputs.length - 1);
        }
    }
    debug("possibleMatches: %o", possibleMatches);
    debug("possibleMatchesWithOptions: %o", possibleMatchesWithOptions);
    //if there's now only one possibility, great!
    if (possibleMatches.length === 1 && possibleMatchesWithOptions.length === 0) {
        //only one possibility, no options. we can just defer to wrapMultiple.
        //(again, point is to have good error messaging)
        debug("only one possibility, no options");
        const method = possibleMatches[0];
        return {
            method,
            arguments: yield* wrapMultiple(method.inputs, inputs, {
                userDefinedTypes,
                loose: true,
                name: "<arguments>",
                allowJson,
                strictBooleans
            }),
            options: {}
        };
    }
    else if (possibleMatchesWithOptions.length === 1 &&
        possibleMatches.length === 0) {
        //only one possibility, with options.  moreover, we already determined the options
        //above, so we can once again just defer to wrapMultiple
        debug("only one possiblity, with options");
        const method = possibleMatchesWithOptions[0];
        return {
            method,
            arguments: yield* wrapMultiple(method.inputs, inputs, {
                userDefinedTypes,
                loose: true,
                name: "<arguments>",
                allowJson,
                strictBooleans
            }),
            options: possibleOptions
        };
    }
    else if (possibleMatches.length === 0 &&
        possibleMatchesWithOptions.length === 0) {
        debug("no possibilities");
        //nothing matches!
        throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);
    }
    //if all of our attempts to avoid it have failed, we'll have to actually use
    //our overload resolution system. note how we do *not* turn on loose in this
    //case!
    debug("attempting overload resolution");
    let resolutions = [];
    for (const method of methods) {
        let wrapped;
        try {
            //note this part takes care of options for us...
            //although yes this means options will be re-wrapped, oh well
            wrapped = yield* wrapForMethodRaw(method, inputs, {
                userDefinedTypes,
                allowOptions,
                allowJson,
                strictBooleans
            });
        }
        catch (error) {
            //if there's an error, don't add it
            debug("failed: %O", method);
            debug("because: %O", error);
            continue;
        }
        //note that options and arguments here are both not correct, but we'll
        //fix them up later!
        debug("adding: %O", method);
        resolutions.push({ method, arguments: wrapped, options: {} });
    }
    //now: narrow it down to the most specific one(s)
    debug("resolutions: %O", resolutions);
    resolutions = resolutions.filter(resolution => resolutions.every(comparisonResolution => !(0, priority_1.isMoreSpecificMultiple)(comparisonResolution.arguments, resolution.arguments, strictBooleans, userDefinedTypes) ||
        //because the comparison is nonstrict, this comparison is added to
        //effectively make it strict
        // i.e. we have !(x<=y) but we want !(x<y), i.e.,
        // !(x<=y) | x=y, i.e., !(x<=y) | (x<=y & y<=x),
        // i.e., !(x<=y) | y<=x
        (0, priority_1.isMoreSpecificMultiple)(resolution.arguments, comparisonResolution.arguments, strictBooleans, userDefinedTypes)));
    debug("resolutions remaining: %O", resolutions);
    switch (resolutions.length) {
        case 0:
            //no resolution worked
            throw new errors_1.NoOverloadsMatchedError(methods, inputs, userDefinedTypes);
        case 1:
            //there was a most specific resolution; fix up options and arguments
            //before returning
            const { method, arguments: wrapped } = resolutions[0];
            return wrappingToResolution(method, wrapped);
        default:
            //no unique most-specific resolution
            throw new errors_1.NoUniqueBestOverloadError(resolutions);
    }
}
exports.resolveAndWrap = resolveAndWrap;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 47779:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.integerCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:integer");
const Format = __importStar(__webpack_require__(29965));
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const Conversion = __importStar(__webpack_require__(52714));
const Utils = __importStar(__webpack_require__(33272));
const Messages = __importStar(__webpack_require__(53983));
const bn_js_1 = __importDefault(__webpack_require__(13550));
const big_js_1 = __importDefault(__webpack_require__(13012));
const bytes_1 = __webpack_require__(62083);
//NOTE: all cases called "integerFrom..." also work for enums.
//The cases labeled "enumFrom..." work only for enums.
//there are no cases that work only for integers and not enums,
//because we always want input for integers to also be valid for enums.
const integerFromStringCases = [
    integerFromIntegerString,
    enumFromNameString,
    integerFromScientificOrUnits,
    integerFromNegatedBaseString,
    integerFromStringFailureCase
];
//note: doesn't include UDVT case,
//or error case
const integerFromWrappedValueCases = [
    integerFromCodecIntegerValue,
    integerFromCodecEnumValue,
    integerFromCodecDecimalValue
];
const integerCasesBasic = [
    ...integerFromStringCases,
    integerFromNumber,
    integerFromBoxedNumber,
    integerFromBoxedString,
    integerFromBigint,
    integerFromBN,
    integerFromBig,
    integerFromUint8ArrayLike,
    ...integerFromWrappedValueCases,
    integerFromCodecEnumError,
    integerFromCodecUdvtValue,
    integerFromOther //must go last!
];
exports.integerCases = [
    integerFromIntegerTypeValueInput,
    enumFromEnumTypeValueInput,
    ...integerCasesBasic
];
function* integerFromIntegerString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (input.trim() === "") {
        //bigint accepts this but we shouldn't
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, dataType.typeClass === "enum"
            ? Messages.badEnumMessage
            : Messages.nonNumericMessage);
    }
    const stripped = Utils.removeUnderscoresNumeric(input);
    let asBN;
    try {
        //we'll use BigInt to parse integer strings, as it's pretty good at it.
        //Note that it accepts hex/octal/binary with prefixes 0x, 0o, 0b.
        const asBigInt = BigInt(stripped);
        asBN = Conversion.toBN(asBigInt);
    }
    catch (_a) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input string was not an integer string");
    }
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
//this case handles both scientific notation, and numbers with units
function* integerFromScientificOrUnits(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (input.trim() === "") {
        //the code below accepts this but we shouldn't
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 since it's already specificity 5 above
        dataType.typeClass === "enum"
            ? Messages.badEnumMessage
            : Messages.nonNumericMessage);
    }
    const stripped = Utils.removeUnderscoresNoHex(input);
    let [_, quantityString, unit] = stripped.match(/^(.*?)(|wei|gwei|shannon|finney|szabo|ether)\s*$/i); //units will be case insensitive; note this always matches
    quantityString = quantityString.trim(); //Big rejects whitespace, let's allow it
    const unitPlacesTable = {
        //we could accept all of web3's units here, but, that's a little much;
        //we'll just accept the most common ones
        "": 0,
        "wei": 0,
        "gwei": 9,
        "shannon": 9,
        "szabo": 12,
        "finney": 15,
        "ether": 18
    };
    let quantity;
    try {
        quantity = quantityString.match(/^\s*$/)
            ? new big_js_1.default(1) //allow just "ether" e.g.
            : new big_js_1.default(quantityString);
    }
    catch (_a) {
        quantity = null;
    }
    if (quantity === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string using scientific notation or units");
    }
    const places = unitPlacesTable[unit.toLowerCase()];
    const asBig = Conversion.shiftBigUp(quantity, places);
    if (Conversion.countDecimalPlaces(asBig) !== 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, unit !== ""
            ? "Input numeric value was not an integral number of wei"
            : Messages.nonIntegerMessage);
    }
    const asBN = Conversion.toBN(asBig);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromNegatedBaseString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!input.match(/^\s*-/)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a negated numeric string");
    }
    const stripped = Utils.removeUnderscoresNumeric(input);
    let positiveAsBN;
    const [_, positiveString] = stripped.match(/^\s*-(.*)$/);
    try {
        const positive = BigInt(positiveString);
        positiveAsBN = Conversion.toBN(positive);
    }
    catch (_a) {
        positiveAsBN = null;
    }
    if (positiveAsBN === null ||
        positiveString === "" ||
        positiveString.match(/^(-|\s)/)) {
        //no double negation, no bare "-", and no space after the minus!
        //(we do this as a string check, rather than checking if
        //positiveAsBN is >=0, in order to prevent entering e.g. "--" or "- 2")
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);
    }
    const asBN = positiveAsBN.neg();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* enumFromNameString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (dataType.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.nonNumericMessage);
    }
    const fullType = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));
    const options = fullType.options;
    const components = input.split(".");
    const finalComponent = components[components.length - 1];
    debug("components: %O", components);
    debug("dataType: %O", dataType);
    debug("options: %O", options);
    //the enum can be qualified.  if it's qualified, does the type match?
    let matchingType;
    switch (components.length) {
        case 1:
            //not qualified, automatically matches
            matchingType = true;
            break;
        case 2:
            //qualified by type name, does it match?
            matchingType = components[0] === dataType.typeName;
            break;
        case 3:
            //qualified by type name and contract name, does it match?
            matchingType =
                dataType.kind === "local" &&
                    components[0] === dataType.definingContractName &&
                    components[1] === dataType.typeName;
            break;
        default:
            //no valid reason to have 3 or more periods
            //(and split cannot return an empty array)
            matchingType = false;
    }
    debug("matchingType: %O", matchingType);
    const numeric = matchingType ? options.indexOf(finalComponent) : -1; //if type doesn't match, just indicate error
    debug("numeric: %d", numeric);
    if (numeric === -1) {
        //-1 comes from either our setting it manually above to indicate error,
        //or from a failed indexOf call
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.badEnumMessage);
    }
    const asBN = new bn_js_1.default(numeric); //whew!
    //now: unlike in every other case, we can skip validation!
    //so let's just wrap and return!
    return {
        type: dataType,
        kind: "value",
        value: {
            numericAsBN: asBN,
            name: finalComponent //we know it matches!
        },
        interpretations: {}
    };
}
function* integerFromStringFailureCase(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, dataType.typeClass === "enum"
        ? Messages.badEnumMessage
        : Messages.nonNumericMessage);
}
function* integerFromBN(dataType, input, wrapOptions) {
    if (!bn_js_1.default.isBN(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a BN");
    }
    const asBN = input.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromBigint(dataType, input, wrapOptions) {
    if (typeof input !== "bigint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a bigint");
    }
    const asBN = Conversion.toBN(input);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromNumber(dataType, input, wrapOptions) {
    if (typeof input !== "number") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a number");
    }
    if (!Number.isInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    if (!Number.isSafeInteger(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonSafeMessage);
    }
    const asBN = new bn_js_1.default(input);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromBig(dataType, input, wrapOptions) {
    if (!Conversion.isBig(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Big");
    }
    if (Conversion.countDecimalPlaces(input) !== 0) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.nonIntegerMessage);
    }
    const asBN = Conversion.toBN(input);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromUint8ArrayLike(dataType, input, wrapOptions) {
    if (!Utils.isUint8ArrayLike(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Uint8Array-like");
    }
    //the next series of checks is delegated to a helper fn
    (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)
    const asBN = Conversion.toBN(new Uint8Array(input)); //I am surprised TS accepts this!
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromBoxedNumber(dataType, input, wrapOptions) {
    if (!Utils.isBoxedNumber(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed number");
    }
    //unbox and try again
    return yield* integerFromNumber(dataType, input.valueOf(), wrapOptions);
}
function* integerFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //unbox and try again
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.valueOf(), wrapOptions, integerFromStringCases);
}
function* integerFromCodecIntegerValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "int" && input.type.typeClass !== "uint") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        (input.type.typeClass !== dataType.typeClass ||
            input.type.bits !== dataType.bits)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBN = input.value.asBN.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecDecimalValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "fixed" && input.type.typeClass !== "ufixed") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    if (!wrapOptions.loose) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBN = Conversion.toBN(input.value.asBig);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecEnumValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, //only specificity 1 due to EnumError case
        Messages.errorResultMessage);
    }
    if (!wrapOptions.loose &&
        (dataType.typeClass !== "enum" || input.type.id !== dataType.id)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const asBN = input.value.numericAsBN.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecEnumError(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "error") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Wrapped result was a value rather than an error");
    }
    if (!wrapOptions.loose &&
        (dataType.typeClass !== "enum" || input.type.id !== dataType.id)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    const coercedInput = input;
    //only one specific kind of error will be allowed
    if (coercedInput.error.kind !== "EnumOutOfRangeError") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const asBN = coercedInput.error.rawAsBN.clone();
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function* integerFromCodecUdvtValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "userDefinedValueType") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, integerFromWrappedValueCases);
}
function* integerFromIntegerTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (!input.type.match(/^u?int\d*$/)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === "enum" ? 1 : 5, 
        //use specificity 5 when getting an integer (which have no alternative),
        //but specificity 1 when getting an enum (which have enum type/value input also)
        Messages.specifiedTypeMessage(input.type));
    }
    const [_, typeClass, bitsAsString] = input.type.match(/^(u?int)(\d*)$/);
    const bits = bitsAsString ? Number(bitsAsString) : 256; //defaults to 256
    //(not using the WORD_SIZE constant due to fixed types bringing its applicability
    //here into question)
    const requiredTypeClass = dataType.typeClass !== "enum" ? dataType.typeClass : "uint"; //allow underlying uint type to work for enums
    //(we handle "enum" given as type in a separate case below)
    const requiredBits = dataType.typeClass !== "enum"
        ? dataType.bits
        : 8 *
            Math.ceil(Math.log2((Format.Types.fullType(dataType, wrapOptions.userDefinedTypes)).options.length) / 8); //compute required bits for enum type (sorry)
    if (requiredTypeClass !== typeClass || requiredBits !== bits) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), integerCasesBasic);
}
function* enumFromEnumTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, dataType.typeClass === "enum" ? 5 : 1, 
        //use specificity 5 when getting an enum (which will have also failed integer type/value input),
        //but specificity 1 when getting an integer (to which this doesn't really apply)
        Messages.specifiedTypeMessage(input.type));
    }
    if (dataType.typeClass !== "enum") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    //(we'll also coerce the type on this one since we know it's
    //going to be an enum value :P )
    return (yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), integerCasesBasic));
}
function* integerFromOther(dataType, input, wrapOptions) {
    const request = { kind: "integer", input };
    const response = yield request;
    if (response.kind !== "integer") {
        throw new errors_1.BadResponseTypeError(request, response);
    }
    if (response.value === null) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, response.partiallyRecognized ? 5 : 3, response.reason || Messages.unrecognizedNumberMessage(dataType));
    }
    const asBN = Conversion.toBN(response.value);
    return validateAndWrap(dataType, asBN, wrapOptions, input);
}
function validateAndWrap(dataType, asBN, wrapOptions, input //just for erroring
) {
    switch (dataType.typeClass) {
        case "uint":
            if (asBN.isNeg() || asBN.bitLength() > dataType.bits) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);
            }
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN
                },
                interpretations: {}
            };
        case "int":
            if ((!asBN.isNeg() && asBN.bitLength() >= dataType.bits) || //>= since signed
                (asBN.isNeg() && asBN.neg().subn(1).bitLength() >= dataType.bits)
            //bitLength doesn't work great for negatives so we do this instead
            ) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeMessage);
            }
            return {
                type: dataType,
                kind: "value",
                value: {
                    asBN
                },
                interpretations: {}
            };
        case "enum":
            const fullType = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));
            if (asBN.isNeg() || asBN.gten(fullType.options.length)) {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.outOfRangeEnumMessage);
            }
            return {
                type: dataType,
                kind: "value",
                value: {
                    numericAsBN: asBN,
                    name: fullType.options[asBN.toNumber()]
                },
                interpretations: {}
            };
    }
}
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ 53983:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unrecognizedNumberMessage = exports.wrongLengthMessage = exports.notABytestringMessage = exports.tooPreciseMessage = exports.overlongMessage = exports.specifiedTypeMessage = exports.wrappedTypeMessage = exports.negativeBytesMessage = exports.looseModeOnlyMessage = exports.invalidUtf16Message = exports.checksumFailedMessage = exports.outOfRangeEnumMessage = exports.outOfRangeMessage = exports.badEnumMessage = exports.nonSafeMessage = exports.nonNumericMessage = exports.nonIntegerMessage = exports.notAStringMessage = exports.errorResultMessage = exports.wrongArrayLengthMessage = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:messages");
const Format = __importStar(__webpack_require__(29965));
function wrongArrayLengthMessage(expected, got) {
    return `Incorrect array length (expected ${expected.toString()} entries, got ${got})`;
}
exports.wrongArrayLengthMessage = wrongArrayLengthMessage;
exports.errorResultMessage = "Input is a wrapped result representing an error rather than a value";
exports.notAStringMessage = "Input was not a string, type/value pair, or wrapped or boxed string";
exports.nonIntegerMessage = "Input numeric value was not an integer";
exports.nonNumericMessage = "Input string was not numeric";
exports.nonSafeMessage = "Input number is not a Javascript safe integer";
exports.badEnumMessage = "Input string was neither numeric nor a valid enum value";
exports.outOfRangeMessage = "Input is outside the range of this numeric type";
exports.outOfRangeEnumMessage = "Input is outside the range of this enum type";
exports.checksumFailedMessage = "Address checksum failed (use all lowercase or all uppercase to circumvent)";
exports.invalidUtf16Message = "Input string was not valid UTF-16";
exports.looseModeOnlyMessage = "Numeric input for bytes is only allowed in loose mode and only for dynamic-length bytestrings";
exports.negativeBytesMessage = "Input for bytes cannot be negative";
function wrappedTypeMessage(dataType) {
    return `Input is a wrapped value of type ${Format.Types.typeString(dataType)}`;
}
exports.wrappedTypeMessage = wrappedTypeMessage;
function specifiedTypeMessage(dataType) {
    return `Input had type explicitly specified as ${dataType}`;
}
exports.specifiedTypeMessage = specifiedTypeMessage;
function overlongMessage(expected, got) {
    return `Input is too long for type (expected ${expected} bytes, got ${got} bytes)`;
}
exports.overlongMessage = overlongMessage;
function tooPreciseMessage(expected, got) {
    return `Input has too many decimal places for type (expected ${expected} decimal places, got ${got} decimal places)`;
}
exports.tooPreciseMessage = tooPreciseMessage;
function notABytestringMessage(what) {
    return `${what} is not a valid bytestring (even-length hex string)`;
}
exports.notABytestringMessage = notABytestringMessage;
function wrongLengthMessage(what, expected, got) {
    return `Input ${what} was ${got} bytes instead of ${expected} bytes`;
}
exports.wrongLengthMessage = wrongLengthMessage;
function unrecognizedNumberMessage(dataType) {
    const enumMessage = dataType.typeClass === "enum"
        ? "enum value name, "
        : "";
    const byteArrayMessage = dataType.typeClass !== "fixed" && dataType.typeClass !== "ufixed"
        ? "byte-array-like, "
        : "";
    return `Input was not a number, big integer, numeric string, ${enumMessage}type/value pair, boxed number, ${byteArrayMessage}wrapped number or enum, or recognized big number class`;
}
exports.unrecognizedNumberMessage = unrecognizedNumberMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 62131:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isMoreSpecific = exports.isMoreSpecificMultiple = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:priority");
const Format = __importStar(__webpack_require__(29965));
const utils_1 = __webpack_require__(33272);
//is input 1 more specific than input 2? (nonstrict)
function isMoreSpecificMultiple(types1, types2, strictBooleans, userDefinedTypes) {
    //just wrap the types in tuples and defer to isMoreSpecific()
    const combinedType1 = {
        typeClass: "tuple",
        memberTypes: types1
    };
    const combinedType2 = {
        typeClass: "tuple",
        memberTypes: types2
    };
    return isMoreSpecific(combinedType1, combinedType2, strictBooleans, userDefinedTypes, true);
    //that last flag is so we ignore variable names at top level
}
exports.isMoreSpecificMultiple = isMoreSpecificMultiple;
//is input 1 more specific than input 2?
//(this is nonstrict)
function isMoreSpecific(type1, type2, strictBooleans, userDefinedTypes, ignoreComponentNames = false //this flag is *not* applied recursively!
) {
    //udvts get priority of underlying type!
    if (type1.typeClass === "userDefinedValueType") {
        type1 = getUnderlyingType(type1, userDefinedTypes);
    }
    if (type2.typeClass === "userDefinedValueType") {
        type2 = getUnderlyingType(type2, userDefinedTypes);
    }
    const typeClassesMinusStringAndBool = [
        ["options"],
        ["array"],
        ["struct", "tuple"],
        ["address", "contract"],
        ["bytes"],
        ["function"],
        ["uint", "int", "fixed", "ufixed"],
        ["enum"]
    ];
    const typeClasses = typeClassesMinusStringAndBool.concat(strictBooleans ? [["bool"], ["string"]] : [["string"], ["bool"]]);
    //for each type, what's the first one it counts as?
    const index1 = typeClasses.findIndex(classes => classes.includes(type1.typeClass));
    const index2 = typeClasses.findIndex(classes => classes.includes(type2.typeClass));
    //NOTE: I am assuming neither will be -1!
    //If either is, something has gone very wrong!
    if (index1 < index2) {
        return true;
    }
    else if (index2 < index1) {
        return false;
    }
    //otherwise, indices are equal, defer to tiebreaker
    switch (type1.typeClass) {
        case "options":
            return isMoreSpecificOptions(type1, type2);
        case "address":
        case "contract":
            return isMoreSpecificAddress(type1, type2);
        case "function":
            return isMoreSpecificFunction(
            //we haven't actually checked visibility, so we'll have to coerce
            type1, type2, strictBooleans, userDefinedTypes);
        case "array":
            return isMoreSpecificArray(type1, type2, strictBooleans, userDefinedTypes);
        case "bytes":
            return isMoreSpecificBytes(type1, type2);
        case "uint":
        case "int":
        case "fixed":
        case "ufixed":
            return isMoreSpecificNumeric(type1, type2);
        case "enum":
            return isMoreSpecificEnum(type1, type2);
        case "string":
            return isMoreSpecificString(type1, type2);
        case "struct":
        case "tuple":
            return isMoreSpecificTuple(type1, type2, strictBooleans, userDefinedTypes, ignoreComponentNames);
        case "bool":
            return isMoreSpecificBool(type1, type2);
    }
}
exports.isMoreSpecific = isMoreSpecific;
function isMoreSpecificAddress(type1, type2) {
    //address payable more specific than address
    //contract types more specific than address
    //*payable* contract types more specific than address payable
    if (type1.typeClass === "address" && type2.typeClass === "address") {
        if (type1.kind === "specific" && type2.kind === "specific") {
            return type1.payable || !type2.payable;
        }
        else if (type2.kind === "general") {
            //specific is more specific than general :P
            return true;
        }
    }
    if (type1.typeClass === "contract" && type2.typeClass === "contract") {
        if (type1.kind === "native" && type2.kind === "native") {
            return type1.id === type2.id;
        } //foreign contract types will always be incomparable, I guess?
        //(they shouldn't come up here anyway)
    }
    if (type1.typeClass === "contract" && type2.typeClass === "address") {
        return (type2.kind === "general" ||
            (type2.kind === "specific" && !type2.payable) ||
            (type2.kind === "specific" && type1.payable));
    }
    return false; //otherwise
}
function isMoreSpecificBytes(type1, type2) {
    //static more specific than dynamic, with shorter
    //lengths more specific than longer ones
    return ((type1.kind === "dynamic" && type2.kind === "dynamic") ||
        (type1.kind === "static" && type2.kind === "dynamic") ||
        (type1.kind === "static" &&
            type2.kind === "static" &&
            type1.length <= type2.length));
}
function isMoreSpecificNumeric(type1, type2) {
    return ((0, utils_1.maxValue)(type1).lte((0, utils_1.maxValue)(type2)) &&
        (0, utils_1.minValue)(type1).gte((0, utils_1.minValue)(type2)) &&
        (0, utils_1.places)(type1) <= (0, utils_1.places)(type2) &&
        //note: I don't know whether this final bit is actually necessary
        //since we don't actually know yet whether fixedNx0 will be legal
        !((type1.typeClass === "fixed" || type1.typeClass === "ufixed") &&
            (type2.typeClass === "int" || type2.typeClass === "uint")));
}
function isMoreSpecificEnum(type1, type2) {
    //different enum types are incomparable
    return type1.id === type2.id;
}
function isMoreSpecificString(_type1, _type2) {
    //only one string type
    return true;
}
function isMoreSpecificArray(type1, type2, strictBooleans, userDefinedTypes) {
    //static is more specific than dynamic, but
    //different static lengths are incomparable
    const moreSpecificLength = (type1.kind === "dynamic" && type2.kind === "dynamic") ||
        (type1.kind === "static" && type2.kind === "dynamic") ||
        (type1.kind === "static" &&
            type2.kind === "static" &&
            type1.length.eq(type2.length));
    //length and types must both be more specific
    return (moreSpecificLength &&
        isMoreSpecific(type1.baseType, type2.baseType, strictBooleans, userDefinedTypes));
}
function isMoreSpecificFunction(type1, type2, strictBooleans, userDefinedTypes) {
    switch (type2.kind) {
        case "general":
            return true;
        case "specific":
            switch (type1.kind) {
                case "general":
                    return false;
                case "specific":
                    //now: if they're both specific...
                    //(this case doesn't really matter, but let's do it anyway)
                    if (!isMutabilityMoreSpecific(type1.mutability, type2.mutability)) {
                        return false;
                    }
                    if (type1.outputParameterTypes.length !==
                        type2.outputParameterTypes.length) {
                        return false;
                    }
                    for (let i = 0; i < type1.outputParameterTypes.length; i++) {
                        if (!isMoreSpecific(type1.outputParameterTypes[i], type2.outputParameterTypes[i], strictBooleans, userDefinedTypes)) {
                            return false;
                        }
                    }
                    if (type1.inputParameterTypes.length !==
                        type2.inputParameterTypes.length) {
                        return false;
                    }
                    for (let i = 0; i < type1.inputParameterTypes.length; i++) {
                        if (!isMoreSpecific(
                        //swapped for contravariance, I guess...?
                        type2.inputParameterTypes[i], type1.inputParameterTypes[i], strictBooleans, userDefinedTypes)) {
                            return false;
                        }
                    }
                    return true;
            }
    }
}
function isMutabilityMoreSpecific(mutability1, mutability2) {
    //pure <= view <= nonpayable, payable <= nonpayable
    return (mutability1 === mutability2 ||
        (mutability1 === "pure" && mutability2 !== "payable") ||
        mutability2 === "nonpayable");
}
function isMoreSpecificTuple(type1, type2, strictBooleans, userDefinedTypes, ignoreComponentNames = false) {
    debug("type1: %O", type1);
    debug("type2: %O", type2);
    const fullType1 = (Format.Types.fullType(type1, userDefinedTypes));
    const fullType2 = (Format.Types.fullType(type2, userDefinedTypes));
    const types1 = (fullType1.memberTypes).map(member => member.type);
    const types2 = (fullType2.memberTypes).map(member => member.type);
    //lengths must match
    if (types1.length !== types2.length) {
        return false;
    }
    //individual types must satisfy isMoreSpecific
    for (let i = 0; i < types1.length; i++) {
        //note we do *not* pass along the ignoreComponentNames flag
        if (!isMoreSpecific(types1[i], types2[i], strictBooleans, userDefinedTypes)) {
            return false;
        }
    }
    if (!ignoreComponentNames) {
        debug("checking by name");
        //if this flag is not set, *and* the component names match,
        //(and all exist)
        //then compare by component names in addition to by position
        let names1 = (fullType1.memberTypes).map(member => member.name);
        let names2 = (fullType2.memberTypes).map(member => member.name);
        //we just created these via a map so it's OK to sort in-place
        names1.sort();
        names2.sort();
        let namesEqual = true;
        for (let i = 0; i < names1.length; i++) {
            if (!names1[i] || !names2[i] || names1[i] !== names2[i]) {
                namesEqual = false;
                break;
            }
        }
        if (namesEqual) {
            debug("names equal");
            for (let i = 0; i < types1.length; i++) {
                const type1 = types1[i];
                const name = fullType1.memberTypes[i].name;
                const type2 = fullType2.memberTypes.find(({ name: name2 }) => name2 === name).type;
                debug("name: %s", name);
                debug("type1: %O", type1);
                debug("type2: %O", type2);
                if (!isMoreSpecific(type1, type2, strictBooleans, userDefinedTypes)) {
                    debug("returning false");
                    return false;
                }
            }
            debug("name check ok");
        }
    }
    return true;
    //I was going to make structs more specific than their underlying
    //tuples, and different equivalent structs incomparable, but I
    //couldn't find a good way to do that, so whatever, they're all
    //just equivalent, it won't come up
}
function isMoreSpecificOptions(_type1, _type2) {
    //only one options type
    return true;
}
function isMoreSpecificBool(_type1, _type2) {
    //only one boolean type
    return true;
}
function getUnderlyingType(udvtType, userDefinedTypes) {
    return (Format.Types.fullType(udvtType, userDefinedTypes)).underlyingType;
}
//# sourceMappingURL=priority.js.map

/***/ }),

/***/ 24578:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:string");
const dispatch_1 = __webpack_require__(73898);
const errors_1 = __webpack_require__(74595);
const decode_1 = __webpack_require__(59495);
const bytes_1 = __webpack_require__(62083);
const Utils = __importStar(__webpack_require__(33272));
const Messages = __importStar(__webpack_require__(53983));
const stringCasesBasic = [
    stringFromString,
    stringFromBoxedString,
    stringFromCodecStringValue,
    stringFromUint8ArrayLike,
    stringFailureCase
];
exports.stringCases = [stringFromTypeValueInput, ...stringCasesBasic];
function* stringFromString(dataType, input, wrapOptions) {
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    if (!Utils.isValidUtf16(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.invalidUtf16Message);
    }
    return {
        type: dataType,
        kind: "value",
        value: {
            kind: "valid",
            asString: input
        },
        interpretations: {}
    };
}
function* stringFromBoxedString(dataType, input, wrapOptions) {
    if (!Utils.isBoxedString(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a boxed string");
    }
    //defer to primitive string case
    return yield* stringFromString(dataType, input.valueOf(), wrapOptions);
}
function* stringFromCodecStringValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    //rather than dealing with the different kinds in this case
    //for rewrapping, we'll just rewrap directly;
    //yes, this is a bit inconsistent with how we handle this case for other types
    return {
        type: dataType,
        kind: "value",
        value: input.value,
        interpretations: {}
    };
}
function* stringFromUint8ArrayLike(dataType, input, wrapOptions) {
    if (!Utils.isUint8ArrayLike(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a Uint8Array-like");
    }
    //the next series of checks is delegated to a helper fn
    (0, bytes_1.validateUint8ArrayLike)(input, dataType, wrapOptions.name); //(this fn just throws an appropriate error if something's bad)
    const info = (0, decode_1.decodeString)(new Uint8Array(input));
    return {
        type: dataType,
        kind: "value",
        value: info,
        interpretations: {}
    };
}
function* stringFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //extract value & try again, with loose option turned on
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), stringCasesBasic);
}
function* stringFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, Messages.notAStringMessage);
}
//# sourceMappingURL=string.js.map

/***/ }),

/***/ 10076:
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 33272:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.removeUnderscoresHex = exports.removeUnderscoresNoHex = exports.removeUnderscoresNumeric = exports.isValidUtf16 = exports.isBoxedPrimitive = exports.isBoxedBoolean = exports.isBoxedNumber = exports.isBoxedString = exports.isByteStringWithUnderscores = exports.isByteString = exports.isPrefixlessHexString = exports.isHexString = exports.base64Length = exports.isBase64 = exports.isPlainObject = exports.isUint8ArrayLike = exports.isWrappedResult = exports.isFunctionExternalInput = exports.isContractInput = exports.isEncodingTextInput = exports.isTypeValueInput = exports.isSafeNumber = exports.minValue = exports.maxValue = exports.places = void 0;
const big_js_1 = __importDefault(__webpack_require__(13012));
const Conversion = __importStar(__webpack_require__(52714));
const isBoolean_1 = __importDefault(__webpack_require__(51584)); //recognizes boolean *or* Boolean
const isString_1 = __importDefault(__webpack_require__(47037)); //recognizes string *or* String
const isNumber_1 = __importDefault(__webpack_require__(81763)); //recognizes number *or* Number
const utf8_1 = __importDefault(__webpack_require__(57458));
function places(dataType) {
    switch (dataType.typeClass) {
        case "int":
        case "uint":
            return 0;
        case "fixed":
        case "ufixed":
            return dataType.places;
    }
}
exports.places = places;
function maxValue(dataType) {
    let bits = dataType.bits;
    if (dataType.typeClass === "int" || dataType.typeClass === "fixed") {
        bits -= 1; //subtract 1 for signed
    }
    const maxIntegerValue = new big_js_1.default(2).pow(bits).minus(1);
    return Conversion.shiftBigDown(maxIntegerValue, places(dataType));
}
exports.maxValue = maxValue;
function minValue(dataType) {
    if (dataType.typeClass === "uint" || dataType.typeClass === "ufixed") {
        return new big_js_1.default(0);
    }
    const minIntegerValue = new big_js_1.default(0).minus(new big_js_1.default(2).pow(dataType.bits));
    return Conversion.shiftBigDown(minIntegerValue, places(dataType));
}
exports.minValue = minValue;
function isSafeNumber(dataType, input) {
    const scaledUp = input * 10 ** dataType.places;
    return (Number.MIN_SAFE_INTEGER <= scaledUp && scaledUp <= Number.MAX_SAFE_INTEGER);
}
exports.isSafeNumber = isSafeNumber;
function isTypeValueInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.type === "string" &&
        "value" in input &&
        Object.keys(input).length === 2);
}
exports.isTypeValueInput = isTypeValueInput;
function isEncodingTextInput(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.encoding === "string" &&
        typeof input.text === "string" &&
        Object.keys(input).length === 2);
}
exports.isEncodingTextInput = isEncodingTextInput;
function isContractInput(input) {
    return ((typeof input === "object" || typeof input === "function") &&
        input !== null &&
        typeof input.address === "string" &&
        //we *don't* check anything more for addresses, we'll let the
        //address wrapper handle that
        !("selector" in input));
}
exports.isContractInput = isContractInput;
function isFunctionExternalInput(input) {
    return ((typeof input === "object" || typeof input === "function") &&
        input !== null &&
        "address" in input &&
        "selector" in input);
}
exports.isFunctionExternalInput = isFunctionExternalInput;
function isWrappedResult(input) {
    return (typeof input === "object" &&
        input !== null &&
        typeof input.type === "object" &&
        input.type !== null &&
        typeof input.type.typeClass === "string" &&
        ((input.kind === "value" && typeof input.value === "object") ||
            (input.kind === "error" && typeof input.error === "object")));
}
exports.isWrappedResult = isWrappedResult;
function isUint8ArrayLike(input) {
    return (input instanceof Uint8Array ||
        (typeof input === "object" &&
            input !== null &&
            typeof input.length === "number"));
}
exports.isUint8ArrayLike = isUint8ArrayLike;
//hack?
function isPlainObject(input) {
    return typeof input === "object" && input !== null;
}
exports.isPlainObject = isPlainObject;
function isBase64(input) {
    const base64Pattern = /^([A-Za-z0-9+/]{4})*([A-Za-z0-9+/]{2}([A-Za-z0-9+/]|=)=)?$/; //Vim's syntax highlighting is wrong here
    return Boolean(input.match(base64Pattern));
}
exports.isBase64 = isBase64;
function base64Length(base64) {
    const [_, endingEquals] = base64.match(/(=*)$/); //note this match always succeeds
    return (base64.length * 3) / 4 - endingEquals.length;
}
exports.base64Length = base64Length;
function isHexString(input) {
    //(with prefix, to be clear)
    const hexStringPattern = /^0[xX][0-9a-fA-F]*$/;
    return Boolean(input.match(hexStringPattern));
}
exports.isHexString = isHexString;
function isPrefixlessHexString(input) {
    const shortHexStringPattern = /^[0-9a-fA-F]*$/;
    return Boolean(input.match(shortHexStringPattern));
}
exports.isPrefixlessHexString = isPrefixlessHexString;
function isByteString(input) {
    const byteStringPattern = /^0[xX]([0-9a-fA-F]{2})*$/;
    return Boolean(input.match(byteStringPattern));
}
exports.isByteString = isByteString;
function isByteStringWithUnderscores(input) {
    const byteStringWithUnderscoresPattern = /^0[xX](([0-9a-fA-F]{2}_?)*([0-9a-fA-F]{2}))?$/;
    return Boolean(input.match(byteStringWithUnderscoresPattern));
}
exports.isByteStringWithUnderscores = isByteStringWithUnderscores;
function isBoxedString(input) {
    //unfortunately, isString has been typed incorrectly.
    //it should return `input is string|String`, but instead it
    //incorrectly returns `input is string`.  As such, we have
    //to work around its incorrect typing here.
    return (0, isString_1.default)(input) && typeof input !== "string";
}
exports.isBoxedString = isBoxedString;
function isBoxedNumber(input) {
    //see comment on isBoxedString
    return (0, isNumber_1.default)(input) && typeof input !== "number";
}
exports.isBoxedNumber = isBoxedNumber;
function isBoxedBoolean(input) {
    //see comment on isBoxedString
    return (0, isBoolean_1.default)(input) && typeof input !== "boolean";
}
exports.isBoxedBoolean = isBoxedBoolean;
function isBoxedPrimitive(input) {
    return isBoxedString(input) || isBoxedNumber(input) || isBoxedBoolean(input);
}
exports.isBoxedPrimitive = isBoxedPrimitive;
function isValidUtf16(input) {
    try {
        utf8_1.default.encode(input); //encode but discard :P
        return true;
    }
    catch (_a) {
        return false;
    }
}
exports.isValidUtf16 = isValidUtf16;
function removeUnderscoresNumeric(numeric) {
    //if it contains 0x or 0X, treat as hex;
    //otherwise, treat as non-hex (decimal/octal/binary)
    return numeric.match(/0x/i)
        ? removeUnderscoresHex(numeric)
        : removeUnderscoresNoHex(numeric);
}
exports.removeUnderscoresNumeric = removeUnderscoresNumeric;
function removeUnderscoresNoHex(numeric) {
    //this would be easy with lookbehind assertions, but those aren't safe to use
    //in all browsers, so, we're going to have to do things a bit more
    //manually...
    return removeUnderscoresWithRegex(numeric, /\d_\d/);
}
exports.removeUnderscoresNoHex = removeUnderscoresNoHex;
function removeUnderscoresHex(hex) {
    //same comment
    return removeUnderscoresWithRegex(hex, /[\da-f]_[\da-f]/i);
}
exports.removeUnderscoresHex = removeUnderscoresHex;
//note: regex should be of the form <A>_<A>, where <A> is a regex that matches
//precisely one character!  this will not work otherwise!
function removeUnderscoresWithRegex(input, regex) {
    let match;
    while ((match = input.match(regex))) {
        //replace input by the same thing but w/ the underscore removed,
        //by taking the text before and after the underscore
        input = input.slice(0, match.index + 1) + input.slice(match.index + 2);
    }
    return input;
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 18400:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.wrap = exports.udvtCases = exports.txOptionsCases = exports.tupleCases = exports.arrayCases = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("codec:wrap:wrap");
const Format = __importStar(__webpack_require__(29965));
const errors_1 = __webpack_require__(74595);
const dispatch_1 = __webpack_require__(73898);
const Messages = __importStar(__webpack_require__(53983));
const Conversion = __importStar(__webpack_require__(52714));
const Utils = __importStar(__webpack_require__(33272));
const integer_1 = __webpack_require__(47779);
const decimal_1 = __webpack_require__(36902);
const bool_1 = __webpack_require__(56291);
const bytes_1 = __webpack_require__(62083);
const address_1 = __webpack_require__(8871);
const string_1 = __webpack_require__(24578);
const function_1 = __webpack_require__(52181);
//this file contains the main wrap function, as well as the cases
//for arrays, tuples, udvts, and tx options.  all other types get their
//own file.
const arrayCasesBasic = [
    arrayFromArray,
    arrayFromCodecArrayValue,
    arrayFromJson,
    arrayFailureCase
];
exports.arrayCases = [arrayFromTypeValueInput, ...arrayCasesBasic];
const tupleCasesBasic = [
    tupleFromArray,
    tupleFromCodecTupleLikeValue,
    tupleFromObject,
    tupleFromJson,
    tupleFailureCase
];
exports.tupleCases = [
    tupleFromTypeValueInput,
    ...tupleCasesBasic
];
const txOptionsCasesBasic = [optionsFromCodecOptionsValue, optionsFromObject, optionsFailureCase];
exports.txOptionsCases = [optionsFromTypeValueInput, ...txOptionsCasesBasic];
exports.udvtCases = [
    //no separate case for udvtFromUdvtValue,
    //since underlying already handles this
    udvtFromUnderlying
];
function* wrap(dataType, input, wrapOptions) {
    if (!wrapOptions.name) {
        wrapOptions = Object.assign(Object.assign({}, wrapOptions), { name: "<input>" });
    }
    switch (dataType.typeClass) {
        case "uint":
        case "int":
        case "enum":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, integer_1.integerCases);
        case "fixed":
        case "ufixed":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, decimal_1.decimalCases);
        case "bool":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bool_1.boolCases);
        case "bytes":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, bytes_1.bytesCases);
        case "address":
        case "contract":
            //these are treated the same
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, address_1.addressCases);
        case "string":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, string_1.stringCases);
        case "function":
            //special check: weed out internal functions
            if (dataType.visibility === "internal") {
                throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity
                `Wrapping/encoding for internal function pointers is not supported`);
            }
            //otherwise, go ahead
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, function_1.functionExternalCases);
        case "array":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.arrayCases);
        case "struct":
        case "tuple":
            //these are treated the same as well
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.tupleCases);
        case "userDefinedValueType":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.udvtCases);
        case "options":
            return yield* (0, dispatch_1.wrapWithCases)(dataType, input, wrapOptions, exports.txOptionsCases);
        default:
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, //it doesn't matter, but we'll make this error high specificity
            `Wrapping/encoding for type ${Format.Types.typeStringWithoutLocation(dataType)} is not supported`);
    }
}
exports.wrap = wrap;
//array cases
function* arrayFromArray(dataType, input, wrapOptions) {
    if (!Array.isArray(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an array");
    }
    if (dataType.kind === "static" && !dataType.length.eqn(input.length)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(dataType.length, input.length));
    }
    //can't do yield in a map, so manual loop here
    let value = [];
    for (let index = 0; index < input.length; index++) {
        value.push(yield* wrap(dataType.baseType, input[index], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}[${index}]`, specificityFloor: 5 //errors in components are quite specific!
         })));
    }
    return {
        type: dataType,
        kind: "value",
        value,
        interpretations: {}
    };
}
function* arrayFromCodecArrayValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "array") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    //we won't bother with detailed typechecking as much of it is handled
    //either in the call to arrayFromArray or in the wrapping of the
    //individual elements; we will check dynamic vs static though as that
    //isn't handled elsewhere
    if (!wrapOptions.loose && input.type.kind === dataType.kind) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    //note that we do *not* just copy over input.value, but rather we
    //defer to arrayFromArray; this is because there might be some elements
    //where the type is not the same but is compatible
    const value = input.value;
    return yield* arrayFromArray(dataType, value, wrapOptions);
}
function* arrayFromJson(dataType, input, wrapOptions) {
    if (!wrapOptions.allowJson) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "JSON input must be explicitly enabled");
    }
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    let parsedInput;
    try {
        parsedInput = JSON.parse(input);
    }
    catch (error) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);
    }
    return yield* arrayFromArray(dataType, parsedInput, wrapOptions);
}
function* arrayFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "array") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //don't turn on loose here, only do that for non-container types!
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, arrayCasesBasic);
}
function* arrayFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not an array, type/value pair or wrapped array");
}
//tuple/struct cases;
//note even with loose turned off, we won't distinguish
//between tuples and structs
function* tupleFromArray(dataType, input, wrapOptions) {
    //first: obtain the types of the members
    if (!Array.isArray(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not an array");
    }
    debug("input is array");
    const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);
    if (memberTypes.length !== input.length) {
        debug("input is wrong-length array");
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrongArrayLengthMessage(memberTypes.length, input.length));
    }
    //can't do yield in a map, so manual loop here
    let value = [];
    for (let index = 0; index < input.length; index++) {
        const memberName = memberTypes[index].name;
        debug("wrapping %s", memberName);
        value.push({
            name: memberName,
            value: yield* wrap(memberTypes[index].type, input[index], Object.assign(Object.assign({}, wrapOptions), { name: memberName
                    ? wrapOptions.name.match(/^<.*>$/) //hack?
                        ? memberName
                        : `${wrapOptions.name}.${memberName}`
                    : `${wrapOptions.name}[${index}]`, specificityFloor: 5 }))
        });
    }
    //we need to coerce here because TS doesn't know that if it's a struct
    //then everything has a name
    return {
        type: dataType,
        kind: "value",
        value,
        interpretations: {}
    };
}
function* tupleFromObject(dataType, input, wrapOptions) {
    if (!Utils.isPlainObject(input)) {
        //just checks that it's an object & not null
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a non-null object");
    }
    if (!wrapOptions.loose && Utils.isTypeValueInput(input)) {
        //let's exclude these unless loose is turned on
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a type/value pair");
    }
    if (!wrapOptions.loose && Utils.isWrappedResult(input)) {
        //similarly here
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a wrapped result");
    }
    const memberTypes = memberTypesForType(dataType, wrapOptions.userDefinedTypes);
    if (memberTypes.some(({ name }) => !name)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, "Plain object input is allowed only when all elements of tuple are named");
    }
    let unusedKeys = new Set(Object.keys(input));
    let value = [];
    for (let index = 0; index < memberTypes.length; index++) {
        //note we had better process these in order!
        const memberName = memberTypes[index].name;
        if (!(memberName in input)) {
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Missing key from tuple or struct: ${memberName}`);
        }
        unusedKeys.delete(memberName);
        value.push({
            name: memberName,
            value: yield* wrap(memberTypes[index].type, input[memberName], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${memberName}`, specificityFloor: 4 //not sure this warrants a 5
             }))
        });
    }
    if (!wrapOptions.loose) {
        if (unusedKeys.size > 0) {
            //choose one arbitrarily
            const exampleKey = unusedKeys.values().next().value;
            throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Unknown key ${exampleKey} included`);
        }
    }
    //we need to coerce here because TS doesn't know that if it's a struct
    //then everything has a name
    return {
        type: dataType,
        kind: "value",
        value
    };
}
function* tupleFromJson(dataType, input, wrapOptions) {
    if (!wrapOptions.allowJson) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "JSON input must be explicitly enabled");
    }
    if (typeof input !== "string") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a string");
    }
    let parsedInput;
    try {
        parsedInput = JSON.parse(input);
    }
    catch (error) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, `Input was not valid JSON: ${error.message}`);
    }
    debug("input is JSON");
    debug("parses to: %O", parsedInput);
    return yield* (0, dispatch_1.wrapWithCases)(dataType, parsedInput, wrapOptions, [
        tupleFromObject,
        tupleFromArray
    ]);
}
function* tupleFromCodecTupleLikeValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "tuple" && input.type.typeClass !== "struct") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    //not going to do much typechecking here as it'll be handled in the call
    //to tupleFromArray
    //Typescript complains if I try to say it can be either struct or
    //tuple, so, uh, let's just tell it it's a tuple <shrug>
    const coercedInput = input; //HACK!
    //note that we do *not* just copy over input.value, but rather we
    //defer to tupleFromArray; this is because there might be some elements
    //where the type is not the same but is compatible
    return yield* tupleFromArray(dataType, coercedInput.value.map(({ value }) => value), wrapOptions);
}
function* tupleFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "tuple" && input.type !== "struct") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //don't turn on loose here, only do that for non-container types!
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, wrapOptions, tupleCasesBasic);
}
function* tupleFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Input was not an array, plain object, type/value pair or wrapped tuple or struct");
}
function memberTypesForType(dataType, userDefinedTypes) {
    switch (dataType.typeClass) {
        case "tuple":
            return dataType.memberTypes;
            break;
        case "struct":
            debug("wrapping for struct %s", dataType.typeName);
            return (Format.Types.fullType(dataType, userDefinedTypes)).memberTypes;
    }
}
//udvt cases
function* udvtFromUnderlying(dataType, input, wrapOptions) {
    const { underlyingType } = (Format.Types.fullType(dataType, wrapOptions.userDefinedTypes));
    const value = yield* wrap(underlyingType, input, wrapOptions);
    return {
        type: dataType,
        kind: "value",
        value: value,
        interpretations: {}
    };
}
//tx options cases
function* optionsFromObject(dataType, input, wrapOptions) {
    if (!Utils.isPlainObject(input)) {
        //just checks that it's an object & not null
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a non-null object");
    }
    debug("options input is object: %O", input);
    debug("wrapOptions: %O", wrapOptions);
    if (!wrapOptions.loose && Utils.isWrappedResult(input)) {
        //similarly here
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was a wrapped result");
    }
    //now... the main case
    let value = {};
    const uintKeys = [
        "gas",
        "gasPrice",
        "value",
        "nonce",
        "maxFeePerGas",
        "maxPriorityFeePerGas"
    ];
    const uint8Keys = ["type"];
    const addressKeys = ["from", "to"];
    const bytesKeys = ["data"];
    const boolKeys = ["overwrite"];
    const accessListKeys = ["accessList"];
    const specialKeys = ["privateFor"];
    const allKeys = [
        ...uintKeys,
        ...uint8Keys,
        ...addressKeys,
        ...bytesKeys,
        ...boolKeys,
        ...accessListKeys,
        ...specialKeys
    ];
    const badKey = Object.keys(input).find(key => !allKeys.includes(key));
    const goodKey = Object.keys(input).find(key => allKeys.includes(key));
    if (badKey !== undefined && !wrapOptions.oldOptionsBehavior) {
        //note we allow extra keys if oldOptionsBehavior is on -- this is a HACK
        //to preserve existing behavior of Truffle Contract (perhaps we can
        //change this in Truffle 6)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included unknown option ${badKey}`);
    }
    if (wrapOptions.oldOptionsBehavior && goodKey === undefined) {
        //similarly, if oldOptionsBehavior is on, we require at least
        //one *legit* key (again, HACK to preserve existing behavior,
        //maybe remove this in Truffle 6)
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 4, `Transaction options included no recognized options`);
    }
    //otherwise, if all keys are transaction options, let's process them...
    //part 1: uint options
    for (const key of uintKeys) {
        //note we check input[key] !== undefined, rather than key in input,
        //because if one of them is undefined we want to just allow that but ignore it
        if (input[key] !== undefined) {
            const wrappedOption = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: "uint", bits: 256 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), integer_1.integerCases));
            value[key] = wrappedOption.value.asBN;
        }
    }
    //part 2: uint8 options (just type for now)
    for (const key of uint8Keys) {
        if (input[key] !== undefined) {
            const wrappedOption = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: "uint", bits: 8 }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), integer_1.integerCases));
            const asBN = wrappedOption.value.asBN;
            //since this is just type right now, we're going to reject illegal types
            if (asBN.gten(0xc0)) {
                //not making a constant for this, this is its only use here
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.type`, 4, "Transaction types must be less than 0xc0");
            }
            //for compatibility, we give type as a hex string rather than
            //leaving it as a BN.  Since it's unsigned we don't have to
            //worry about negatives.
            value[key] = Conversion.toHexString(asBN);
        }
    }
    //part 3: address options
    for (const key of addressKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = (yield* (0, dispatch_1.wrapWithCases)({ typeClass: "address", kind: "general" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), address_1.addressCases));
            value[key] = wrappedOption.value.asAddress;
        }
    }
    //part 4: bytestring options
    for (const key of bytesKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({ typeClass: "bytes", kind: "dynamic" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), bytes_1.bytesCases);
            value[key] = wrappedOption.value.asHex;
        }
    }
    //part 5: boolean options
    for (const key of boolKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({ typeClass: "bool" }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), bool_1.boolCases);
            value[key] = wrappedOption.value.asBoolean;
        }
    }
    //part 6: the access list
    for (const key of accessListKeys) {
        if (input[key] !== undefined) {
            const wrappedOption = yield* (0, dispatch_1.wrapWithCases)({
                typeClass: "array",
                kind: "dynamic",
                baseType: {
                    typeClass: "tuple",
                    memberTypes: [
                        {
                            name: "address",
                            type: {
                                typeClass: "address",
                                kind: "general"
                            }
                        },
                        {
                            name: "storageKeys",
                            type: {
                                typeClass: "array",
                                kind: "dynamic",
                                baseType: {
                                    //we use uint256 rather than bytes32 to allow
                                    //abbreviating and left-padding
                                    typeClass: "uint",
                                    bits: 256
                                }
                            }
                        }
                    ]
                }
            }, input[key], Object.assign(Object.assign({}, wrapOptions), { name: `${wrapOptions.name}.${key}` }), exports.arrayCases);
            value[key] = Format.Utils.Inspect.nativizeAccessList(wrappedOption);
        }
    }
    //part 7: the special case of privateFor
    if (input.privateFor !== undefined) {
        //this doesn't correspond to any of our usual types, so we have to handle it specially
        if (!Array.isArray(input.privateFor)) {
            throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, "Transaction option privateFor should be an array of base64-encoded bytestrings of 32 bytes");
        }
        value.privateFor = input.privateFor.map((publicKey, index) => {
            if (Utils.isBoxedString(publicKey)) {
                publicKey = publicKey.valueOf();
            }
            if (typeof publicKey !== "string") {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not a string`);
            }
            if (!Utils.isBase64(publicKey)) {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} is not base64-encoded`);
            }
            const length = Utils.base64Length(publicKey);
            if (length !== 32) {
                throw new errors_1.TypeMismatchError(dataType, input, `${wrapOptions.name}.privateFor`, 4, `Public key at index ${index} should encode a bytestring of 32 bytes; got ${length} bytes instead`);
            }
            return publicKey;
        });
    }
    return {
        type: dataType,
        kind: "value",
        value,
        interpretations: {}
    };
}
function* optionsFromCodecOptionsValue(dataType, input, wrapOptions) {
    if (!Utils.isWrappedResult(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a wrapped result");
    }
    if (input.type.typeClass !== "options") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.wrappedTypeMessage(input.type));
    }
    if (input.kind !== "value") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.errorResultMessage);
    }
    const value = input.value;
    //unlike in the array or tuple cases, here should not have
    //to worry about compatible-but-not-identical types, so it's
    //safe to just copy value over
    return {
        type: dataType,
        kind: "value",
        value,
        interpretations: {}
    };
}
function* optionsFromTypeValueInput(dataType, input, wrapOptions) {
    if (!Utils.isTypeValueInput(input)) {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 1, "Input was not a type/value pair");
    }
    if (input.type !== "options") {
        throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 5, Messages.specifiedTypeMessage(input.type));
    }
    //because options, unlike other containers, has specific types, we *will* turn on loose
    return yield* (0, dispatch_1.wrapWithCases)(dataType, input.value, Object.assign(Object.assign({}, wrapOptions), { loose: true }), txOptionsCasesBasic);
}
function* optionsFailureCase(dataType, input, wrapOptions) {
    throw new errors_1.TypeMismatchError(dataType, input, wrapOptions.name, 2, "Transaction options input was not a plain object, type/value pair or wrapped options object");
}
//# sourceMappingURL=wrap.js.map

/***/ })

};
;
//# sourceMappingURL=102.bundled.js.map