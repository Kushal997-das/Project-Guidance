#!/usr/bin/env node

exports.id = 8852;
exports.ids = [8852];
exports.modules = {

/***/ 8135:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseCode = void 0;
const opcodes_1 = __webpack_require__(89537);
const cbor = __importStar(__webpack_require__(82141));
/**
 * parseCode - return a list of instructions given a 0x-prefixed code string.
 *
 * The optional second options argument allows two options; both are ways of
 * attempting to limit the disassembly to only the code section rather than the
 * data section.  If maxInstructionCount is used, the disassembly will be limited
 * to the specified number of instructions (one may pass in here the number of
 * instructions in the corresponding source map).
 *
 * If attemptStripMetadata is used, we will attempt to strip the metadata at the
 * end of the code.  This is not reliable, and should be avoided if better
 * alternatives are available.  It may be particularly unreliable when dealing with
 * constructors that have had arguments attached to the end!
 *
 * These options can be combined, although I'm not sure why you'd want to.
 *
 * @param  {String} hexString Hex string representing the code
 * @return Array               Array of instructions
 */
function parseCode(hexString, { maxInstructionCount, attemptStripMetadata } = {}) {
    // Convert to an array of bytes
    let code = new Uint8Array((hexString.slice(2).match(/(..?)/g) || []).map(hex => parseInt(hex, 16)));
    if (attemptStripMetadata && code.length >= 2) {
        // Remove the contract metadata; last two bytes encode its length (not
        // including those two bytes)
        let foundMetadata = false;
        const metadataLength = (code[code.length - 2] << 8) + code[code.length - 1];
        //check: is this actually valid CBOR?
        if (metadataLength + 2 <= code.length) {
            const metadata = code.subarray(-(metadataLength + 2), -2);
            if (isValidCBOR(metadata)) {
                code = code.subarray(0, -(metadataLength + 2));
                foundMetadata = true;
            }
        }
        if (!foundMetadata) {
            const vyper034MetadataLength = 11; //vyper 0.3.4 (that version specifically;
            //this will be corrected in 0.3.5, and earlier vyper versions do not include
            //metadata) has metadata on the end but with no length information supplied
            //afterward; instead it has a fixed length of 11
            if (vyper034MetadataLength <= code.length) {
                const metadata = code.subarray(-vyper034MetadataLength);
                if (isValidCBOR(metadata)) {
                    code = code.subarray(0, -vyper034MetadataLength);
                }
            }
        }
    }
    let instructions = [];
    if (maxInstructionCount === undefined) {
        //if maxInstructionCount wasn't passed, we'll set it to
        //Infinity so that we don't limit the number of instructions
        maxInstructionCount = Infinity;
    }
    for (let pc = 0; pc < code.length && instructions.length < maxInstructionCount; pc++) {
        let opcode = {
            pc,
            name: (0, opcodes_1.parseOpcode)(code[pc])
        };
        if (opcode.name.slice(0, 4) === "PUSH") {
            const length = code[pc] - 0x5f; //0x5f is code for PUSH0
            let pushData = code.subarray(pc + 1, pc + length + 1);
            if (pushData.length < length) {
                //if we run out of bytes for our pushdata, fill the rest
                //with zeroes
                pushData = Uint8Array.from([
                    ...pushData,
                    ...new Uint8Array(length - pushData.length)
                ]);
            }
            // convert pushData to hex
            opcode.pushData = `0x${Buffer.from(pushData).toString("hex")}`;
            pc += length;
        }
        instructions.push(opcode);
    }
    return instructions;
}
exports.parseCode = parseCode;
function isValidCBOR(metadata) {
    try {
        //attempt to decode but discard the value
        //note this *will* throw if there's data left over,
        //which is what we want it to do
        //HACK: this version of cbor doesn't accept Uint8Arrays,
        //but it does accept Buffers.  (Unfortunately newer versions
        //cause problems. :-/ )
        cbor.decodeFirstSync(Buffer.from(metadata));
    }
    catch (_a) {
        return false;
    }
    return true;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 89537:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseOpcode = void 0;
const codes = {
    0x00: "STOP",
    0x01: "ADD",
    0x02: "MUL",
    0x03: "SUB",
    0x04: "DIV",
    0x05: "SDIV",
    0x06: "MOD",
    0x07: "SMOD",
    0x08: "ADDMOD",
    0x09: "MULMOD",
    0x0a: "EXP",
    0x0b: "SIGNEXTEND",
    // 0x10 range - bit ops
    0x10: "LT",
    0x11: "GT",
    0x12: "SLT",
    0x13: "SGT",
    0x14: "EQ",
    0x15: "ISZERO",
    0x16: "AND",
    0x17: "OR",
    0x18: "XOR",
    0x19: "NOT",
    0x1a: "BYTE",
    0x1b: "SHL",
    0x1c: "SHR",
    0x1d: "SAR",
    // 0x20 range - crypto
    0x20: "SHA3",
    // 0x30 range - closure state
    0x30: "ADDRESS",
    0x31: "BALANCE",
    0x32: "ORIGIN",
    0x33: "CALLER",
    0x34: "CALLVALUE",
    0x35: "CALLDATALOAD",
    0x36: "CALLDATASIZE",
    0x37: "CALLDATACOPY",
    0x38: "CODESIZE",
    0x39: "CODECOPY",
    0x3a: "GASPRICE",
    0x3b: "EXTCODESIZE",
    0x3c: "EXTCODECOPY",
    0x3d: "RETURNDATASIZE",
    0x3e: "RETURNDATACOPY",
    0x3f: "EXTCODEHASH",
    // 0x40 range - block operations
    0x40: "BLOCKHASH",
    0x41: "COINBASE",
    0x42: "TIMESTAMP",
    0x43: "NUMBER",
    0x44: "PREVRANDAO|DIFFICULTY",
    0x45: "GASLIMIT",
    0x46: "CHAINID",
    0x47: "SELFBALANCE",
    0x48: "BASEFEE",
    // 0x50 range - 'storage' and execution
    0x50: "POP",
    0x51: "MLOAD",
    0x52: "MSTORE",
    0x53: "MSTORE8",
    0x54: "SLOAD",
    0x55: "SSTORE",
    0x56: "JUMP",
    0x57: "JUMPI",
    0x58: "PC",
    0x59: "MSIZE",
    0x5a: "GAS",
    0x5b: "JUMPDEST",
    // 0x60 & 0x70 range - pushes
    0x5f: "PUSH0",
    0x60: "PUSH1",
    0x61: "PUSH2",
    0x62: "PUSH3",
    0x63: "PUSH4",
    0x64: "PUSH5",
    0x65: "PUSH6",
    0x66: "PUSH7",
    0x67: "PUSH8",
    0x68: "PUSH9",
    0x69: "PUSH10",
    0x6a: "PUSH11",
    0x6b: "PUSH12",
    0x6c: "PUSH13",
    0x6d: "PUSH14",
    0x6e: "PUSH15",
    0x6f: "PUSH16",
    0x70: "PUSH17",
    0x71: "PUSH18",
    0x72: "PUSH19",
    0x73: "PUSH20",
    0x74: "PUSH21",
    0x75: "PUSH22",
    0x76: "PUSH23",
    0x77: "PUSH24",
    0x78: "PUSH25",
    0x79: "PUSH26",
    0x7a: "PUSH27",
    0x7b: "PUSH28",
    0x7c: "PUSH29",
    0x7d: "PUSH30",
    0x7e: "PUSH31",
    0x7f: "PUSH32",
    // 0x80 range - duplication
    0x80: "DUP1",
    0x81: "DUP2",
    0x82: "DUP3",
    0x83: "DUP4",
    0x84: "DUP5",
    0x85: "DUP6",
    0x86: "DUP7",
    0x87: "DUP8",
    0x88: "DUP9",
    0x89: "DUP10",
    0x8a: "DUP11",
    0x8b: "DUP12",
    0x8c: "DUP13",
    0x8d: "DUP14",
    0x8e: "DUP15",
    0x8f: "DUP16",
    // 0x90 range - swaps
    0x90: "SWAP1",
    0x91: "SWAP2",
    0x92: "SWAP3",
    0x93: "SWAP4",
    0x94: "SWAP5",
    0x95: "SWAP6",
    0x96: "SWAP7",
    0x97: "SWAP8",
    0x98: "SWAP9",
    0x99: "SWAP10",
    0x9a: "SWAP11",
    0x9b: "SWAP12",
    0x9c: "SWAP13",
    0x9d: "SWAP14",
    0x9e: "SWAP15",
    0x9f: "SWAP16",
    // '0xa0' range - logging
    0xa0: "LOG0",
    0xa1: "LOG1",
    0xa2: "LOG2",
    0xa3: "LOG3",
    0xa4: "LOG4",
    // '0xf0' range - closures
    0xf0: "CREATE",
    0xf1: "CALL",
    0xf2: "CALLCODE",
    0xf3: "RETURN",
    0xf4: "DELEGATECALL",
    0xf5: "CREATE2",
    0xfa: "STATICCALL",
    0xfd: "REVERT",
    0xfe: "INVALID",
    0xff: "SELFDESTRUCT"
};
const parseOpcode = (op) => op in codes ? codes[op] : "INVALID";
exports.parseOpcode = parseOpcode;
//# sourceMappingURL=opcodes.js.map

/***/ }),

/***/ 95532:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractInstanceDecoder = exports.ContractDecoder = exports.ProjectDecoder = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("decoder:decoders");
const Abi = __importStar(__webpack_require__(7651));
const Codec = __importStar(__webpack_require__(20102));
const codec_1 = __webpack_require__(20102);
const Encoder = __importStar(__webpack_require__(15967));
const encoder_1 = __webpack_require__(15967);
const web3_utils_1 = __importDefault(__webpack_require__(18269));
const bn_js_1 = __importDefault(__webpack_require__(13550));
const errors_1 = __webpack_require__(13552);
const fetch_signatures_1 = __webpack_require__(72794);
const compile_common_1 = __webpack_require__(29833);
//sorry for untyped imports!
const SourceMapUtils = __webpack_require__(32731);
const { default: ENS, getEnsAddress } = __webpack_require__(26143);
const defaultSelectorDirectory = "https://www.4byte.directory/api";
/**
 * The ProjectDecoder class.  Decodes transactions and logs.  See below for a method listing.
 * @category Decoder
 */
class ProjectDecoder {
    /**
     * @protected
     */
    constructor(compilations, provider, ensSettings, selectorDirectory) {
        var _a;
        this.contexts = {}; //all contexts
        this.deployedContexts = {};
        this.contractsAndContexts = [];
        this.codeCache = {};
        this.ensCache = {};
        this.addProjectInfoNonce = 0;
        if (!provider) {
            throw new errors_1.NoProviderError();
        }
        //check for repeat compilation IDs
        const repeatIds = Codec.Compilations.Utils.findRepeatCompilationIds(compilations);
        if (repeatIds.size !== 0) {
            throw new Codec.RepeatCompilationIdError([...repeatIds]);
        }
        this.providerAdapter = new encoder_1.ProviderAdapter(provider);
        this.compilations = compilations;
        this.ensSettings = {
            provider: (ensSettings === null || ensSettings === void 0 ? void 0 : ensSettings.provider) !== undefined ? ensSettings === null || ensSettings === void 0 ? void 0 : ensSettings.provider : provider,
            registryAddress: ensSettings === null || ensSettings === void 0 ? void 0 : ensSettings.registryAddress
        }; //we don't use an object spread because we want undefined to be ignored
        this.selectorDirectory = (selectorDirectory === null || selectorDirectory === void 0 ? void 0 : selectorDirectory.enabled)
            ? (_a = selectorDirectory.url) !== null && _a !== void 0 ? _a : defaultSelectorDirectory
            : null;
        let allocationInfo;
        ({
            definitions: this.referenceDeclarations,
            typesByCompilation: this.userDefinedTypesByCompilation,
            types: this.userDefinedTypes
        } = codec_1.Compilations.Utils.collectUserDefinedTypesAndTaggedOutputs(this.compilations));
        ({
            contexts: this.contexts,
            deployedContexts: this.deployedContexts,
            contractsAndContexts: this.contractsAndContexts,
            allocationInfo
        } = codec_1.AbiData.Allocate.Utils.collectAllocationInfo(this.compilations));
        this.allocations = {};
        this.allocations.abi = codec_1.AbiData.Allocate.getAbiAllocations(this.userDefinedTypes);
        this.allocations.storage = codec_1.Storage.Allocate.getStorageAllocations(this.userDefinedTypesByCompilation); //not used by project decoder itself, but used by contract decoder
        this.allocations.calldata = codec_1.AbiData.Allocate.getCalldataAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        this.allocations.returndata = codec_1.AbiData.Allocate.getReturndataAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        this.allocations.event = codec_1.AbiData.Allocate.getEventAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        this.allocations.state = codec_1.Storage.Allocate.getStateAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.storage);
        debug("done with allocation");
    }
    /**
     * @protected
     * WARNING: this code is copypasted (w/slight modifications) from encoder!!
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            debug("initting!");
            const { provider, registryAddress } = this.ensSettings;
            if (provider) {
                debug("provider given!");
                if (registryAddress !== undefined) {
                    this.ens = new ENS({
                        provider,
                        ensAddress: registryAddress
                    });
                }
                else {
                    //if we weren't given a registry address, we use the default one,
                    //but what is that?  We have to look it up.
                    //NOTE: ENS is supposed to do this for us in the constructor,
                    //but due to a bug it doesn't.
                    debug("using default registry address");
                    const networkId = yield new encoder_1.ProviderAdapter(provider).getNetworkId();
                    const registryAddress = getEnsAddress(networkId);
                    if (registryAddress) {
                        this.ens = new ENS({
                            provider: provider,
                            ensAddress: registryAddress
                        });
                    }
                    else {
                        //there is no default registry on this chain
                        this.ens = null;
                    }
                }
            }
            else {
                debug("no provider given, ens off");
                this.ens = null;
            }
        });
    }
    /**
     * **This function is asynchronous.**
     *
     * Adds compilations to the decoder after it has started.  Note it is
     * only presently possible to do this with a `ProjectDecoder` and not
     * with the other decoder classes.
     *
     * @param compilations The compilations to be added.  Take care that these
     * have IDs distinct from those the decoder already has.
     */
    addCompilations(compilations) {
        return __awaiter(this, void 0, void 0, function* () {
            //first: make sure we're not adding a compilation with an existing ID
            const existingIds = new Set(this.compilations.map(compilation => compilation.id));
            const newIds = new Set(compilations.map(compilation => compilation.id));
            //we use a find() rather than a some() so that we can put the ID in the error
            const overlappingIds = [...newIds].filter(id => existingIds.has(id));
            if (overlappingIds.length !== 0) {
                throw new Codec.RepeatCompilationIdError(overlappingIds);
            }
            //also: check for repeats among the ones we're adding
            const repeatIds = Codec.Compilations.Utils.findRepeatCompilationIds(compilations);
            if (repeatIds.size !== 0) {
                throw new Codec.RepeatCompilationIdError([...repeatIds]);
            }
            //now: checks are over, start adding stuff
            this.compilations = [...this.compilations, ...compilations];
            const { definitions: referenceDeclarations, typesByCompilation: userDefinedTypesByCompilation, types: userDefinedTypes } = codec_1.Compilations.Utils.collectUserDefinedTypesAndTaggedOutputs(compilations);
            Object.assign(this.referenceDeclarations, referenceDeclarations);
            Object.assign(this.userDefinedTypesByCompilation, userDefinedTypesByCompilation);
            Object.assign(this.userDefinedTypes, userDefinedTypes);
            const { contexts, deployedContexts, contractsAndContexts, allocationInfo } = codec_1.AbiData.Allocate.Utils.collectAllocationInfo(compilations);
            this.contexts = Object.assign(contexts, this.contexts); //HACK: we want to
            //prioritize new contexts over old contexts, so we do this.  a proper timestamp
            //system would be better, but this should hopefully do for now.
            Object.assign(this.deployedContexts, deployedContexts);
            this.contractsAndContexts = [
                ...this.contractsAndContexts,
                ...contractsAndContexts
            ];
            //everything up till now has been pretty straightforward merges.
            //but allocations are a bit more complicated.
            //some of them can be merged straightforwardly, some can't.
            //we'll start with the straightforward ones.
            const abiAllocations = codec_1.AbiData.Allocate.getAbiAllocations(userDefinedTypes);
            Object.assign(this.allocations.abi, abiAllocations);
            const storageAllocations = codec_1.Storage.Allocate.getStorageAllocations(userDefinedTypesByCompilation);
            Object.assign(this.allocations.storage, storageAllocations);
            const stateAllocations = codec_1.Storage.Allocate.getStateAllocations(allocationInfo, referenceDeclarations, userDefinedTypes, storageAllocations //only need the ones from the new compilations
            );
            Object.assign(this.allocations.state, stateAllocations);
            //now we have calldata allocations.  merging these is still mostly straightforward,
            //but slightly less so.
            const calldataAllocations = codec_1.AbiData.Allocate.getCalldataAllocations(allocationInfo, referenceDeclarations, userDefinedTypes, abiAllocations //only need the ones from the new compilations
            );
            //merge constructor and function allocations separately
            Object.assign(this.allocations.calldata.constructorAllocations, calldataAllocations.constructorAllocations);
            Object.assign(this.allocations.calldata.functionAllocations, calldataAllocations.functionAllocations);
            //finally, redo the allocations for returndata and eventdata.
            //attempting to perform a merge on these is too complicated, so we
            //won't try; we'll just recompute.
            this.allocations.returndata = codec_1.AbiData.Allocate.getReturndataAllocations(allocationInfo, referenceDeclarations, userDefinedTypes, this.allocations.abi //we're doing this for merged result, so use merged input!
            );
            this.allocations.event = codec_1.AbiData.Allocate.getEventAllocations(allocationInfo, referenceDeclarations, userDefinedTypes, this.allocations.abi //we're doing this for merged result, so use merged input!
            );
        });
    }
    /**
     * **This function is asynchronous.**
     *
     * Adds additional compilations to the decoder like [[addCompilations]],
     * but allows it to be specified in more general forms.
     *
     * @param projectInfo Information about the additional compilations or
     * contracts to be decoded.  This may come in several forms; see the type
     * documentation for more information.  If passing in `{ compilations: ... }`,
     * take care that the compilations have different IDs from others passed in
     * so far, otherwise this will error.  If passed in in another form, an ID
     * will be assigned automatically, which should generally avoid any
     * collisions.
     */
    addAdditionalProjectInfo(projectInfo) {
        return __awaiter(this, void 0, void 0, function* () {
            const compilations = codec_1.Compilations.Utils.infoToCompilations(projectInfo, `decoderAdditionalShimmedCompilationGroup(${this.addProjectInfoNonce})`);
            this.addProjectInfoNonce++;
            yield this.addCompilations(compilations);
        });
    }
    /**
     * @protected
     */
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            //if pending, ignore the cache
            if (block === "pending") {
                return codec_1.Conversion.toBytes(yield this.providerAdapter.getCode(address, block));
            }
            //otherwise, start by setting up any preliminary layers as needed
            if (this.codeCache[block] === undefined) {
                this.codeCache[block] = {};
            }
            //now, if we have it cached, just return it
            if (this.codeCache[block][address] !== undefined) {
                return this.codeCache[block][address];
            }
            //otherwise, get it, cache it, and return it
            let code = codec_1.Conversion.toBytes(yield this.providerAdapter.getCode(address, block));
            this.codeCache[block][address] = code;
            return code;
        });
    }
    /**
     * @protected
     */
    regularizeBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof block === "number" || block === "pending") {
                return block;
            }
            if (block === null) {
                return "pending";
            }
            return (yield this.providerAdapter.getBlockByNumber(block)).number;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Takes a [[Transaction]] object and decodes it.  The result is a
     * [[CalldataDecoding]]; see the documentation on that interface for more.
     *
     * Note that decoding of transactions sent to libraries is presently not
     * supported and may have unreliable results.  Limited support for this is
     * planned for future versions.
     * @param transaction The transaction to be decoded.
     */
    decodeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decodeTransactionWithAdditionalContexts(transaction);
        });
    }
    /**
     * @protected
     */
    reverseEnsResolve(address) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("reverse resolving %s", address);
            if (this.ens === null) {
                debug("no ens set up!");
                return null;
            }
            if (address in this.ensCache) {
                debug("got cached: %o", this.ensCache[address]);
                return this.ensCache[address];
            }
            let name;
            try {
                //try-catch because ensjs throws on bad UTF-8 :-/
                //this should be fixed later
                name = (yield this.ens.getName(address)).name;
                debug("got name: %o", name);
            }
            catch (_a) {
                //Normally I'd rethrow unexpected errors, but given the context here
                //that seems like it might be a problem
                name = null;
            }
            if (name !== null) {
                //do a forward resolution check to make sure it matches
                let checkAddress;
                try {
                    checkAddress = yield this.ens.name(name).getAddress();
                }
                catch (_b) {
                    //why the try/catch?  because forward resolution will throw if the
                    //name contains certain characters that are illegal in a domain name,
                    //but this isn't in any way enforced on reverse resolution above. yay.
                    checkAddress = null;
                }
                if (checkAddress !== address) {
                    //if it doesn't, the name is no good!
                    name = null;
                }
            }
            const nameAsBytes = name !== null ? codec_1.Conversion.stringToBytes(name) : null;
            this.ensCache[address] = nameAsBytes;
            return nameAsBytes;
        });
    }
    /**
     * @protected
     */
    decodeTransactionWithAdditionalContexts(transaction, additionalContexts = {}, additionalAllocations, overrideContext, isForSelectorBasedDecoding) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = transaction.blockNumber !== null ? Number(transaction.blockNumber) : null;
            const blockNumber = yield this.regularizeBlock(block);
            const isConstructor = transaction.to === null;
            const context = overrideContext ||
                (yield this.getContextByAddress(transaction.to, blockNumber, transaction.input, additionalContexts));
            let allocations = this.allocations;
            if (overrideContext) {
                //if we've got an override context, let's override some things
                //(this branch is used when doing selector-based decoding)
                allocations = Object.assign(Object.assign({}, this.allocations), { calldata: Object.assign(Object.assign({}, this.allocations.calldata), { functionAllocations: Object.assign(Object.assign({}, this.allocations.calldata.functionAllocations), { [context.context]: additionalAllocations }) }) });
            }
            else if (context && !(context.context in this.contexts)) {
                //otherwise, if the context comes from additionalContexts,
                //we'll add the additional allocations to the allocations;
                //however, we'll allow other allocations to override it...
                //when we're not overriding, it's only supposed to be used if necessary!
                allocations = Object.assign(Object.assign({}, this.allocations), { calldata: Object.assign(Object.assign({}, this.allocations.calldata), { functionAllocations: Object.assign({ [context.context]: additionalAllocations }, this.allocations.calldata.functionAllocations) }) });
            }
            const data = codec_1.Conversion.toBytes(transaction.input);
            const contexts = Object.assign(Object.assign({}, this.deployedContexts), additionalContexts);
            const info = {
                state: {
                    storage: {},
                    calldata: data
                },
                userDefinedTypes: this.userDefinedTypes,
                allocations,
                contexts,
                currentContext: context
            };
            const decoder = (0, codec_1.decodeCalldata)(info, isConstructor, isForSelectorBasedDecoding); //turn on strict mode for selector-based decoding
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "code":
                        response = yield this.getCode(request.address, blockNumber);
                        break;
                    case "ens-primary-name":
                        response = yield this.reverseEnsResolve(request.address);
                        break;
                    //not writing a storage case as it shouldn't occur here!
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            let decoding = result.value;
            //...except wait!  we're not done yet! we need to do multicall processing!
            if (decoding.kind === "function") {
                decoding = yield this.withMulticallInterpretations(decoding, transaction, additionalContexts, additionalAllocations, overrideContext);
            }
            //...and 4byte.directory processing
            if ((decoding.kind === "message" || decoding.kind === "unknown") &&
                !isForSelectorBasedDecoding //prevent infinite loops!
            ) {
                const selectorBasedDecodings = yield this.decodeTransactionBySelector(transaction, data, //this is redundant but included for convenience
                additionalContexts, context);
                if (selectorBasedDecodings.length > 0) {
                    decoding.interpretations.selectorBasedDecodings =
                        selectorBasedDecodings;
                }
            }
            return decoding;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Takes a [[Log]] object and decodes it.  Logs can be ambiguous, so
     * this function returns an array of [[LogDecoding|LogDecodings]].
     *
     * Note that logs are decoded in strict mode, so (with one exception) none of the decodings should
     * contain errors; if a decoding would contain an error, instead it is simply excluded from the
     * list of possible decodings.  The one exception to this is that indexed parameters of reference
     * type cannot meaningfully be decoded, so those will decode to an error.
     *
     * If there are multiple possible decodings, they will always be listed in the following order:
     *
     * 1. Non-anonymous events coming from the contract itself (these will moreover be ordered
     *   from most derived to most base)
     * 2. Non-anonymous events coming from libraries
     * 3. Anonymous events coming from the contract itself (again, ordered from most derived
     *   to most base)
     * 4. Anonymous events coming from libraries
     *
     * You can check the kind and class.contractKind fields to distinguish between these.
     *
     * If no possible decodings are found, the returned array of decodings will be empty.
     *
     * Note that different decodings may use different decoding modes.
     *
     * Using `options.extras = "on"` or `options.extras = "necessary"` will change the
     * above behavior; see the documentation on [[ExtrasAllowed]] for more.
     *
     * If absolutely necessary, you can also set `options.disableChecks = true` to allow
     * looser decoding.  Only use this option if you know what you are doing.
     *
     * @param log The log to be decoded.
     * @param options Options for controlling decoding.
     */
    decodeLog(log, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decodeLogWithAdditionalOptions(log, options);
        });
    }
    /**
     * @protected
     */
    decodeLogWithAdditionalOptions(log, options = {}, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const block = log.blockNumber !== null ? Number(log.blockNumber) : null;
            const blockNumber = yield this.regularizeBlock(block);
            const data = codec_1.Conversion.toBytes(log.data);
            const topics = log.topics.map(codec_1.Conversion.toBytes);
            const info = {
                state: {
                    storage: {},
                    eventdata: data,
                    eventtopics: topics
                },
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                contexts: Object.assign(Object.assign({}, this.deployedContexts), additionalContexts)
            };
            const decoder = (0, codec_1.decodeEvent)(info, log.address, options);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "code":
                        response = yield this.getCode(request.address, blockNumber);
                        break;
                    case "ens-primary-name":
                        response = yield this.reverseEnsResolve(request.address);
                        break;
                    //not writing a storage case as it shouldn't occur here!
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            return result.value;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Gets all events meeting certain conditions and decodes them.
     * This function is fairly rudimentary at the moment but more functionality
     * will be added in the future.
     * @param options Used to determine what events to fetch and how to decode
     *   them; see the documentation on the [[EventOptions]] type for more.
     * @return An array of [[DecodedLog|DecodedLogs]].
     *   These consist of a log together with its possible decodings; see that
     *   type for more info.  And see [[decodeLog]] for more info on how log
     *   decoding works in general.
     * @example `events({name: "TestEvent"})` -- get events named "TestEvent"
     *   from the most recent block
     */
    events(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.eventsWithAdditionalContexts(options);
        });
    }
    /**
     * @protected
     */
    eventsWithAdditionalContexts(options = {}, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let { address, name, fromBlock, toBlock } = options;
            if (fromBlock === undefined) {
                fromBlock = "latest";
            }
            if (toBlock === undefined) {
                toBlock = "latest";
            }
            const fromBlockNumber = yield this.regularizeBlock(fromBlock);
            const toBlockNumber = yield this.regularizeBlock(toBlock);
            const logs = yield this.providerAdapter.getPastLogs({
                address,
                fromBlock: fromBlockNumber,
                toBlock: toBlockNumber
            });
            let events = yield Promise.all(logs.map((log) => __awaiter(this, void 0, void 0, function* () {
                return (Object.assign(Object.assign({}, log), { decodings: yield this.decodeLogWithAdditionalOptions(log, options, additionalContexts) }));
            })));
            debug("events: %o", events);
            //if a target name was specified, we'll restrict to events that decoded
            //to something with that name.  (note that only decodings with that name
            //will have been returned from decodeLogs in the first place)
            if (name !== undefined) {
                events = events.filter(event => event.decodings.length > 0);
            }
            return events;
        });
    }
    /**
     * Takes a [[CalldataDecoding]], which may have been produced in full mode or ABI mode,
     * and converts it to its ABI mode equivalent.  See the README for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyCalldataDecoding(decoding) {
        return Codec.abifyCalldataDecoding(decoding, this.userDefinedTypes);
    }
    /**
     * Takes a [[LogDecoding]], which may have been produced in full mode or ABI mode,
     * and converts it to its ABI mode equivalent.  See the README for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyLogDecoding(decoding) {
        return Codec.abifyLogDecoding(decoding, this.userDefinedTypes);
    }
    /**
     * Takes a [[ReturndataDecoding]], which may have been produced in full mode
     * or ABI mode, and converts it to its ABI mode equivalent.  See the README
     * for more information.
     *
     * Please only use on decodings produced by this same decoder instance; use
     * on decodings produced by other instances may not work consistently.
     * @param decoding The decoding to abify
     */
    abifyReturndataDecoding(decoding) {
        return Codec.abifyReturndataDecoding(decoding, this.userDefinedTypes);
    }
    //normally, this function gets the code of the given address at the given block,
    //and checks this against the known contexts to determine the contract type
    //however, if this fails and constructorBinary is passed in, it will then also
    //attempt to determine it from that
    getContextByAddress(address, block, constructorBinary, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            let code;
            if (address !== null) {
                code = codec_1.Conversion.toHexString(yield this.getCode(address, block));
            }
            else if (constructorBinary) {
                code = constructorBinary;
            }
            //if neither of these hold... we have a problem
            let contexts = Object.assign(Object.assign({}, this.contexts), additionalContexts);
            return codec_1.Contexts.Utils.findContext(contexts, code);
        });
    }
    //finally: the spawners!
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract decoder for a given contract artifact.
     * @param artifact The artifact for the contract.
     *
     *   A contract constructor object may be substituted for the artifact, so if
     *   you're not sure which you're dealing with, it's OK.
     *
     *   Note: The artifact must be for a contract that the decoder knows about;
     *   otherwise you will have problems.
     */
    forArtifact(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            let { compilation, contract } = codec_1.Compilations.Utils.findCompilationAndContract(this.compilations, artifact);
            //to be *sure* we've got the right ABI, we trust the input over what was
            //found
            contract = Object.assign(Object.assign({}, contract), { abi: artifact.abi });
            let contractDecoder = new ContractDecoder(contract, compilation, this, artifact);
            yield contractDecoder.init();
            return contractDecoder;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of a contract in this
     * project.
     * @param artifact The artifact for the contract.
     *
     *   A contract constructor object may be substituted for the artifact, so if
     *   you're not sure which you're dealing with, it's OK.
     *
     *   Note: The artifact must be for a contract that the decoder knows about;
     *   otherwise you will have problems.
     * @param address The address of the contract instance to decode.  If left out, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(artifact, address) {
        return __awaiter(this, void 0, void 0, function* () {
            let contractDecoder = yield this.forArtifact(artifact);
            return yield contractDecoder.forInstance(address);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of a contract in this
     * project.  Unlike [[forInstance]], this method doesn't require an artifact; it
     * will automatically detect the class of the given contract.  If it's not in
     * the project, or the decoder can't identify it, you'll get an exception.
     * @param address The address of the contract instance to decode.
     *   If an invalid address is provided, this method will throw an exception.
     * @param block You can include this argument to specify that this should be
     *   based on the addresses content's at a specific block (if say the contract
     *   has since self-destructed).
     */
    forAddress(address, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            if (!web3_utils_1.default.isAddress(address)) {
                throw new errors_1.InvalidAddressError(address);
            }
            address = web3_utils_1.default.toChecksumAddress(address);
            const blockNumber = yield this.regularizeBlock(block);
            const deployedBytecode = codec_1.Conversion.toHexString(yield this.getCode(address, blockNumber));
            const contractAndContexts = this.contractsAndContexts.find(({ deployedContext }) => deployedContext &&
                codec_1.Contexts.Utils.matchContext(deployedContext, deployedBytecode));
            if (!contractAndContexts) {
                throw new errors_1.ContractNotFoundError(undefined, undefined, deployedBytecode, address);
            }
            const { contract, compilationId } = contractAndContexts;
            const compilation = this.compilations.find(compilation => compilation.id === compilationId);
            let contractDecoder = new ContractDecoder(contract, compilation, this); //no artifact
            //(artifact is only used for address autodetection, and here we're supplying the
            //address, so this won't cause any problems)
            yield contractDecoder.init();
            return yield contractDecoder.forInstance(address);
        });
    }
    //the following functions are intended for internal use only
    /**
     * @protected
     */
    getReferenceDeclarations() {
        return this.referenceDeclarations;
    }
    /**
     * @protected
     */
    getUserDefinedTypes() {
        return this.userDefinedTypes;
    }
    /**
     * @protected
     */
    getAllocations() {
        return this.allocations;
    }
    /**
     * @protected
     */
    getProviderAdapter() {
        return this.providerAdapter;
    }
    /**
     * @protected
     */
    getEnsSettings() {
        return this.ensSettings;
    }
    /**
     * @protected
     */
    getDeployedContexts() {
        return this.deployedContexts;
    }
    //now, the interpretation stuff.  ideally this would be a separate file
    //(I mean, as would each decoder!) but that would cause circular imports, so... :-/
    withMulticallInterpretations(decoding, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            //first, let's clone our decoding and its interpretations
            decoding = Object.assign(Object.assign({}, decoding), { interpretations: Object.assign({}, decoding.interpretations) });
            //now we can freely modify decoding.interpretations
            //(note: these may return undefined)
            decoding.interpretations.multicall = yield this.interpretMulticall(decoding, transaction, additionalContexts, additionalAllocations, overrideContext);
            decoding.interpretations.aggregate = yield this.interpretAggregate(decoding, transaction, additionalContexts, additionalAllocations, overrideContext);
            decoding.interpretations.tryAggregate = yield this.interpretTryAggregate(decoding, transaction, additionalContexts, additionalAllocations, overrideContext);
            decoding.interpretations.deadlinedMulticall =
                yield this.interpretDeadlinedMulticall(decoding, transaction, additionalContexts, additionalAllocations, overrideContext);
            decoding.interpretations.specifiedBlockhashMulticall =
                yield this.interpretBlockhashedMulticall(decoding, transaction, additionalContexts, additionalAllocations, overrideContext);
            return decoding;
        });
    }
    interpretMulticall(decoding, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (decoding.kind === "function" &&
                decoding.abi.name === "multicall" &&
                decoding.abi.inputs.length === 1 &&
                decoding.abi.inputs[0].type === "bytes[]" &&
                decoding.arguments[0].value.kind === "value") {
                //sorry, this is going to involve some coercion...
                const decodedArray = decoding.arguments[0]
                    .value;
                return yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInMulti(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })));
            }
            else {
                return undefined;
            }
        });
    }
    interpretCallInMulti(callResult, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (callResult.kind) {
                case "value":
                    return yield this.decodeTransactionWithAdditionalContexts(Object.assign(Object.assign({}, transaction), { input: callResult.value.asHex }), additionalContexts, additionalAllocations, overrideContext);
                case "error":
                    return null;
            }
        });
    }
    interpretAggregate(decoding, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (decoding.kind === "function" &&
                (decoding.abi.name === "aggregate" ||
                    decoding.abi.name === "blockAndAggregate") &&
                decoding.abi.inputs.length === 1 &&
                decoding.abi.inputs[0].type === "tuple[]" &&
                decoding.abi.inputs[0].components.length === 2 &&
                decoding.abi.inputs[0].components[0].type === "address" &&
                decoding.abi.inputs[0].components[1].type === "bytes" &&
                decoding.arguments[0].value.kind === "value") {
                //sorry, this is going to involve some coercion...
                const decodedArray = decoding.arguments[0]
                    .value;
                return yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInAggregate(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })));
            }
            else if (decoding.kind === "function" &&
                decoding.abi.name === "aggregate3" &&
                decoding.abi.inputs.length === 1 &&
                decoding.abi.inputs[0].type === "tuple[]" &&
                decoding.abi.inputs[0].components.length === 3 &&
                decoding.abi.inputs[0].components[0].type === "address" &&
                decoding.abi.inputs[0].components[1].type === "bool" &&
                decoding.abi.inputs[0].components[2].type === "bytes" &&
                decoding.arguments[0].value.kind === "value") {
                //Identical to above, just split out for clarity
                const decodedArray = decoding.arguments[0]
                    .value;
                return yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInAggregate(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })));
            }
            else if (decoding.kind === "function" &&
                decoding.abi.name === "aggregate3Value" &&
                decoding.abi.inputs.length === 1 &&
                decoding.abi.inputs[0].type === "tuple[]" &&
                decoding.abi.inputs[0].components.length === 4 &&
                decoding.abi.inputs[0].components[0].type === "address" &&
                decoding.abi.inputs[0].components[1].type === "bool" &&
                decoding.abi.inputs[0].components[2].type === "uint256" &&
                decoding.abi.inputs[0].components[3].type === "bytes" &&
                decoding.arguments[0].value.kind === "value") {
                //Identical to above, just split out for clarity
                const decodedArray = decoding.arguments[0]
                    .value;
                return yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInAggregate(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })));
            }
            else {
                return undefined;
            }
        });
    }
    interpretCallInAggregate(callResult, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (callResult.kind === "error") {
                return {
                    address: null,
                    allowFailure: null,
                    value: null,
                    decoding: null
                };
            }
            let address;
            let subDecoding;
            let value = new bn_js_1.default(0);
            let allowFailure = false;
            for (const { value: subResult } of callResult.value) {
                switch (subResult.type.typeClass) {
                    case "address":
                        if (subResult.kind === "error") {
                            address = null;
                        }
                        else {
                            address = subResult.value.asAddress;
                        }
                        break;
                    case "bool":
                        if (subResult.kind === "error") {
                            allowFailure = null;
                        }
                        else {
                            allowFailure = subResult.value
                                .asBoolean;
                        }
                        break;
                    case "uint":
                        if (subResult.kind === "error") {
                            value = null;
                        }
                        else {
                            value = subResult.value.asBN.clone();
                        }
                        break;
                    case "bytes":
                        if (subResult.kind === "error") {
                            subDecoding = null;
                        }
                        else {
                            const asHex = subResult.value.asHex;
                            subDecoding = yield this.decodeTransactionWithAdditionalContexts(Object.assign(Object.assign({}, transaction), { input: asHex, to: address }), additionalContexts, additionalAllocations, overrideContext);
                        }
                        break;
                }
            }
            return { address, allowFailure, value, decoding: subDecoding };
        });
    }
    interpretTryAggregate(decoding, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (decoding.kind === "function" &&
                (decoding.abi.name === "tryAggregate" ||
                    decoding.abi.name === "tryBlockAndAggregate") &&
                decoding.abi.inputs.length === 2 &&
                decoding.abi.inputs[0].type === "bool" &&
                decoding.abi.inputs[1].type === "tuple[]" &&
                decoding.abi.inputs[1].components.length === 2 &&
                decoding.abi.inputs[1].components[0].type === "address" &&
                decoding.abi.inputs[1].components[1].type === "bytes" &&
                decoding.arguments[0].value.kind === "value" &&
                decoding.arguments[1].value.kind === "value") {
                //sorry, this is going to involve some coercion...
                const decodedBool = decoding.arguments[0]
                    .value;
                const decodedArray = decoding.arguments[1]
                    .value;
                const requireSuccess = decodedBool.value.asBoolean;
                const calls = (yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInAggregate(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })))).map(call => (Object.assign(Object.assign({}, call), { allowFailure: !requireSuccess })));
                return { requireSuccess, calls };
            }
            else {
                return undefined;
            }
        });
    }
    interpretDeadlinedMulticall(decoding, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (decoding.kind === "function" &&
                decoding.abi.name === "multicall" &&
                decoding.abi.inputs.length === 2 &&
                decoding.abi.inputs[0].type === "uint256" &&
                decoding.abi.inputs[1].type === "bytes[]" &&
                decoding.arguments[0].value.kind === "value" &&
                decoding.arguments[1].value.kind === "value") {
                //sorry, this is going to involve some coercion...
                const decodedUint = decoding.arguments[0]
                    .value;
                const decodedArray = decoding.arguments[1]
                    .value;
                const deadline = decodedUint.value.asBN;
                const calls = yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInMulti(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })));
                return { deadline, calls };
            }
            else {
                return undefined;
            }
        });
    }
    interpretBlockhashedMulticall(decoding, transaction, additionalContexts = {}, additionalAllocations, overrideContext) {
        return __awaiter(this, void 0, void 0, function* () {
            if (decoding.kind === "function" &&
                decoding.abi.name === "multicall" &&
                decoding.abi.inputs.length === 2 &&
                decoding.abi.inputs[0].type === "bytes32" &&
                decoding.abi.inputs[1].type === "bytes[]" &&
                decoding.arguments[0].value.kind === "value" &&
                decoding.arguments[1].value.kind === "value") {
                //sorry, this is going to involve some coercion...
                const decodedHash = decoding.arguments[0]
                    .value;
                const decodedArray = decoding.arguments[1]
                    .value;
                const specifiedBlockhash = decodedHash.value.asHex;
                const calls = yield Promise.all(decodedArray.value.map((callResult) => __awaiter(this, void 0, void 0, function* () {
                    return yield this.interpretCallInMulti(callResult, transaction, additionalContexts, additionalAllocations, overrideContext);
                })));
                return { specifiedBlockhash, calls };
            }
            else {
                return undefined;
            }
        });
    }
    decodeTransactionBySelector(transaction, data, //this is redundant but included for convenience
    additionalContexts, context) {
        return __awaiter(this, void 0, void 0, function* () {
            //first: bail out if no directory
            if (this.selectorDirectory === null) {
                return [];
            }
            if (data.length < codec_1.Evm.Utils.SELECTOR_SIZE) {
                return [];
            }
            const selector = data.slice(0, codec_1.Evm.Utils.SELECTOR_SIZE);
            const signatures = yield (0, fetch_signatures_1.fetchSignatures)(selector, this.selectorDirectory);
            debug("signatures: %O", signatures);
            const abis = signatures.map(Abi.parseFunctionSignature);
            const fakeContextHash = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470"; //hash of empty string
            //the particular choice here doesn't really matter, but I figured let's pick something that will never
            //occur as a real context hash
            //(remember that context hashes are currently taken of the ASCII hex string, so the input
            //will never be empty)
            let decodings = [];
            for (const abiEntry of abis) {
                //create a fake context with only this one ABI entry
                //we can't do it with multiple of them because codec is not prepared
                //for the idea that multiple might match
                const fakeContextAbi = { [Abi.abiSelector(abiEntry)]: abiEntry };
                const fakeContext = context
                    ? Object.assign(Object.assign({}, context), { abi: fakeContextAbi }) : {
                    abi: fakeContextAbi,
                    context: fakeContextHash,
                    binary: "0x",
                    isConstructor: false
                };
                const additionalAllocations = Object.values(codec_1.AbiData.Allocate.getCalldataAllocations([
                    {
                        abi: [abiEntry],
                        compiler: null,
                        contractNode: null,
                        deployedContext: fakeContext
                        //we won't need anything else
                    }
                ], {}, //we won't need the reference declarations
                {}, //we won't need the user-defined types
                {} //we won't need the struct allocations
                ).functionAllocations)[0];
                let decoding;
                try {
                    decoding = yield this.decodeTransactionWithAdditionalContexts(transaction, additionalContexts, additionalAllocations, fakeContext, //force decoding to use the fake context & not attempt to detect
                    true //prevent infinite loops! and turn on strict mode
                    );
                }
                catch (error) {
                    //because we're decoding in strict mode, it may error.
                    if (error instanceof Codec.StopDecodingError) {
                        //decoding didn't match, go to the next one
                        continue;
                    }
                    else {
                        //unexpected error, rethrow!
                        throw error;
                    }
                }
                if (decoding.kind === "function") {
                    debug("accepted");
                    decodings.push(decoding);
                }
                debug("moving on");
            }
            return decodings;
        });
    }
}
exports.ProjectDecoder = ProjectDecoder;
/**
 * The ContractDecoder class.  Decodes return values, and spawns the
 * [[ContractInstanceDecoder]] class.  Also, decodes transactions logs.  See
 * below for a method listing.
 * @category Decoder
 */
class ContractDecoder {
    /**
     * @protected
     */
    constructor(contract, compilation, projectDecoder, artifact) {
        this.artifact = artifact; //may be undefined; only used for address autodetection in instance decoder
        this.contract = contract;
        this.compilation = compilation;
        this.projectDecoder = projectDecoder;
        this.providerAdapter = projectDecoder.getProviderAdapter();
        this.contexts = projectDecoder.getDeployedContexts();
        this.userDefinedTypes = this.projectDecoder.getUserDefinedTypes();
        this.contractNode = codec_1.Compilations.Utils.getContractNode(this.contract, this.compilation);
        this.allocations = this.projectDecoder.getAllocations();
        //note: ordinarily this.contract.deployedBytecode should equal artifact.deployedBytecode
        //at this point, so it may seem strange that I'm using this longer version (but not
        //doing anything to handle the case we're there not).  This is basically because I don't
        //think such error handling is really necessary right now, but this way at least it won't
        //crash.
        if (this.contract.deployedBytecode &&
            this.contract.deployedBytecode !== "0x") {
            const unnormalizedContext = codec_1.Contexts.Utils.makeContext(this.contract, this.contractNode, this.compilation);
            this.contextHash = unnormalizedContext.context;
            //we now throw away the unnormalized context, instead fetching the correct one from
            //this.contexts (which is normalized) via the context getter below
        }
        else {
            //if there's no bytecode, allocate output data manually
            const referenceDeclarations = this.projectDecoder.getReferenceDeclarations();
            const compiler = this.compilation.compiler || this.contract.compiler;
            this.noBytecodeAllocations = Object.values(codec_1.AbiData.Allocate.getCalldataAllocations([
                {
                    abi: Abi.normalize(this.contract.abi),
                    compilationId: this.compilation.id,
                    compiler,
                    contractNode: this.contractNode,
                    deployedContext: codec_1.Contexts.Utils.makeContext(Object.assign(Object.assign({}, this.contract), { deployedBytecode: "0x" //only time this should ever appear in a context!
                     }), this.contractNode, this.compilation)
                }
            ], referenceDeclarations, this.userDefinedTypes, this.allocations.abi).functionAllocations)[0];
        }
        if (this.contractNode) {
            //note: there used to be code here to do state allocations for the contract,
            //but now the project decoder does this all up-front
            //(I could change this back if for some reason performance is an issue,
            //but this way is simpler TBH)
            //NOTE: does this change make this intermediate class essentially pointless?
            //Yes.  But not going to get rid of it now!
            if (this.allocations.state[this.compilation.id] &&
                this.allocations.state[this.compilation.id][this.contractNode.id]) {
                this.stateVariableReferences =
                    this.allocations.state[this.compilation.id][this.contractNode.id].members;
            }
            //if it doesn't exist, we will leave it undefined, and then throw an exception when
            //we attempt to decode
        }
    }
    /**
     * @protected
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            this.contractNetwork = yield this.providerAdapter.getNetworkId();
        });
    }
    get context() {
        return this.contexts[this.contextHash];
    }
    /**
     * **This method is asynchronous.**
     *
     * Decodes the return value of a call.  Return values can be ambiguous, so
     * this function returns an array of [[ReturndataDecoding|ReturndataDecodings]].
     *
     * Note that return values are decoded in strict mode, so none of the decodings should
     * contain errors; if a decoding would contain an error, instead it is simply excluded from the
     * list of possible decodings.
     *
     * If there are multiple possible decodings, they will always be listed in the following order:
     * 1. The decoded return value from a successful call.
     * 2. The decoded revert message from a call that reverted with a message.
     * 3. A decoding indicating that the call reverted with no message.
     * 4. A decoding indicating that the call self-destructed.
     *
     * You can check the kind and field to distinguish between these.
     *
     * If no possible decodings are found, the returned array of decodings will be empty.
     *
     * Note that different decodings may use different decoding modes.
     *
     * Decoding creation calls with this method is not supported.  If you simply
     * want to decode a revert message from an arbitrary call that you know
     * failed, you may also want to see the [[decodeRevert]] function in
     * `@truffle/codec`.
     *
     * @param abi The abi entry for the function call whose return value is being decoded.
     * @param data The data to be decoded, as a hex string (beginning with "0x").
     * @param options Additional options, such as the block the call occurred in.
     *   See [[ReturnOptions]] for more information.
     */
    decodeReturnValue(abi, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.decodeReturnValueWithAdditionalContexts(abi, data, options);
        });
    }
    /**
     * @protected
     */
    decodeReturnValueWithAdditionalContexts(abi, data, options = {}, additionalContexts = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            abi = Abi.normalizeEntry(abi); //just to be absolutely certain!
            const block = options.block !== undefined ? options.block : "latest";
            const blockNumber = yield this.regularizeBlock(block);
            const status = options.status; //true, false, or undefined
            const selector = Abi.abiSelector(abi);
            let allocation;
            if (this.contextHash !== undefined) {
                allocation =
                    this.allocations.calldata.functionAllocations[this.contextHash][selector].output;
            }
            else {
                allocation = this.noBytecodeAllocations[selector].output;
            }
            debug("this.allocations: %O", this.allocations);
            const bytes = codec_1.Conversion.toBytes(data);
            const info = {
                state: {
                    storage: {},
                    returndata: bytes
                },
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                contexts: Object.assign(Object.assign({}, this.contexts), additionalContexts),
                currentContext: this.context
            };
            const decoder = (0, codec_1.decodeReturndata)(info, allocation, status);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "code":
                        response = yield this.getCode(request.address, blockNumber);
                        break;
                    case "ens-primary-name":
                        response = yield this.reverseEnsResolve(request.address);
                        break;
                    //not writing a storage case as it shouldn't occur here!
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            return result.value;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance decoder for a given instance of this contract.
     * @param address The address of the contract instance decode.  If left out, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            let instanceDecoder = new ContractInstanceDecoder(this, address);
            yield instanceDecoder.init();
            return instanceDecoder;
        });
    }
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.getCode(address, block);
        });
    }
    reverseEnsResolve(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.reverseEnsResolve(address);
        });
    }
    regularizeBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.regularizeBlock(block);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeTransaction]].
     * @param transaction The transaction to be decoded.
     */
    decodeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeTransaction(transaction);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeLog]].
     * @param log The log to be decoded.
     */
    decodeLog(log, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeLog(log, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.events]].
     * @param options Used to determine what events to fetch and how to decode them;
     *   see the documentation on the EventOptions type for more.
     */
    events(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.events(options);
        });
    }
    /**
     * See [[ProjectDecoder.abifyCalldataDecoding]].
     */
    abifyCalldataDecoding(decoding) {
        return this.projectDecoder.abifyCalldataDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyLogDecoding]].
     */
    abifyLogDecoding(decoding) {
        return this.projectDecoder.abifyLogDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyReturndataDecoding]].
     */
    abifyReturndataDecoding(decoding) {
        return this.projectDecoder.abifyReturndataDecoding(decoding);
    }
    //the following functions are for internal use
    /**
     * @protected
     */
    getAllocations() {
        return this.allocations;
    }
    /**
     * @protected
     */
    getStateVariableReferences() {
        return this.stateVariableReferences;
    }
    /**
     * @protected
     */
    getProjectDecoder() {
        return this.projectDecoder;
    }
    /**
     * @protected
     */
    getNoBytecodeAllocations() {
        return this.noBytecodeAllocations;
    }
    /**
     * @protected
     */
    getContractInfo() {
        return {
            compilation: this.compilation,
            contract: this.contract,
            artifact: this.artifact,
            contractNode: this.contractNode,
            contractNetwork: this.contractNetwork,
            contextHash: this.contextHash
        };
    }
}
exports.ContractDecoder = ContractDecoder;
/**
 * The ContractInstanceDecoder class.  Decodes storage for a specified
 * instance.  Also, decodes transactions, logs, and return values.  See below
 * for a method listing.
 *
 * Note that when using this class to decode transactions, logs, and return
 * values, it does have one advantage over using the ProjectDecoder or
 * ContractDecoder.  If the artifact for the class does not have a
 * deployedBytecode field, the ProjectDecoder (and therefore also the
 * ContractDecoder) will not be able to tell that this instance is of that
 * class, and so will fail to decode transactions sent to it or logs
 * originating from it, and will fall back to ABI mode when decoding return
 * values received from it.  However, the ContractInstanceDecoder has that
 * information and will make use of it, making it possible for it to decode
 * transactions sent to this instance, or logs originating from it, or decode
 * return values received from it in full mode, even if the deployedBytecode
 * field is missing.
 * @category Decoder
 */
class ContractInstanceDecoder {
    /**
     * @protected
     */
    constructor(contractDecoder, address) {
        this.contexts = {}; //deployed contexts only
        this.additionalContexts = {}; //for passing to project decoder when contract has no deployedBytecode
        this.mappingKeys = [];
        this.storageCache = {};
        this.contractDecoder = contractDecoder;
        this.projectDecoder = this.contractDecoder.getProjectDecoder();
        this.providerAdapter = this.projectDecoder.getProviderAdapter();
        if (address !== undefined) {
            if (!web3_utils_1.default.isAddress(address)) {
                throw new errors_1.InvalidAddressError(address);
            }
            this.contractAddress = web3_utils_1.default.toChecksumAddress(address);
        }
        this.referenceDeclarations = this.projectDecoder.getReferenceDeclarations();
        this.userDefinedTypes = this.projectDecoder.getUserDefinedTypes();
        this.contexts = this.projectDecoder.getDeployedContexts();
        let artifact;
        ({
            compilation: this.compilation,
            contract: this.contract,
            artifact,
            contractNode: this.contractNode,
            contractNetwork: this.contractNetwork,
            contextHash: this.contextHash
        } = this.contractDecoder.getContractInfo());
        this.allocations = this.contractDecoder.getAllocations();
        this.stateVariableReferences =
            this.contractDecoder.getStateVariableReferences();
        //note that if we're in the null artifact case, this.contractAddress should have
        //been set by now, so we shouldn't end up here
        if (this.contractAddress === undefined) {
            this.contractAddress = artifact.networks[this.contractNetwork].address;
        }
        this.compiler = this.compilation.compiler || this.contract.compiler;
    }
    /**
     * @protected
     */
    init() {
        var _a, _b, _c, _d, _e;
        return __awaiter(this, void 0, void 0, function* () {
            this.contractCode = codec_1.Conversion.toHexString(yield this.getCode(this.contractAddress, yield this.providerAdapter.getBlockNumber() //not "latest" because regularized
            ));
            const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(this.contract.deployedBytecode);
            if (!deployedBytecode || deployedBytecode === "0x") {
                //if this contract does *not* have the deployedBytecode field, then the decoder core
                //has no way of knowing that contracts or function pointers with its address
                //are of its class; this is an especial problem for function pointers, as it
                //won't be able to determine what the selector points to.
                //so, to get around this, we make an "additional context" for the contract,
                //based on its *actual* deployed bytecode as pulled from the blockchain.
                //This way the decoder core can recognize the address as the class, without us having
                //to make serious modifications to contract decoding.  And while sure this requires
                //a little more work, I mean, it's all cached, so, no big deal.
                const contractWithCode = Object.assign(Object.assign({}, this.contract), { deployedBytecode: this.contractCode });
                const extraContext = codec_1.Contexts.Utils.makeContext(contractWithCode, this.contractNode, this.compilation);
                this.contextHash = extraContext.context;
                this.additionalContexts = { [extraContext.context]: extraContext };
                //the following line only has any effect if we're dealing with a library,
                //since the code we pulled from the blockchain obviously does not have unresolved link references!
                //(it's not strictly necessary even then, but, hey, why not?)
                this.additionalContexts = codec_1.Contexts.Utils.normalizeContexts(this.additionalContexts);
                //again, since the code did not have unresolved link references, it is safe to just
                //mash these together like I'm about to
                this.contexts = Object.assign(Object.assign({}, this.contexts), this.additionalContexts);
            }
            //set up encoder for wrapping elementary values.
            //we pass it a provider, so it can handle ENS names.
            const { provider: ensProvider, registryAddress } = this.projectDecoder.getEnsSettings();
            this.encoder = yield Encoder.forProjectInternal({
                provider: ensProvider,
                registryAddress,
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                networkId: this.contractNetwork
            });
            //finally: set up internal functions table, if we can
            const compiler = this.compilation.compiler || this.contract.compiler;
            const viaIR = ((_b = (_a = this.compilation) === null || _a === void 0 ? void 0 : _a.settings) === null || _b === void 0 ? void 0 : _b.viaIR) || ((_d = (_c = this.contract) === null || _c === void 0 ? void 0 : _c.settings) === null || _d === void 0 ? void 0 : _d.viaIR);
            if (!this.compilation.unreliableSourceOrder &&
                !viaIR &&
                this.contract.deployedSourceMap &&
                compiler.name === "solc" &&
                this.compilation.sources.every(source => !source || source.ast)) {
                // old-style internal function pointers
                // (only if source order is reliable; otherwise leave as undefined)
                // unlike the debugger, we don't *demand* an answer, so we won't set up
                // some sort of fake table if we don't have a source map, or if any ASTs
                // are missing (if a whole *source* is missing, we'll consider that OK)
                // note: we don't attempt to handle Vyper source maps!
                // WARNING: untyped code in this block!
                const asts = this.compilation.sources.map(source => source ? source.ast : undefined);
                const instructions = SourceMapUtils.getProcessedInstructionsForBinary(this.compilation.sources.map(source => source ? source.source : undefined), this.contractCode, SourceMapUtils.getHumanReadableSourceMap(this.contract.deployedSourceMap));
                try {
                    //this can fail if some of the source files are missing :(
                    this.internalFunctionsTable =
                        SourceMapUtils.getFunctionsByProgramCounter(instructions, asts, asts.map(SourceMapUtils.makeOverlapFunction), this.compilation.id);
                    this.internalFunctionsTableKind = "pcpair";
                }
                catch (_f) {
                    //just leave the internal functions table undefined
                }
            }
            else if (viaIR && ((_e = this.contractNode) === null || _e === void 0 ? void 0 : _e.internalFunctionIDs)) {
                //and the field
                //unfortunately, unlike in the debugger, we don't have access to scopes
                //(or similar) (well, unless we want to go to the effort of setting that
                //up...).  so we're just going to have to do some searching.
                //so before we do anything else, let's set up what we'll later be searching.
                const asts = this.compilation.sources
                    .map(source => (source ? source.ast : undefined))
                    .filter(ast => ast !== undefined);
                //we don't need to search *every* contract; internal functions can only come
                //from the contract itself, base contracts, libraries, or free functions.
                //I'm assuming that this assumption will continue to hold true in the future as well.
                const sourceUnitsAndRelevantContracts = asts.concat(Object.values(this.referenceDeclarations[this.compilation.id]).filter(node => node.nodeType === "ContractDefinition" &&
                    (node.contractKind === "library" ||
                        this.contractNode.linearizedBaseContracts.includes(node.id))));
                //now, we can construct the table!
                this.internalFunctionsTable = Object.assign(
                //we start with the entry for the designated invalid function in index 0.
                //all other functions should have index 1 or greater.
                [{ isDesignatedInvalid: true }], ...Object.entries(this.contractNode.internalFunctionIDs).map(([nodeIdAsString, index]) => {
                    const nodeId = Number(nodeIdAsString);
                    //now we perform that search we set up earlier
                    let contractNode = undefined;
                    let functionNode = undefined;
                    for (const parentNode of sourceUnitsAndRelevantContracts) {
                        const foundNode = parentNode.nodes.find(node => node.id === nodeId);
                        if (foundNode !== undefined) {
                            functionNode = foundNode;
                            contractNode =
                                parentNode.nodeType === "ContractDefinition"
                                    ? parentNode
                                    : null;
                            break;
                        }
                    }
                    //if we didn't find it... oh well
                    if (functionNode === undefined) {
                        return {};
                    }
                    return {
                        [index]: {
                            //we're just going to omit the pointer-related fields...
                            //it's not worth the effort to determine these, it's not like
                            //they're even used for anything at present
                            isDesignatedInvalid: false,
                            sourceIndex: Number(functionNode.src.split(":")[2]),
                            //parse the node's source range, which has the form start:length:file
                            compilationId: this.compilation.id,
                            node: functionNode,
                            name: functionNode.name,
                            id: nodeId,
                            mutability: Codec.Ast.Utils.mutability(functionNode),
                            contractNode,
                            contractName: contractNode ? contractNode.name : null,
                            contractId: contractNode ? contractNode.id : null,
                            contractKind: contractNode ? contractNode.contractKind : null,
                            contractPayable: contractNode
                                ? Codec.Ast.Utils.isContractPayable(contractNode)
                                : null
                        }
                    };
                }));
                this.internalFunctionsTableKind = "index";
            }
        });
    }
    get context() {
        return this.contexts[this.contextHash];
    }
    checkAllocationSuccess() {
        if (!this.contractNode) {
            throw new errors_1.ContractBeingDecodedHasNoNodeError(this.contract.contractName, this.compilation.id);
        }
        if (!this.stateVariableReferences) {
            throw new errors_1.ContractAllocationFailedError(this.contractNode.id, this.contract.contractName, this.compilation.id);
        }
    }
    decodeVariable(variable, block) {
        return __awaiter(this, void 0, void 0, function* () {
            const info = {
                state: {
                    storage: {},
                    code: codec_1.Conversion.toBytes(this.contractCode)
                },
                mappingKeys: this.mappingKeys,
                userDefinedTypes: this.userDefinedTypes,
                allocations: this.allocations,
                contexts: this.contexts,
                currentContext: this.context,
                internalFunctionsTable: this.internalFunctionsTable,
                internalFunctionsTableKind: this.internalFunctionsTableKind
            };
            debug("this.contextHash: %s", this.contextHash);
            const decoder = Codec.decodeVariable(variable.definition, variable.pointer, info, this.compilation.id);
            let result = decoder.next();
            while (result.done === false) {
                let request = result.value;
                let response;
                switch (request.type) {
                    case "storage":
                        response = yield this.getStorage(this.contractAddress, request.slot, block);
                        break;
                    case "code":
                        response = yield this.getCode(request.address, block);
                        break;
                    case "ens-primary-name":
                        debug("ens request for: %s", request.address);
                        response = yield this.reverseEnsResolve(request.address);
                        debug("response: %o", response);
                        break;
                }
                result = decoder.next(response);
            }
            //at this point, result.value holds the final value
            debug("definedIn: %o", variable.definedIn);
            let classType = codec_1.Ast.Import.definitionToStoredType(variable.definedIn, this.compilation.id, this.compiler); //can skip reference decls
            return {
                name: variable.definition.name,
                class: classType,
                value: result.value
            };
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Returns information about the state of the contract, but does not include
     * information about the storage or decoded variables.  See the documentation
     * for the [[ContractState]] type for more.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     */
    state(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            let blockNumber = yield this.regularizeBlock(block);
            return {
                class: codec_1.Contexts.Import.contextToType(this.context),
                address: this.contractAddress,
                code: this.contractCode,
                balanceAsBN: new bn_js_1.default(yield this.providerAdapter.getBalance(this.contractAddress, blockNumber)),
                nonceAsBN: new bn_js_1.default(yield this.providerAdapter.getTransactionCount(this.contractAddress, blockNumber))
            };
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Decodes the contract's variables; returns an array of these decoded variables.
     * See the documentation of the [[DecodedVariable]] type for more.
     *
     * Note that variable decoding can only operate in full mode; if the decoder wasn't able to
     * start up in full mode, this method will throw a [[ContractAllocationFailedError]].
     *
     * Note that decoding mappings requires first watching mapping keys in order to get any results;
     * see the documentation for [[watchMappingKey]].
     * Additional methods to make mapping decoding a less manual affair are planned for the future.
     *
     * Also, due to a technical limitation, it is not currently possible to
     * usefully decode internal function pointers.  See the
     * [[Format.Values.FunctionInternalValue|FunctionInternalValue]]
     * documentation and the README for more on how these are handled.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     */
    variables(block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let blockNumber = yield this.regularizeBlock(block);
            let result = [];
            for (const variable of this.stateVariableReferences) {
                debug("about to decode %s", variable.definition.name);
                const decodedVariable = yield this.decodeVariable(variable, blockNumber);
                debug("decoded");
                result.push(decodedVariable);
            }
            return result;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Decodes an individual contract variable; returns its value as a
     * [[Format.Values.Result|Result]].  See the documentation for
     * [[variables|variables()]] for various caveats that also apply here.
     *
     * If the variable can't be located, throws an exception.
     * @param nameOrId The name (or numeric ID, if you know that) of the
     *   variable.  Can be given as a qualified name, allowing one to get at
     *   shadowed variables from base contracts.  If given by ID, can be given as a
     *   number or numeric string.
     * @param block The block to inspect the contract's state at.  Defaults to latest.
     *   See [[BlockSpecifier]] for legal values.
     * @example Consider a contract `Derived` inheriting from a contract `Base`.
     *   Suppose `Derived` has a variable `x` and `Base` has variables `x` and
     *   `y`.  One can access `Derived.x` as `variable("x")` or
     *   `variable("Derived.x")`, can access `Base.x` as `variable("Base.x")`,
     *   and can access `Base.y` as `variable("y")` or `variable("Base.y")`.
     */
    variable(nameOrId, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let blockNumber = yield this.regularizeBlock(block);
            let variable = this.findVariableByNameOrId(nameOrId);
            if (variable === undefined) {
                //if user put in a bad name
                throw new errors_1.VariableNotFoundError(nameOrId);
            }
            return (yield this.decodeVariable(variable, blockNumber)).value;
        });
    }
    findVariableByNameOrId(nameOrId) {
        //case 1: an ID was input
        if (typeof nameOrId === "number" || nameOrId.match(/[0-9]+/)) {
            return this.stateVariableReferences.find(({ definition }) => definition.id === nameOrId);
            //there should be exactly one; returns undefined if none
        }
        //case 2: a name was input
        else if (!nameOrId.includes(".")) {
            //we want to search *backwards*, to get most derived version;
            //we use slice().reverse() to clone before reversing since reverse modifies
            return this.stateVariableReferences
                .slice()
                .reverse()
                .find(({ definition }) => definition.name === nameOrId);
        }
        //case 3: a qualified name was input
        else {
            let [className, variableName] = nameOrId.split(".");
            //again, we'll search backwards, although, uhhh...?
            return this.stateVariableReferences
                .slice()
                .reverse()
                .find(({ definition, definedIn }) => definition.name === variableName && definedIn.name === className);
        }
    }
    getStorage(address, slot, block) {
        return __awaiter(this, void 0, void 0, function* () {
            //if pending, bypass the cache
            if (block === "pending") {
                return codec_1.Conversion.toBytes(yield this.providerAdapter.getStorageAt(address, slot, block), Codec.Evm.Utils.WORD_SIZE);
            }
            //otherwise, start by setting up any preliminary layers as needed
            if (this.storageCache[block] === undefined) {
                this.storageCache[block] = {};
            }
            if (this.storageCache[block][address] === undefined) {
                this.storageCache[block][address] = {};
            }
            //now, if we have it cached, just return it
            if (this.storageCache[block][address][slot.toString()] !== undefined) {
                return this.storageCache[block][address][slot.toString()];
            }
            //otherwise, get it, cache it, and return it
            let word = codec_1.Conversion.toBytes(yield this.providerAdapter.getStorageAt(address, slot, block), Codec.Evm.Utils.WORD_SIZE);
            this.storageCache[block][address][slot.toString()] = word;
            return word;
        });
    }
    getCode(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.getCode(address, block);
        });
    }
    reverseEnsResolve(address) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.reverseEnsResolve(address);
        });
    }
    regularizeBlock(block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.regularizeBlock(block);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Watches a mapping key; adds it to the decoder's list of watched mapping
     * keys.  This affects the results of both [[variables|variables()]] and
     * [[variable|variable()]].  When a mapping is decoded, only the values at
     * its watched keys will be included in its value.
     *
     * Note that it is possible
     * to watch mappings that are inside structs, arrays, other mappings, etc;
     * see below for more on how to do this.
     *
     * Note that watching mapping keys is
     * only possible in full mode; if the decoder wasn't able to start up in full
     * mode, this method will throw an exception.
     *
     * (A bad variable name will cause an exception though; that input is checked.)
     * @param variable The variable that the mapping lives under; this works like
     *   the nameOrId argument to [[variable|variable()]].  If the mapping is a
     *   top-level state variable, put the mapping itself here.  Otherwise, put the
     *   top-level state variable it lives under.
     * @param indices Further arguments to watchMappingKey, if given, will be
     *   interpreted as indices into or members of the variable identified by the
     *   variable argument; see the example.  Array indices and mapping
     *   keys are specified by value; struct members are specified by name.
     *
     *   Values (for array indices and mapping keys) may be given in any format
     *   understood by Truffle Encoder; see the documentation for
     *   [[Encoder.ProjectEncoder.wrap|ProjectEncoder.wrap]] for details.
     *
     *   Note that if the path to a given mapping key
     *   includes mapping keys above it, any ancestors will also be watched
     *   automatically.
     * @example First, a simple example.  Say we have a mapping `m` of type
     *   `mapping(uint => uint)`.  You could call `watchMappingKey("m", 0)` to
     *   watch `m[0]`.
     * @example Now for a slightly more complicated example.  Say `m` is of type
     *   `mapping(uint => mapping(uint => uint))`, then to watch `m[3][5]`, you
     *   can call `watchMappingKey("m", 3, 5)`.  This will also automatically
     *   watch `m[3]`; otherwise, watching `m[3][5]` wouldn't do much of
     *   anything.
     * @example Now for a well more complicated example.  Say we have a struct
     *   type `MapStruct` with a member called `map` which is a `mapping(string => string)`,
     *   and say we have a variable `arr` of type `MapStruct[]`, then one could
     *   watch `arr[3].map["hello"]` by calling `watchMappingKey("arr", 3, "map", "hello")`.
     */
    watchMappingKey(variable, ...indices) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let { slot } = yield this.constructSlot(variable, ...indices);
            //add mapping key and all ancestors
            debug("slot: %O", slot);
            while (slot !== undefined &&
                this.mappingKeys.every(existingSlot => !codec_1.Storage.Utils.equalSlots(existingSlot, slot)
                //we put the newness requirement in the while condition rather than a
                //separate if because if we hit one ancestor that's not new, the futher
                //ones won't be either
                )) {
                if (slot.key !== undefined) {
                    //only add mapping keys
                    this.mappingKeys = [...this.mappingKeys, slot];
                }
                slot = slot.path;
            }
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Opposite of [[watchMappingKey]]; unwatches the specified mapping key.  See
     * watchMappingKey for more on how watching mapping keys works, and on how
     * the parameters work.
     *
     * Note that unwatching a mapping key will also unwatch all its descendants.
     * E.g., if `m` is of type `mapping(uint => mapping(uint => uint))`, then
     * unwatching `m[0]` will also unwatch `m[0][0]`, `m[0][1]`, etc, if these
     * are currently watched.
     */
    unwatchMappingKey(variable, ...indices) {
        return __awaiter(this, void 0, void 0, function* () {
            this.checkAllocationSuccess();
            let { slot } = yield this.constructSlot(variable, ...indices);
            if (slot === undefined) {
                return; //not strictly necessary, but may as well
            }
            //remove mapping key and all descendants
            this.mappingKeys = this.mappingKeys.filter(existingSlot => {
                while (existingSlot !== undefined) {
                    if (codec_1.Storage.Utils.equalSlots(existingSlot, slot)) {
                        return false; //if it matches, remove it
                    }
                    existingSlot = existingSlot.path;
                }
                return true; //if we didn't match, keep the key
            });
        });
    }
    //NOTE: if you decide to add a way to remove a mapping key *without* removing
    //all descendants, you'll need to alter watchMappingKey to use an if rather
    //than a while
    /**
     * **This method is asynchronous.**
     *
     * Behaves mostly as [[ProjectDecoder.decodeTransaction]].  However, it is
     * capable of more robustly decoding transactions that were sent to this
     * particular instance.
     */
    decodeTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeTransactionWithAdditionalContexts(transaction, this.additionalContexts, this.contractDecoder.getNoBytecodeAllocations());
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ProjectDecoder.decodeLog]].
     */
    decodeLog(log, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.decodeLogWithAdditionalOptions(log, options, this.additionalContexts);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * See [[ContractDecoder.decodeReturnValue]].
     *
     * If the contract artifact is missing its bytecode, using this method,
     * rather than the one in [[ContractDecoder]], can sometimes provide
     * additional decoding information.
     */
    decodeReturnValue(abi, data, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractDecoder.decodeReturnValueWithAdditionalContexts(abi, data, options, this.additionalContexts);
        });
    }
    /**
     * See [[ProjectDecoder.abifyCalldataDecoding]].
     */
    abifyCalldataDecoding(decoding) {
        return this.projectDecoder.abifyCalldataDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyLogDecoding]].
     */
    abifyLogDecoding(decoding) {
        return this.projectDecoder.abifyLogDecoding(decoding);
    }
    /**
     * See [[ProjectDecoder.abifyReturndataDecoding]].
     */
    abifyReturndataDecoding(decoding) {
        return this.projectDecoder.abifyReturndataDecoding(decoding);
    }
    /**
     * **This method is asynchronous.**
     *
     * This mostly behaves as [[ProjectDecoder.events]].
     * However, unlike other variants of this function, this one, by default, restricts to events originating from this instance's address.
     * If you don't want to restrict like that, you can explicitly use `address: undefined` in the options to disable this.
     * (You can also of course set a different address to restrict to that.)
     * @param options Used to determine what events to fetch; see the documentation on the [[EventOptions]] type for more.
     */
    events(options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectDecoder.eventsWithAdditionalContexts(Object.assign({ address: this.contractAddress }, options), this.additionalContexts);
        });
    }
    //in addition to returning the slot we want, it also returns a Type
    //used in the recursive call
    //HOW TO USE:
    //variable may be a variable id (number or numeric string) or name (string) or qualified name (also string)
    //struct members are given by name (string)
    //array indices and numeric mapping keys may be BN, number, or numeric string
    //string mapping keys should be given as strings. duh.
    //bytes mapping keys should be given as hex strings beginning with "0x"
    //address mapping keys are like bytes; checksum case is not required
    //boolean mapping keys may be given either as booleans, or as string "true" or "false"
    constructSlot(variable, ...indices) {
        return __awaiter(this, void 0, void 0, function* () {
            //base case: we need to locate the variable and its definition
            if (indices.length === 0) {
                let allocation = this.findVariableByNameOrId(variable);
                if (!allocation) {
                    throw new errors_1.VariableNotFoundError(variable);
                }
                let dataType = codec_1.Ast.Import.definitionToType(allocation.definition, this.compilation.id, this.contract.compiler, "storage");
                let pointer = allocation.pointer;
                if (pointer.location !== "storage") {
                    //i.e., if it's a constant
                    return { slot: undefined, type: undefined };
                }
                return { slot: pointer.range.from.slot, type: dataType };
            }
            //main case
            let parentIndices = indices.slice(0, -1); //remove last index
            let { slot: parentSlot, type: parentType } = yield this.constructSlot(variable, ...parentIndices);
            if (parentSlot === undefined) {
                return { slot: undefined, type: undefined };
            }
            let rawIndex = indices[indices.length - 1];
            let slot;
            let dataType;
            switch (parentType.typeClass) {
                case "array":
                    const wrappedIndex = (yield this.encoder.wrapElementaryValue({ typeClass: "uint", bits: 256 }, rawIndex));
                    const index = wrappedIndex.value.asBN;
                    if (parentType.kind === "static" && index.gte(parentType.length)) {
                        throw new errors_1.ArrayIndexOutOfBoundsError(index, parentType.length, variable, indices);
                    }
                    dataType = parentType.baseType;
                    let size = codec_1.Storage.Allocate.storageSize(dataType, this.userDefinedTypes, this.allocations.storage);
                    if (!codec_1.Storage.Utils.isWordsLength(size)) {
                        return { slot: undefined, type: undefined };
                    }
                    slot = {
                        path: parentSlot,
                        offset: index.muln(size.words),
                        hashPath: parentType.kind === "dynamic"
                    };
                    break;
                case "mapping":
                    let keyType = parentType.keyType;
                    const key = yield this.encoder.wrapElementaryValue(keyType, rawIndex);
                    dataType = parentType.valueType;
                    slot = {
                        path: parentSlot,
                        key,
                        offset: new bn_js_1.default(0)
                    };
                    break;
                case "struct":
                    //NOTE: due to the reliance on storage allocations,
                    //we don't need to use fullType or what have you
                    let allocation = this.allocations.storage[parentType.id].members.find(({ name }) => name === rawIndex); //there should be exactly one
                    if (!allocation) {
                        const stringIndex = typeof rawIndex === "string"
                            ? rawIndex
                            : "specified by non-string argument";
                        throw new errors_1.MemberNotFoundError(stringIndex, parentType, variable, indices);
                    }
                    slot = {
                        path: parentSlot,
                        //need type coercion here -- we know structs don't contain constants but the compiler doesn't
                        offset: allocation.pointer.range.from.slot.offset.clone()
                    };
                    dataType = allocation.type;
                    break;
                default:
                    return { slot: undefined, type: undefined };
            }
            return { slot, type: dataType };
        });
    }
}
exports.ContractInstanceDecoder = ContractInstanceDecoder;
//# sourceMappingURL=decoders.js.map

/***/ }),

/***/ 13552:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoProviderError = exports.ArrayIndexOutOfBoundsError = exports.MemberNotFoundError = exports.VariableNotFoundError = exports.InvalidAddressError = exports.ContractAllocationFailedError = exports.ContractNotFoundError = exports.ContractBeingDecodedHasNoNodeError = void 0;
const codec_1 = __webpack_require__(20102);
/**
 * This error indicates that the contract you are attempting to decode does not have AST
 * information associated with it, or that the decoder cannot find it.  This error will
 * be thrown if you attempt to use functions that require AST information with such a contract.
 * @category Exception
 */
class ContractBeingDecodedHasNoNodeError extends Error {
    constructor(contractName, compilationId) {
        const message = `Contract ${contractName} does not appear to have been compiled with Solidity (cannot locate contract node)`;
        super(message);
        this.contractName = contractName;
        this.compilationId = compilationId;
        this.name = "ContractBeingDecodedHasNoNodeError";
    }
}
exports.ContractBeingDecodedHasNoNodeError = ContractBeingDecodedHasNoNodeError;
/**
 * This error indicates that the contract you are attempting to decode could not be found in
 * the project info.  This error will be thrown if you attempt to spawn a contract decoder or
 * contract instance decoder for a contract not appearing in the project info.
 * @category Exception
 */
class ContractNotFoundError extends Error {
    constructor(contractName, bytecode, deployedBytecode, address) {
        let message;
        if (contractName) {
            message = `Contract ${contractName} could not be found in the project information`;
        }
        else {
            message = `Contract at ${address} could not be found in the project information`;
        }
        super(message);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.deployedBytecode = deployedBytecode;
        this.address = address;
        this.name = "ContractNotFoundError";
    }
}
exports.ContractNotFoundError = ContractNotFoundError;
/**
 * This error indicates that something went wrong while attempting to determine the location
 * of this contract's state variables.  This error will be thrown if you attempt to use
 * decoding functions after something went wrong during setup.  Unfortunately, we can't
 * always avoid this at the moment; we're hoping to make this more robust in the future
 * with Truffle DB.  In the meantime, it is at least worth noting that you should not encounter
 * this error if your entire project was written in Solidity and all compiled at once.  Sorry.
 * @category Exception
 */
class ContractAllocationFailedError extends Error {
    constructor(id, contractName, compilationId) {
        super(`No allocation found for contract ID ${id} (${contractName}) in compilation ${compilationId}`);
        this.id = id;
        this.contractName = contractName;
        this.compilationId = compilationId;
        this.name = "ContractAllocationFailedError";
    }
}
exports.ContractAllocationFailedError = ContractAllocationFailedError;
/**
 * This error indicates that an invalid address was passed to one of the
 * contract instance decoder spawners ([[forContractInstance]], etc).  Valid
 * addresses are those that Web3 accepts; i.e., either those with correct
 * checksums, or those that are all-lowercase or all-uppercase to deliberately
 * circumvent the checksum.
 * @category Exception
 */
class InvalidAddressError extends Error {
    constructor(address) {
        super(`Invalid address ${address}`);
        this.address = address;
        this.name = "InvalidAddressError";
    }
}
exports.InvalidAddressError = InvalidAddressError;
/**
 * This error indicates that the user requested a variable that does not exist.
 * @category Exception
 */
class VariableNotFoundError extends Error {
    constructor(nameOrId) {
        super(`No such variable ${nameOrId}`);
        this.nameOrId = nameOrId;
        this.name = "VariableNotFoundError";
    }
}
exports.VariableNotFoundError = VariableNotFoundError;
/**
 * This error indicates that the user requested a struct member that does not
 * exist.
 * @category Exception
 */
class MemberNotFoundError extends Error {
    constructor(memberName, structType, variable, indices) {
        const message = `Member ${memberName} does not exist on struct type ${codec_1.Format.Types.typeStringWithoutLocation(structType)} in attempting to access variable ${variable}$, indexSequence ${indices.join(", ")}`;
        super(message);
        this.memberName = memberName;
        this.structType = structType;
        this.variable = variable;
        this.indices = indices;
        this.name = "MemberNotFoundError";
    }
}
exports.MemberNotFoundError = MemberNotFoundError;
/**
 * This error indicates that the user requested an array index that is out
 * of bounds.  Note that currently this error is only thrown when an index
 * is requested that is outside *static* bounds; dynamic array bounds are
 * currently not checked.
 * @category Exception
 */
class ArrayIndexOutOfBoundsError extends Error {
    constructor(index, length, variable, indices) {
        const message = `Index ${index} is out of bounds for array of length ${length} in attempting to access variable ${variable}, index sequence ${indices.join(", ")}`;
        super(message);
        this.index = index.clone();
        this.length = length.clone();
        this.variable = variable;
        this.indices = indices;
        this.name = "ArrayIndexOutOfBoundsError";
    }
}
exports.ArrayIndexOutOfBoundsError = ArrayIndexOutOfBoundsError;
/**
 * This error indicates that no provider was passed to the decoder.
 */
class NoProviderError extends Error {
    constructor() {
        super("No provider was given for the decoder to use.");
        this.name = "NoProviderError";
    }
}
exports.NoProviderError = NoProviderError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 72794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fetchSignatures = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("decoder:fetch-signatures");
const axios_1 = __importDefault(__webpack_require__(43306));
const async_retry_1 = __importDefault(__webpack_require__(72047));
const codec_1 = __webpack_require__(20102);
function fetchSignatures(selector, //note: input should be 4 bytes long
url) {
    return __awaiter(this, void 0, void 0, function* () {
        const selectorString = codec_1.Conversion.toHexString(selector);
        let page = 1;
        let signatures = [];
        while (true) {
            const response = yield getSuccessfulResponse(selectorString, url, page);
            signatures = signatures.concat(response.results.map(({ text_signature }) => text_signature)); //append new signatures
            if (response.next === null) {
                break;
            }
            page++; //ideally we'd use the actual value of response.next, but this is easier
        }
        return signatures;
    });
}
exports.fetchSignatures = fetchSignatures;
function getSuccessfulResponse(selector, url, page) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield (0, async_retry_1.default)(() => __awaiter(this, void 0, void 0, function* () {
            return (yield axios_1.default.get(`${url}/v1/signatures/`, {
                params: {
                    hex_signature: selector,
                    page
                },
                responseType: "json",
                maxRedirects: 50
            })).data;
        }), { retries: 3 } //we'll leave minTimeout as the default 1000
        );
    });
}
//# sourceMappingURL=fetch-signatures.js.map

/***/ }),

/***/ 18852:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
# Truffle Decoder

This module provides an interface for decoding contract state, transaction
calldata, events, and return values and revert strings.  It's an interface to
the same low-level decoding functionality that Truffle Debugger uses.  However,
it has additional functionality that the debugger does not need, and the
debugger has additional functionality that this decoder does not need.

The interface is split into three classes: The project decoder, the contract
decoder, and the contract instance decoder.  The project decoder is associated
to the project as a whole and decodes transaction calldata and events.  The
contract decoder is associated to a specific contract class.  It has all the
capabilities of the project decoder, but it can also decode return values from
calls made by the given contract class.  The contract instance decoder is
associated to a specific contract instance; it again has all the capabilities
of the project decoder and contract decoder, but it can also decode the state
variables for the specific instance.  (In addition, in the case that the
contract does not include a `deployedBytecode` field in its artifact, which can
hinder decoding certain things, the contract instance decoder can sometimes
work around this where the other decoders cannot.)

This documentation describes the current state of the decoder, but further
improvements are planned.

## Usage

### Initialization

Create a decoder with one of the various constructor functions.

For a project decoder, use the [[forProject|`forProject`]] function.

For a contract decoder, use the [[forArtifact|`forArtifact`]] or
[[forContract|`forContract`]] function.

For a contract instance decoder, use one of the following:
* [[forDeployedArtifact|`forDeployedArtifact`]]
* [[forDeployedContract|`forDeployedContract`]]
* [[forArtifactAt|`forArtifactAt`]]
* [[forContractAt|`forContractAt`]]
* [[forContractInstance|`forContractInstance`]]
* [[forAddress|`forAddress`]]

See the documentation of these functions for details, or below for usage
examples.

All of these functions take a final argument in which information about the
project is specified; currently only a few methods for specifying project
information are allowed, but more are planned.

One can also spawn decoders from other decoders by supplying additional
information.  See the documentation for the individual decoder classes for a
method listing.

### Decoder methods

See the documentation for the individual decoder classes for a method listing.

### Output format information

The decoder outputs lossless, machine-readable [[Format.Values.Result]] objects
containing individual decoded values. See the [[Format|format documentation]]
for an overview and complete module listing.

### Decoding modes, abification, and caveats

The decoder runs in either of two modes: full mode or ABI mode. Full mode
requires some additional constraints but returns substantially more detailed
information. Please see the notes on [decoding modes](../#decoding-modes) for
more about this distinction.

See also the notes about [decoding state variables](../#additional-notes-on-decoding-state-variables) for additional
caveats about what may or may not be fully decodable.

### Basic usage examples

#### Decoding a log with the project decoder

This usage example is for a project with two contracts, `Contract1` and
`Contract2`.

```typescript
import { forProject } from "@truffle/decoder";
const contract1 = artifacts.require("Contract1");
const contract2 = artifacts.require("Contract2");
const provider = web3.currentProvider;
const decoder = await Decoder.forProject(provider, [contract1, contract2]);
const decodings = await decoder.decodeLog(log);
```

The usage of [[ProjectDecoder.decodeTransaction|decodeTransaction]] is similar.

For getting already-decoded logs meeting appropriate conditions, see
[[ProjectDecoder.events]].

#### Decoding state variables with the contract instance decoder

This usage example is for decoding the state variables of a contract `Contract`
in a project that also contains a contract `OtherContract`.

```typescript
import { forContract } from "@truffle/decoder";
const contract = artifacts.require("Contract");
const otherContract = artifacts.require("OtherContract");
const decoder = await Decoder.forContract(contract, [otherContract]);
const instanceDecoder = await decoder.forInstance();
const variables = await instanceDecoder.variables();
```

In this example, we use the deployed version of `Contract`.  If we wanted an
instance at a different address, we could pass the address to `forInstance`.

In addition, rather than using `forContract` and then `forInstance`, we could
also use [[forDeployedContract|`forContractInstance`]] to perform both of these
in one step.  If we wanted to do this with a specified address, we could use
[[forContractAt|`forContractAt`]].

Yet another way would be:
```typescript
import { forContractInstance } from "@truffle/decoder";
const contract = artifacts.require("Contract");
const otherContract = artifacts.require("OtherContract");
const deployedContract = await contract.deployed();
const instanceDecoder = await Decoder.forContractInstance(deployedContract, [otherContract]);
const variables = await instanceDecoder.variables();
```

These examples are not exhaustive.

One can find more advanced decoding examples with
[[ContractInstanceDecoder.variable|`variable`]] and
[[ContractInstanceDecoder.watchMappingKey|`watchMappingKey`]] at the
documentation for these individual functions.
 *
 * @module @truffle/decoder
 * @packageDocumentation
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forAddress = exports.forContractInstance = exports.forContractAt = exports.forArtifactAt = exports.forDeployedContract = exports.forDeployedArtifact = exports.forContract = exports.forArtifact = exports.forProject = exports.NoProviderError = exports.VariableNotFoundError = exports.InvalidAddressError = exports.ContractAllocationFailedError = exports.ContractNotFoundError = exports.ContractBeingDecodedHasNoNodeError = exports.ProjectDecoder = exports.ContractInstanceDecoder = exports.ContractDecoder = void 0;
const decoders_1 = __webpack_require__(95532);
Object.defineProperty(exports, "ContractDecoder", ({ enumerable: true, get: function () { return decoders_1.ContractDecoder; } }));
Object.defineProperty(exports, "ContractInstanceDecoder", ({ enumerable: true, get: function () { return decoders_1.ContractInstanceDecoder; } }));
Object.defineProperty(exports, "ProjectDecoder", ({ enumerable: true, get: function () { return decoders_1.ProjectDecoder; } }));
var errors_1 = __webpack_require__(13552);
Object.defineProperty(exports, "ContractBeingDecodedHasNoNodeError", ({ enumerable: true, get: function () { return errors_1.ContractBeingDecodedHasNoNodeError; } }));
Object.defineProperty(exports, "ContractNotFoundError", ({ enumerable: true, get: function () { return errors_1.ContractNotFoundError; } }));
Object.defineProperty(exports, "ContractAllocationFailedError", ({ enumerable: true, get: function () { return errors_1.ContractAllocationFailedError; } }));
Object.defineProperty(exports, "InvalidAddressError", ({ enumerable: true, get: function () { return errors_1.InvalidAddressError; } }));
Object.defineProperty(exports, "VariableNotFoundError", ({ enumerable: true, get: function () { return errors_1.VariableNotFoundError; } }));
Object.defineProperty(exports, "NoProviderError", ({ enumerable: true, get: function () { return errors_1.NoProviderError; } }));
const codec_1 = __webpack_require__(20102);
/**
 * **This function is asynchronous.**
 *
 * Constructs a project decoder for the project.
 * See the [[DecoderSettings]] documentation for further information.
 * @category Provider-based Constructor
 */
function forProject(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let compilations = codec_1.Compilations.Utils.infoToCompilations(settings.projectInfo);
        let ensSettings = ensSettingsForInfo(settings);
        let decoder = new decoders_1.ProjectDecoder(compilations, settings.provider, ensSettings, settings.selectorDirectory);
        yield decoder.init();
        return decoder;
    });
}
exports.forProject = forProject;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract decoder for a given contract artifact.
 * @param artifact The artifact for the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!settings.projectInfo) {
            settings = Object.assign(Object.assign({}, settings), { projectInfo: { artifacts: [artifact] } });
        }
        let projectDecoder = yield forProject(settings);
        return yield projectDecoder.forArtifact(artifact);
    });
}
exports.forArtifact = forArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract decoder for a given contract.
 * @param contract The contract constructor object corresponding to the type of
 *   the contract.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forArtifact(contract, Object.assign({ provider: contract.web3.currentProvider }, settings));
    });
}
exports.forContract = forContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a deployed contract instance.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forDeployedArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forArtifact(artifact, settings);
        let instanceDecoder = yield contractDecoder.forInstance();
        return instanceDecoder;
    });
}
exports.forDeployedArtifact = forDeployedArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a deployed contract instance.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on just the
 *   single contract provided; it is recommended to pass more information to get the
 *   decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forDeployedContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forContract(contract, settings);
        let instanceDecoder = yield contractDecoder.forInstance();
        return instanceDecoder;
    });
}
exports.forDeployedContract = forDeployedContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forArtifactAt(artifact, address, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forArtifact(artifact, settings);
        let instanceDecoder = yield contractDecoder.forInstance(address);
        return instanceDecoder;
    });
}
exports.forArtifactAt = forArtifactAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on just the
 *   single contract provided; it is recommended to pass more information to get the
 *   decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forContractAt(contract, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractDecoder = yield forContract(contract, settings);
        let instanceDecoder = yield contractDecoder.forInstance(address);
        return instanceDecoder;
    });
}
exports.forContractAt = forContractAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a given contract instance.
 * @param contract The contract abstraction object corresponding to the contract instance.
 * @param settings The [[DecoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the decoder will be based on just the
 *   single contract provided; it is recommended to pass more information to get the
 *   decoder's full power.
 * @category Truffle Contract-based Constructor
 */
function forContractInstance(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forContractAt(contract.constructor, contract.address, settings);
    });
}
exports.forContractInstance = forContractInstance;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a given instance of a contract in this
 * project.  Unlike the other functions, this method doesn't require giving an
 * artifact for the address itself; however, the address had better correspond to
 * a contract of a type given in the project info, or you'll get an exception.
 * @param address The address of the contract instance to decode.
 *   If an invalid address is provided, this method will throw an exception.
 * @param settings The [[DecoderSettings]] to use, including the provider;
 *   see the documentation for that type for more information.
 * @category Provider-based Constructor
 */
function forAddress(address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let projectDecoder = yield forProject(settings);
        return yield projectDecoder.forAddress(address);
    });
}
exports.forAddress = forAddress;
//warning: copypasted from @truffle/encoder!
//Also the category is fake but is put here to hide it :P
/**
 * @category Provider-based constructor
 */
function ensSettingsForInfo(settings) {
    if (settings.ens) {
        return settings.ens;
    }
    else {
        return {
            provider: settings.provider
        };
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 12165:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProviderAdapter = exports.formatBlockSpecifier = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("decoder:adapter");
const stringWhitelist = ["latest", "pending", "genesis", "earliest"];
const formatBlockSpecifier = (block) => {
    if (typeof block === "string" && stringWhitelist.includes(block)) {
        // block is one of 'latest', 'pending', 'earliest', or 'genesis'
        return block === "genesis"
            ? // convert old web3 input format which uses 'genesis'
                "earliest"
            : block;
    }
    else if (typeof block === "string" && !isNaN(parseInt(block))) {
        // block is a string representation of a number
        if (block.startsWith("0x"))
            return block;
        // convert to hex and add '0x' prefix in case block is decimal
        return `0x${parseInt(block).toString(16)}`;
    }
    else if (typeof block === "number") {
        return `0x${block.toString(16)}`;
    }
    else {
        throw new Error("The block specified must be a number or one of the strings 'latest'," +
            "'pending', or 'earliest'.");
    }
};
exports.formatBlockSpecifier = formatBlockSpecifier;
const formatBlock = (block) => {
    return Object.assign(Object.assign({}, block), { number: parseInt(block.number), size: parseInt(block.size), gasLimit: parseInt(block.gasLimit), gasUsed: parseInt(block.gasUsed), timestamp: parseInt(block.timestamp) });
};
// EIP-1193 providers use `request()` instead of `send()`
// NOTE this provider returns `response.result` already unwrapped
// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1193.md
const isEip1193Provider = (provider) => "request" in provider;
/**
 * @hidden
 */
class ProviderAdapter {
    constructor(provider) {
        this.provider = provider;
    }
    request({ method, params, formatOutput }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.provider) {
                throw new Error("There is not a valid provider present.");
            }
            let result;
            if (isEip1193Provider(this.provider)) {
                result = yield this.provider.request({
                    method,
                    params
                });
            }
            else {
                // HACK MetaMask's injected provider doesn't allow `.send()` with
                // a callback, so prefer `.sendAsync()` if it's defined
                const send = ("sendAsync" in this.provider
                    ? // uses `any` because LegacyProvider type doesn't define sendAsync
                        this.provider.sendAsync
                    : this.provider.send).bind(this.provider);
                // HACK this uses a manual `new Promise` instead of promisify because
                // users reported difficulty running this package in a browser extension
                result = yield new Promise((accept, reject) => send({
                    jsonrpc: "2.0",
                    id: new Date().getTime(),
                    method,
                    params
                }, ((error, response) => {
                    if (error) {
                        return reject(error);
                    }
                    if (response.error) {
                        return reject(response.error);
                    }
                    return accept(response.result);
                })));
            }
            if (formatOutput)
                return formatOutput(result);
            return result;
        });
    }
    call(fromAddress, contractAddress, data, blockNumber) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockToFetch = (0, exports.formatBlockSpecifier)(blockNumber);
            return yield this.request({
                method: "eth_call",
                params: [
                    {
                        from: fromAddress,
                        to: contractAddress,
                        data: data
                    },
                    blockToFetch
                ]
            });
        });
    }
    getCode(address, block //making this one not regularized to support encoder
    ) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockToFetch = (0, exports.formatBlockSpecifier)(block);
            return yield this.request({
                method: "eth_getCode",
                params: [address, blockToFetch]
            });
        });
    }
    getBlockByNumber(block) {
        return __awaiter(this, void 0, void 0, function* () {
            const blockToFetch = (0, exports.formatBlockSpecifier)(block);
            return yield this.request({
                method: "eth_getBlockByNumber",
                params: [blockToFetch, false],
                formatOutput: formatBlock
            });
        });
    }
    getPastLogs({ address, fromBlock, toBlock }) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({
                method: "eth_getLogs",
                params: [{ fromBlock, toBlock, address }]
            });
        });
    }
    getNetworkId() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({
                method: "net_version",
                params: [],
                formatOutput: result => parseInt(result)
            });
        });
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({
                method: "eth_blockNumber",
                params: [],
                formatOutput: result => parseInt(result)
            });
        });
    }
    getBalance(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({
                method: "eth_getBalance",
                params: [address, (0, exports.formatBlockSpecifier)(block)],
                formatOutput: result => parseInt(result).toString()
            });
        });
    }
    getTransactionCount(address, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({
                method: "eth_getTransactionCount",
                params: [address, (0, exports.formatBlockSpecifier)(block)],
                formatOutput: result => parseInt(result).toString()
            });
        });
    }
    getStorageAt(address, position, block) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.request({
                method: "eth_getStorageAt",
                params: [
                    address,
                    `0x${position.toString(16)}`,
                    (0, exports.formatBlockSpecifier)(block)
                ]
            });
        });
    }
}
exports.ProviderAdapter = ProviderAdapter;
//# sourceMappingURL=adapter.js.map

/***/ }),

/***/ 13247:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractInstanceEncoder = exports.ContractEncoder = exports.ProjectEncoder = void 0;
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("encoder:encoders");
const bignumber_1 = __webpack_require__(833);
const address_1 = __webpack_require__(92936);
const Codec = __importStar(__webpack_require__(20102));
const Abi = __importStar(__webpack_require__(7651));
const big_js_1 = __importDefault(__webpack_require__(13012));
const web3_utils_1 = __importDefault(__webpack_require__(18269));
const adapter_1 = __webpack_require__(12165);
const Utils = __importStar(__webpack_require__(89916));
const errors_1 = __webpack_require__(79);
const compile_common_1 = __webpack_require__(29833);
//sorry for untyped imports!
const { default: ENS, getEnsAddress } = __webpack_require__(26143);
const nonIntegerMessage = "Input value was not an integer";
/**
 * The ProjectEncoder class.  Can wrap values; can also encode transactions and
 * resolve overloads if sufficient information is provided.  See below for a
 * method listing.
 * @category Encoder
 */
class ProjectEncoder {
    /**
     * @protected
     */
    getAllocations() {
        return this.allocations;
    }
    /**
     * @protected
     */
    getUserDefinedTypes() {
        return this.userDefinedTypes;
    }
    /**
     * @protected
     */
    getNetworkId() {
        return this.networkId;
    }
    /**
     * @protected
     */
    getReferenceDeclarations() {
        return this.referenceDeclarations;
    }
    /**
     * @protected
     */
    constructor(info) {
        this.registryAddress = undefined;
        this.ensCache = {};
        this.contractsAndContexts = [];
        //first, set up the basic info that we need to run
        if (info.userDefinedTypes && info.allocations) {
            debug("internal route!");
            this.userDefinedTypes = info.userDefinedTypes;
            this.allocations = info.allocations;
        }
        else {
            if (!info.compilations) {
                throw new errors_1.NoInternalInfoError();
            }
            //check for repeat compilation IDs
            const repeatIds = Codec.Compilations.Utils.findRepeatCompilationIds(info.compilations);
            if (repeatIds.size !== 0) {
                throw new Codec.RepeatCompilationIdError([...repeatIds]);
            }
            //since that's good, save it and continue
            this.compilations = info.compilations;
            ({
                definitions: this.referenceDeclarations,
                types: this.userDefinedTypes
            } = Codec.Compilations.Utils.collectUserDefinedTypesAndTaggedOutputs(info.compilations));
            let allocationInfo;
            ({ allocationInfo, contractsAndContexts: this.contractsAndContexts } =
                Codec.AbiData.Allocate.Utils.collectAllocationInfo(info.compilations));
            this.allocations = {};
            //only doing the relevant allocations: abi & calldata
            this.allocations.abi = Codec.AbiData.Allocate.getAbiAllocations(this.userDefinedTypes);
            this.allocations.calldata = Codec.AbiData.Allocate.getCalldataAllocations(allocationInfo, this.referenceDeclarations, this.userDefinedTypes, this.allocations.abi);
        }
        this.provider = info.provider || null;
        debug("provider: %o", this.provider);
        if (info.registryAddress !== undefined) {
            this.registryAddress = info.registryAddress;
        }
        debug("registryAddress: %o", this.registryAddress);
        this.networkId = info.networkId || null;
    }
    /**
     * @protected
     */
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.provider) {
                debug("provider given!");
                if (this.registryAddress !== undefined) {
                    debug("using custom registry address: %o", this.registryAddress);
                    this.ens = new ENS({
                        provider: this.provider,
                        ensAddress: this.registryAddress
                    });
                }
                else {
                    //if we weren't given a registry address, we use the default one,
                    //but what is that?  We have to look it up.
                    //NOTE: ENS is supposed to do this for us in the constructor,
                    //but due to a bug it doesn't.
                    debug("using default registry address");
                    const networkId = yield new adapter_1.ProviderAdapter(this.provider).getNetworkId();
                    const registryAddress = getEnsAddress(networkId);
                    if (registryAddress) {
                        this.ens = new ENS({
                            provider: this.provider,
                            ensAddress: registryAddress
                        });
                    }
                    else {
                        //there is no default registry on this chain
                        this.ens = null;
                    }
                }
            }
            else {
                debug("no provider given, ens off");
                this.ens = null;
            }
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This is a restricted version of [[wrap]], which only handles elementary
     * types and values (those that can be used as mapping keys in Solidity);
     * it's present here for type convenience.  See the [[wrap]] and
     * [[ContractEncoder.encodeTransaction]] documentation
     * for further information.
     */
    wrapElementaryValue(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.wrap(dataType, input));
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method recognizes user input for a given data type and attempts
     * to interpret it as a value of that type.  It will throw a
     * [[TypeMismatchError]] if it cannot do this.
     *
     * For documentation of the accepted forms of input, see
     * [[ContractEncoder.encodeTransaction]].
     *
     * @param dataType The data type that the given value is to be interpreted
     *   as.
     * @param input The value to be interpreted.  This can take a number of
     *   forms depending on the data type, as documented above.
     * @return The interpreted value wrapped as a [[Format.Values.Value|Value]]
     *   object.
     */
    wrap(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.driveGenerator(Codec.Wrap.wrap(dataType, input, {
                userDefinedTypes: this.userDefinedTypes,
                loose: true
            }));
        });
    }
    /**
     * @protected
     */
    wrapForTransaction(method, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("wrapForTransaction");
            return yield this.driveGenerator(Codec.Wrap.wrapForMethod(method, inputs, Object.assign({ userDefinedTypes: this.userDefinedTypes }, options)));
        });
    }
    /**
     * @protected
     */
    resolveAndWrap(methods, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.driveGenerator(Codec.Wrap.resolveAndWrap(methods, inputs, Object.assign({ userDefinedTypes: this.userDefinedTypes }, options)));
        });
    }
    driveGenerator(generator) {
        return __awaiter(this, void 0, void 0, function* () {
            let response;
            let next = generator.next();
            while (!next.done) {
                const request = next.value;
                debug("request: %O", request);
                // @ts-ignore: HACK HACK to make typedoc work
                // (the TS is fine with strict null checks on,
                // but typedoc has it turned off, so... :-/ )
                // please remove this ts-ignore once you turn on
                // strict null checks in typedoc
                response = yield this.respond(request);
                debug("response: %O", response);
                next = generator.next(response);
            }
            debug("returning: %O", next.value);
            return next.value;
        });
    }
    respond(request) {
        return __awaiter(this, void 0, void 0, function* () {
            switch (request.kind) {
                case "integer":
                    return this.recognizeInteger(request.input);
                case "decimal":
                    return this.recognizeDecimal(request.input);
                case "address":
                    return yield this.recognizeAddress(request.name);
            }
        });
    }
    /**
     * @protected
     */
    encodeTxNoResolution(method, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("encoding transaction");
            const resolution = yield this.wrapForTransaction(method, inputs, options);
            const data = (Codec.AbiData.Encode.encodeTupleAbiWithSelector(resolution.arguments, Codec.Conversion.toBytes(resolution.method.selector), this.allocations.abi));
            //note that the data option on resolution.options is ignored;
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            let encoded = Object.assign(Object.assign({}, resolution.options), { data: Codec.Conversion.toHexString(data) });
            if (method.abi.type === "constructor") {
                delete encoded.to;
            }
            return encoded;
        });
    }
    /**
     * @protected
     */
    encodeTransaction(methods, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            debug("resolve & encode");
            const resolution = yield this.resolveAndWrap(methods, inputs, options);
            const data = (Codec.AbiData.Encode.encodeTupleAbiWithSelector(resolution.arguments, Codec.Conversion.toBytes(resolution.method.selector), this.allocations.abi));
            //note that the data option on resolution.options is ignored;
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            return {
                tx: Object.assign(Object.assign({}, resolution.options), { data: Codec.Conversion.toHexString(data) }),
                abi: resolution.method.abi
            };
        });
    }
    recognizeInteger(input) {
        if (Utils.isBigNumber(input)) {
            if (input.isInteger()) {
                return {
                    kind: "integer",
                    value: BigInt(input.toFixed())
                };
            }
            else {
                return {
                    kind: "integer",
                    value: null,
                    reason: nonIntegerMessage,
                    partiallyRecognized: true
                };
            }
        }
        else if (Utils.isEthersBigNumber(input)) {
            const asHexString = input.toHexString();
            const asBigInt = asHexString[0] === "-"
                ? -BigInt(asHexString.slice(1))
                : BigInt(asHexString);
            return {
                kind: "integer",
                value: asBigInt
            };
        }
        else if (bignumber_1.FixedNumber.isFixedNumber(input)) {
            //they had to make this one a pain...
            const asString = input.toString();
            //problem: the string might still have trailing ".0" on the end,
            //so let's run it through something that recognizes that (hack?)
            const asBig = new big_js_1.default(asString);
            if (Codec.Conversion.countDecimalPlaces(asBig) === 0) {
                return {
                    kind: "integer",
                    value: BigInt(asBig.toFixed())
                };
            }
            else {
                return {
                    kind: "integer",
                    value: null,
                    reason: nonIntegerMessage,
                    partiallyRecognized: true
                };
            }
        }
        else {
            return {
                kind: "integer",
                value: null
            };
        }
    }
    recognizeDecimal(input) {
        if (Utils.isBigNumber(input)) {
            if (input.isFinite()) {
                return {
                    kind: "decimal",
                    value: new big_js_1.default(input.toFixed())
                };
            }
            else {
                return {
                    kind: "decimal",
                    value: null,
                    reason: "Input was not a finite value",
                    partiallyRecognized: true
                };
            }
        }
        else if (Utils.isEthersBigNumber(input)) {
            //as before, this has to come after
            return {
                kind: "decimal",
                value: new big_js_1.default(input.toString())
            };
        }
        else if (bignumber_1.FixedNumber.isFixedNumber(input)) {
            return {
                kind: "decimal",
                value: new big_js_1.default(input.toString())
            };
        }
        else {
            return {
                kind: "decimal",
                value: null
            };
        }
    }
    recognizeAddress(input) {
        return __awaiter(this, void 0, void 0, function* () {
            let address = null;
            try {
                address = (0, address_1.getAddress)(input); //maybe it's an ICAP address?
                return {
                    kind: "address",
                    address
                };
            }
            catch (error) {
                debug("address error: %O", error);
                if (!error) {
                    throw error; //rethrow unepxected errors
                }
                switch (error.reason) {
                    case "bad address checksum":
                        //note: this won't be visible because we've already
                        //checked this for ourselves
                        return {
                            kind: "address",
                            address: null,
                            reason: Codec.Wrap.Messages.checksumFailedMessage,
                            partiallyRecognized: true
                        };
                    case "bad icap checksum":
                        return {
                            kind: "address",
                            address: null,
                            reason: "ICAP address had bad checksum",
                            partiallyRecognized: true
                        };
                    case "invalid address":
                        //in this case, try resolving it as an ENS name
                        const address = yield this.resolveEnsName(input);
                        if (address !== null) {
                            return {
                                kind: "address",
                                address
                            };
                        }
                        else {
                            return {
                                kind: "address",
                                address: null,
                                reason: "Input was not recognizable as an address or ENS name"
                            };
                        }
                    default:
                        throw error; //rethrow unexpected errors
                }
            }
        });
    }
    resolveEnsName(input) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.ens === null) {
                return null;
            }
            if (input in this.ensCache) {
                return this.ensCache[input];
            }
            let address;
            try {
                address = yield this.ens.name(input).getAddress();
            }
            catch (_a) {
                //Normally I'd rethrow unexpected errors, but given the context here
                //that seems like it might be a problem
                address = null;
            }
            if (address === Codec.Evm.Utils.ZERO_ADDRESS) {
                //ENS returns zero address to indicate "not found"
                address = null;
            }
            this.ensCache[input] = address;
            return address;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract encoder for a given contract in this project.
     * @param artifact The contract the encoder is for.  If you want to
     *   encode contract creation transactions, it must have all of
     *   its libraries linked.
     *
     *   Note: The contract must be one that the encoder knows about;
     *   otherwise you will have problems.
     */
    forArtifact(artifact) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.compilations) {
                throw new errors_1.NoCompilationsForSpawnerError();
            }
            let { compilation, contract } = Codec.Compilations.Utils.findCompilationAndContract(this.compilations, artifact);
            //to be *sure* we've got the right ABI, we trust the input over what was
            //found
            contract = Object.assign(Object.assign({}, contract), { abi: artifact.abi });
            return new ContractEncoder(this, compilation, contract, artifact);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract encoder for a given contract in this project.
     * @param contract The contract the encoder is for.  If you want to
     *   encode contract creation transactions, it must have all of
     *   its libraries linked.
     *
     *   Note: The contract must be one that the encoder knows about;
     *   otherwise you will have problems.
     */
    forContract(contract) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.forArtifact(contract);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance encoder for a given contract instance.
     * @param artifact The artifact for the contract the encoder is for.  If you
     *   want to encode contract creation transactions, it must have all of its
     *   libraries linked.
     *
     *   Note: The contract must be one that the encoder knows about;
     *   otherwise you will have problems.
     * @param address The address of the contract instance.
     *   If omitted, but the project encoder has a provider or network ID,
     *   it will be autodetected.  If there is no provider or network ID,
     *   it must be included.
     *
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(artifact, address) {
        return __awaiter(this, void 0, void 0, function* () {
            const contractEncoder = yield this.forArtifact(artifact);
            return yield contractEncoder.forInstance(address);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance encoder for a given instance of a contract in this
     * project.  Unlike [[forInstance]], this method doesn't require an artifact; it
     * will automatically detect the class of the given contract.  If it's not in
     * the project, or the encoder can't identify it, you'll get an exception.
     * @param address The address of the contract instance to encoder for.
     *   If an invalid address is provided, this method will throw an exception.
     * @param block You can include this argument to specify that this should be
     *   based on the addresses content's at a specific block (if say the contract
     *   has since self-destructed).
     */
    forAddress(address, block = "latest") {
        return __awaiter(this, void 0, void 0, function* () {
            //code duplication warning: this method is basically copypasted
            //from the decoder!
            if (!this.compilations) {
                throw new errors_1.NoCompilationsForSpawnerError();
            }
            if (this.provider === null) {
                throw new errors_1.NoNetworkError();
            }
            if (!web3_utils_1.default.isAddress(address)) {
                throw new errors_1.InvalidAddressError(address);
            }
            address = web3_utils_1.default.toChecksumAddress(address);
            const deployedBytecode = yield new adapter_1.ProviderAdapter(this.provider).getCode(address, block);
            const contractAndContexts = this.contractsAndContexts.find(({ deployedContext }) => deployedContext &&
                Codec.Contexts.Utils.matchContext(deployedContext, deployedBytecode));
            if (!contractAndContexts) {
                throw new errors_1.ContractNotFoundError(undefined, undefined, deployedBytecode, address);
            }
            const { contract, compilationId } = contractAndContexts;
            const compilation = this.compilations.find(compilation => compilation.id === compilationId);
            if (!compilation) {
                throw new errors_1.ContractNotFoundError(undefined, undefined, deployedBytecode, address);
            }
            //no artifact... hope you don't need to link any bytecode!
            const contractEncoder = new ContractEncoder(this, compilation, contract);
            return yield contractEncoder.forInstance(address);
        });
    }
}
exports.ProjectEncoder = ProjectEncoder;
/**
 * The ContractEncoder class.
 * Can encode transactions, resolve overloads, and wrap values.
 * See below for a method listing.
 * @category Encoder
 */
class ContractEncoder {
    /**
     * Just used for testing, currently
     * @protected
     */
    getProjectEncoder() {
        return this.projectEncoder;
    }
    /**
     * @protected
     */
    constructor(projectEncoder, compilation, contract, artifact) {
        this.projectEncoder = projectEncoder;
        this.contract = contract;
        this.abi = Abi.normalize(contract.abi);
        this.artifact = artifact;
        this.compilation = compilation;
        this.contractNode = Codec.Compilations.Utils.getContractNode(this.contract, this.compilation);
        //set up constructor binary w/resolved link references
        const networkId = this.projectEncoder.getNetworkId();
        const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode); //sorry, codec still uses legacy, to be changed in future
        const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);
        //determine linked bytecode -- we'll determine it ourself rather than
        //using contract.binary
        const links = networkId !== null
            ? (((artifact || { networks: {} }).networks || {})[networkId] || {
                links: {}
            }).links || {}
            : {};
        this.constructorBinary = Utils.link(bytecode, links);
        //now, set up context hashes
        if (bytecode && bytecode !== "0x") {
            this.constructorContextHash = Codec.Conversion.toHexString(Codec.Evm.Utils.keccak256({
                type: "string",
                value: bytecode //has link references unresolved
            }));
        }
        if (deployedBytecode && deployedBytecode !== "0x") {
            this.deployedContextHash = Codec.Conversion.toHexString(Codec.Evm.Utils.keccak256({
                type: "string",
                value: deployedBytecode //has link references unresolved
            }));
        }
        else {
            //if there's no bytecode, allocate input data manually
            const compiler = this.compilation.compiler || this.contract.compiler;
            this.noBytecodeAllocations = Object.values(Codec.AbiData.Allocate.getCalldataAllocations([
                {
                    abi: this.abi,
                    compilationId: this.compilation.id,
                    //@ts-ignore sorry this is what happens when you mix strictNullChecks on with off
                    compiler,
                    contractNode: this.contractNode,
                    deployedContext: Codec.Contexts.Utils.makeContext(Object.assign(Object.assign({}, this.contract), { deployedBytecode: "0x" //only time this should ever appear in a context!
                     }), this.contractNode, this.compilation)
                }
            ], this.projectEncoder.getReferenceDeclarations(), this.projectEncoder.getUserDefinedTypes(), this.projectEncoder.getAllocations().abi).functionAllocations)[0];
        }
    }
    /**
     * See [[ProjectEncoder.wrapElementaryValue]].
     */
    wrapElementaryValue(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectEncoder.wrapElementaryValue(dataType, input);
        });
    }
    /**
     * See [[ProjectEncoder.wrap]].
     */
    wrap(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.projectEncoder.wrap(dataType, input);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method recognizes user input for a transaction.  It will throw
     * a [[TypeMismatchError]] if it cannot do this.  This method requires
     * that the precise function be specified; it does not perofrm overload
     * resolution.  See [[encodeTransaction]] for documentation of the accepted
     * forms of input.
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.
     *
     * Note that use of the encoder for transactions to be sent to libraries is
     * presently not supported and may have unreliable results.  Limited support
     * for this is planned for future versions.
     *
     * @param method ABI entry for the transaction being prepared.  Must be one
     *   associated with this contract.  Can be for either a function or a
     *   constructor.
     * @param inputs An array of the inputs to the transaction.  May include a
     *   transaction options argument on the end if the `allowOptions` flag is
     *   set.
     * @param options Contains options to control the operation of this method.
     * @return The interpretation of the input, as a
     *   [[Resolution]] object.
     */
    wrapForTransaction(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = this.getMethod(abi);
            return yield this.projectEncoder.wrapForTransaction(method, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method attempts to perform overload resolution given user input
     * to one of several possible methods.  If the given input matches more than
     * one of these methods, it will attempt to select the best match.  See
     * [[encodeTransaction]] for documentation of the acccepted input forms.
     *
     * If it is not possible for the given input to match any of the given methods,
     * either a [[TypeMismatchError]] or a
     * [[NoOverloadsMatchedError]] will be
     * thrown.  If more than one overload matches but none can be considered the
     * unique best, you will get a
     * [[NoUniqueBestOverloadError]].
     * If due to inputting a nonexistent function name there are no overloads to
     * check, you will get a [[NoFunctionByThatNameError]].
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.
     *
     * Note that use of the encoder for transactions to be sent to libraries is
     * presently not supported and may have unreliable results.  Limited support
     * for this is planned for future versions.
     *
     * **Overload resolution system**
     *
     * If it is necessary to perform overload resolution by type rather than
     * simply by length, the encoder will select among the overloads that
     * could work the one it considers to be the best match.  To be the best
     * match, it must be a best match for each argument.  An overload is
     * a best match for a given argument if the type it would assign that
     * argument is highest-priority among all types it could assign that
     * argument (selected from overloads that match overall).
     *
     * Note that when doing this the match checker will be somewhat stricter than
     * usual; inputs for structs/tuples will not be allowed to contain extra
     * keys, numeric input (including odd-length hex strings)
     * will not be accepted for dynamic-length bytestrings,
     * and if a value is given as a [[Format.Values.Value|Value]], it
     * will only match its specific type, rather than being allowed to match
     * other types as usual (unless it is itself wrapped in a type/value pair).
     *
     * The overall order of priority of types is as follows:
     * 1. transaction options
     * 2. arrays
     * 3. structs and tuples
     * 4. addresses and contracts
     * 5. bytestrings (`bytesN` and `bytes`)
     * 6. external function pointers
     * 7. numeric types
     * 8. `enum`s
     * 9. `string` [is #10 with `strictBooleans`]
     * 10. `bool` [is #9 with `strictBooleans`]
     *
     * (Note that if the encoder does not know that a certain argument is
     * supposed to be an enum, it will of course just be treated as the
     * underlying numeric type.)
     *
     * (If the `strictBooleans` option is passed, the priority order of `string`
     * and `bool` is swapped.)
     *
     * Moreover, within each category there is a priority ordering (which is
     * not always total).  Specifically:
     * * For arrays, if `S` has priority over `T`, then `S[]` has priority
     *   over `T[]`, and `S[n]` has priority over `T[n]`.  Moreover, `S[n]`
     *   has priority over `S[]` and so also over `T[]`.
     * * Structs and tuples mostly act the same as the overall arguments list; for
     *   one such type `S` to have priority over another type `T`, each
     *   member type of `S` must have priority over the corresponding member type
     *   of `T` (correspondence being determined by the order of the members).
     *   However, if the two types `S` and `T` also have exactly the same
     *   component names (and each has all of its components named), then
     *   this will also be checked with correspondence by name instead of
     *   position, and `S` will only be considered more specific than `T` if
     *   both checks pass.
     * * `bytesN` has priority over `bytesM` if `N<=M`, and has priority over
     *   `bytes`
     * * A numeric type `S` has priority over a numeric type `T` if the values
     *   representable by `S` are a subset of those representable by `T`.
     *
     * If you are not getting the overload you want, you can use explicit
     * type-value input as discussed in the documentation for
     * [[encodeTransaction]], or you can skip overload resolution and explicitly
     * select an overload by other means.  For enums you may also specify the
     * enum type as documented in [[encodeTransaction]].
     *
     * @param abisOrNameOrSig The ABI entries for the overloads, or the name or
     *   full signature of the function.  Note that if you are inputting ABI
     *   entries, they must be for functions, not constructors.  The entries must
     *   be ones associated with this contract.
     * @param inputs An array of the inputs to the transaction.  May include a
     *   transaction options argument on the end if the `allowOptions` flag is
     *   set.
     * @param options Contains options to control the operation of this method.
     * @return The interpretation of the input and the resolved method, as a
     *   [[Resolution]] object.
     */
    resolveAndWrap(abisOrNameOrSig, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const abis = this.getAbis(abisOrNameOrSig);
            const methods = abis.map(abi => this.getMethod(abi));
            //note we can't just write abis.map(this.getMethod)
            //because this would be undefined inside of it... I could
            //write abis.map(this.getMethod.bind(this)), but I find the
            //arrow way to be more readable
            return yield this.projectEncoder.resolveAndWrap(methods, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method is similar to [[encodeTransaction]], except that it does not
     * perform overload resolution; it takes a single ABI entry, rather than a
     * list of them or a function name.  Note that unlike [[encodeTransaction]],
     * it can also encode contract creation transactions.
     *
     * Because this method does not perform overload resolution, it only returns
     * the resulting transaction options (including the encoded `data`), and does
     * not bother returning the ABI used (as this was user-supplied.)
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.  Any non-`data` options not specified in such a transaction
     * options argument will be simply omitted; it you want some options to have
     * defaults, it is up to the you to set these options as appropriate
     * afterwards.
     *
     * If the transaction options parameter has a `data` option, this option will
     * be recognized but ignored.  Similarly, when encoding a contract creation,
     * the `to` option will also be ignored.
     *
     * See [[encodeTransaction]] for documentation of most of the inputs.
     *
     * @param abi The ABI entry for the transaction to encode for.  Note it must
     *   be one for this contract.  May be for either a function or a constructor.
     * @return The resulting transaction options, including the encoded `data`.
     */
    encodeTxNoResolution(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = this.getMethod(abi);
            return yield this.projectEncoder.encodeTxNoResolution(method, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method recognizes user input for a given set of contract methods,
     * attempts to interpret it as valid input for one of them, and then
     * encodes the result.  (That is to say, it performs overload resolution,
     * then encodes.)  Note that this method cannot be used to encode contract
     * creations; use [[encodeTxNoResolution]] for that.
     *
     * If this method cannot match the user input to any of the possible
     * overloads, it will throw a [[TypeMismatchError]] or a
     * [[NoOverloadsMatchedError]].  If more than one overload matches but none
     * can be considered the unique best, you will get a
     * [[NoUniqueBestOverloadError]].  If due to inputting a nonexistent function
     * name there are no overloads to check, you will get a
     * [[NoFunctionByThatNameError]].  See below for a full list of the accepted
     * forms of input, and see [[resolveAndWrap]] for full documentation of the
     * overload resolution system.
     *
     * Be aware that overload resolution may not always be fully reliable; if you
     * want to be absolutely certain that you get the right overload, you can use
     * [[encodeTxNoResolution]], which does not perform overload resolution, but
     * requires you to specify exactly which overload you mean.  However, you can
     * also adjust your input to this function to get the overload you want; see
     * below about `{ type: ..., value: ... }` input and enum string input for
     * details.
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.  Any non-`data` options not specified in such a transaction
     * options argument will be simply omitted; it you want some options to have
     * defaults, it is up to the you to set these options as appropriate
     * afterwards.  Also, if the transaction options parameter has a `data`
     * option, this option will be recognized but ignored.
     *
     * Use of the encoder for transactions to be sent to libraries is
     * presently not supported and may have unreliable results.  Limited support
     * for this is planned for future versions.
     *
     * **Accepted forms of input**
     *
     * The `input` argument may come in a number of forms, depending on the
     * target data type.  A list of the specific inputs accepted for each type is
     * below.  However first we must note a few generic forms that inputs are
     * accepted in.
     *
     * Inputs may be given as an object of the form `{ type: ..., value: ... }`
     * (additional fields not allowed), where `type` is a string describing the
     * type, and `value` is anything that would be accepted for that type (other
     * than another type/value object).  This form of input is not very useful
     * with *this* method, but it is useful when performing overload resolution
     * (see [[resolveAndWrap]]) to restrict the overloads that will be selected
     * from.  Note that for arrays, `type` should simply be `"array"`; for
     * structs and tuples, `"struct"` or `"tuple"`; for addresses and contracts,
     * `"address"` or `"contract"`; for external functions, `"function"`; for
     * transaction options, `"options"`; and for enums, it can be either `"enum"`
     * (or the underlying uint type).  For other Solidity types, it should be the
     * name of the type; note that `"uint"`, `"int"`, `"fixed"`, `"ufixed"`, and
     * `"byte"` are accepted.  Vyper's `"decimal"` type is also accepted.
     * Also, user-defined value types use exactly the same
     * `type` field as the underlying type; this input format does not distinguish
     * between them and the underlying type.
     *
     * Note that input in the form of a [[Format.Values.Value|Value]] is
     * accepted, so long as the type is appropriate, but error results are
     * typically not accepted (exceptions are discussed below).
     *
     * Now then, the list of accepted inputs by type, excluding the above:
     *
     * **Strings**: The input may be given as string (or `String`); note that
     * strings with invalid UTF-16 will not be accepted.  It may also be given as a
     * `Uint8Array` (or anything that mimics one; see below about bytestrings), which
     * will be treated as UTF-8; note that invalid UTF-8 is allowed in this format.
     * Strings may also be given as a [[Format.Values.StringValue|StringValue]].
     *
     * **Integer types**: Input for integer types may take a variety of forms.
     * The input may be a `number` (or `Number`); note that if so it must be a
     * safe integer.  For larger integers, you must use other forms of input.
     * For instance, the input may be a `BigInt`.  The input may also be one
     * of several recognized big number classes:
     *   * [`BN`](https://github.com/indutny/bn.js)
     *   * [`Big`](https://github.com/MikeMcl/Big.js)
     *   * MikeMcl's [`BigNumber`](https://github.com/MikeMcl/bignumber.js)
     *   * Ethers's [`BigNumber` or `FixedNumber`](https://www.npmjs.com/package/@ethersproject/bignumber)
     * Of course, any numeric input, no matter the format, must be integral.
     * Input may also take the form of a numeric string (or `String`).
     * The string may be decimal, but it may also be hexadecimal with `"0x"`
     * prefix, octal with `"0o"` prefix, or binary with `"0xb"` prefix.
     * You can also use a negated hexadecimal, octal, or binary string to
     * represent a negative number.  Whitespace before or after the number is OK,
     * and you may use underscores to separate groups of digits (in any base).
     * For decimal strings, scientific notation (e.g. `1.1e4`) is also accepted.
     * It is also possible to affix one of the units `"wei"`, `"gwei"`,
     * `"shannon"`, `"finney"`, `"szabo"`, or `"ether"` (these are case-insensitive)
     * onto a decimal numeric string (you may include space inbetween the
     * quantity and the unit) to act as a multiplier (where here the
     * assumption is that 1 wei means the number 1).  You may also use a
     * unit by itself, with no specified quantity, to mean 1 of that unit.
     * (E.g., an input of `"wei"` will be interpreted as 1.)  Note that it's OK
     * if the quantity before the unit is not itself an integer, so long as the
     * overall resulting quantity is an integer; e.g., "1.1 gwei" is legal integer
     * input.  In addition to giving the input in any of these obviously numeric
     * forms, the input may also be given a a `Uint8Array` or anything that
     * mimics one (see above about bytestrings); in this case the input will
     * be interpreted as the big-endian byte representation of an unsigned
     * integer (or in other words, it will be interpreted as base 256).
     * Negative numbers cannot be represented in this way.
     * Finally, the input may be given as a
     * [[Format.Values.UintValue|UintValue]],
     * [[Format.Values.IntValue|IntValue]],
     * [[Format.Values.UfixedValue|UfixedValue]],
     * [[Format.Values.FixedValue|FixedValue]],
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of one of these,
     * or [[Format.Values.EnumValue|EnumValue]]; the type is not required to
     * match unless strict checking is on (see [[resolveAndWrap]]), in which case
     * the type must match exactly.  In addition, the input may also be a
     * [[Format.Errors.EnumErrorResult|EnumErrorResult]] so long as
     * the error is a
     * [[Format.Errors.EnumOutOfRangeError|EnumOutOfRangeError]];
     * other types of error results are not accepted.
     *
     * **Enums**: Enums accept all the same forms of input as integer types.
     * However, if the encoder is aware that a particular argument or field is in
     * fact an enum and not just an integer, it accepts one additional form of
     * input; the input may be a string (or `String`) containing the name of the
     * enumerated option.  So, for instance, given the following Solidity code:
     * ```solidity
     * contract MyContract {
     *   enum Ternary {
     *     No, Yes, Maybe
     *   }
     * }
     * ```
     * then `"Yes"` would be a valid input for an enum of type
     * `MyContract.Ternary`.  Moreover, `"Ternary.Yes"` and
     * `"MyContract.Ternary.Yes"` would also work; these latter forms will only
     * match enum types with the appropriate name and optionally defining
     * contract, so you can use these to restrict matching for overload
     * resolution, much like type/value input.  Note these forms do not require
     * the enum to be defined inside of a contract; those defined outside of
     * contracts are supported too, so long as the encoder was initialized to
     * know about them.
     *
     * **Bytestrings**: Bytestrings can be given in several forms.  Note that for
     * all forms of input, if the specified type is `bytesN`, it is OK if the
     * length of the input is shorter than N bytes; it will automatically be
     * right-padded with zero bytes in this case.  (The exception is if the input
     * is a [[Format.Values.BytesValue|BytesValue]] and strict checking is
     * on; see [[resolveAndWrap]].)  Bytestrings may be given as `"0x"`-prefixed
     * even-length hex strings (a `String` may be used in place of a string);
     * underscores may be used to separate groups of hex digits.
     * Bytestrings may also be given as a `Uint8Array`, or anything resembling a
     * `Uint8Array` -- any object with a `length` field which is a `number`, and
     * which has fields from `0` to `length-1` all `number`s from 0 to 255, will
     * be accepted.  Input may also be given as a
     * [[Format.Values.BytesValue|BytesValue]] or a
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]]
     * on top of one; the specific type does not
     * have to match unless strict checking is on.  In addition, a bytestring may be
     * given as an object with just the fields `text` and `encoding`; in this
     * case, `text` should be a string (it must not have invalid UTF-16) and
     * `encoding` an encoding to encode it as.  The only supported encoding
     * currently is `"utf8"`.  Finally, for compatibility with ethers, when
     * strict checking is off (see [[resolveAndWrap]]), a
     * bytestring of dynamic length (`bytes`) may have its input given numerically.
     * The valid formats for this are the same as for integer types, except that
     * wrapped numeric values are not accepted, numeric strings may not use
     * scientific notation or units, and the number may not be negative.  For
     * compatibility reasons, if the number zero is given as input in this way,
     * it will be treated as a bytestring consisting of a single zero byte, rather
     * than the empty bytestring.  Warning: an odd-length hex string will be
     * treated as numeric input!  (Effectively, it will be padded on the left
     * with a zero hex digit.)
     *
     * **Addresses and contracts**: Input may be given as a hex string
     * representing 20 bytes, with capitalization according to the Ethereum
     * address checksum.  The `"0x"` prefix is optional.  If the hex string
     * is all lowercase or all uppercase, however, then the checksum check will
     * be skipped, and the input accepted regardless.  Input may also be given
     * as an ICAP address; again, the checksum must be correct.  Finally, if ENS
     * resolution has been configured, input may be given as an ENS name.
     * All of these may also be given as `String`s instead of strings.
     * Input may also be given as an object with an `address` field, although the
     * contents of that address field must be a `"0x"`-prefixed hex string (not
     * `String`), and not any other address format.  Input may also be given
     * as a [[Format.Values.AddressValue|AddressValue]],
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of such, or
     * [[Format.Values.ContractValue|ContractValue]]; the specific type
     * does not matter.
     *
     * **Booleans**: Unless the `strictBooleans` option is passed, almost any
     * input is accepted (as long as it's not type/value input for a different
     * type), but how it is interpreted depends on the input.  A boolean will be
     * interpreted in the obvious way, and a `Boolean` will be unwrapped.  A
     * string will be considered true unless it is falsy or is equal (ignoring
     * case) to the string `"false"`; however, if `strictBooleans` is passed, then
     * only strings that are (ignoring case) equal to `"true"` or `"false"` will
     * be accepted.  A `String` will be
     * considered true if and only if the underlying string is.  A number will be
     * considered true so long as it is truthy, and a `Number` will be considered
     * true if and only if the underlying number is.  A
     * [[Format.Values.BoolValue|BoolValue]], or
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of such,
     * will be considered true so
     * long as it represents a true value.  Moreover, two types of
     * [[Format.Errors.BoolErrorResult|BoolErrorResult]] also count as
     * true: Those where the error is a
     * [[Format.Errors.BoolOutOfRangeError|BoolOutOfRangeError]] and
     * those where the error is a
     * [[Format.Errors.BoolPaddingError|BoolPaddingError]].  This also applies to
     * a [[Format.Errors.UserDefinedTypeValue|UserDefinedTypeErrors]] on top of one
     * of these.  All other
     * error results, and all [[Format.Values.Value|Values]] that are not
     * [[Format.Values.BoolValue|BoolValues]] or a
     * [[Format.Values.UserDefinedTypeValue|UserDefinedTypeValue]] on top of one,
     * will be rejected.  All other inputs will be considered true so long as
     * they are truthy, unless `strictBooleans` is passed, in which case they will
     * be rejected.
     *
     * **Decimal fixed-point types**: Input for fixed-point decimal types is
     * similar to input for integer types.  The differences are as follows:
     *   * Units are not accepted in numeric strings (or `String`s).
     *   * Hexadecimal, octal, and binary strings (or `String`s) are not
     *     accepted.
     *   * `Uint8Array`s, or objects that mimic them, are not accepted.
     *   * Numeric values do not have to be integral.
     * Note that if the input is a `number` (or `Number`) or MikeMcl
     * [BigNumber](https://github.com/MikeMcl/bignumber.js), it must be a finite
     * value.  Also, the number of decimal places in the input may not exceed the
     * number of decimal places allowed in the type.  Finally, just as integer
     * types do not allow `number`s (or `Number`s) that are unsafe integers as
     * input, decimal types will not accept a `number` (or `Number`) as input if
     * that `number` is outside the safe range for that type, i.e., it is large
     * enough that there may be loss of precision.  (This means that `1` is not
     * valid input for a `fixed128x18`!)  Using other, safer, forms of input is
     * encouraged.
     *
     * **User-defined value types**: These take exactly the same input as the
     * underlying type.
     *
     * **Arrays**: The input may be an array, or it may be a
     * [[Format.Values.ArrayValue|ArrayValue]].  In the latter case,
     * whether it is static-length or dynamic-length does not need to match
     * (unless strict checking is on, see [[resolveAndWrap]]).  If the `allowJson`
     * option is passed, the array may also be a JSON string.  Note that any allowed
     * format is allowed for the individual elements.
     *
     * **Structs and tuples**: The input can be given either as an array or as an
     * object; if the `allowJson` option is passed, it may also be given as a
     * JSON string for one of these (any format is allowed for the individual
     * elements).  If given as an array, the elements should be the members of
     * the struct/tuple, in order.  If given as an object, it should be keyed by
     * the struct or tuple's field names; if any of the elements of the tuple are
     * unnamed, then input cannot be given as an object.  Additional keys are
     * also allowed unless strict checking is on.  Input may also be given as a
     * [[Format.Values.StructValue|StructValue]] or
     * [[Format.Values.TupleValue|TupleValue]]; the specific type does not
     * matter.
     *
     * **External function pointers**: These may be given as an object with fields
     * `address` and `selector` (additional fields are allowed); the `address`
     * field may be anything that would be recognized as an address (see above),
     * and the `selector` field may be anything that would be recgonized as a
     * `bytes4` (see above).  Alternatively, this may be given as a bytestring
     * (even length `"0x"`-prefixed hex string or `String`) of 24 bytes,
     * specifying the address followed by the selector; in this case, the address
     * does not need to be checksummed.  Finally, input may of course also be
     * given as a
     * [[Format.Values.FunctionExternalValue|FunctionExternalValue]];
     * its more specific type does not matter.
     *
     * * Transaction options: These are given as an object with fields for the
     * desired options (you can leave options out or have them be `undefined` and
     * they'll be ignored).  Note that, in order to maintain compatibility with
     * older versions of Truffle, additional keys are accepted, but there must be
     * at least one key that belongs in a transaction options object.  Note that
     * if any field exists, and is not `undefined`, but the value of that field
     * cannot be interpreted as input of the appropriate type, the input will be
     * rejected.  Otherwise, inputs for each field can be anything that the
     * encoder will understand for this field.  Accepted fields are:
     *   * `gas`, `gasPrice`, `value`, `nonce`: These take integer input
     *     (see above).
     *   * `from`, `to`: These take address input (see above).
     *   * `data`: This takes `bytes` input (see above).
     *   * `overwrite`: This takes boolean input (see above).
     *   * `type`: This takes integer input, which must be in the range from
     *     0 to `0xbf`.
     *   * `accessList`: This takes input as if for an array of type `AccessListForAddress[]`,
     *      if `AccessListForAddress` were a struct with two fields, `address` and `storageKeys`,
     *      with `address` being an `address` and `storageKeys` being of type `uint256[]`.
     *      Yes, this means storage keys may be given numerically; it also means that if a
     *      storage key is given as a hex string representing less than 32 bytes, it will be
     *      padded on the left, rather than on the right.
     *   * `privateFor`: This one is a special case, and requires a specific
     *     form of input.  Input must be an array of base64-encoded
     *     bytestrings (as strings or `String`s), each with a decoded length of
     *     32 bytes.
     * In addition, input may also be given as a
     * [[Format.Values.OptionsValue|OptionsValue]].
     *
     * @param abisOrNameOrSig The ABI entries for the overloads, or the name
     *   or full signature of the function.  Note that if you are inputting ABI
     *   entries, they must be for functions, not constructors.  The entries must
     *   be ones associated with this contract.
     * @param input The value to be interpreted.  This can take a number of
     *   forms depending on the data type, as documented above.
     * @return An object with a `tx` field, holding the transaction options,
     *   including the encoded `data`, and an `abi` field, indicating which
     *   ABI entry was used for encoding.
     */
    encodeTransaction(abisOrNameOrSig, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const abis = this.getAbis(abisOrNameOrSig);
            const methods = abis.map(abi => this.getMethod(abi));
            //note we can't just write abis.map(this.getMethod)
            //because this would be undefined inside of it... I could
            //write abis.map(this.getMethod.bind(this)), but I find the
            //arrow way to be more readable
            return yield this.projectEncoder.encodeTransaction(methods, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method is similar to [[encodeTransaction]], except that instead of
     * encoding a function transaction, it encodes a creation transaction.
     *
     * Because this method does not perform overload resolution, it only returns
     * the resulting transaction options (including the encoded `data`), and does
     * not bother returning the ABI used (as this was user-supplied.)
     *
     * If the `allowOptions` flag is set in the `options` argument, the input may
     * contain an additional transaction options argument after the other
     * arguments.  Any non-`data` options not specified in such a transaction
     * options argument will be simply omitted; it you want some options to have
     * defaults, it is up to the you to set these options as appropriate
     * afterwards.
     *
     * If the transaction options parameter has a `data` or a `to` option,
     * these option will be recognized but ignored.
     *
     * See [[encodeTransaction]] for documentation of the inputs.
     */
    encodeCreation(inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const method = this.getConstructorMethod();
            return yield this.projectEncoder.encodeTxNoResolution(method, inputs, options);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * Constructs a contract instance encoder for a given instance of the
     * contract this encoder is for.
     * @param address The address of the contract instance.
     *   If omitted, it will be autodetected.
     *   If an invalid address is provided, this method will throw an exception.
     */
    forInstance(address) {
        return __awaiter(this, void 0, void 0, function* () {
            if (address === undefined) {
                const networkId = this.projectEncoder.getNetworkId();
                if (networkId === null) {
                    throw new errors_1.NoNetworkError();
                }
                address = ((this.artifact || { networks: {} }).networks || {})[networkId]
                    .address;
                if (address === undefined) {
                    throw new errors_1.ContractNotDeployedError(this.contract.contractName, networkId);
                }
            }
            return new ContractInstanceEncoder(this, address);
        });
    }
    getAbis(abisOrNameOrSig) {
        const abis = typeof abisOrNameOrSig === "string"
            ? this.abi.filter((abi) => abi.type === "function" &&
                (abi.name === abisOrNameOrSig ||
                    Codec.AbiData.Utils.abiSignature(abi) === abisOrNameOrSig))
            : abisOrNameOrSig;
        if (typeof abisOrNameOrSig === "string" && abis.length === 0) {
            //we don't throw this if the input was an empty list of ABIs
            //rather than a name... the user knew what they were doing if they
            //did that :P
            throw new errors_1.NoFunctionByThatNameError(abisOrNameOrSig, this.contract.contractName);
        }
        return abis;
    }
    getMethod(abi) {
        abi = Abi.normalizeEntry(abi); //just to be absolutely certain!
        debug("got allocations");
        switch (abi.type) {
            case "constructor":
                return this.getConstructorMethod(abi);
            case "function":
                const allocations = this.projectEncoder.getAllocations();
                const selector = Codec.AbiData.Utils.abiSelector(abi);
                const allocation = this
                    .deployedContextHash
                    ? //@ts-ignore: This is set up earlier
                        allocations.calldata.functionAllocations[this.deployedContextHash][selector].input
                    : this.noBytecodeAllocations[selector].input;
                const inputs = allocation.arguments.map(input => ({ type: input.type, name: input.name || undefined }) //convert "" to undefined
                );
                return {
                    name: abi.name,
                    selector,
                    inputs,
                    abi
                };
        }
    }
    //if you already know the ABI, you can pass it in for convenience.
    //if you don't, we'll find it for you.
    getConstructorMethod(abi) {
        if (!abi) {
            abi = this.getConstructorAbi();
        }
        const allocations = this.projectEncoder.getAllocations();
        debug("constructor binary: %s", this.constructorBinary);
        //first check that we have constructor binary, and that it's all linked
        if (!this.constructorBinary || this.constructorBinary === "0x") {
            throw new errors_1.NoBytecodeError(this.contract.contractName);
        }
        else if (!this.constructorBinary.match(/^0x([0-9a-fA-F]{2})+$/)) {
            throw new errors_1.UnlinkedContractError(this.contract.contractName, this.artifact ? this.artifact.bytecode : undefined);
        }
        //otherwise, we're good to go!
        const allocation = 
        //@ts-ignore: We set this up and checked this earlier
        allocations.calldata.constructorAllocations[this.constructorContextHash].input;
        const inputs = allocation.arguments.map(input => ({ type: input.type, name: input.name || undefined }) //convert "" to undefined
        );
        return {
            selector: this.constructorBinary,
            inputs,
            abi
        };
    }
    getConstructorAbi() {
        return (this.abi.find((abi) => abi.type === "constructor") || Codec.AbiData.Utils.DEFAULT_CONSTRUCTOR_ABI);
    }
}
exports.ContractEncoder = ContractEncoder;
/**
 * The ContractInstanceEncoder class.
 * Can encode transactions, resolve overloads, and wrap values.
 * Differs from the [[ContractEncoder]] only in that it carries
 * a `to` address for non-constructor transactions.
 * See below for a method listing.
 * @category Encoder
 */
class ContractInstanceEncoder {
    /**
     * @protected
     */
    constructor(contractEncoder, toAddress) {
        this.contractEncoder = contractEncoder;
        if (!web3_utils_1.default.isAddress(toAddress)) {
            throw new errors_1.InvalidAddressError(toAddress);
        }
        this.toAddress = web3_utils_1.default.toChecksumAddress(toAddress);
    }
    /**
     * See [[ProjectEncoder.wrapElementaryValue]].
     */
    wrapElementaryValue(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractEncoder.wrapElementaryValue(dataType, input);
        });
    }
    /**
     * See [[ProjectEncoder.wrap]].
     */
    wrap(dataType, input) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractEncoder.wrap(dataType, input);
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.wrapForTransaction]],
     * except that, when preparing a function transaction, the `to` option is
     * automatically set to this contract instance's address.  If an explicit
     * `to` address is passed as a transaction option, it will be recognized
     * but ignored.
     */
    wrapForTransaction(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolution = yield this.contractEncoder.wrapForTransaction(abi, inputs, options);
            if (!resolution.options.to && abi.type === "function") {
                resolution.options.to = this.toAddress;
            }
            return resolution;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.resolveAndWrap]],
     * except that the `to` option is automatically set to this contract
     * instance's address.  If an explicit `to` address is passed as a
     * transaction option, it will be recognized but ignored.
     */
    resolveAndWrap(abis, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const resolution = yield this.contractEncoder.resolveAndWrap(abis, inputs, options);
            resolution.options.to = this.toAddress;
            return resolution;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.encodeTxNoResolution]],
     * except that, when preparing a function transaction, the `to` option is
     * automatically set to this contract instance's address.  If an explicit
     * `to` address is passed as a transaction option, it will be recognized
     * but ignored.
     */
    encodeTxNoResolution(abi, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoded = yield this.contractEncoder.encodeTxNoResolution(abi, inputs, options);
            //note that the to options is simply overridden
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            if (abi.type === "function") {
                encoded.to = this.toAddress;
            }
            else if (abi.type === "constructor") {
                delete encoded.to;
            }
            return encoded;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.encodeTransaction]],
     * except that the `to` option is automatically set to this contract
     * instance's address.  If an explicit `to` address is passed as a
     * transaction option, it will be recognized but ignored.
     */
    encodeTransaction(abisOrNameOrSig, inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            const encoded = yield this.contractEncoder.encodeTransaction(abisOrNameOrSig, inputs, options);
            //note that the to options is simply overridden
            //perhaps we can change this in the future, but for now we keep this
            //for compatibility
            encoded.tx.to = this.toAddress;
            return encoded;
        });
    }
    /**
     * **This method is asynchronous.**
     *
     * This method functions identically to [[ContractEncoder.encodeCreation]].
     * The particular contract instance is ignored, only its class is used.
     */
    encodeCreation(inputs, options = {}) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.contractEncoder.encodeCreation(inputs, options);
        });
    }
}
exports.ContractInstanceEncoder = ContractInstanceEncoder;
//# sourceMappingURL=encoders.js.map

/***/ }),

/***/ 79:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContractNotFoundError = exports.NoNetworkError = exports.NoBytecodeError = exports.ContractNotDeployedError = exports.UnlinkedContractError = exports.InvalidAddressError = exports.NoFunctionByThatNameError = exports.NoCompilationsForSpawnerError = exports.NoInternalInfoError = void 0;
/**
 * @category Exception
 * @protected
 */
class NoInternalInfoError extends Error {
    constructor() {
        super("No compilations provided, but userDefinedTypes or allocations is missing");
        this.name = "NoInternalInfoError";
    }
}
exports.NoInternalInfoError = NoInternalInfoError;
/**
 * @category Exception
 * @protected
 */
class NoCompilationsForSpawnerError extends Error {
    constructor() {
        super("Contract decoders cannot be spawned without compilations info");
        this.name = "NoCompilationsForSpawnerError";
    }
}
exports.NoCompilationsForSpawnerError = NoCompilationsForSpawnerError;
/**
 * @category Exception
 * @protected
 */
class NoFunctionByThatNameError extends Error {
    constructor(functionNameOrSig, contractName) {
        const message = contractName
            ? `Contract ${contractName} has no function with name or signature ${functionNameOrSig}`
            : `This contract has no function with name or signature ${functionNameOrSig}`;
        super(message);
        this.functionNameOrSig = functionNameOrSig;
        this.contractName = contractName;
        this.name = "NoFunctionByThatNameError";
    }
}
exports.NoFunctionByThatNameError = NoFunctionByThatNameError;
//warning: copypasted from @truffle/decoder!
/**
 * This error indicates that an invalid address was passed to one of the
 * contract instance encoder spawners ([[forContractInstance]], etc).  Valid
 * addresses are those that Web3 accepts; i.e., either those with correct
 * checksums, or those that are all-lowercase or all-uppercase to deliberately
 * circumvent the checksum.
 * @category Exception
 */
class InvalidAddressError extends Error {
    constructor(address) {
        super(`Invalid address ${address}`);
        this.address = address;
        this.name = "InvalidAddressError";
    }
}
exports.InvalidAddressError = InvalidAddressError;
/**
 * This error indicates that you attempted to encode a contract creation
 * transaction for a contract that has not had all of its libraries linked.
 * @category Exception
 */
class UnlinkedContractError extends Error {
    constructor(contractName, bytecode) {
        const nameString = contractName !== undefined ? contractName + " " : "";
        super(`Contract ${nameString}has not had all its libraries linked`);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.name = "UnlinkedContractError";
    }
}
exports.UnlinkedContractError = UnlinkedContractError;
/**
 * This error indicates that you attempted to use address autodetection
 * for a contract that isn't deployed to the current network.
 * @category Exception
 */
class ContractNotDeployedError extends Error {
    constructor(contractName, networkId) {
        const nameString = contractName !== undefined ? contractName + " " : "";
        super(`Contract ${nameString}has not been deployed to network ${networkId} with deployer; address must be given explicitly`);
        this.contractName = contractName;
        this.name = "ContractNotDeployedError";
    }
}
exports.ContractNotDeployedError = ContractNotDeployedError;
/**
 * This error indicates that you attempted to encode a contract creation
 * transaction for a contract that lacks constructor bytecode.
 * @category Exception
 */
class NoBytecodeError extends Error {
    constructor(contractName) {
        const nameString = contractName !== undefined ? contractName + " " : "";
        super(`Contract ${nameString}has missing or empty constructor bytecode`);
        this.contractName = contractName;
        this.name = "NoBytecodeError";
    }
}
exports.NoBytecodeError = NoBytecodeError;
/**
 * This error indicates that the user attempted to do something that
 * requires a network ID (e.g.: autodetect an address for a deployed
 * contract) when no network ID or provider was set.
 * @category Exception
 */
class NoNetworkError extends Error {
    constructor() {
        super("This operation requires a provider or network ID.");
        this.name = "NoNetworkError";
    }
}
exports.NoNetworkError = NoNetworkError;
/**
 * This error indicates that the contract you are attempting to create an
 * encoder for does not appear in the project info.
 * @category Exception
 */
class ContractNotFoundError extends Error {
    constructor(contractName, bytecode, deployedBytecode, address) {
        let message;
        if (contractName) {
            message = `Contract ${contractName} could not be found in the project information`;
        }
        else if (address) {
            message = `Contract at ${address} could not be found in the project information`;
        }
        else {
            message = `Contract could not be found in the project information`;
        }
        super(message);
        this.contractName = contractName;
        this.bytecode = bytecode;
        this.deployedBytecode = deployedBytecode;
        this.name = "ContractNotFoundError";
    }
}
exports.ContractNotFoundError = ContractNotFoundError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 15967:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

/**
 * # Truffle Encoder
 *
 * This module provides an interface for recognizing JavaScript user input of
 * Solidity values, encoding those values for use in a transaction, and performing
 * overload resolution based on those values to determine which Solidity method to
 * encode for.
 *
 * The interface is split into three classes: The project encoder, the contract
 * encoder, and the contract instance encoder.  The project encoder is associated
 * to the project as a whole; it can recognize user input, encode transactions,
 * and resolve overloads, although the interface for the latter two is somewhat
 * inconvenient.  The contract encoder is associated to a specific contract class.
 * It is similar to the project encoder, but presents an easier-to-use interface
 * for transaction encoding and overload resolution, so long as one is dealing
 * with methods of the specified class.  The contract instance encoder is
 * associated to a specific contract instance; it is like the contract encoder,
 * but is associated to a specific address, allowing the `to` option in
 * transactions to be populated automatically.
 *
 * ## Usage
 *
 * ### Initialization
 *
 * Create a encoder with one of the various constructor functions.
 *
 * For a project encoder, use the [[forProject|`forProject`]] function.
 *
 * For a contract encoder, use the [[forArtifact|`forArtifact`]] or
 * [[forContract|`forContract`]] function.
 *
 * For a contract instance encoder, use one of the following:
 * * [[forDeployedArtifact|`forDeployedArtifact`]]
 * * [[forDeployedContract|`forDeployedContract`]]
 * * [[forArtifactAt|`forArtifactAt`]]
 * * [[forContractAt|`forContractAt`]]
 * * [[forContractInstance|`forContractInstance`]]
 *
 * See the documentation of these functions for details, or below for usage
 * examples.
 *
 * All of these functions take a final argument in which information about the
 * project is specified; currently only a few methods for specifying project
 * information are allowed, but more are planned.
 *
 * One can also spawn encoders from other encoders by supplying additional
 * information.  See the documentation for the individual encoder classes for a
 * method listing.
 *
 * ### Encoder methods
 *
 * See the documentation for the individual encoder classes for a method listing.
 *
 * ### Wrapped format information
 *
 * When using the various "wrap" functions, values will be wrapped in
 * machine-readable [[Format.Values.Value]] objects containing individual wrapped
 * values.  (This is the same format that `@truffle/decoder` produces output in.)
 * See the [[Format|format documentation]] for an overview and complete module
 * listing.
 *
 * ### Use of project information and encoding of enums
 *
 * The encoder can do purely ABI-based encoding, like other encoders; however it
 * has the capability to use project information to do more.
 *
 * The most significant use of this is that if further project information is
 * present, this allows for enums to be entered as strings with the name of
 * the option, rather than having to be entered via the underlying number.
 * See the documentation of [[ProjectEncoder.wrap]] for more.
 *
 * Similarly, if project information is present, the encoder will also throw an
 * error if you attempt to put an out-of-range value into an enum type, and
 * refuse to consider overloads that would result in this during overload
 * resolution.  If project information is absent, the encoder will be unable to
 * recognize any error in these situations.
 *
 * ### ENS resolution
 *
 * The encoder supports ENS resolution for address and contract types if
 * initialized to support such.  See the documentation of the [[EncoderSettings]]
 * and [[EnsSettings]] types for more.
 *
 * ### Basic usage examples
 *
 * These usage examples are for a project with two contracts, `Contract1` and
 * `Contract2`.  Let's suppose these look like the following:
 *
 * ```solidity
 *pragma solidity ^0.8.0;
 *
 *contract Contract1 {
 *  function enumExample(Contract2.Ternary x) public payable {
 *  }
 *
 *  function overloaded(uint x) public payable {
 *  }
 *
 *  function overloaded(string x) public payable {
 *  }
 *}
 *
 *contract Contract2 {
 *  enum Ternary { No, Yes, Maybe }
 *}
 * ```
 *
 * #### Encoding a transaction
 *
 * ```typescript
 *import { forContract } from "@truffle/encoder";
 *const contract1 = artifacts.require("Contract1");
 *const contract2 = artifacts.require("Contract2");
 *const encoder = await Encoder.forContract(Contract1, [Contract1, Contract2]);
 *const abi = Contract1.abi.find(abiEntry => abiEntry.name === "enumExample");
 *const tx = await encoder.encodeTransaction(
 *  abi,
 *  ["Maybe", { value: 1 }],
 *  { allowOptions: true }
 *);
 * ```
 *
 * ### Performing overload resolution
 *
 * ```typescript
 *import { forContract } from "@truffle/encoder";
 *const contract1 = artifacts.require("Contract1");
 *const contract2 = artifacts.require("Contract2");
 *const encoder = await Encoder.forContract(Contract1, [Contract1, Contract2]);
 *const abis = Contract1.abi.filter(abiEntry => abiEntry.name === "overloaded");
 *const { tx, abi } = await encoder.encodeTransaction(
 *  abis,
 *  ["hello", { value: 1 }],
 *  { allowOptions: true }
 *);
 * ```
 *
 * @module @truffle/encoder
 * @packageDocumentation
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.forContractInstance = exports.forContractAt = exports.forArtifactAt = exports.forDeployedContract = exports.forDeployedArtifact = exports.forContract = exports.forArtifact = exports.forProjectInternal = exports.forProject = exports.ProviderAdapter = exports.NoFunctionByThatNameError = exports.ContractNotDeployedError = exports.ContractNotFoundError = exports.UnlinkedContractError = exports.NoInternalInfoError = exports.InvalidAddressError = exports.ContractInstanceEncoder = exports.ContractEncoder = exports.ProjectEncoder = void 0;
const encoders_1 = __webpack_require__(13247);
Object.defineProperty(exports, "ProjectEncoder", ({ enumerable: true, get: function () { return encoders_1.ProjectEncoder; } }));
Object.defineProperty(exports, "ContractEncoder", ({ enumerable: true, get: function () { return encoders_1.ContractEncoder; } }));
Object.defineProperty(exports, "ContractInstanceEncoder", ({ enumerable: true, get: function () { return encoders_1.ContractInstanceEncoder; } }));
var errors_1 = __webpack_require__(79);
Object.defineProperty(exports, "InvalidAddressError", ({ enumerable: true, get: function () { return errors_1.InvalidAddressError; } }));
Object.defineProperty(exports, "NoInternalInfoError", ({ enumerable: true, get: function () { return errors_1.NoInternalInfoError; } }));
Object.defineProperty(exports, "UnlinkedContractError", ({ enumerable: true, get: function () { return errors_1.UnlinkedContractError; } }));
Object.defineProperty(exports, "ContractNotFoundError", ({ enumerable: true, get: function () { return errors_1.ContractNotFoundError; } }));
Object.defineProperty(exports, "ContractNotDeployedError", ({ enumerable: true, get: function () { return errors_1.ContractNotDeployedError; } }));
Object.defineProperty(exports, "NoFunctionByThatNameError", ({ enumerable: true, get: function () { return errors_1.NoFunctionByThatNameError; } }));
const adapter_1 = __webpack_require__(12165);
Object.defineProperty(exports, "ProviderAdapter", ({ enumerable: true, get: function () { return adapter_1.ProviderAdapter; } }));
const codec_1 = __webpack_require__(20102);
/**
 * **This function is asynchronous.**
 *
 * Constructs a project encoder for the project.
 * @category Constructors
 */
function forProject(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        const compilations = codec_1.Compilations.Utils.infoToCompilations(settings.projectInfo);
        const ens = ensSettingsForInfo(settings);
        const networkId = yield networkIdForInfo(settings);
        const encoder = new encoders_1.ProjectEncoder(Object.assign({ compilations, networkId }, ens));
        yield encoder.init();
        return encoder;
    });
}
exports.forProject = forProject;
/**
 * @protected
 * @category Constructors
 */
function forProjectInternal(info) {
    return __awaiter(this, void 0, void 0, function* () {
        const encoder = new encoders_1.ProjectEncoder(info);
        yield encoder.init();
        return encoder;
    });
}
exports.forProjectInternal = forProjectInternal;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract encoder for a given contract artifact.
 * @param artifact The artifact for the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[EncoderSettings]] to use;
 *   see the documentation for that type for more information.  If absent, the
 *   encoder will be based on just the single contract provided; it is
 *   recommended to pass more information to get the encoder's full power.
 *
 *   Note that if the artifact contains unlinked libraries, you will have to
 *   pass either the `provider` or `networkId` setting in order to encode
 *   contract creation transactions.
 * @category Constructors
 */
function forArtifact(artifact, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!settings.projectInfo) {
            settings = Object.assign(Object.assign({}, settings), { projectInfo: { artifacts: [artifact] } });
        }
        let projectEncoder = yield forProject(settings);
        return yield projectEncoder.forArtifact(artifact);
    });
}
exports.forArtifact = forArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract encoder for a given contract.
 * @param contract The contract the encoder is for.  It should have all of
 *   its libraries linked.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return yield forArtifact(contract, Object.assign({ provider: contract.web3.currentProvider, networkId: parseInt(contract.network_id) || undefined }, settings));
    });
}
exports.forContract = forContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * You must pass in a provider or network ID to use this function.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param settings The [[EncoderSettings]] to use, including the provider or
 *   network id; see the documentation for that type for more information.
 * @category Constructors
 */
function forDeployedArtifact(artifact, settings) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractEncoder = yield forArtifact(artifact, settings);
        let instanceEncoder = yield contractEncoder.forInstance();
        return instanceEncoder;
    });
}
exports.forDeployedArtifact = forDeployedArtifact;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forDeployedContract(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractEncoder = yield forContract(contract, settings);
        return yield contractEncoder.forInstance();
    });
}
exports.forDeployedContract = forDeployedContract;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance decoder for a contract instance at a given address.
 * @param artifact The artifact corresponding to the type of the contract.
 *
 *   A contract constructor object may be substituted for the artifact, so if
 *   you're not sure which you're dealing with, it's OK.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[EncoderSettings]] to use;
 *   see the documentation for that type for more information.  If absent, the
 *   encoder will be based on just the single contract provided; it is
 *   recommended to pass more information to get the encoder's full power.
 *
 *   Note that if the artifact contains unlinked libraries, you will have to
 *   pass either the `provider` or `networkId` setting in order to encode
 *   contract creation transactions.
 * @category Provider-based Constructor
 */
function forArtifactAt(artifact, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let contractEncoder = yield forArtifact(artifact, settings);
        let instanceEncoder = yield contractEncoder.forInstance(address);
        return instanceEncoder;
    });
}
exports.forArtifactAt = forArtifactAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a contract instance at a given address.
 * @param contract The contract constructor object corresponding to the type of the contract.
 * @param address The address of the contract instance to decode.
 *
 *   Address must either be checksummed, or in all one case to circumvent the checksum.
 *   Mixed-case with bad checksum will cause this function to throw an exception.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContractAt(contract, address, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const contractEncoder = yield forContract(contract, settings);
        return contractEncoder.forInstance(address);
    });
}
exports.forContractAt = forContractAt;
/**
 * **This function is asynchronous.**
 *
 * Constructs a contract instance encoder for a deployed contract instance.
 * @param contract The contract abstraction object corresponding to the contract instance.
 * @param settings The [[EncoderSettings]] to use; see the documentation for
 *   that type for more information.  If absent, the encoder will be based on
 *   just the single contract provided; it is recommended to pass more
 *   information to get the encoder's full power.
 * @category Truffle Contract-based Constructors
 */
function forContractInstance(contract, settings = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        return forContractAt(contract.constructor, contract.address, settings);
    });
}
exports.forContractInstance = forContractInstance;
/**
 * @category Constructors
 */
function ensSettingsForInfo(settings) {
    if (settings.ens) {
        return settings.ens;
    }
    else {
        return {
            provider: settings.provider
        };
    }
}
/**
 * @category Constructors
 */
function networkIdForInfo(settings) {
    return __awaiter(this, void 0, void 0, function* () {
        if (settings.networkId !== undefined) {
            return settings.networkId;
        }
        else if (settings.provider) {
            return yield new adapter_1.ProviderAdapter(settings.provider).getNetworkId();
        }
        else {
            return null;
        }
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 89916:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.link = exports.isEthersBigNumber = exports.isBigNumber = void 0;
const bignumber_js_1 = __importDefault(__webpack_require__(70794));
const bignumber_1 = __webpack_require__(833);
const escapeRegExp_1 = __importDefault(__webpack_require__(3522));
// Unfortunately, both BigNumber and EthersBigNumber's isBigNumber methods
// **both return false positives on the other BigNumber class**.
// (This is because they both just check for the _isBigNumber flag.)
// As such, we've made our own method to recognize these, by
// A. using the appropriate method, but then also
// B. checking for the presence of a method that one class has but the other
// doesn't.
function isBigNumber(input) {
    return bignumber_js_1.default.isBigNumber(input) && Boolean(input.toFixed);
}
exports.isBigNumber = isBigNumber;
function isEthersBigNumber(input) {
    return bignumber_1.BigNumber.isBigNumber(input) && Boolean(input.toHexString);
}
exports.isEthersBigNumber = isEthersBigNumber;
//warning: copied (OK, adapted) from Truffle Contract!
function link(bytecode, links) {
    if (!bytecode) {
        return bytecode;
    }
    const names = Object.keys(links).sort((a, b) => b.length - a.length); //sort from longest to shortest
    //(this allows overlong names to be handled properly)
    for (const name of names) {
        const address = links[name];
        bytecode = bytecode.replace(
        //we have to escape as names may include '$'
        new RegExp(`__${(0, escapeRegExp_1.default)(name)}_*`, "g"), 
        //note: we don't have to worry about link references running into
        //one another, because each one is always preceded by a PUSH20 (0x73)
        address.slice(2) //cut off initial 0x
        );
    }
    return bytecode;
}
exports.link = link;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 32731:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("source-map-utils");
const CodeUtils = __webpack_require__(8135);
const Codec = __webpack_require__(20102);
const Web3Utils = __webpack_require__(18269);
const jsonpointer = __webpack_require__(83573);
const IntervalTree = (__webpack_require__(91501)/* ["default"] */ .ZP);

var SourceMapUtils = {
  getCharacterOffsetToLineAndColumnMapping: function (source) {
    var mapping = [];

    source = Array.from(source); //note: this will correctly handle
    //surrogate pairs, but there's still the problem of grapheme
    //clusters!  We should do something about that later.

    var line = 0;
    var column = 0;

    source.forEach(function (character) {
      let loc = { line, column };
      if (character === "\n") {
        line += 1;
        column = -1;

        loc = {
          line: line,
          column: 0
        };
      }

      for (let i = 0; i < Buffer.from(character).length; i++) {
        //because our character offsets here are in bytes, we need to
        //pad out the line/column map as per the UTF-8 length of the
        //characters so we're mapping *bytes* to line/columns
        mapping.push(loc);
      }
      column += 1;
    });

    return mapping;
  },

  getHumanReadableSourceMap: function (sourceMap) {
    const instructions = sourceMap.split(";");

    let processedInstruction = {
      start: 0,
      length: 0,
      file: 0
    }; //persists across instructions for when info doesn't change
    let processedSourceMap = [];

    //JS doesn't have scan, so we'll do this scan manually
    for (let instruction of instructions) {
      let splitInstruction = instruction.split(":");

      //note: if(splitInstruction[i]) checks both that there are
      //at least that many fields, and that that particular field
      //is nonempty

      if (splitInstruction[0]) {
        processedInstruction.start = parseInt(splitInstruction[0]);
      }

      if (splitInstruction[1]) {
        processedInstruction.length = parseInt(splitInstruction[1]);
      }

      if (splitInstruction[2]) {
        processedInstruction.file = parseInt(splitInstruction[2]);
      }

      if (splitInstruction[3]) {
        processedInstruction.jump = splitInstruction[3];
      }

      if (splitInstruction[4]) {
        processedInstruction.modifierDepth = parseInt(splitInstruction[4]);
      }

      //we need to clone before pushing so that the array won't contain a
      //bunch of copies of the same thing.  unfortunately, we don't have
      //babel here, so we need to clone a bit manually.
      let clonedProcessedInstruction = {
        start: processedInstruction.start,
        length: processedInstruction.length,
        file: processedInstruction.file,
        jump: processedInstruction.jump,
        modifierDepth: processedInstruction.modifierDepth
      };

      processedSourceMap.push(clonedProcessedInstruction);
    }

    return processedSourceMap;
  },

  //sources: array of text sources (must be in order!)
  //binary: raw binary to process.  should not have unresolved links.
  //sourceMap: a processed source map as output by getHumanReadableSourceMap above
  //if missing, we... attempt to muddle through.
  getProcessedInstructionsForBinary: function (sources, binary, sourceMap) {
    if (!sources || !binary) {
      return [];
    }
    debug("sourceMap: %O", sourceMap);

    let numInstructions;
    if (sourceMap) {
      numInstructions = sourceMap.length;
    }

    //because we might be dealing with a constructor with arguments, we do
    //*not* pass attemptStripMetadata under any circumstances as a safety
    //measure (to prevent accidentally removing some of the *code* as well)
    //(this is pretty unlikely but I'm going to continue to err on the safe
    //side here I figure)
    let instructions = CodeUtils.parseCode(binary, {
      maxInstructionCount: numInstructions
    });

    if (!sourceMap) {
      // HACK
      // Let's create a source map to use since none exists. This source
      // map maps just as many ranges as there are instructions (or
      // possibly more), and marks them all as being Solidity-internal and
      // not jumps.
      sourceMap = new Array(instructions.length);
      sourceMap.fill({
        start: 0,
        length: 0,
        file: -1,
        jump: "-",
        modifierDepth: "0"
      });
    }

    const lineAndColumnMappings = sources.map(source =>
      SourceMapUtils.getCharacterOffsetToLineAndColumnMapping(source || "")
    );

    let primaryFile;
    if (sourceMap[0]) {
      primaryFile = sourceMap[0].file;
    }
    debug("primaryFile %o", primaryFile);

    return instructions
      .map((instruction, index) => {
        // lookup source map by index and add `index` property to
        // instruction
        //

        const instructionSourceMap = sourceMap[index] || {};

        instruction.index = index; //should be fine to modify this

        return {
          instruction,
          instructionSourceMap
        };
      })
      .map(({ instruction, instructionSourceMap }) => {
        // add source map information to instruction, or defaults

        //I think it is also OK to modify instruction here
        ({
          jump: instruction.jump,
          start: instruction.start = 0,
          length: instruction.length = 0,
          file: instruction.file = primaryFile,
          modifierDepth: instruction.modifierDepth = 0
        } = instructionSourceMap);
        if (instruction.start === -1 && instruction.length === -1) {
          instruction.start = 0;
          instruction.length = 0;
        }
        const lineAndColumnMapping =
          lineAndColumnMappings[instruction.file] || {};
        instruction.range = {
          start: lineAndColumnMapping[instruction.start] || {
            line: null,
            column: null
          },
          end: lineAndColumnMapping[instruction.start + instruction.length] || {
            line: null,
            column: null
          }
        };

        return instruction;
      });
  },

  //instructions: as output by the function above
  //asts: array of abstract syntax trees for the sources. must be in order!
  //overlapFunctions: an array of functions -- each one corresponding to the AST of the same index --
  //that, given a start index and a length, will search for all nodes in that AST overlapping the
  //given range, and will return an array of objects with fields node and pointer; node should
  //be the corresponding node, and pointer a jsonpointer to it (from the AST root)
  //compilationId: what it says.  the function will work fine without it.
  getFunctionsByProgramCounter: function (
    instructions,
    asts,
    overlapFunctions,
    compilationId
  ) {
    return Object.assign(
      {},
      ...instructions
        .filter(instruction => instruction.name === "JUMPDEST")
        .map(instruction => {
          debug("instruction %O", instruction);
          const sourceIndex = instruction.file;
          const findOverlappingRange = overlapFunctions[sourceIndex];
          const ast = asts[sourceIndex];
          //first off, if we can't get the AST, check for designated
          //invalid and if it's not that give up
          //(note that being unable to get the AST includes the case
          //of source index -1; designated invalid has source index
          //-1 in some Solidity versions)
          if (!ast) {
            if (
              SourceMapUtils.isDesignatedInvalid(
                instructions,
                instruction.index,
                overlapFunctions
              )
            ) {
              //designated invalid, include it
              return {
                [instruction.pc]: {
                  isDesignatedInvalid: true
                }
              };
            } else {
              //not designated invalid, filter it out
              return {};
            }
          }
          const range = SourceMapUtils.getSourceRange(instruction);
          let { node, pointer } = SourceMapUtils.findRange(
            findOverlappingRange,
            range.start,
            range.length
          );
          if (!pointer) {
            node = ast;
          }
          if (!node || node.nodeType !== "FunctionDefinition") {
            //filter out JUMPDESTs that aren't function definitions...
            //except for the designated invalid function
            if (
              SourceMapUtils.isDesignatedInvalid(
                instructions,
                instruction.index,
                overlapFunctions,
                node
              )
            ) {
              //designated invalid, include it
              return {
                [instruction.pc]: {
                  isDesignatedInvalid: true
                }
              };
            } else {
              //not designated invalid, filter it out
              return {};
            }
          }
          //otherwise, we're good to go, so let's find the contract node and
          //put it all together
          //to get the contract node, we go up twice from the function node;
          //the path from one to the other should have a very specific form,
          //so this is easy
          let contractPointer = pointer.replace(/\/nodes\/\d+$/, "");
          let contractNode = jsonpointer.get(ast, contractPointer);
          if (contractNode.nodeType !== "ContractDefinition") {
            //if it's a free function, there is no contract pointer or contract node
            contractPointer = null;
            contractNode = null;
          }
          return {
            [instruction.pc]: {
              sourceIndex,
              compilationId,
              //note: we're assuming that functions in generated sources are never pointed to
              pointer,
              node,
              name: node.name,
              id: node.id,
              mutability: Codec.Ast.Utils.mutability(node),
              contractPointer,
              contractNode,
              contractName: contractNode ? contractNode.name : null,
              contractId: contractNode ? contractNode.id : null,
              contractKind: contractNode ? contractNode.contractKind : null,
              contractPayable: contractNode
                ? Codec.Ast.Utils.isContractPayable(contractNode)
                : null,
              isDesignatedInvalid: false
            }
          };
        })
    );
  },

  getSourceRange: function (instruction = {}) {
    return {
      start: instruction.start || 0,
      length: instruction.length || 0,
      lines: instruction.range || {
        start: {
          line: 0,
          column: 0
        },
        end: {
          line: 0,
          column: 0
        }
      }
    };
  },

  //findOverlappingRange should be as described above
  findRange: function (findOverlappingRange, sourceStart, sourceLength) {
    // find nodes that fully contain requested range,
    // return one with longest pointer
    // (note: returns { range, node, pointer }
    let sourceEnd = sourceStart + sourceLength;
    let pointerLength = pointer => (pointer.match(/\//g) || []).length; //counts number of slashes in ptr
    return findOverlappingRange(sourceStart, sourceLength)
      .filter(({ range }) => sourceStart >= range[0] && sourceEnd <= range[1])
      .reduce(
        (acc, cur) =>
          pointerLength(cur.pointer) >= pointerLength(acc.pointer) ? cur : acc,
        { pointer: "" }
      );
    //note we make sure to bias towards cur (the new value being compared) rather than acc (the old value)
    //so that we don't actually get {pointer: ""} as our result
  },

  //makes the overlap function for an AST
  makeOverlapFunction: function (ast) {
    let tree = new IntervalTree();
    let ranges = SourceMapUtils.rangeNodes(ast);
    for (let { range, node, pointer } of ranges) {
      let [start, end] = range;
      tree.insert(start, end, { range, node, pointer });
    }
    return (sourceStart, sourceLength) =>
      tree.search(sourceStart, sourceStart + sourceLength);
  },

  //for use by makeOverlapFunction
  rangeNodes: function (node, pointer = "") {
    if (node instanceof Array) {
      return [].concat(
        ...node.map((sub, i) =>
          SourceMapUtils.rangeNodes(sub, `${pointer}/${i}`)
        )
      );
    } else if (node instanceof Object) {
      let results = [];

      if (node.src !== undefined && node.nodeType !== undefined) {
        //don't add "pseudo-nodes" (i.e.: outside variable references
        //in assembly) with no nodeType
        results.push({ pointer, node, range: SourceMapUtils.getRange(node) });
      }

      return results.concat(
        ...Object.keys(node).map(key =>
          SourceMapUtils.rangeNodes(node[key], `${pointer}/${key}`)
        )
      );
    } else {
      return [];
    }
  },

  getRange: function (node) {
    // src: "<start>:<length>:<_>"
    // returns [start, end]
    let [start, length] = node.src
      .split(":")
      .slice(0, 2)
      .map(i => parseInt(i));

    return [start, start + length];
  },

  //takes an array of instructions & an index into it
  //and asks: is this index the start of this instruction array the
  //start of a Solidity designated invalid function?
  //i.e. what an uninitialized internal function pointer jumps to?
  isDesignatedInvalid: function (
    instructions,
    index,
    overlapFunctions,
    node = undefined
  ) {
    const oldSequence = [{ name: "JUMPDEST" }, { name: "INVALID" }];
    const panicSelector = Web3Utils.soliditySha3({
      type: "string",
      value: "Panic(uint256)"
    }).slice(0, 2 + 2 * Codec.Evm.Utils.SELECTOR_SIZE);
    const paddedSelector = panicSelector.padEnd(
      2 + 2 * Codec.Evm.Utils.WORD_SIZE,
      "00"
    );
    //we double and add 2 because we're using hex strings...
    const newSequence = [
      { name: "JUMPDEST" },
      { name: "PUSH32", pushData: paddedSelector },
      { name: "PUSH1", pushData: "0x00" },
      { name: "MSTORE" },
      { name: "PUSH1", pushData: "0x51" },
      { name: "PUSH1", pushData: "0x04" },
      { name: "MSTORE" },
      { name: "PUSH1", pushData: "0x24" },
      { name: "PUSH1", pushData: "0x00" },
      { name: "REVERT" }
    ];

    const checkAgainstTemplate = (instructions, index, template) => {
      for (let offset = 0; offset < template.length; offset++) {
        const instruction = instructions[index + offset];
        const comparison = template[offset];
        if (!instruction || instruction.name !== comparison.name) {
          return false;
        }
        if (
          comparison.pushData &&
          instruction.pushData !== comparison.pushData
        ) {
          return false;
        }
      }
      return true;
    };

    //gets the final pushdata in a JUMPDEST, PUSH, [PUSH,] JUMP sequence;
    //returns null if the code is not of that form
    const getIndirectAddress = (instructions, startingIndex) => {
      let index = startingIndex;
      if (instructions[index].name !== "JUMPDEST") {
        return null;
      }
      index++;
      while (
        instructions[index] &&
        instructions[index].name.match(/^PUSH\d*/)
      ) {
        index++;
        if (index > startingIndex + 3) {
          //check: are there more than 2 PUSHes?
          return null;
        }
      }
      if (!instructions[index]) {
        //covers both the case where we ran off already,
        //and where we're about to run off
        return null;
      }
      if (instructions[index].name === "JUMP") {
        if (index === startingIndex + 1) {
          //check: was there at least one push?
          return null;
        }
        index--;
        return parseInt(instructions[index].pushData);
      } else {
        return null;
      }
    };

    //if it matches either direct template, return true
    if (
      checkAgainstTemplate(instructions, index, oldSequence) ||
      checkAgainstTemplate(instructions, index, newSequence)
    ) {
      return true;
    }

    //if it's panic_error_0x51, return true
    if (
      node &&
      node.nodeType === "YulFunctionDefinition" &&
      node.name === "panic_error_0x51"
    ) {
      return true;
    }

    //otherwise, check if it's indirect for the new template
    //(or for panic_error_0x51)
    const jumpAddress = getIndirectAddress(instructions, index);
    if (jumpAddress !== null) {
      const jumpIndex = instructions.findIndex(
        instruction => instruction.pc === jumpAddress
      );
      if (jumpIndex !== -1) {
        if (checkAgainstTemplate(instructions, jumpIndex, newSequence)) {
          return true;
        }
        debug("indirect: %O", instructions.slice(index, index + 4));
        debug("jumpAddress: %d", jumpAddress);
        debug("jumpIndex: %d", jumpIndex);
        debug("instr count: %d", instructions.length);
        const jumpInstruction = instructions[jumpIndex];
        const jumpFile = jumpInstruction.file;
        if (jumpFile !== -1) {
          const findOverlappingRange = overlapFunctions[jumpFile];
          const range = SourceMapUtils.getSourceRange(jumpInstruction);
          const { node: jumpNode } = SourceMapUtils.findRange(
            findOverlappingRange,
            range.start,
            range.length
          );
          if (
            jumpNode &&
            jumpNode.nodeType === "YulFunctionDefinition" &&
            jumpNode.name === "panic_error_0x51"
          ) {
            return true;
          }
        }
      }
    }

    //otherwise, return false
    return false;
  }
};

module.exports = SourceMapUtils;


/***/ })

};
;
//# sourceMappingURL=8852.bundled.js.map