#!/usr/bin/env node

exports.id = 4986;
exports.ids = [4986];
exports.modules = {

/***/ 27073:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 27073;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 34763:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { bundled, core } = (__webpack_require__(64146).info)();
const OS = __webpack_require__(22037);
const analytics = __webpack_require__(95614);
const { extractFlags } = __webpack_require__(54708); // contains utility methods
const globalCommandOptions = __webpack_require__(67023);
const debugModule = __webpack_require__(15158);
const debug = debugModule("core:command:run");
const {
  validTruffleCommands,
  validTruffleConsoleCommands
} = __webpack_require__(91874);
const Web3 = __webpack_require__(3283);
const TruffleError = __webpack_require__(73321);

const defaultHost = "127.0.0.1";
const managedGanacheDefaultPort = 9545;
const managedGanacheDefaultNetworkId = 5777;
const managedDashboardDefaultPort = 24012;

//takes a string and splits it into arguments, shell-style, while
//taking account of quotes and escapes; the escape character can be
//customized (you can also pass in more than one valid escape character)
function parseQuotesAndEscapes(args, escapeCharacters = "\\") {
  const quoteCharacters = "\"'"; //note we will handle the two quote types differently
  let argArray = [];
  let currentArg = "";
  let currentQuote = undefined;
  let currentEscape = undefined;
  let whitespace = true; //are we currently on whitespace? start this as true to allow whitespace at beginning
  for (const char of args) {
    if (currentEscape !== undefined) {
      //escaped character
      //note that inside quotes, we don't allow escaping everything;
      //outside quotes, we allow escaping anything
      if (currentQuote === '"') {
        //inside a double-quote case
        if (char === currentQuote) {
          currentArg += char; //an escaped quote
        } else {
          //attempted to escape something not the current quote;
          //don't treat it as an escape, include the escape char as well
          currentArg += currentEscape + char;
        }
      } else {
        //outside a quote case
        //(note there's no single-quote case because we can't reach here
        //in that case; currentEscape can't get set inside single quotes)
        currentArg += char; //just the escaped character
      }
      currentEscape = undefined;
      whitespace = false; //(this is not strictly necessary, but for clarity)
    } else if (escapeCharacters.includes(char) && currentQuote !== "'") {
      //(unescaped) escape character
      //(again, inside single quotes, there is no escaping, so we just treat
      //as ordinary character in that case)
      currentEscape = char;
      whitespace = false;
    } else if (currentQuote !== undefined) {
      //quoted character (excluding escape/escaped chars)
      if (currentQuote === char) {
        //closing quote
        currentQuote = undefined;
      } else {
        //ordinary quoted character, including quote of non-matching type
        currentArg += char;
      }
      whitespace = false; //again not necessary, included for clarity
    } else if (quoteCharacters.includes(char)) {
      //(unescaped) opening quote (closing quotes & quoted quotes handled above)
      currentQuote = char;
      whitespace = false;
    } else if (char.match(/\s/)) {
      //(unescaped) whitespace
      if (!whitespace) {
        //if we're already on whitespace, we don't need
        //to do anything, this is just more whitespace.
        //if however we're transitioning to whitespace, that means we need
        //to split arguments here.
        argArray.push(currentArg);
        currentArg = "";
        whitespace = true;
      }
    } else {
      //default case -- ordinary character
      currentArg += char;
      whitespace = false;
    }
  }
  //having reached the end of the string, let's check for unterminated quotes & such
  if (currentQuote !== undefined) {
    throw new TruffleError(`Error: quote with ${currentQuote} not terminated`);
  }
  if (currentEscape !== undefined) {
    throw new TruffleError(
      `Error: line ended with escape character ${currentEscape}`
    );
  }
  //now, we push our final argument,
  //assuming of course that it's nonempty
  if (currentArg !== "") {
    argArray.push(currentArg);
  }
  return argArray;
}

// this function takes an object with an array of input strings, an options
// object, and a boolean determining whether we allow inexact matches for
// command names - it returns an object with the command name, the run method,
// and the command's meta object containing help and command description
const getCommand = ({ inputStrings, options, noAliases }) => {
  if (inputStrings.length === 0) {
    return null;
  }

  const firstInputString = inputStrings[0];
  let chosenCommand = null;

  // If the command wasn't specified directly, go through a process
  // for inferring the command.
  if (firstInputString === "-v" || firstInputString === "--version") {
    chosenCommand = "version";
  } else if (validTruffleCommands.includes(firstInputString)) {
    chosenCommand = firstInputString;
  } else if (noAliases !== true) {
    let currentLength = 1;
    const availableCommandNames = validTruffleCommands;

    // Loop through each letter of the input until we find a command
    // that uniquely matches.
    while (currentLength <= firstInputString.length) {
      // Gather all possible commands that match with the current length
      const possibleCommands = availableCommandNames.filter(possibleCommand => {
        return (
          possibleCommand.substring(0, currentLength) ===
          firstInputString.substring(0, currentLength)
        );
      });

      // Did we find only one command that matches? If so, use that one.
      if (possibleCommands.length === 1) {
        chosenCommand = possibleCommands[0];
        // if they miskey a command we need to make sure it is correct so that
        // yargs can parse it correctly later
        inputStrings.shift();
        inputStrings.unshift(chosenCommand);
        break;
      }
      currentLength += 1;
    }
  }

  if (chosenCommand === null) {
    return null;
  }

  // determine whether Truffle is being run from the bundle or from ./cli.js
  // and require commands accordingly
  let command;
  if (true) {
    const path = __webpack_require__(71017);
    const filePath = path.join(__dirname, `${chosenCommand}.bundled.js`);
    // we need to use this library to bypass webpack's require which can't
    // access the user's filesystem
    const originalRequire = __webpack_require__(44516);
    command = originalRequire(filePath);
  } else {}

  // several commands have a help property that is a function
  if (typeof command.meta.help === "function") {
    command.meta.help = command.meta.help(options);
  }

  return {
    name: chosenCommand,
    run: command.run,
    meta: command.meta
  };
};

// takes an object containing the command (name, run method, and meta object),
// the array of strings that were input, and an options object - it sanitizes
// the input options, merges it with the input options, and returns the result
const prepareOptions = ({ command, inputStrings, options }) => {
  const yargs = __webpack_require__(64968)();
  yargs
    .command(__webpack_require__(36219)(`./${command.name}/meta`))
    //Turn off yargs' default behavior when handling `truffle --version` & `truffle <cmd> --help`
    .version(false)
    .help(false);

  const commandOptions = yargs.parse(inputStrings);

  // remove the task name itself put there by yargs
  if (commandOptions._) commandOptions._.shift();

  // some options might throw if options is a Config object
  // if so, let's ignore those values
  const clone = {};
  Object.keys(options).forEach(key => {
    try {
      clone[key] = options[key];
    } catch {
      // do nothing with values that throw
    }
  });

  // method `extractFlags(args)` : Extracts the `--option` & `-option` flags from arguments
  let inputOptions = extractFlags(inputStrings);

  //prevent invalid option warning for `truffle -v` & `truffle --version`
  if (command.name === "version") {
    inputOptions = inputOptions.filter(
      opt => opt !== "-v" && opt !== "--version"
    );
  }
  // adding allowed global options as enumerated in each command
  const allowedGlobalOptions = command.meta.help.allowedGlobalOptions
    .filter(tag => tag in globalCommandOptions)
    .map(tag => globalCommandOptions[tag]);

  const allValidOptions = [
    ...command.meta.help.options,
    ...allowedGlobalOptions
  ];

  const validOptions = allValidOptions.reduce((a, item) => {
    // we split the options off from the arguments
    // and then we split to handle options of the form --<something>|-<s>
    let options = item.option.split(" ")[0].split("|");
    return [
      ...a,
      ...options.filter(
        option => option.startsWith("--") || option.startsWith("-")
      )
    ];
  }, []);

  let invalidOptions = inputOptions.filter(opt => !validOptions.includes(opt));

  // TODO: Remove exception for 'truffle run' when plugin options support added.
  if (invalidOptions.length > 0 && command.name !== "run") {
    if (options.logger) {
      const log = options.logger.log || options.logger.debug;
      log(
        "> Warning: possible unsupported (undocumented in help) command line option(s): " +
          invalidOptions
      );
    }
  }

  return {
    ...clone,
    ...commandOptions
  };
};

const runCommand = async function (command, options) {
  try {
    // migrate Truffle data to the new location if necessary
    const configMigration = __webpack_require__(99043);
    await configMigration.migrateTruffleDataIfNecessary();
  } catch (error) {
    debug("Truffle data migration failed: %o", error);
  }

  analytics.send({
    command: command.name ? command.name : "other",
    args: options._,
    version: bundled || "(unbundled) " + core
  });

  const unhandledRejections = new Map();

  process.on("unhandledRejection", (reason, promise) => {
    unhandledRejections.set(promise, reason);
  });

  process.on("rejectionHandled", promise => {
    unhandledRejections.delete(promise);
  });

  process.on("exit", _ => {
    const log = options.logger
      ? options.logger.log || options.logger.debug
      : console.log;
    if (unhandledRejections.size) {
      log("UnhandledRejections detected");
      unhandledRejections.forEach((reason, promise) => {
        log(promise, reason);
      });
    }
  });

  return await command.run(options);
};

/**
 * Display general help for Truffle commands
 * @param {Object} options - options object
 * @param {Boolean} options.isREPL - whether or not the help is being displayed in a REPL
 * @returns {void}
 */
const displayGeneralHelp = options => {
  const yargs = __webpack_require__(64968)();
  const isREPL = options?.isREPL ?? false; //default to not displaying REPL commands
  const commands = isREPL ? validTruffleConsoleCommands : validTruffleCommands;
  commands.forEach(command => {
    // Exclude "install" and "publish" commands from the generated help list
    // because they have been deprecated/removed.
    if (command !== "install" && command !== "publish") {
      yargs.command(__webpack_require__(36219)(`./${command}/meta`));
    }
  });
  yargs
    .scriptName("truffle")
    .usage(
      "Truffle v" +
        (bundled || core) +
        " - a development framework for Ethereum" +
        OS.EOL +
        OS.EOL +
        "Usage: truffle <command> [options]"
    )
    .epilog("See more at https://trufflesuite.com/docs/" + 
      OS.EOL +
      "For Ethereum JSON-RPC documentation see https://ganache.dev")
    // showHelp prints using console.error, this won't log in a
    // child process - "log" forces it to use console.log instead
    .showHelp("log");
};

/**
 * This is a function to configure the url from the user specified network settings in the config.
 * @param {TruffleConfig} customConfig - Default config with user specified settings.
 * @param {boolean} isDashboardNetwork - Check if the network is dashboard or not.
 * @returns a string with the configured url
 */
const getConfiguredNetworkUrl = function (customConfig, isDashboardNetwork) {
  const defaultPort = isDashboardNetwork
    ? managedDashboardDefaultPort
    : managedGanacheDefaultPort;
  const configuredNetworkOptions = {
    host: customConfig.host || defaultHost,
    port: customConfig.port || defaultPort
  };
  const urlSuffix = isDashboardNetwork ? "/rpc" : "";
  return `http://${configuredNetworkOptions.host}:${configuredNetworkOptions.port}${urlSuffix}`;
};

/**
 * This is a function to derive the config environment from the user specified settings.
 * @param {TruffleConfig} detectedConfig - Default config with user specified settings.
 * @param {string} network - Network name specified with the `--network` option.
 * @param {string} url - URL specified with the `--url` option.
 * @returns a TruffleConfig object with the user specified settings in the config
 */
const deriveConfigEnvironment = function (detectedConfig, network, url) {
  let configuredNetwork;

  const configDefinesProvider =
    detectedConfig.networks[network] &&
    detectedConfig.networks[network].provider;

  if (configDefinesProvider) {
    // Use "provider" specified in the config to connect to the network
    // along with the other network properties
    configuredNetwork = {
      network_id: "*",
      ...detectedConfig.networks[network]
    };
  } else if (url) {
    // Use "url" to configure network (implies not "develop" and not "dashboard")
    configuredNetwork = {
      network_id: "*",
      url,
      provider: function () {
        return new Web3.providers.HttpProvider(url, {
          keepAlive: false
        });
      }
    };
  } else {
    // Otherwise derive network settings
    const customConfig = detectedConfig.networks[network] || {};
    const isDashboardNetwork = network === "dashboard";
    const configuredNetworkUrl = getConfiguredNetworkUrl(
      customConfig,
      isDashboardNetwork
    );
    const defaultNetworkId = isDashboardNetwork
      ? "*"
      : managedGanacheDefaultNetworkId;

    configuredNetwork = {
      network_id: customConfig.network_id || defaultNetworkId,
      provider: function () {
        return new Web3.providers.HttpProvider(configuredNetworkUrl, {
          keepAlive: false
        });
      },
      // customConfig will spread only when it is defined and ignored when undefined
      ...customConfig
    };
  }

  detectedConfig.networks[network] = {
    ...configuredNetwork
  };

  return detectedConfig;
};

module.exports = {
  displayGeneralHelp,
  parseQuotesAndEscapes,
  getCommand,
  prepareOptions,
  runCommand,
  getConfiguredNetworkUrl,
  deriveConfigEnvironment
};


/***/ }),

/***/ 62571:
/***/ ((module) => {

module.exports = {
  command: "build",
  description: "Execute build pipeline (if configuration present)",
  builder: {},
  help: {
    usage: "truffle build",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 22674:
/***/ ((module) => {

module.exports = {
  command: "call",
  description: "Call read-only contract function with arguments",
  builder: {
    "url": {
      describe: "Connect to a specified provider given via URL",
      type: "string"
    },
    "network": {
      describe: "The network name to connect to as specified in the config",
      type: "string"
    },
    "from": {
      describe: "The address to perform the call from",
      type: "string"
    },
    "_": {
      type: "string"
    },
    "fetch-external": {
      describe: "Fetch referenced verified contracts as needed",
      alias: "x",
      type: "boolean",
      default: false
    },
    "block-number": {
      describe: "Specify the block for the function to be called in.",
      alias: "b",
      type: "string",
      default: "latest"
    }
  },
  help: {
    usage:
      "truffle call <contract-address>|<contract-name> <function-name>|<function-signature>\n" +
      "                             " + // spacing to align with previous line
      "<arg1> ... <argN> [--fetch-external|-x] [--network <network>|--url <provider_url>]\n" +
      "                             " + // spacing to align with previous line
      "[--block-number|-b <block_number>]",
    options: [
      {
        option: "<contract-name>",
        description: "The name of the contract to be called."
      },
      {
        option: "<contract-address>",
        description: "The address of the contract to be called."
      },
      {
        option: "<function-name>",
        description: "The name of the function to be called."
      },
      {
        option: "<function-signature>",
        description:
          "The full function ABI signature (not selector) to be called."
      },
      {
        option: "<arg1> ... <argN>",
        description: "List of arguments to be passed to the function."
      },
      {
        option: "--fetch-external|-x",
        description:
          "Allows Truffle to fetch verified source for the contract being called;\n" +
          "                    note this is useful only when the contract is supplied by address."
      },
      {
        option: "--url",
        description:
          "Connects to a specified provider given via URL, ignoring networks in config."
      },
      {
        option: "--network",
        description:
          "The network to connect to, as specified in the Truffle config."
      },
      {
        option: "--block-number|-b",
        description: "Specifies the block for the function to be called in."
      }
    ],
    allowedGlobalOptions: ["from", "config"]
  }
};


/***/ }),

/***/ 91874:
/***/ ((module) => {

const validTruffleCommands = [
  "build",
  "call",
  "compile",
  "config",
  "console",
  "create",
  "dashboard",
  "db",
  "debug",
  "deploy",
  "develop",
  "exec",
  "help",
  "init",
  "install", // removed/deprecated
  "migrate",
  "networks",
  "obtain",
  "opcode",
  "preserve",
  "publish", // removed/deprecated
  "run",
  "test",
  "unbox",
  "version",
  "watch"
];

//List of truffle commands that are excluded from the console REPLS.
const excludedTruffleConsoleCommands = [
  "console",
  "dashboard",
  "db",
  "develop",
  "init",
  "watch"
];

const validTruffleConsoleCommands = validTruffleCommands.filter(
  command => !excludedTruffleConsoleCommands.includes(command)
);

module.exports = {
  excludedTruffleConsoleCommands,
  validTruffleCommands,
  validTruffleConsoleCommands
};


/***/ }),

/***/ 53051:
/***/ ((module) => {

module.exports = {
  command: "compile",
  description: "Compile contract source files",
  builder: {
    all: {
      type: "boolean",
      default: false
    },
    compiler: {
      type: "string",
      default: null
    },
    list: {
      type: "string"
    },
    help: {
      type: "boolean",
      default: "false"
    }
  },
  help: {
    usage:
      "truffle compile [<source1> <source2>...] [--list <filter>] [--all] [--quiet]",
    options: [
      {
        option: "--all",
        description:
          "Compile all contracts instead of only the contracts changed since last compile."
      },
      {
        option: "--list <filter>",
        description:
          "List all recent stable releases from solc-bin.  If filter is specified then it will display only " +
          "that\n                    type of release or docker tags. The filter parameter must be one of the following: " +
          "prereleases,\n                    releases, latestRelease or docker."
      },
      {
        option: "--compiler <compiler-name>",
        description:
          "Specify a single compiler to use (e.g. `--compiler=solc`). Specify `none` to skip compilation."
      },
      {
        option: "--save-intermediate <output-file>",
        hidden: true,
        description:
          "Save the raw compiler results into <output-file>, overwriting any existing content."
      }
    ],
    allowedGlobalOptions: ["config", "quiet"]
  }
};


/***/ }),

/***/ 24722:
/***/ ((module) => {

module.exports = {
  command: "config",
  description: "Set user-level configuration options",
  help: {
    usage:
      "truffle config [--enable-analytics|--disable-analytics] [<list>] [[<get|set> <key>] [<value-for-set>]]",
    options: [
      {
        option: "--enable-analytics",
        description: "Enable Truffle to send usage data to Google Analytics."
      },
      {
        option: "--disable-analytics",
        description:
          "Disable Truffle's ability to send usage data to Google Analytics."
      },
      {
        option: "get",
        description: "Get a Truffle config option value."
      },
      {
        option: "set",
        description: "Set a Truffle config option value."
      },
      {
        option: "list",
        description: "List all Truffle config values."
      }
    ],
    allowedGlobalOptions: []
  },
  builder: {
    _: {
      type: "string"
    }
  }
};


/***/ }),

/***/ 21288:
/***/ ((module) => {

module.exports = {
  command: "console",
  description:
    "Run a console with contract abstractions and commands available",
  builder: {
    url: {
      describe: "Use specified URL for provider",
      type: "string"
    }
  },
  help: {
    usage:
      "truffle console [--verbose-rpc] [--require|-r <file>] [--network <network>|--url <provider_url>]",
    options: [
      {
        option: "--url",
        description:
          "Creates a provider using the given url and connects to the network. This can be used outside of a Truffle project."
      },
      {
        option: "--network",
        description:
          "The network to connect to, as specified in the Truffle config."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--require|-r <file>",
        description:
          "Preload console environment from required JavaScript " +
          "file. The default export must be an object with named keys that " +
          "will be used\n                    to populate the console environment."
      },
      {
        option: "--require-none",
        description:
          "Do not load any user-defined JavaScript into the " +
          "console environment. This option takes precedence over --require, " +
          "-r, and\n                    values provided for console.require " +
          "in your project's truffle-config.js."
      }
    ],
    // The 'network' option is excluded from here and added manually above as a workaround to combine its usage
    // instructions with url to show that they are mutually exclusive.
    allowedGlobalOptions: ["config"]
  }
};


/***/ }),

/***/ 46038:
/***/ ((module) => {

module.exports = {
  command: "create",
  description: "Helper to create new contracts, migrations and tests",
  builder: {
    all: {
      type: "boolean",
      default: false
    },
    force: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle create <artifact_type> <ArtifactName>",
    options: [
      {
        option: "<artifact_type>",
        description:
          "Create a new artifact where artifact_type is one of the following: " +
          "contract, migration,\n                    test or all. The new artifact is created " +
          "along with one (or all) of the following\n                    files: `contracts/ArtifactName.sol`, " +
          "`migrations/####_artifact_name.js` or\n                    `tests/artifact_name.js`. (required)"
      },
      {
        option: "<ArtifactName>",
        description: "Name of new artifact. (required)"
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 99608:
/***/ ((module) => {

module.exports = {
  command: "dashboard",
  description:
    "Start Truffle Dashboard to sign development transactions using browser wallet",
  builder: {
    "port": {
      describe: "Specify the port to start the dashboard and RPC endpoint on",
      type: "number"
    },
    "host": {
      describe: "Specify the host to start the dashboard and RPC endpoint on",
      type: "string"
    },
    "no-auto-open": {
      describe: "Disable opening dashboard in default browser on start",
      type: "boolean"
    },
    "verbose": {
      describe: "Display debug logs for the dashboard server and message bus",
      type: "boolean"
    }
  },
  help: {
    usage: "truffle dashboard [--port <number>] [--host <string>] [--verbose]",
    options: [
      {
        option: "--port <number>",
        description: "Start the dashboard and RPC endpoint on a specific port."
      },
      {
        option: "--host <string>",
        description: "Start the dashboard and RPC endpoint on a specific host."
      },
      {
        option: "--no-auto-open",
        description: "Disable opening dashboard in default browser on start"
      },
      {
        option: "--verbose",
        description:
          "Log debug information from the Dashboard server and message bus."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 42089:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(50823),
  meta: __webpack_require__(79062)
};


/***/ }),

/***/ 79062:
/***/ ((module) => {

module.exports = {
  command: "query",
  description: "Query @truffle/db",
  builder: {},
  help: {
    usage: "truffle db query <query>",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 50823:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This command does starts an express derived server that invokes
 * `process.exit()` on SIGINT. As a result there is no need to invoke
 * truffle's own `process.exit()` which is triggered by invoking the `done`
 * callback.
 *
 * Todo: blacklist this command for REPLs
 */
module.exports = async function (argv) {
  const Config = __webpack_require__(20553);
  const { getTruffleDb } = __webpack_require__(70972);
  const Db = getTruffleDb();
  if (Db === null) {
    throw new Error(
      "There was a problem importing Truffle Db. Ensure that you have " +
        "@truffle/db installed."
    );
  }
  const { connect } = Db;

  const config = Config.detect(argv);
  const [_, query] = config._;

  if (!query) {
    throw new Error(
      "Query not provided. Please run `truffle db query <query>`"
    );
  }

  const db = connect(config.db);

  const result = await db.execute(query, {});
  console.log(JSON.stringify(result, null, 2));
};


/***/ }),

/***/ 43405:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(12233),
  meta: __webpack_require__(11297)
};


/***/ }),

/***/ 11297:
/***/ ((module) => {

module.exports = {
  command: "serve",
  description: "Start Truffle's GraphQL UI playground",
  builder: {},
  help: {
    usage: "truffle db serve",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 12233:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* This command does starts an express derived server that invokes
 * `process.exit()` on SIGINT. As a result there is no need to invoke
 * truffle's own `process.exit()` which is triggered by invoking the `done`
 * callback.
 *
 * Todo: blacklist this command for REPLs
 */
module.exports = async function (argv) {
  const Config = __webpack_require__(20553);
  const { getTruffleDb } = __webpack_require__(70972);
  const Db = getTruffleDb();
  if (Db === null) {
    throw new Error(
      "There was a problem importing Truffle Db. Ensure that you have " +
        "@truffle/db installed."
    );
  }
  const { serve } = Db;

  const config = Config.detect(argv);
  const port = (config.db && config.db.port) || 4444;
  const host = (config.db && config.db.host) || "127.0.0.1";

  const { url } = await serve(config.db).listen({ host, port });

  console.log(`ðŸš€ Playground listening at ${url}`);
  console.log(`â„¹  Press Ctrl-C to exit`);

  await new Promise(() => {});
};


/***/ }),

/***/ 50111:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);
const serveCommand = __webpack_require__(43405);
const queryCommand = __webpack_require__(42089);

const usage =
  "truffle db <sub-command> [options]" +
  OS.EOL +
  "  Available sub-commands: " +
  OS.EOL +
  "                serve \tStart the GraphQL server" +
  OS.EOL +
  "                query \tQuery @truffle/db";

module.exports = {
  command: "db",
  description: "Database interface commands",
  builder: function (yargs) {
    return yargs
      .command({
        ...serveCommand.run,
        ...serveCommand.meta
      })
      .command({
        ...queryCommand.run,
        ...queryCommand.meta
      })
      .demandCommand();
  },

  subCommands: {
    serve: serveCommand.meta,
    query: queryCommand.meta
  },

  help: {
    usage,
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 42285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);

module.exports = {
  command: "debug",
  description: "Interactively debug any transaction on the blockchain",
  builder: {
    "url": {
      describe: "Use specified URL for provider",
      type: "string"
    },
    "_": {
      type: "string"
    },
    "fetch-external": {
      describe: "Allow debugging of external contracts",
      alias: "x",
      type: "boolean",
      default: false
    },
    "compile-tests": {
      describe: "Allow debugging of Solidity test contracts",
      type: "boolean",
      default: false
    },
    "compile-all": {
      describe: "Force debugger to compile all contracts for extra safety",
      type: "boolean",
      default: false
    },
    "compile-none": {
      describe: "Force debugger to skip compilation (dangerous!)",
      type: "boolean",
      default: false
    },
    "no-ens": {
      describe: "Turns off ens reverse resolution",
      type: "boolean",
      default: false
    },
    "registry": {
      describe: "Allows setting a custom address for the ENS registry",
      type: "string"
    }
  },
  help: {
    usage:
      "truffle debug [<transaction_hash>] [--fetch-external|-x]" +
      OS.EOL +
      "                             [--network <network>|--url <provider_url>]" +
      OS.EOL +
      "                             [--no-ens|--registry <registry_address>]" +
      OS.EOL +
      "                             [--compile-tests|--compile-all|--compile-none]",
    options: [
      {
        option: "<transaction_hash>",
        description:
          "Transaction ID to use for debugging.  Mandatory if --fetch-external is passed."
      },
      {
        option: "--fetch-external|-x",
        description:
          "Allows debugging of external contracts with verified sources."
      },
      {
        option: "--network",
        description:
          "The network to connect to, as specified in the Truffle config."
      },
      {
        option: "--url",
        description:
          "Connects to a specified provider given via URL, ignoring networks in config. This option allows using the debugger outside of a Truffle project."
      },
      {
        option: "--no-ens",
        description: "Disables ENS reverse resolution when decoding addresses."
      },
      {
        option: "--registry",
        description:
          "Allows setting a custom registry for performing reverse ENS resolution, or setting such a registry at all on lesser-known networks."
      },
      {
        option: "--compile-tests",
        description:
          "Allows debugging of Solidity test contracts from the test directory.  Implies --compile-all."
      },
      {
        option: "--compile-all",
        description:
          "Forces the debugger to recompile all contracts even if it detects that it can use the artifacts."
      },
      {
        option: "--compile-none",
        description:
          "Forces the debugger to use artifacts even if it detects a problem.  Dangerous; may cause errors."
      }
    ],
    allowedGlobalOptions: ["config"]
    //although network is an allowed global option, it isn't listed here because listing it here would cause
    //it to be tacked on to the end of usage, which would prevent us from doing the thing above where we
    //combine its usage instructions with url to show that they're mutually exclusive.  so as a workaround
    //we've excluded network from here, and added it manually above.
  }
};


/***/ }),

/***/ 5561:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const migrate = __webpack_require__(1827);

module.exports = {
  command: "deploy",
  description: "(alias for migrate)",
  builder: migrate.builder,
  help: {
    usage:
      "truffle deploy [--reset] [-f <number>] [--compile-all] [--verbose-rpc]",
    options: migrate.meta.help.options,
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 14957:
/***/ ((module) => {

module.exports = {
  command: "develop",
  description: "Open a console with a local development blockchain",
  builder: {
    log: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle develop [--log] [--require|-r <file>]",
    options: [
      {
        option: `--log`,
        description:
          `Start/Connect to a Truffle develop session and log all ` +
          `rpc activity. You will\n                    need to open a ` +
          `different Truffle develop or console session to interact via the repl.`
      },
      {
        option: "--require|-r <file>",
        description:
          "Preload console environment from required JavaScript " +
          "file. The default export must be an object with named keys that " +
          "will be used\n                    to populate the console environment."
      },
      {
        option: "--require-none",
        description:
          "Do not load any user-defined JavaScript into the " +
          "console environment. This option takes precedence over --require, " +
          "-r, and\n                    values provided for console.require " +
          "in your project's truffle-config.js."
      }
    ],
    allowedGlobalOptions: ["config"]
  }
};


/***/ }),

/***/ 81483:
/***/ ((module) => {

module.exports = {
  command: "exec",
  description: "Execute a JS module within this Truffle environment",
  builder: {
    file: {
      type: "string"
    },
    c: {
      type: "boolean",
      default: false
    },
    compile: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle exec <script.js> [--compile]",
    options: [
      {
        option: "<script.js>",
        description:
          "JavaScript file to be executed. Can include path information if the script" +
          " does not exist in the current\n                    directory. (required)"
      },
      {
        option: "--compile",
        description: "Compile contracts before executing the script."
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 34914:
/***/ ((module) => {

module.exports = {
  command: "help",
  description:
    "List all commands or provide information about a specific command",
  help: {
    usage: "truffle help [<command> [<subCommand>]]",
    options: [
      {
        option: "<command>",
        description: "Name of the command to display information for."
      }
    ],
    allowedGlobalOptions: []
  },
  builder: {}
};


/***/ }),

/***/ 83193:
/***/ ((module) => {

module.exports = {
  command: "init",
  description: "Initialize new and empty Ethereum project",
  builder: {},
  help: {
    usage: "truffle init [--force]",
    options: [
      {
        option: "--force",
        description:
          "Initialize project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 72545:
/***/ ((module) => {

module.exports = {
  command: "install",
  description:
    "ethpm has moved on faster than truffle's integration. " +
    "\n                This feature has been broken for some time, so we've disabled it. " +
    "\n                Please refer to https://github.com/trufflesuite/truffle/discussions/5293",
  builder: {},
  help: {
    usage: "truffle install has been removed.",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 83292:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Ganache = __webpack_require__(11651);

module.exports = function (config, options) {
  //note: this is a list of chain IDs but we're still using
  //network ID.  This should be fixed later.
  const supportedChainIds = Ganache.__experimental_info().fork.knownChainIds;

  let dryRunOnly, skipDryRun;
  const networkSettingsInConfig = config.networks[config.network];
  if (networkSettingsInConfig) {
    dryRunOnly =
      options.dryRun === true ||
      networkSettingsInConfig.dryRun === true ||
      networkSettingsInConfig["dry-run"] === true;
    skipDryRun =
      options.skipDryRun === true ||
      networkSettingsInConfig.skipDryRun === true ||
      networkSettingsInConfig["skip-dry-run"] === true;
  } else {
    dryRunOnly = options.dryRun === true;
    skipDryRun = options.skipDryRun === true;
  }
  const production =
    supportedChainIds.includes(parseInt(config.network_id)) ||
    config.production;
  const dryRunAndMigrations = production && !skipDryRun;
  return { dryRunOnly, dryRunAndMigrations };
};


/***/ }),

/***/ 1827:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(52423),
  meta: __webpack_require__(88226),
  runMigrations: __webpack_require__(96146),
  setUpDryRunEnvironmentThenRunMigrations: __webpack_require__(43687),
  determineDryRunSettings: __webpack_require__(83292),
  prepareConfigForRealMigrations: __webpack_require__(97374)
};


/***/ }),

/***/ 88226:
/***/ ((module) => {

module.exports = {
  command: "migrate",
  description: "Run migrations to deploy contracts",
  builder: {
    "reset": {
      type: "boolean",
      default: false
    },
    "compile-all": {
      describe: "Recompile all contracts",
      type: "boolean",
      default: false
    },
    "compile-none": {
      describe: "Do not compile contracts",
      type: "boolean",
      default: false
    },
    "--verbose-rpc": {
      describe: "Log communication between Truffle and the Ethereum client.",
      type: "boolean",
      default: false
    },
    "dry-run": {
      describe: "Run migrations against an in-memory fork, for testing",
      type: "boolean",
      default: false
    },
    "skip-dry-run": {
      describe: "Skip the test or 'dry run' migrations",
      type: "boolean",
      default: false
    },
    "f": {
      describe: "Specify a migration number to run from",
      type: "number"
    },
    "to": {
      describe: "Specify a migration number to run to",
      type: "number"
    },
    "interactive": {
      describe: "Manually authorize deployments after seeing a preview",
      type: "boolean",
      default: false
    },
    "describe-json": {
      describe: "Adds extra verbosity to the status of an ongoing migration",
      type: "boolean",
      default: false
    },
    "save": {
      describe: "Specify whether the migration will save on chain",
      type: "boolean",
      default: true,
      hidden: true
    }
  },
  help: {
    usage:
      "truffle migrate [--reset] [--f <number>] [--to <number>]\n" +
      "                                " + // spacing to align with previous line
      "[--compile-all] [--compile-none] [--verbose-rpc] [--interactive]\n" +
      "                                " + // spacing to align with previous line
      "[--skip-dry-run] [--describe-json] [--dry-run]",
    options: [
      {
        option: "--reset",
        description:
          "Run all migrations from the beginning, instead of running from the last " +
          "completed migration."
      },
      {
        option: "--f <number>",
        description:
          "Run contracts from a specific migration. The number refers to the prefix of " +
          "the migration file."
      },
      {
        option: "--to <number>",
        description:
          "Run contracts to a specific migration. The number refers to the prefix of the migration file."
      },
      {
        option: "--compile-all",
        description:
          "Compile all contracts instead of intelligently choosing which contracts need to " +
          "be compiled."
      },
      {
        option: "--compile-none",
        description: "Do not compile any contracts before migrating."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--interactive",
        description:
          "Prompt to confirm that the user wants to proceed after the dry run."
      },
      {
        option: "--dry-run",
        description: "Only perform a test or 'dry run' migration."
      },
      {
        option: "--skip-dry-run",
        description: "Do not run a test or 'dry run' migration."
      },
      {
        option: "--describe-json",
        description:
          "Adds extra verbosity to the status of an ongoing migration"
      },
      {
        option: "--save",
        description: "Specify whether the migration will save on chain",
        hidden: true
      }
    ],
    allowedGlobalOptions: ["network", "config", "quiet"]
  }
};


/***/ }),

/***/ 97374:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (buildDir, options) {
  const Artifactor = __webpack_require__(29463);
  const { Resolver } = __webpack_require__(48511);
  const Migrate = (__webpack_require__(22478)["default"]);
  const { Environment } = __webpack_require__(76765);
  const Config = __webpack_require__(20553);

  let accept = true;

  if (options.interactive) {
    accept = await Migrate.promptToAcceptDryRun();
  }

  if (accept) {
    const config = Config.detect(options);

    config.contracts_build_directory = buildDir;
    config.artifactor = new Artifactor(buildDir);
    config.resolver = new Resolver(config);

    try {
      await Environment.detect(config);
    } catch (error) {
      throw new Error(error);
    }

    config.dryRun = false;
    return {
      preparedConfig: config,
      proceed: true
    };
  } else {
    return { proceed: false };
  }
};


/***/ }),

/***/ 52423:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const WorkflowCompile = (__webpack_require__(37017)["default"]);
  const { Environment } = __webpack_require__(76765);
  const Config = __webpack_require__(20553);
  const determineDryRunSettings = __webpack_require__(83292);
  const prepareConfigForRealMigrations = __webpack_require__(97374);
  const runMigrations = __webpack_require__(96146);
  const setUpDryRunEnvironmentThenRunMigrations = __webpack_require__(43687);
  const tmp = __webpack_require__(36276);
  tmp.setGracefulCleanup();

  const config = Config.detect(options);
  if (config.compileNone || config["compile-none"]) {
    config.compiler = "none";
  }

  const result = await WorkflowCompile.compileAndSave(config);
  await WorkflowCompile.assignNames(config, result);
  await Environment.detect(config);

  const { dryRunOnly, dryRunAndMigrations } = determineDryRunSettings(
    config,
    options
  );

  if (dryRunOnly) {
    config.dryRun = true;
    await setUpDryRunEnvironmentThenRunMigrations(config);
  } else if (dryRunAndMigrations) {
    const currentBuild = config.contracts_build_directory;
    config.dryRun = true;

    await setUpDryRunEnvironmentThenRunMigrations(config);

    const { preparedConfig, proceed } = await prepareConfigForRealMigrations(
      currentBuild,
      options
    );
    if (proceed) await runMigrations(preparedConfig);
  } else {
    await runMigrations(config);
  }
};


/***/ }),

/***/ 96146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { createReadStream } = __webpack_require__(57147);
const { readdir } = __webpack_require__(73292);
const path = __webpack_require__(71017);
const JSONStream = __webpack_require__(31327);
const Migrate = (__webpack_require__(22478)["default"]);
const TruffleError = __webpack_require__(73321);
const os = __webpack_require__(22037);
const debug = __webpack_require__(15158)("migrate:run");

// Search for Push1 (60) to Push(32) 7F + console.log
//                      60 ---- 7F  C O N S O L E . L O G
const consoleLogRex = /[67][0-9a-f]636F6e736F6c652e6c6f67/i;

async function usesConsoleLog(artifactJson) {
  const debugLog = debug.extend("test");
  debugLog("Artifact: %o", artifactJson);

  //create a parser to get the value of jsonpath .deployedBytecode
  const parser = JSONStream.parse(["deployedBytecode"]);
  const stream = createReadStream(artifactJson).pipe(parser);

  return new Promise((resolve, reject) => {
    stream.on("data", data => {
      //JSONParse will emit the entire string/value
      //so initiate stream cleanup here
      stream.destroy();
      const usesConsoleLog = consoleLogRex.test(data);
      debugLog("usesConsoleLog:", usesConsoleLog);
      resolve(usesConsoleLog);
    });

    stream.on("error", err => {
      stream.destroy();
      debugLog("onError: %o", err);
      reject(err);
    });
  });
}

async function findArtifactsThatUseConsoleLog(buildDir) {
  const debugLog = debug.extend("dirty-files");
  const filenames = await readdir(buildDir);

  const artifacts = [];
  await Promise.allSettled(
    filenames.map(async filename => {
      if (filename.endsWith(".json")) {
        try {
          const itLogs = await usesConsoleLog(path.join(buildDir, filename));
          if (itLogs) {
            artifacts.push(filename);
          }
        } catch (e) {
          debugLog("Promise failure: %o", e.message);
        }
      }
    })
  );
  return artifacts;
}

module.exports = async function (config) {
  const debugLog = debug.extend("guard");
  // only check if deploying on MAINNET
  // NOTE: this includes Ethereum Classic as well as Ethereum as they're only
  // distinguishable by checking their chainIds, 2 and 1 respectively.
  if (config.network_id === 1) {
    debugLog("solidityLog guard for mainnet");
    try {
      const buildDir = config.contracts_build_directory;
      const loggingArtifacts = await findArtifactsThatUseConsoleLog(buildDir);

      debugLog(`${loggingArtifacts.length} consoleLog artifacts detected`);
      debugLog(
        "config.solidityLog.preventConsoleLogMigration: " +
          config.solidityLog.preventConsoleLogMigration
      );

      if (loggingArtifacts.length) {
        console.warn(
          `${os.EOL}Solidity console.log detected in the following assets:`
        );
        console.warn(loggingArtifacts.join(", "));
        console.warn();

        if (config.solidityLog.preventConsoleLogMigration) {
          throw new TruffleError(
            "You are trying to deploy contracts that use console.log." +
              os.EOL +
              "Please fix, or disable this check by setting solidityLog.preventConsoleLogMigration to false" +
              os.EOL
          );
        }
      }
    } catch (err) {
      if (err instanceof TruffleError) throw err;

      debugLog("Unexpected error %o:", err);
      // Something went wrong while inspecting for console log.
      // Log warning and skip the remaining logic in this branch
      console.warn();
      console.warn(
        "Failed to detect Solidity console.log usage:" + os.EOL + err
      );
    }
  }

  if (config.f) {
    return await Migrate.runFrom(config.f, config);
  } else {
    const needsMigrating = await Migrate.needsMigrating(config);

    if (needsMigrating) {
      return await Migrate.run(config);
    } else {
      config.logger.log("Network up to date.");
    }
  }
};


/***/ }),

/***/ 43687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Environment } = __webpack_require__(76765);
const Artifactor = __webpack_require__(29463);

const { Resolver } = __webpack_require__(48511);
const fse = __webpack_require__(55674);

const tmp = __webpack_require__(36276);
tmp.setGracefulCleanup();
const runMigrations = __webpack_require__(96146);

module.exports = async function (config) {
  await Environment.fork(config, {
    logging: {
      quiet: true
    },
    // we need to tell Ganache to not unlock any accounts so that only
    // user's accounts are unlocked since this will be a dry run
    wallet: {
      totalAccounts: 0
    }
  });
  // Copy artifacts to a temporary directory
  const temporaryDirectory = tmp.dirSync({
    unsafeCleanup: true,
    prefix: "migrate-dry-run-"
  }).name;

  fse.copySync(config.contracts_build_directory, temporaryDirectory);

  config.contracts_build_directory = temporaryDirectory;
  // Note: Create a new artifactor and resolver with the updated config.
  // This is because the contracts_build_directory changed.
  // Ideally we could architect them to be reactive of the config changes.
  config.artifactor = new Artifactor(temporaryDirectory);
  config.resolver = new Resolver(config);

  return await runMigrations(config);
};


/***/ }),

/***/ 41873:
/***/ ((module) => {

module.exports = {
  command: "networks",
  description: "Show addresses for deployed contracts on each network",
  builder: {
    clean: {
      describe:
        "Remove network artifacts that don't belong to any configuration",
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle networks [--clean]",
    options: [
      {
        option: "--clean",
        description:
          "Remove all network artifacts that aren't associated with a named network."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 19518:
/***/ ((module) => {

module.exports = {
  command: "obtain",
  description: "Fetch and cache a specified compiler",
  help: {
    usage: "truffle obtain [--solc <version>]",
    options: [
      {
        option: "--solc <version>",
        description: `Download and cache a version of the solc compiler. (required)`
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 3697:
/***/ ((module) => {

module.exports = {
  command: "opcode",
  description: "Print the compiled opcodes for a given contract",
  builder: {
    all: {
      type: "boolean",
      default: false
    }
  },
  help: {
    usage: "truffle opcode <contract_name>",
    options: [
      {
        option: "<contract_name>",
        description:
          "Name of the contract to print opcodes for. Must be a contract name, not a file name. (required)"
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 75861:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  command: "preserve",
  description:
    "Save data to decentralized storage platforms like IPFS and Filecoin",
  help: options => {
    const TruffleError = __webpack_require__(73321);
    const { Plugins } = __webpack_require__(42113);
    const { getConfig } = __webpack_require__(61914);
    const semver = __webpack_require__(81249);

    if (!semver.satisfies(process.version, ">=12")) {
      throw new TruffleError(
        `The current version of Node (${process.version}) does not support \`truffle preserve\`, please update to Node >=12`
      );
    }

    const config = getConfig(options);

    const recipes = Plugins.listAllRecipes(config);

    // If a recipe does not define a tag, it is not an end-user recipe
    const recipeFlags = recipes
      .filter(recipe => recipe.tag !== undefined)
      .map(recipe => ({
        option: `--${recipe.tag}`,
        description: recipe.loadRecipe().help
      }));

    const flags = [
      {
        option: "--environment",
        description:
          "Environment name, as defined in truffle-config `environments` object"
      },
      ...recipeFlags
    ];

    return {
      usage:
        "truffle preserve [--environment=<environment>] <target-path>... --<recipe-tag>",
      options: flags,
      allowedGlobalOptions: []
    };
  }
};


/***/ }),

/***/ 61914:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(20553);

const getConfig = options => {
  let config;
  try {
    config = Config.detect(options);
  } catch (_) {
    config = Config.default().with(options);
  }

  config.plugins = config.plugins || [];
  return config;
};

const constructRecipes = (plugins, environment) => {
  return plugins.map(plugin => {
    const options = (environment || {})[plugin.tag] || {};
    const Recipe = plugin.loadRecipe();
    const recipe = new Recipe(options);
    return recipe;
  });
};

module.exports = {
  getConfig,
  constructRecipes
};


/***/ }),

/***/ 39662:
/***/ ((module) => {

module.exports = {
  command: "publish",
  description:
    "ethpm has moved on faster than truffle's integration. " +
    "\n                This feature has been broken for some time, so we've disabled it. " +
    "\n                Please refer to https://github.com/trufflesuite/truffle/discussions/5293",
  builder: {},
  help: {
    usage: "truffle publish has been removed",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 52068:
/***/ ((module) => {

module.exports = {
  command: "run",
  description: "Run a third-party command",
  builder: {},
  help: {
    usage: "truffle run [<command>]",
    options: [
      {
        option: "<command>",
        description: "Name of the third-party command to run."
      }
    ],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 43059:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);

module.exports = {
  command: "test",
  description: "Run JavaScript and Solidity tests",
  builder: {
    "show-events": {
      describe: "Show all test logs",
      type: "boolean",
      default: false
    },
    "compile-all-debug": {
      describe: "Compile in debug mode",
      type: "boolean",
      default: false
    },
    "debug": {
      describe: "Enable in-test debugging",
      type: "boolean",
      default: false
    },
    "debug-global": {
      describe: "Specify debug global function name",
      default: "debug"
    },
    "runner-output-only": {
      describe: "Suppress all output except for test runner output.",
      type: "boolean",
      default: false
    },
    "bail": {
      alias: "b",
      describe: "Bail after first test failure",
      type: "boolean",
      default: false
    },
    "grep": {
      alias: "g",
      type: "string",
      describe:
        `Use mocha's "grep" option while running tests. This ` +
        `option only runs tests that match the supplied regex/string.`
    },
    "stacktrace": {
      alias: "t",
      describe: "Produce Solidity stacktraces",
      type: "boolean",
      default: false
    },
    "stacktrace-extra": {
      describe: "Produce Solidity stacktraces and compile in debug mode",
      type: "boolean",
      default: false
    },
    "reporter": {
      alias: "r",
      describe: "Specify the type of mocha reporter",
      default: undefined
    }
  },
  help: {
    usage:
      `truffle test [<test_file>] [--compile-all[-debug]] [--compile-none] ` +
      `[--migrate-none] ` +
      `[--network <name>]${OS.EOL}                             ` +
      `[--verbose-rpc] [--show-events] [--debug] ` +
      `[--debug-global <identifier>] [--bail|-b]${OS.EOL}                      ` +
      `       [--stacktrace[-extra]] [--grep|-g <regex>] ` +
      `[--reporter|-r <name>] `,
    options: [
      {
        option: "<test_file>",
        description:
          "Name of the test file to be run. Can include path information if the file " +
          "does not exist in the\n                    current directory."
      },
      {
        option: "--compile-all",
        description:
          "Compile all contracts instead of intelligently choosing which contracts need " +
          "to be compiled."
      },
      {
        option: "--compile-none",
        description: "Do not compile any contracts before running the tests"
      },
      {
        option: "--compile-all-debug",
        description:
          "Compile all contracts and do so in debug mode for extra revert info.  May " +
          "cause errors on large\n                    contracts."
      },
      {
        option: "--migrate-none",
        description: "Do not migrate any contracts before running the tests."
      },
      {
        option: "--verbose-rpc",
        description:
          "Log communication between Truffle and the Ethereum client."
      },
      {
        option: "--show-events",
        description: "Log all contract events."
      },
      {
        option: "--debug",
        description:
          "Provides global debug() function for in-test debugging. " +
          "JS tests only; implies --compile-all."
      },
      {
        option: "--debug-global <identifier>",
        description:
          'Specify global identifier for debug function. Default: "debug"'
      },
      {
        option: "--runner-output-only",
        description: "Suppress all output except for test runner output."
      },
      {
        option: "--bail|-b",
        description: "Bail after first test failure."
      },
      {
        option: "--stacktrace",
        description:
          "Allows for mixed JS/Solidity stacktraces when a Truffle Contract transaction " +
          "or deployment\n                    reverts.  Does not apply to calls or gas estimates.  " +
          "Implies --compile-all.  Experimental.  Alias: -t"
      },
      {
        option: "--stacktrace-extra",
        description: "Shortcut for --stacktrace --compile-all-debug."
      },
      {
        option: "--grep|-g",
        description:
          'Use mocha\'s "grep" option while running tests. This ' +
          "option only runs tests that match the supplied regex/string."
      },
      {
        option: "--reporter|-r <name>",
        description:
          "Specify the type of mocha reporter to use during testing. Default: 'spec'"
      }
    ],
    allowedGlobalOptions: ["network", "config"]
  }
};


/***/ }),

/***/ 74292:
/***/ ((module) => {

module.exports = {
  command: "unbox",
  description: "Download a Truffle Box, a pre-built Truffle project",
  builder: {},
  help: {
    usage: "truffle unbox [<box_name>] [destination] [--force]",
    options: [
      {
        option: "destination",
        description:
          "Path to the directory in which you would like " +
          "to unbox the project files. If destination is\n                  " +
          "  not provided, this defaults to the current directory."
      },
      {
        option: "<box_name>",
        description:
          "Name of the truffle box. If no box_name is specified, a default " +
          "truffle box will be downloaded."
      },
      {
        option: "--force",
        description:
          "Unbox project in the current directory regardless of its " +
          "state. Be careful, this\n                    will potentially overwrite files " +
          "that exist in the directory."
      }
    ],
    allowedGlobalOptions: ["quiet"]
  }
};


/***/ }),

/***/ 74770:
/***/ ((module) => {

module.exports = {
  command: "version",
  description: "Show version number and exit",
  builder: {},
  help: {
    usage: "truffle version",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 47766:
/***/ ((module) => {

module.exports = {
  command: "watch",
  description:
    "Watch filesystem for changes and rebuild the project automatically",
  builder: {},
  help: {
    usage: "truffle watch",
    options: [],
    allowedGlobalOptions: []
  }
};


/***/ }),

/***/ 99043:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);
const path = __webpack_require__(71017);
const fse = __webpack_require__(55674);
const Conf = __webpack_require__(19658);
const TruffleConfig = __webpack_require__(20553);
const debugModule = __webpack_require__(15158);
const debug = debugModule("core:config-migration");

const CURRENT_CONFIG_VERSION = 1;

module.exports = {
  oldTruffleDataDirectory: path.join(OS.homedir(), ".config", "truffle"),

  needsMigrated: function () {
    const conf = new Conf({ projectName: "truffle" });
    if (conf.get("version") === CURRENT_CONFIG_VERSION) return false;
    const oldConfig = path.join(this.oldTruffleDataDirectory, "config.json");
    if (fse.existsSync(oldConfig) && oldConfig !== conf.path) {
      // we are on Windows or a Mac
      return true;
    } else {
      // we are on Linux or previous config doesn't exist and we don't need to
      // perform a migration - current version set to designates success
      conf.set("version", CURRENT_CONFIG_VERSION);
      return false;
    }
  },

  migrateTruffleDataIfNecessary: async function () {
    if (!this.needsMigrated()) return;
    debug("Truffle files need to be migrated");
    const conf = this.migrateGlobalConfig();
    debug("successfully migrated global config");
    const folders = ["compilers", ".db"];
    for (const folder of folders) {
      await this.migrateFolder(folder);
      debug("successfully migrated folder: %o", folder);
    }
    // set version to current only after migration is complete to designate success
    conf.set("version", CURRENT_CONFIG_VERSION);
  },

  migrateGlobalConfig: function () {
    const conf = new Conf({ projectName: "truffle" });
    const oldSettings = __webpack_require__(18727)(path.join(
      this.oldTruffleDataDirectory,
      "config.json"
    ));
    for (const key in oldSettings) {
      conf.set(key, oldSettings[key]);
    }
    return conf;
  },

  migrateFolder: async function (folderName) {
    const targetPath = path.join(this.oldTruffleDataDirectory, folderName);
    // use conf to determine the new Truffle folder as it uses OS-appropriate locations
    const conf = new Conf({ projectName: "truffle" });
    const destinationPath = path.join(TruffleConfig.getTruffleDataDirectory(), folderName);
    if (fse.existsSync(targetPath)) {
      fse.copySync(targetPath, destinationPath);
    }
  }
};


/***/ }),

/***/ 67023:
/***/ ((module) => {

const options = {
  network: {
    option: "--network <name>",
    description:
      "Specify the network to use. Network name must exist in the configuration."
  },
  from: {
    option: "--from <account>",
    description:
      "Specify the default account from which to make calls or send transactions."
  },
  config: {
    option: "--config <file>",
    description:
      "Specify configuration file to be used. The default is truffle-config.js"
  },
  quiet: {
    option: "--quiet",
    description: "Suppress excess logging output."
  }
};
module.exports = options;


/***/ }),

/***/ 95614:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(20553);

const analytics = {
  send: function(eventObject) {
    const userConfig = Config.getUserConfig();

    if (!userConfig.get("enableAnalytics")) {
      // don't bother with creating a new process if we already
      // know the user doesn't want to send analytics
      return;
    }

    let analyticsPath;
    const path = __webpack_require__(71017);
    if (true) {
      analyticsPath = path.join(__dirname, "analytics.bundled.js");
    } else {}

    const cp = __webpack_require__(32081);
    const child = cp.fork(analyticsPath, { silent: true });
    child.send(eventObject);
  }
};

module.exports = analytics;


/***/ }),

/***/ 54708:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Extracts the input flags --option & -option from the arguments  of type `--option=value` or `--option value` or `--flag` or -flag
const extractFlags = inputArguments => {
  // Get all the args that begins with `--`. This also includes `--option=value`
  const inputFlags = inputArguments.filter(flag => {
    return flag.startsWith("--") || flag.startsWith("-") ? flag : null;
  });

  // Extract only the flags i.e `--option` from `--option=value`
  inputFlags.map((flag, i) => {
    let indexOfEqualsSign = flag.indexOf("=");
    if (indexOfEqualsSign > 0) {
      flag = flag.slice(0, indexOfEqualsSign);
      inputFlags.splice(i, 1, flag);
    }
  });
  return inputFlags;
};

const detectConfigOrDefault = options => {
  const Config = __webpack_require__(20553);

  try {
    return Config.detect(options);
  } catch (error) {
    // Suppress error when truffle can't find a config
    if (error.message === "Could not find suitable configuration file.") {
      return Config.default();
    } else {
      throw error;
    }
  }
};

module.exports = { extractFlags, detectConfigOrDefault };


/***/ }),

/***/ 64146:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const pkg = __webpack_require__(73755);
const { CompilerSupplier } = __webpack_require__(4273);
const Config = __webpack_require__(20553);

const info = config => {
  let bundleVersion;
  // NOTE: Webpack will replace BUNDLE_VERSION with a string.
  if (true) bundleVersion = "5.11.5";

  let supplierOptions;
  if (config && config.compilers) {
    supplierOptions = {
      events: config.events,
      solcConfig: config.compilers.solc
    };
  } else {
    const { events, compilers } = new Config();
    const solcConfig = compilers.solc;
    supplierOptions = { events, solcConfig };
  }
  const supplier = new CompilerSupplier(supplierOptions);

  return {
    core: pkg.version,
    bundle: bundleVersion,
    solc: supplier.version
  };
};

const logTruffle = (logger = console, versionInformation) => {
  const bundle = versionInformation.bundle
    ? `v${versionInformation.bundle}`
    : "(unbundled)";
  logger.log(`Truffle ${bundle} (core: ${versionInformation.core})`);
};

const logNode = (logger = console) => {
  logger.log(`Node ${process.version}`);
};

const logSolidity = (logger = console, versionInformation, config) => {
  let solcVersion;
  if (
    config &&
    config.compilers &&
    config.compilers.solc &&
    config.compilers.solc.version
  ) {
    solcVersion = config.compilers.solc.version;
    logger.log(`Solidity - ${solcVersion} (solc-js)`);
  } else {
    const versionInformation = info(config);
    solcVersion = versionInformation.solc;
    logger.log(`Solidity v${solcVersion} (solc-js)`);
  }
};

const logWeb3 = (logger = console) => {
  const web3Version = pkg.dependencies.web3;
  logger.log(`Web3.js v${web3Version}`);
};

const logGanache = (logger = console) => {
  const ganacheVersion = pkg.dependencies.ganache;
  logger.log(`Ganache v${ganacheVersion}`);
};

const logAll = (logger = console, config) => {
  const versionInformation = info(config);
  logTruffle(logger, versionInformation);
  logGanache(logger);
  logSolidity(logger, versionInformation, config);
  logNode(logger);
  logWeb3(logger);
};

const logTruffleAndNode = (logger = console, config) => {
  const versionInformation = info(config);
  logTruffle(logger, versionInformation);
  logNode(logger);
};

module.exports = {
  logAll,
  info,
  logTruffleAndNode
};


/***/ }),

/***/ 86927:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { IPC } = __webpack_require__(39813);
const path = __webpack_require__(71017);
const { spawn } = __webpack_require__(32081);
const debug = __webpack_require__(15158);
const chalk = __webpack_require__(34061);

const Develop = {
  start: async function (ipcNetwork, ganacheOptions = {}) {
    let chainPath;

    // The path to the dev env process depends on whether or not
    // we're running in the bundled version. If not, use chain.js
    // directly, otherwise let the bundle point at the bundled version.
    if (true) {
      // Remember: In the bundled version, __dirname refers to the
      // build directory where cli.bundled.js and cli.chain.js live.
      chainPath = path.join(__dirname, "chain.bundled.js");
    } else {}

    const logger = ganacheOptions.logger || console;
    //check that genesis-time config option passed through the
    //truffle-config.js file is a valid time.
    if (ganacheOptions.time && isNaN(Date.parse(ganacheOptions.time))) {
      ganacheOptions.time = Date.now();
      logger.log(
        "\x1b[31m%s\x1b[0m",
        "Invalid Date passed to genesis-time, using current Date instead",
        "\x1b[0m"
      );
    }

    const stringifiedOptions = JSON.stringify(ganacheOptions);
    const optionsBuffer = Buffer.from(stringifiedOptions);
    const base64OptionsString = optionsBuffer.toString("base64");

    return spawn("node", [chainPath, ipcNetwork, base64OptionsString], {
      detached: true,
      stdio: "ignore"
    });
  },

  /**
   * Connect to an existing Ganache server or start a new one.
   * @param {object} options
   * @param {object} options.ipcOptions - options for IPC connection
   * @param {boolean} options.ipcOptions.log - whether to log IPC messages. Defaults to false.
   * @param {string} options.ipcOptions.network - network name. Defaults to "develop".
   * @param {boolean} options.ipcOptions.retry - whether to retry connection. Defaults to false.
   * @param {string} options.solidityLogDisplayPrefix - prefix to display before solidity log messages. Defaults to "".
   * @returns {Promise<(): void>} - IPC disconnection function.
   */
  connect: function ({ ipcOptions, solidityLogDisplayPrefix }) {
    const debugServer = debug("develop:ipc:server");
    const debugClient = debug("develop:ipc:client");
    const debugRPC = debug("develop:ganache");
    const ganacheColor = {
      hex: "#ffaf5f", // ganache's color in hex
      xterm: 215 // Xterm's number equivalent
    };
    debugRPC.color = ganacheColor.xterm;

    ipcOptions.retry = ipcOptions.retry || false;
    ipcOptions.log = ipcOptions.log || false;
    ipcOptions.network = ipcOptions.network || "develop";
    solidityLogDisplayPrefix = solidityLogDisplayPrefix || "";
    var ipcNetwork = ipcOptions.network;

    var ipc = new IPC();
    ipc.config.appspace = "truffle.";

    // set connectPath explicitly
    var dirname = ipc.config.socketRoot;
    var basename = `${ipc.config.appspace}${ipcNetwork}`;
    var connectPath = path.join(dirname, basename);
    var loggers = {};

    ipc.config.silent = !debugClient.enabled;
    ipc.config.logger = debugClient;

    const sanitizeAndCallFn =
      fn =>
      (...args) => {
        // HACK-y: replace `{}` that is getting logged instead of ""
        if (
          args.length === 1 &&
          typeof args[0] === "object" &&
          Object.keys(args[0]).length === 0
        ) {
          args[0] = "";
        }
        fn.apply(undefined, args);
      };

    if (debugServer.enabled) {
      loggers.ipc = debugServer;
    }

    // create a logger to present Ganache's console log messages
    const createSolidityLogger = prefix => {
      return maybeMultipleLines =>
        maybeMultipleLines.split("\n").forEach(
          // decorate each line's prefix.
          line => console.log(chalk.hex(ganacheColor.hex)(` ${prefix}`), line)
        );
    };

    // enable output/logger for solidity console.log
    loggers.solidity = sanitizeAndCallFn(
      createSolidityLogger(solidityLogDisplayPrefix)
    );

    if (ipcOptions.log) {
      debugRPC.enabled = true;
      loggers.ganache = sanitizeAndCallFn(debugRPC);
    }

    if (!ipcOptions.retry) {
      ipc.config.maxRetries = 0;
    }

    var disconnect = function () {
      ipc.disconnect(ipcNetwork);
    };

    return new Promise((resolve, reject) => {
      ipc.connectTo(ipcNetwork, connectPath, function () {
        ipc.of[ipcNetwork].on("destroy", function () {
          reject(new Error("IPC connection destroyed"));
        });

        ipc.of[ipcNetwork].on("truffle.ready", function () {
          resolve(disconnect);
        });

        Object.keys(loggers).forEach(function (key) {
          var log = loggers[key];
          if (log) {
            var message = `truffle.${key}.log`;
            ipc.of[ipcNetwork].on(message, log);
          }
        });
      });
    });
  },

  /**
   * Connect to a managed Ganache service. This will connect to an existing
   * Ganache service if one exists, or, create a new one to connect to.
   *
   * @param {Object} ipcOptions - IPC connection options.
   * @param {string} ipcOptions.network - the network name.
   * @param {Object} ganacheOptions - Ganache options if service is necessary.
   * @param {string} solidityLogDisplayPrefix - solidity log messages prefix.
   * @returns {Promise<Object>} - object with `disconnect` function and
   *     `started` boolean. The `disconnect` function is used to disconnect
   *     from the Ganache service. The `started` boolean is true if a new
   *     Ganache service was started, false otherwise.
   */
  connectOrStart: async function (
    ipcOptions,
    ganacheOptions,
    solidityLogDisplayPrefix = ""
  ) {
    ipcOptions.retry = false;

    const ipcNetwork = ipcOptions.network || "develop";

    let started = false;
    let disconnect;

    try {
      disconnect = await this.connect({ ipcOptions, solidityLogDisplayPrefix });
    } catch (_error) {
      await this.start(ipcNetwork, ganacheOptions);
      ipcOptions.retry = true;
      disconnect = await this.connect({ ipcOptions, solidityLogDisplayPrefix });
      started = true;
    } finally {
      return {
        disconnect,
        started
      };
    }
  }
};

module.exports = Develop;


/***/ }),

/***/ 53234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Web3 = __webpack_require__(3283);
const { createInterfaceAdapter } = __webpack_require__(36339);
const expect = __webpack_require__(14096);
const TruffleError = __webpack_require__(73321);
const { Resolver } = __webpack_require__(48511);
const Artifactor = __webpack_require__(29463);
const Ganache = __webpack_require__(11651);
const Provider = __webpack_require__(509);

const Environment = {
  // It's important config is a Config object and not a vanilla object
  detect: async function (config) {
    expect.options(config, ["networks"]);

    helpers.setUpConfig(config);
    helpers.validateNetworkConfig(config);

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.network_config.type
    });

    await Provider.testConnection(config);
    await helpers.detectAndSetNetworkId(config, interfaceAdapter);
    await helpers.setFromOnConfig(config, interfaceAdapter);
  },

  // Ensure you call Environment.detect() first.
  fork: async function (config, ganacheOptions) {
    expect.options(config, ["from", "provider", "networks", "network"]);

    const interfaceAdapter = createInterfaceAdapter({
      provider: config.provider,
      networkType: config.network_config.type
    });

    let accounts;
    try {
      accounts = await interfaceAdapter.getAccounts();
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
      accounts = [];
    }
    const block = await interfaceAdapter.getBlock("latest");

    const upstreamNetwork = config.network;
    const upstreamConfig = config.networks[upstreamNetwork];
    const forkedNetwork = config.network + "-fork";
    ganacheOptions = {
      ...ganacheOptions,
      fork: config.provider,
      miner: {
        ...ganacheOptions.miner,
        blockGasLimit: block.gasLimit
      }
    };
    if (accounts.length > 0) ganacheOptions.unlocked_accounts = accounts;

    config.networks[forkedNetwork] = {
      network_id: config.network_id,
      provider: Ganache.provider(ganacheOptions),
      from: config.from,
      gas: upstreamConfig.gas,
      gasPrice: upstreamConfig.gasPrice
    };
    config.network = forkedNetwork;
  },

  develop: async (config, ganacheOptions) => {
    expect.options(config, ["networks"]);

    const network = config.network || "develop";
    const url = `http://${ganacheOptions.host}:${ganacheOptions.port}/`;

    config.networks[network] = {
      ...config.networks[network],
      network_id: ganacheOptions.network_id,
      provider: function () {
        return new Web3.providers.HttpProvider(url, { keepAlive: false });
      }
    };

    config.network = network;

    return await Environment.detect(config);
  }
};

const helpers = {
  setFromOnConfig: async (config, interfaceAdapter) => {
    if (config.from) return;

    try {
      const accounts = await interfaceAdapter.getAccounts();
      config.networks[config.network].from = accounts[0];
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
    }
  },

  detectAndSetNetworkId: async (config, interfaceAdapter) => {
    const configNetworkId = config.networks[config.network].network_id;
    const providerNetworkId = await interfaceAdapter.getNetworkId();
    if (configNetworkId !== "*") {
      // Ensure the network id matches the one in the config for safety
      if (providerNetworkId.toString() !== configNetworkId.toString()) {
        const error =
          `The network id specified in the truffle config ` +
          `(${configNetworkId}) does not match the one returned by the network ` +
          `(${providerNetworkId}).  Ensure that both the network and the ` +
          `provider are properly configured.`;
        throw new Error(error);
      }
    } else {
      // We have a "*" network. Get the current network and replace it with the real one.
      // TODO: Should we replace this with the blockchain uri?
      config.networks[config.network].network_id = providerNetworkId;
    }
  },

  validateNetworkConfig: config => {
    const networkConfig = config.network_config;

    if (!networkConfig) {
      throw new TruffleError(
        `Unknown network "${config.network}` +
          `". See your Truffle configuration file for available networks.`
      );
    }

    const configNetworkId = config.network_config.network_id;

    if (configNetworkId == null) {
      throw new Error(
        `You must specify a network_id in your '` +
          `${config.network}' configuration in order to use this network.`
      );
    }
  },

  setUpConfig: config => {
    if (!config.resolver) {
      config.resolver = new Resolver(config);
    }

    if (!config.artifactor) {
      config.artifactor = new Artifactor(config.contracts_build_directory);
    }

    if (!config.network) {
      if (config.networks["development"]) {
        config.network = "development";
      } else {
        config.network = "ganache";
        config.networks[config.network] = {
          host: "127.0.0.1",
          port: 7545,
          network_id: 5777
        };
      }
    }

    const currentNetworkSettings = config.networks[config.network];
    if (
      currentNetworkSettings &&
      currentNetworkSettings.ens &&
      currentNetworkSettings.ens.registry
    ) {
      config.ens.registryAddress = currentNetworkSettings.ens.registry.address;
    }
  }
};

module.exports = Environment;


/***/ }),

/***/ 76765:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Environment = __webpack_require__(53234);
const Develop = __webpack_require__(86927);

module.exports = { Environment, Develop };


/***/ }),

/***/ 36219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./build/meta": 62571,
	"./call/meta": 22674,
	"./compile/meta": 53051,
	"./config/meta": 24722,
	"./console/meta": 21288,
	"./create/meta": 46038,
	"./dashboard/meta": 99608,
	"./db/commands/query/meta": 79062,
	"./db/commands/serve/meta": 11297,
	"./db/meta": 50111,
	"./debug/meta": 42285,
	"./deploy/meta": 5561,
	"./develop/meta": 14957,
	"./exec/meta": 81483,
	"./help/meta": 34914,
	"./init/meta": 83193,
	"./install/meta": 72545,
	"./migrate/meta": 88226,
	"./networks/meta": 41873,
	"./obtain/meta": 19518,
	"./opcode/meta": 3697,
	"./preserve/meta": 75861,
	"./publish/meta": 39662,
	"./run/meta": 52068,
	"./test/meta": 43059,
	"./unbox/meta": 74292,
	"./version/meta": 74770,
	"./watch/meta": 47766
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 36219;

/***/ }),

/***/ 18727:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 18727;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 21077:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 21077;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 57372:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 57372;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 26503:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 26503;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 95183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plugin = void 0;
const TruffleError = __webpack_require__(73321);
const originalRequire = __webpack_require__(44516);
const path_1 = __importDefault(__webpack_require__(71017));
class Plugin {
    constructor({ module, definition }) {
        this.module = module;
        this.definition = definition;
    }
    /*
     * `truffle run` support
     */
    get commands() {
        return Object.keys(this.definition.commands || {});
    }
    definesCommand(commandName) {
        return this.commands.includes(commandName);
    }
    loadCommand(commandName) {
        const commandLocalPath = this.definition.commands && this.definition.commands[commandName];
        if (!commandLocalPath) {
            throw new TruffleError(`Plugin ${this.module} does not define command ${commandName}`);
        }
        return this.loadModule(commandLocalPath);
    }
    /*
     * `truffle preserve` support
     */
    get tag() {
        return this.definition.tag;
    }
    definesRecipe() {
        return !!(this.definition.preserve && this.definition.preserve.recipe);
    }
    loadRecipe() {
        if (!this.definesRecipe()) {
            throw new TruffleError(`Plugin ${this.module} does not define a \`truffle preserve\` recipe.`);
        }
        return this.loadModule(this.definition.preserve.recipe).Recipe;
    }
    loadModule(localPath) {
        if (path_1.default.isAbsolute(localPath)) {
            throw new TruffleError(`\nError: Absolute paths not allowed!\nPlease ensure truffle-plugin.json only references paths relative to the plugin root.\n`);
        }
        const pluginPath = originalRequire.resolve(this.module);
        const modulePath = path_1.default.resolve(path_1.default.dirname(pluginPath), localPath);
        return originalRequire(modulePath);
    }
}
exports.Plugin = Plugin;
//# sourceMappingURL=Plugin.js.map

/***/ }),

/***/ 8097:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plugins = void 0;
const TruffleError = __webpack_require__(73321);
const originalRequire = __webpack_require__(44516);
const path_1 = __importDefault(__webpack_require__(71017));
const Plugin_1 = __webpack_require__(95183);
const utils_1 = __webpack_require__(36025);
class Plugins {
    /**
     * Given a truffle-config-like, find and return all configured plugins
     */
    static listAll(config) {
        const plugins = Plugins.checkPluginModules(config);
        const definitions = Plugins.loadPluginDefinitions(plugins);
        return Object.entries(definitions).map(([module, definition]) => new Plugin_1.Plugin({ module, definition }));
    }
    /**
     * Given a truffle-config-like and command, find and return all plugins that define the command
     */
    static findPluginsForCommand(config, command) {
        const allPlugins = Plugins.listAll(config);
        const pluginsForCommand = allPlugins.filter(plugin => plugin.definesCommand(command));
        return pluginsForCommand;
    }
    /**
     * Given a truffle-config-like, find and return all plugins that define any command
     */
    static listAllCommandPlugins(config) {
        const allPlugins = Plugins.listAll(config);
        const pluginsWithCommands = allPlugins.filter(plugin => plugin.commands.length > 0);
        return pluginsWithCommands;
    }
    /**
     * Given a truffle-config-like, find and return all plugins that define a recipe
     */
    static listAllRecipes(config) {
        const allPlugins = Plugins.listAll(config);
        const recipes = allPlugins.filter(plugin => plugin.definesRecipe());
        return recipes;
    }
    /*
     * internals
     */
    static checkPluginModules(config) {
        originalRequire("app-module-path").addPath(path_1.default.resolve(config.working_directory, "node_modules"));
        const plugins = (0, utils_1.normalizeConfigPlugins)(config.plugins || []);
        return plugins;
    }
    static loadPluginDefinitions(plugins) {
        let pluginConfigs = {};
        for (const { module, tag } of plugins) {
            try {
                const required = originalRequire(`${module}/truffle-plugin.json`);
                const defaultTag = required.preserve && required.preserve.tag;
                required.tag = tag || defaultTag || undefined;
                pluginConfigs[module] = required;
            }
            catch (_) {
                throw new TruffleError(`\nError: truffle-plugin.json not found in the ${module} plugin package!\n`);
            }
        }
        return pluginConfigs;
    }
}
exports.Plugins = Plugins;
//# sourceMappingURL=Plugins.js.map

/***/ }),

/***/ 42113:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(49094), exports);
__exportStar(__webpack_require__(95183), exports);
__exportStar(__webpack_require__(8097), exports);
__exportStar(__webpack_require__(36025), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 49094:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 36025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeConfigPlugins = exports.resolves = void 0;
const TruffleError = __webpack_require__(73321);
const originalRequire = __webpack_require__(44516);
/**
 * Returns true or false based on whether or not a particular plugin
 * resolves successfully
 */
const resolves = (module) => {
    try {
        originalRequire.resolve(module);
        return true;
    }
    catch (_) {
        return false;
    }
};
exports.resolves = resolves;
/**
 * Takes a list of raw plugin configurations and returns a list of normalized
 * internal representations
 */
const normalizeConfigPlugins = (plugins) => {
    const map = new Map([]);
    const normalized = plugins.map((plugin) => typeof plugin === "string" ? { module: plugin } : plugin);
    for (const plugin of normalized) {
        // fatal error if we can't load a plugin listed in truffle-config.js
        if (!(0, exports.resolves)(plugin.module)) {
            throw new TruffleError(`\nError: ${plugin.module} listed as a plugin, but not found in global or local node modules!\n`);
        }
        map.set(plugin.module, plugin);
    }
    return [...map.values()];
};
exports.normalizeConfigPlugins = normalizeConfigPlugins;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 48511:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resolver = void 0;
const resolver_1 = __webpack_require__(43563);
Object.defineProperty(exports, "Resolver", ({ enumerable: true, get: function () { return resolver_1.Resolver; } }));
exports["default"] = resolver_1.Resolver;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 73755:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@truffle/core","description":"Core code for Truffle command line tool","license":"MIT","author":"consensys.net","homepage":"https://github.com/trufflesuite/truffle#readme","repository":{"type":"git","url":"https://github.com/trufflesuite/truffle.git","directory":"packages/core"},"bugs":{"url":"https://github.com/trufflesuite/truffle/issues"},"version":"5.11.5","bin":{"truffle":"./cli.js","truffle-exec":"./exec.js"},"scripts":{"prepare":"exit 0","test":"mocha ./test/** ./test/**/*.js ./test/**/**/*.js"},"dependencies":{"@truffle/artifactor":"^4.0.199","@truffle/box":"^2.1.81","@truffle/code-utils":"^3.0.4","@truffle/codec":"^0.17.3","@truffle/compile-common":"^0.9.8","@truffle/compile-solidity":"^6.0.79","@truffle/config":"^1.3.61","@truffle/contract":"^4.6.31","@truffle/dashboard":"^0.4.5","@truffle/db-loader":"^0.2.36","@truffle/debug-utils":"^6.0.57","@truffle/debugger":"^12.1.5","@truffle/decoder":"^6.1.5","@truffle/deployer":"^3.3.27","@truffle/environment":"^0.2.160","@truffle/error":"^0.2.2","@truffle/expect":"^0.1.7","@truffle/fetch-and-compile":"^0.5.56","@truffle/from-hardhat":"^0.2.20","@truffle/hdwallet":"^0.1.4","@truffle/interface-adapter":"^0.5.37","@truffle/migrate":"^3.3.48","@truffle/plugins":"^0.2.15","@truffle/preserve":"^0.2.17","@truffle/promise-tracker":"^0.1.7","@truffle/provider":"^0.3.13","@truffle/provisioner":"^0.2.84","@truffle/require":"^2.1.43","@truffle/resolver":"^9.0.53","@truffle/source-fetcher":"^1.0.44","@truffle/spinners":"^0.2.5","@truffle/test":"^0.2.7","@truffle/workflow-compile":"^4.0.71","JSONStream":"^1.3.5","address":"^1.1.2","chai":"^4.2.0","colors":"1.4.0","command-exists":"^1.2.8","conf":"^10.0.2","debug":"^4.3.1","del":"^2.2.0","ethereum-cryptography":"1.1.2","fs-extra":"^9.1.0","ganache":"7.9.1","get-port":"^5.1.1","get-random-values":"^1.2.2","glob":"^7.1.6","inquirer":"8.2.2","iter-tools":"^7.5.0","js-interpreter":"2.2.0","lodash":"^4.17.21","mixpanel":"^0.17.0","mocha":"10.1.0","node-emoji":"^1.8.1","original-require":"^1.0.1","sane":"^4.0.2","semver":"^7.5.4","source-map-support":"^0.5.19","spawn-args":"0.2.0","tmp":"^0.2.1","uuid":"^9.0.0","web3":"1.10.0","web3-utils":"1.10.0","xregexp":"^4.2.4","yargs":"^13.3.0"},"devDependencies":{"@truffle/blockchain-utils":"^0.1.9","app-module-path":"^2.2.0","chai-as-promised":"^7.1.1","memorystream":"^0.3.1","sinon":"^9.0.2"},"publishConfig":{"access":"public"},"authors":[{"name":"Tim Coulter","email":"tim@trufflesuite.com","url":"https://github.com/tcoulter"}],"namespace":"consensys","engines":{"node":"^16.20 || ^18.16 || >=20"},"gitHead":"a26df1ff53c01e6d82ad490338850360f6f970a9"}');

/***/ })

};
;
//# sourceMappingURL=4986.bundled.js.map