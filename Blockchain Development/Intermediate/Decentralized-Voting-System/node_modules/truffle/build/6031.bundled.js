#!/usr/bin/env node

exports.id = 6031;
exports.ids = [6031,7017];
exports.modules = {

/***/ 18967:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 18967;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 3196:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 3196;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 41912:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 41912;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 60627:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fse = __webpack_require__(55674);
const del = __webpack_require__(95752);
const WorkflowCompile = (__webpack_require__(37017)["default"]);
const BuildError = __webpack_require__(42863);
const { spawn } = __webpack_require__(32081);
const spawnargs = __webpack_require__(72255);
const _ = __webpack_require__(96486);
const expect = __webpack_require__(14096);

function CommandBuilder(command) {
  this.command = command;
}

CommandBuilder.prototype.build = function (options, callback) {
  console.log("Running `" + this.command + "`...");

  const args = spawnargs(this.command);
  const ps = args.shift();

  const cmd = spawn(ps, args, {
    detached: false,
    cwd: options.working_directory,
    env: _.merge(process.env, {
      WORKING_DIRECTORY: options.working_directory,
      BUILD_DESTINATION_DIRECTORY: options.destination_directory,
      BUILD_CONTRACTS_DIRECTORY: options.contracts_build_directory
    })
  });

  cmd.stdout.on("data", function (data) {
    console.log(data.toString());
  });

  cmd.stderr.on("data", function (data) {
    console.error(data);
  });

  cmd.on("close", function (code) {
    let error = null;
    if (code !== 0) {
      error = "Command exited with code " + code;
    }
    callback(error);
  });
};

const Build = {
  clean: async function (options) {
    const destination = options.build_directory;
    const contracts_build_directory = options.contracts_build_directory;

    // Clean first.
    await del([destination + "/*", "!" + contracts_build_directory]);
    fse.ensureDirSync(destination);
  },

  build: async function (options) {
    expect.options(options, [
      "build_directory",
      "working_directory",
      "contracts_build_directory",
      "networks"
    ]);

    const logger = options.logger || console;
    let builder = options.build;

    // Duplicate build directory for legacy purposes
    options.destination_directory = options.build_directory;

    if (builder === null || typeof builder === "undefined") {
      logger.log(
        "No build configuration found. Preparing to compile contracts."
      );
    } else if (typeof builder === "string") {
      builder = new CommandBuilder(builder);
    } else if (typeof builder === "function") {
      // If they've only provided a build function, use that.
      builder = { build: builder };
    } else if (builder.build == null) {
      throw new BuildError(
        "Build configuration can no longer be specified as an object. Please see our documentation for an updated list of supported build configurations."
      );
    }

    // Use our own clean method unless the builder supplies one.
    let clean = this.clean;
    if (builder && builder.hasOwnProperty("clean")) {
      clean = builder.clean;
    }

    await clean(options);

    // If necessary. This prevents errors due to the .sol.js files not existing.
    await WorkflowCompile.compileAndSave(options);
    if (builder) {
      builder.build(options, function (err) {
        if (typeof err === "string") {
          throw new BuildError(err);
        }
      });
    }
  }
};

module.exports = Build;


/***/ }),

/***/ 23525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(58327),
  meta: __webpack_require__(62571)
};


/***/ }),

/***/ 58327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const OS = __webpack_require__(22037);
  const colors = __webpack_require__(83196);
  const deprecationMessage = colors.yellow(
    `> The build command is planned ` +
      `for deprecation in version 6 of Truffle.${OS.EOL}> See ` +
      `https://github.com/trufflesuite/truffle/issues/3226 for more ` +
      `information.`
  );
  console.log(deprecationMessage);
  const Config = __webpack_require__(20553);
  const Build = __webpack_require__(60627);
  const config = Config.detect(options);

  return await Build.build(config);
};


/***/ }),

/***/ 51788:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(7847),
  meta: __webpack_require__(22674)
};


/***/ }),

/***/ 7847:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const debug = __webpack_require__(15158)("core:commands:call");
  const fs = __webpack_require__(57147);
  const util = __webpack_require__(73837);
  const { Environment } = __webpack_require__(76765);
  const OS = __webpack_require__(22037);
  const Codec = __webpack_require__(20102);
  const Encoder = __webpack_require__(15967);
  const Decoder = __webpack_require__(18852);
  const TruffleError = __webpack_require__(73321);
  const { fetchAndCompile } = __webpack_require__(5523);
  const loadConfig = __webpack_require__(932);
  const DebugUtils = __webpack_require__(93293);
  const web3Utils = __webpack_require__(18269);

  if (options.url && options.network) {
    const message =
      "" +
      "Mutually exclusive options, --url and --network detected!" +
      OS.EOL +
      "Please use either --url or --network and try again." +
      OS.EOL +
      "See: https://trufflesuite.com/docs/truffle/reference/truffle-commands/#call" +
      OS.EOL;
    throw new TruffleError(message);
  }

  let config = loadConfig(options);
  await Environment.detect(config);

  const [contractNameOrAddress, functionNameOrSignature, ...args] = config._;
  let functionEntry, transaction;

  const fromAddress =
    options.from ??
    config.networks[config.network]?.from ??
    Codec.Evm.Utils.ZERO_ADDRESS;
  if (!web3Utils.isAddress(fromAddress)) {
    throw new TruffleError(
      `Error: Address ${fromAddress} is not a valid Ethereum address.` +
        OS.EOL +
        "Please check the address and try again."
    );
  }

  let blockNumber = options.block ?? "latest";
  if (!Number.isNaN(Number(blockNumber))) {
    blockNumber = Number(blockNumber);
  }
  if (
    !(Number.isSafeInteger(blockNumber) && blockNumber >= 0) &&
    !["latest", "pending", "genesis", "earliest"].includes(blockNumber)
  ) {
    throw new TruffleError(
      "Error: Invalid block number.  Block number must be nonnegative integer or one of 'latest', 'pending', 'genesis', or 'earliest'."
    );
  }

  const { encoder, decoder } = config.fetchExternal
    ? await sourceFromExternal(contractNameOrAddress, config)
    : await sourceFromLocal(contractNameOrAddress, config);

  try {
    ({ abi: functionEntry, tx: transaction } = await encoder.encodeTransaction(
      functionNameOrSignature,
      args,
      {
        allowJson: true,
        strictBooleans: true
      }
    ));
  } catch (error) {
    const expectedErrors = [
      Encoder.NoFunctionByThatNameError,
      Codec.Wrap.NoOverloadsMatchedError,
      Codec.Wrap.NoUniqueBestOverloadError,
      Codec.Wrap.TypeMismatchError
    ];
    debug("expectedErrors: %O", expectedErrors);
    if (expectedErrors.some(errorClass => error instanceof errorClass)) {
      //if it was an expected error, turn it into a TruffleError so that it
      //displays nicely
      throw new TruffleError("Error: " + error.message);
    } else {
      //unexpected error, rethrow
      throw error;
    }
  }

  if (!["pure", "view"].includes(functionEntry.stateMutability)) {
    console.log(
      "WARNING: Making read-only call to non-view function." +
        OS.EOL +
        "Any changes this function attempts to make will not be saved to the blockchain."
    );
  }

  const adapter = new Encoder.ProviderAdapter(config.provider);
  let result;
  let status = undefined;

  try {
    result = await adapter.call(
      fromAddress,
      transaction.to,
      transaction.data,
      blockNumber
    );
    //note we don't set status to true... a revert need not cause an
    //error, depending on client
    if (typeof result !== "string") {
      //if we couldn't extract a return value, something's gone badly wrong;
      //let's just throw
      throw new Error("Malformed response from call");
    }
  } catch (error) {
    status = false;
    result = extractResult(error);
    if (result === undefined) {
      //if we couldn't extract a return value, something's gone badly wrong;
      //let's just rethrow the error in that case
      throw error;
    }
  }

  debug("result: %O", result);

  const decodings = await decoder.decodeReturnValue(functionEntry, result, {
    status
  });
  if (decodings.length === 0) {
    throw new TruffleError("Error: Could not decode result.");
  }
  const decoding = decodings[0];

  if (decoding.status) {
    //successful return
    config.logger.log(
      util.inspect(new Codec.Export.ReturndataDecodingInspector(decoding), {
        colors: true,
        depth: null,
        maxArrayLength: null,
        breakLength: 79
      })
    );
  } else {
    //revert case
    if (
      decoding.kind === "revert" &&
      Codec.AbiData.Utils.abiSignature(decoding.abi) === "Panic(uint256)"
    ) {
      // for panics specifically, we'll want a bit more interpretation
      // (shouldn't this be a proper interpretation? yes, but there's no
      // time to refactor that right now)
      const panicCode = decoding.arguments[0].value.value.asBN;
      throw new TruffleError(
        `The call resulted in a panic: ${DebugUtils.panicString(panicCode)}`
      );
    }
    //usual revert case
    throw new TruffleError(
      util.inspect(new Codec.Export.ReturndataDecodingInspector(decoding), {
        colors: false, //don't want colors in an error message
        depth: null,
        maxArrayLength: null,
        breakLength: 79
      })
    );
  }

  return;
  //Note: This is the end of the function.  After this point is just inner
  //function declarations.  These declarations are made as inner functions
  //so they can use the imports above.

  async function sourceFromLocal(contractNameOrAddress, config) {
    if (
      contractNameOrAddress.startsWith("0x") &&
      !web3Utils.isAddress(contractNameOrAddress)
    ) {
      throw new TruffleError(
        `Error: Address ${contractNameOrAddress} is not a valid Ethereum address.` +
          OS.EOL +
          "Please check the address and try again."
      );
    }

    const contractNames = fs
      .readdirSync(config.contracts_build_directory)
      .filter(filename => filename.endsWith(".json"))
      .map(filename => filename.slice(0, -".json".length));

    const contracts = contractNames
      .map(contractName => ({
        [contractName]: config.resolver.require(contractName)
      }))
      .reduce((a, b) => ({ ...a, ...b }), {});

    if (Object.keys(contracts).length === 0) {
      throw new TruffleError(
        "Error: No artifacts found; please run `truffle compile` first to compile your contracts."
      );
    }

    if (contractNameOrAddress.startsWith("0x")) {
      //note in this case we already performed validation above
      const contractAddress = contractNameOrAddress;
      const projectInfo = {
        artifacts: Object.values(contracts)
      };

      return await getEncoderDecoderForContractAddress(
        contractAddress,
        projectInfo
      );
    } else {
      // contract name case
      const contractName = contractNameOrAddress;
      const settings = {
        provider: config.provider,
        projectInfo: {
          artifacts: Object.values(contracts)
        }
      };

      const contract = contracts[contractName];
      if (!contract) {
        throw new TruffleError(
          `Error: No artifacts found for contract named ${contractName} found.  Check the name and make sure you have compiled your contracts.`
        );
      }
      let instance;
      try {
        instance = await contract.deployed();
      } catch (error) {
        throw new TruffleError(
          "Error: This contract has not been deployed to the detected network." +
            OS.EOL +
            "Please run `truffle migrate` to deploy the contract."
        );
      }
      const encoder = await Encoder.forContractInstance(instance, settings);
      const decoder = await Decoder.forContractInstance(instance, settings);
      return { encoder, decoder };
    }
  }

  async function sourceFromExternal(contractAddress, config) {
    if (!web3Utils.isAddress(contractAddress)) {
      throw new TruffleError(
        `Error: Address ${contractAddress} is not a valid Ethereum address.` +
          OS.EOL +
          "Please check the address and try again, or remove `-x` if you are supplying a contract name."
      );
    }

    const { compileResult } = await fetchAndCompile(contractAddress, config);

    const projectInfo = {
      commonCompilations: compileResult.compilations
    };

    return await getEncoderDecoderForContractAddress(
      contractAddress,
      projectInfo
    );
  }

  async function getEncoderDecoderForContractAddress(
    contractAddress,
    projectInfo
  ) {
    const projectEncoder = await Encoder.forProject({
      provider: config.provider,
      projectInfo
    });
    const encoder = await projectEncoder.forAddress(
      contractAddress,
      blockNumber
    );

    const projectDecoder = await Decoder.forProject({
      provider: config.provider,
      projectInfo
    });
    const decoder = await projectDecoder.forAddress(
      contractAddress,
      blockNumber
    );

    return { encoder, decoder };
  }
};

function extractResult(error) {
  //CODE DUPLICATION WARNING!!
  //the following code is copied (w/slight adaptations) from contract/lib/reason.js
  //it should really be factored!!  but there may not be time to do that right now
  if (!error || !error.data) {
    return undefined;
  }

  // NOTE that Ganache >=2 returns the reason string when
  // vmErrorsOnRPCResponse === true, which this code could
  // be updated to respect (instead of computing here)
  const { data } = error;
  if (typeof data === "string") {
    return data; // geth, Ganache >7.0.0
  } else if ("result" in data) {
    // there is a single result (Ganache 7.0.0)
    return data.result;
  } else {
    // handle `evm_mine`, `miner_start`, batch payloads, and ganache 2.0
    // NOTE this only works for a single failed transaction at a time.
    const hash = Object.keys(data)[0];
    const errorDetails = data[hash];
    return errorDetails.return /* ganache 2.0 */;
  }
}


/***/ }),

/***/ 14033:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(38666),
  meta: __webpack_require__(53051)
};


/***/ }),

/***/ 38666:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(71017);
const fse = __webpack_require__(55674);

module.exports = async function (options) {
  const TruffleError = __webpack_require__(73321);
  const WorkflowCompile = (__webpack_require__(37017)["default"]);
  const Config = __webpack_require__(20553);
  const config = Config.detect(options);

  if (config.list !== undefined) {
    return await listVersions(config);
  }

  if (
    options.saveIntermediate === true ||
    (typeof options.saveIntermediate === "string" &&
      options.saveIntermediate.trim() === "")
  ) {
    // user asked to save the intermediate compilation results
    // but didn't provide the file to save the results to
    throw new TruffleError(
      "You must provide a file to save compilation results to."
    );
  }

  if (config._ && config._.length > 0) {
    // set paths based on command-line inputs, transforming to absolute
    // paths where appropriate
    config.paths = config._.map(specifiedPath => {
      // convert relative paths to absolute paths based on whether
      // the naive absolute path exists on disk
      //
      // NOTE in case of collision where the specified path refers to some
      // non-FS source (e.g. `truffle/Assert.sol`) and where that specified
      // path corresponds to an existing file relative to the working dir.,
      // this selects the latter as priority over the former.

      const absolutePath = path.resolve(
        config.working_directory,
        specifiedPath
      );

      // i.e., pass the absolutePath if it's a real file, otherwise just
      // pass whatever was specified.
      if (fse.existsSync(absolutePath)) {
        return absolutePath;
      } else {
        return specifiedPath;
      }
    });
  }

  const compilationOutput = await WorkflowCompile.compile(config);
  if (options.saveIntermediate) {
    // Get the filename the user provided to save the compilation results to
    const compilationOutputFile = path.resolve(options.saveIntermediate);

    await fse.writeFile(
      compilationOutputFile,
      JSON.stringify(compilationOutput),
      { encoding: "utf8" }
    );
  }

  const result = await WorkflowCompile.save(config, compilationOutput);
  if (config.db && config.db.enabled) {
    await WorkflowCompile.assignNames(config, result);
  }
};

const listVersions = async function (options) {
  const { CompilerSupplier } = __webpack_require__(4273);
  const { asyncTake } = __webpack_require__(84248);

  const supplier = new CompilerSupplier({
    solcConfig: {
      ...options.compilers.solc,
      // HACK to force use of the VersionRange or Docker strategy
      // as implemented, Docker requires a version to be specified, and so
      // we can't simply remove this field entirely.
      version: "0.5.16",
      docker: options.list === "docker"
    },
    events: options.events
  });

  const log = options.logger.log;
  options.list = options.list.length ? options.list : "releases";

  const { latestRelease, releases, prereleases } = await supplier.list();
  if (options.list === "latestRelease") {
    log(JSON.stringify(latestRelease, null, " "));
    return;
  }

  const allVersions = options.list === "prereleases" ? prereleases : releases;
  const versions = options.all ? allVersions : asyncTake(10, allVersions);

  if (options.all && options.list === "docker") {
    log(
      "Warning: using `--all` with `--list=docker` is very slow and makes " +
        "many HTTP requests."
    );
    log(
      "You may instead want to browse tags on the web here: " +
        "https://hub.docker.com/r/ethereum/solc/tags/"
    );
  }

  const tags = [];
  // use `for await` because Docker strategy returns AsyncIterableIterators
  for await (const version of versions) {
    tags.push(version);
  }

  // Docker tags are best browsed via their own web UI
  if (options.list === "docker" && !options.all) {
    tags.push("See more at: hub.docker.com/r/ethereum/solc/tags/");
  }

  log(JSON.stringify(tags, null, " "));
  return;
};


/***/ }),

/***/ 74445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(83523),
  meta: __webpack_require__(24722)
};


/***/ }),

/***/ 83523:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const analyticsUtils = __webpack_require__(79429);
const userLevelSettings = ["analytics"];
/**
 * run config commands to get/set/list Truffle config options
 * @param {Object} options
 **/
module.exports = async function (options) {
  const Config = __webpack_require__(20553);
  const OS = __webpack_require__(22037);

  const log = options.logger
    ? options.logger.log || options.logger.debug
    : console.log;

  let command;
  if (options.enableAnalytics || options.disableAnalytics) {
    // TODO: Deprecate the --(en|dis)able-analytics flag in favor of `set analytics true`
    command = {
      set: true,
      userLevel: true,
      key: "analytics",
      value: options.enableAnalytics || false
    };
    const message =
      `> WARNING: The --enable-analytics and ` +
      `--disable-analytics flags have been deprecated.${OS.EOL}> Please ` +
      `use 'truffle config set analytics <boolean>'.`;
    console.warn(OS.EOL + message + OS.EOL);
  } else {
    command = parse(options._);
  }

  if (command === null) {
    return await analyticsUtils.setUserConfigViaPrompt();
  } else if (command.userLevel) {
    switch (command.key) {
      case "analytics": {
        if (command.set) {
          analyticsUtils.setAnalytics(command.value);
        } else {
          log(analyticsUtils.getAnalytics());
        }
        break;
      }
    }

    return;
  } else if (command.list) {
    log("Truffle config values");
    log(`analytics = ${analyticsUtils.getAnalytics()}`);
  } else {
    const config = Config.detect(options);

    if (command.set) {
      log("Setting project-level parameters is not supported yet.");
      // TODO: add support for writing project-level settings to the truffle config file
      // config[command.key] = command.value;
    } else {
      log(config[command.key]);
    }
    return;
  }
};

const parse = function (args) {
  if (args.length === 0) {
    return null;
  }

  let option = args[0];

  if (typeof option !== "string") {
    // invalid option
    throw new Error(`Invalid config option "${option}"`);
  }
  option = option.toLowerCase();

  let set = false;
  let list = false;
  let key = args[1];
  let value = args[2];

  switch (option) {
    case "get": {
      set = false;
      if (typeof key === "undefined" || key === null || key === "") {
        // invalid key
        throw new Error("Must provide a <key>");
      }

      break;
    }
    case "set": {
      set = true;
      if (typeof key === "undefined" || key === null || key === "") {
        // invalid key
        throw new Error("Must provide a <key>");
      }

      if (typeof value !== "string" || value === "") {
        // invalid value
        throw new Error("Must provide a <value-for-set>");
      }

      switch (value.toLowerCase()) {
        case "null": {
          value = null;
          break;
        }
        case "undefined": {
          value = undefined;
          break;
        }
        case "true": {
          value = true;
          break;
        }
        case "false": {
          value = false;
          break;
        }
        default: {
          // check if number, otherwise leave as string
          const float = parseFloat(value);
          if (!isNaN(float) && value === float.toString()) {
            value = float;
          }
          break;
        }
      }

      break;
    }
    case "list": {
      list = true;
      break;
    }
    default: {
      if (
        option !== "--enable-analytics" &&
        option !== "--disable-analytics" &&
        option !== ""
      ) {
        // TODO: Deprecate the --(en|dis)able-analytics flag in favor for `enable analytics`
        // invalid command!
        throw new Error(`Invalid config option "${option}"`);
      } else {
        // we should not have gotten here
        return null;
      }
    }
  }

  return {
    set,
    list,
    userLevel: userLevelSettings.includes(key),
    key,
    value
  };
};


/***/ }),

/***/ 79429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Config = __webpack_require__(20553);
const inquirer = __webpack_require__(85346);
const { v4: uuid } = __webpack_require__(76351);

const analyticsInquiry = [
  {
    type: "list",
    name: "analyticsInquiry",
    message:
      "Would you like to enable analytics for your Truffle projects? Doing so will allow us to make sure Truffle is working as expected and help us address any bugs more efficiently.",
    choices: ["Yes, enable analytics", "No, do not enable analytics"]
  }
];
const analyticsDisable = [
  {
    type: "confirm",
    name: "analyticsDisable",
    message: "Analytics are currently enabled. Would you like to disable them?",
    default: false
  }
];
const analyticsEnable = [
  {
    type: "confirm",
    name: "analyticsEnable",
    message: "Analytics are currently disabled. Would you like to enable them?",
    default: false
  }
];

module.exports = {
  getUserConfig: function () {
    return Config.getUserConfig();
  },
  /**
   * set user-level unique id
   */
  setUserId: function () {
    if (!this.getUserConfig().get("uniqueId")) {
      const userId = uuid();
      this.getUserConfig().set({ uniqueId: userId });
    }
  },
  /**
   * get user-level options for analytics
   * @param {Object} userConfig
   * @returns {bool}
   */
  getAnalytics: function () {
    return this.getUserConfig().get("enableAnalytics");
  },
  /**
   * set user-level options for analytics
   * @param {bool} analyticsBool
   * @param {Object} userConfig
   */
  setAnalytics: function (analyticsBool) {
    if (analyticsBool === true) {
      this.setUserId();
      console.log("Analytics enabled");
      this.getUserConfig().set({
        enableAnalytics: true,
        analyticsSet: true,
        analyticsMessageDateTime: Date.now()
      });
    } else if (analyticsBool === false) {
      console.log("Analytics disabled");
      this.getUserConfig().set({
        enableAnalytics: false,
        analyticsSet: true,
        analyticsMessageDateTime: Date.now()
      });
    } else {
      const message =
        `Error setting config option.` +
        `\n> You must set the 'analytics' option to either 'true' ` +
        `or 'false'. \n> The value you provided was ${analyticsBool}.`;
      throw new Error(message);
    }
    return true;
  },
  /**
   * prompt user to determine values for user-level analytics config options
   * @param {Object} userConfig
   */
  setUserConfigViaPrompt: async function () {
    if (
      !this.getUserConfig().get("analyticsSet") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsInquiry);
      if (answer.analyticsInquiry === analyticsInquiry[0].choices[0]) {
        this.setAnalytics(true);
      } else {
        this.setAnalytics(false);
      }
    } else if (
      this.getUserConfig().get("analyticsSet") &&
      this.getUserConfig().get("enableAnalytics") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsDisable);
      if (answer.analyticsDisable) {
        this.setAnalytics(false);
      } else {
        this.setAnalytics(true);
      }
    } else if (
      this.getUserConfig().get("analyticsSet") &&
      !this.getUserConfig().get("enableAnalytics") &&
      process.stdin.isTTY === true
    ) {
      let answer = await inquirer.prompt(analyticsEnable);
      if (answer.analyticsEnable) {
        this.setAnalytics(true);
      } else {
        this.setAnalytics(false);
      }
    }
    return true;
  }
};


/***/ }),

/***/ 89923:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(69909),
  meta: __webpack_require__(21288)
};


/***/ }),

/***/ 69909:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const OS = __webpack_require__(22037);
  const { Console } = __webpack_require__(68303);
  const { Environment } = __webpack_require__(76765);
  const TruffleError = __webpack_require__(73321);
  const loadConfig = __webpack_require__(932);

  if (options.url && options.network) {
    const message =
      "" +
      "Mutually exclusive options, --url and --network detected!" +
      OS.EOL +
      "Please use either --url or --network and try again." +
      OS.EOL +
      "See: https://trufflesuite.com/docs/truffle/reference/truffle-commands/#console" +
      OS.EOL;
    throw new TruffleError(message);
  }

  let config = loadConfig(options);
  await Environment.detect(config);
  const c = new Console(config.with({ noAliases: true }));
  return await c.start();
};


/***/ }),

/***/ 89664:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(71017);
const fse = __webpack_require__(55674);

const templates = {
  test: {
    filename: path.join(__dirname, "templates", "example.js"),
    variable: "example"
  },
  contract: {
    filename: path.join(__dirname, "templates", "Example.sol"),
    name: "Example",
    license: "MIT",
    variable: "example"
  },
  migration: {
    filename: path.join(__dirname, "templates", "migration.js")
  }
};

const replaceContents = (filePath, find, replacement) => {
  const data = fse.readFileSync(filePath, { encoding: "utf8" });
  if (typeof find === "string") {
    find = new RegExp(find, "g");
  }
  const result = data.replace(find, replacement);
  fse.writeFileSync(filePath, result, { encoding: "utf8" });
};

const toUnderscoreFromCamel = (string) => {
  string = string.replace(/([A-Z])/g, function ($1) {
    return "_" + $1.toLowerCase();
  });

  if (string[0] === "_") {
    string = string.substring(1);
  }

  return string;
};

// getLicense return the license property value from Truffle config first and
// in case that the file doesn't exist it will fallback to package.json
const getLicense = (options) => {
  try {
    const license = (__webpack_require__(20553).detect)(options).license;
    if (license) {
      return license;
    }
  } catch (err) {
    console.log(err);
  }

  try {
    return __webpack_require__(76775)(path.join(process.cwd(), "package.json")).license;
  } catch {}
};

const Create = {
  contract: function (directory, name, options) {
    const from = templates.contract.filename;
    const to = path.join(directory, name + ".sol");

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + name + ".sol: file exists");
    }

    fse.copySync(from, to);

    replaceContents(to, templates.contract.name, name);
    const license = getLicense(options);
    if (license) {
      replaceContents(to, templates.contract.license, license);
    }
  },

  test: function (directory, name, options) {
    let underscored = toUnderscoreFromCamel(name);
    underscored = underscored.replace(/\./g, "_");
    const from = templates.test.filename;
    const to = path.join(directory, underscored + ".js");

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + underscored + ".js: file exists");
    }

    fse.copySync(from, to);
    replaceContents(to, templates.contract.name, name);
    replaceContents(to, templates.contract.variable, underscored);
  },

  migration: function (directory, name, options) {
    let underscored = toUnderscoreFromCamel(name || "");
    underscored = underscored.replace(/\./g, "_");
    const from = templates.migration.filename;
    let filename = (new Date().getTime() / 1000) | 0; // Only do seconds.

    if (name != null && name !== "") {
      filename += "_" + underscored;
    }

    filename += ".js";
    const to = path.join(directory, filename);

    if (!options.force && fse.existsSync(to)) {
      throw new Error("Can not create " + filename + ": file exists");
    }
    fse.copySync(from, to);
  }
};

module.exports = Create;


/***/ }),

/***/ 42957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(59442),
  meta: __webpack_require__(46038)
};


/***/ }),

/***/ 59442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(20553);
  const ConfigurationError = __webpack_require__(48937);
  const create = __webpack_require__(89664);

  const config = Config.detect(options);

  let type = config.type;

  if (type == null && config._.length > 0) {
    type = config._[0];
  }

  let name = config.name;

  if (name == null && config._.length > 1) {
    name = config._[1];
  }

  if (type == null) {
    throw new ConfigurationError(
      "Please specify the type of item to create. Example: truffle create contract MyContract"
    );
  }

  if (name == null) {
    throw new ConfigurationError(
      "Please specify the name of item to create. Example: truffle create contract MyContract"
    );
  }

  if (!/^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(name)) {
    throw new ConfigurationError(
      `The name ${name} is invalid. Please enter a valid name using alpha-numeric characters.`
    );
  }

  const fn = create[type];

  const destinations = {
    contract: config.contracts_directory,
    migration: config.migrations_directory,
    test: config.test_directory
  };

  if (type === "all") {
    for (const key of Object.keys(destinations)) {
      await create[key](destinations[key], name, options);
    }
    return;
  } else if (fn == null) {
    throw new ConfigurationError(`Cannot find creation type: ${type}`);
  } else {
    return create[type](destinations[type], name, options);
  }
};


/***/ }),

/***/ 59602:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(44556),
  meta: __webpack_require__(99608)
};


/***/ }),

/***/ 44556:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const { DashboardServer } = __webpack_require__(97722);
  const address = __webpack_require__(94849);

  const config = detectConfigOrDefault(options);

  const port = options.port || config.dashboard.port;
  const host = options.host || config.dashboard.host;
  const autoOpen = options.autoOpen ?? config.dashboard.autoOpen;
  const verbose = options.verbose || config.dashboard.verbose;
  const rpc = true;

  const dashboardServerOptions = { port, host, autoOpen, verbose, rpc };
  const dashboardServer = new DashboardServer(dashboardServerOptions);
  await dashboardServer.start();

  if (host === "0.0.0.0") {
    // Regex taken from react-scripts to check that the address is a private IP, otherwise we discard it
    // https://en.wikipedia.org/wiki/Private_network#Private_IPv4_address_spaces
    let lanAddress =
      /^10[.]|^172[.](1[6-9]|2[0-9]|3[0-1])[.]|^192[.]168[.]/.test(address.ip())
        ? address.ip()
        : undefined;

    console.log(`Truffle Dashboard running at http://localhost:${port}`);
    lanAddress &&
      console.log(`                             http://${lanAddress}:${port}`);

    console.log(
      `DashboardProvider RPC endpoint running at http://localhost:${port}/rpc`
    );
    lanAddress &&
      console.log(
        `                                          http://${lanAddress}:${port}/rpc`
      );
  } else {
    console.log(`Truffle Dashboard running at http://${host}:${port}`);
    console.log(
      `DashboardProvider RPC endpoint running at http://${host}:${port}/rpc`
    );
  }

  // ensure that `await`-ing this method never resolves. (we want to keep
  // the console open until it exits on its own)
  return new Promise(() => {});
};


/***/ }),

/***/ 49797:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(16487),
  meta: __webpack_require__(50111)
};


/***/ }),

/***/ 16487:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const serveCommand = __webpack_require__(43405);
const queryCommand = __webpack_require__(42089);

module.exports = async function (args) {
  const [subCommand] = args._;
  switch (subCommand) {
    case "serve":
      await serveCommand.run(args);
      break;

    case "query":
      await queryCommand.run(args);
      break;

    default:
      console.log(`Unknown truffle db command: ${subCommand}`);
  }
};


/***/ }),

/***/ 76463:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(30999),
  meta: __webpack_require__(42285)
};


/***/ }),

/***/ 30999:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const OS = __webpack_require__(22037);
  const { promisify } = __webpack_require__(73837);
  const loadConfig = __webpack_require__(932);
  const { Environment } = __webpack_require__(76765);
  const FromHardhat = __webpack_require__(36052);
  const Codec = __webpack_require__(20102);
  const TruffleError = __webpack_require__(73321);
  const { CLIDebugger } = __webpack_require__(9941);
  const { utils: Web3Utils } = __webpack_require__(3283);

  if (options.url && options.network) {
    const message =
      "" +
      "Mutually exclusive options, --url and --network detected!" +
      OS.EOL +
      "Please use either --url or --network and try again." +
      OS.EOL +
      "See: https://trufflesuite.com/docs/truffle/reference/truffle-commands/#debug" +
      OS.EOL;
    throw new TruffleError(message);
  }

  if (options.registry && options.noEns) {
    throw new TruffleError(
      "The --no-ens options and --registry options are mutually exclusive; please remove one and try again."
    );
  }

  if (options.registry) {
    if (!Web3Utils.isAddress(options.registry)) {
      throw new TruffleError(
        "The specified registry is not a valid address.  It may have an incorrect checksum or be otherwise invalid."
      );
    }
  }

  let config;
  let compilations;
  try {
    config = loadConfig(options);
  } catch (configError) {
    // if we can't load config, check to see if this is a hardhat project
    try {
      await FromHardhat.expectHardhat();

      config = await FromHardhat.prepareConfig();
      config.merge(options);
      compilations = Codec.Compilations.Utils.shimCompilations(
        await FromHardhat.prepareCompilations()
      );
    } catch (hardhatError) {
      // if it's not a hardhat project, throw the original error
      // otherwise, throw whatever error we got when process hardhat
      const error =
        hardhatError instanceof FromHardhat.NotHardhatError
          ? configError
          : hardhatError;

      throw error;
    }
  }

  await Environment.detect(config);

  const txHash = config._[0]; //may be undefined
  if (config.fetchExternal && txHash === undefined) {
    throw new Error(
      "Fetch-external mode requires a specific transaction to debug"
    );
  }
  if (config.compileTests) {
    config.compileAll = true;
  }
  if (config.compileAll && config.compileNone) {
    throw new Error("Incompatible options passed regarding what to compile");
  }
  const interpreter = await new CLIDebugger(config, {
    txHash,
    compilations
  }).run();
  return await promisify(interpreter.start.bind(interpreter))();
};


/***/ }),

/***/ 8230:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(1527),
  meta: __webpack_require__(5561)
};


/***/ }),

/***/ 1527:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const runMigrate = __webpack_require__(52423);

module.exports = runMigrate;


/***/ }),

/***/ 55114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(27970),
  meta: __webpack_require__(14957)
};


/***/ }),

/***/ 27970:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const emoji = __webpack_require__(58445);
const mnemonicInfo = __webpack_require__(25603);
const {
  configureManagedGanache,
  getFirstDefinedValue
} = __webpack_require__(84973);

const runConsole = async (config, ganacheOptions) => {
  const { Console } = __webpack_require__(68303);
  const { Environment } = __webpack_require__(76765);

  await Environment.develop(config, ganacheOptions);
  const c = new Console(config.with({ noAliases: true }));
  c.on("exit", () => process.exit());
  return await c.start();
};

module.exports = async options => {
  const { Develop } = __webpack_require__(76765);
  const Config = __webpack_require__(20553);

  const config = Config.detect(options);
  const customConfig = config.networks.develop || {};

  const numberOfAccounts = getFirstDefinedValue(
    customConfig.accounts,
    customConfig.total_accounts,
    10 // Use as default number of accounts
  );
  const { mnemonic, accounts, privateKeys } =
    mnemonicInfo.getAccountsInfo(numberOfAccounts);

  const onMissing = () => "**";

  const warning =
    ":warning:  Important :warning:  : " +
    "This mnemonic was created for you by Truffle. It is not secure.\n" +
    "Ensure you do not use it on production blockchains, or else you risk losing funds.";

  const ipcOptions = {};

  if (options.log) {
    ipcOptions.log = options.log;
  }

  const ganacheOptions = configureManagedGanache(
    config,
    customConfig,
    mnemonic
  );

  const { started } = await Develop.connectOrStart(
    ipcOptions,
    ganacheOptions,
    config?.solidityLog?.displayPrefix ?? ""
  );
  const url = `http://${ganacheOptions.host}:${ganacheOptions.port}/`;

  if (started) {
    config.logger.log(`Truffle Develop started at ${url}`);
    config.logger.log();

    config.logger.log(`Accounts:`);
    accounts.forEach((acct, idx) => config.logger.log(`(${idx}) ${acct}`));
    config.logger.log();

    config.logger.log(`Private Keys:`);
    privateKeys.forEach((key, idx) => config.logger.log(`(${idx}) ${key}`));
    config.logger.log();

    config.logger.log(`Mnemonic: ${mnemonic}`);
    config.logger.log();
    config.logger.log(emoji.emojify(warning, onMissing));
    config.logger.log();
  } else {
    config.logger.log(
      `Connected to existing Truffle Develop session at ${url}`
    );
    config.logger.log();
  }

  if (options.log) {
    // leave the process open so that logging can take place
    return new Promise(() => {});
  }
  return await runConsole(config, ganacheOptions);
};


/***/ }),

/***/ 41400:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(76306),
  meta: __webpack_require__(81483)
};


/***/ }),

/***/ 76306:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(20553);
  const WorkflowCompile = (__webpack_require__(37017)["default"]);
  const ConfigurationError = __webpack_require__(48937);
  const exec = (__webpack_require__(35422).exec);
  const { Environment } = __webpack_require__(76765);
  const path = __webpack_require__(71017);
  const OS = __webpack_require__(22037);
  const { promisify } = __webpack_require__(73837);

  const config = Config.detect(options);

  let file = options.file;

  if (file == null && options._.length > 0) {
    file = options._[0];
  }

  if (file == null) {
    throw new ConfigurationError(
      "Please specify a file, passing the path of the script you'd like the run. Note that all scripts *must* call process.exit() when finished."
    );
  }

  if (path.isAbsolute(file) === false) {
    file = path.join(process.cwd(), file);
  }

  await Environment.detect(config);
  if (config.networkHint !== false) {
    config.logger.log("Using network '" + config.network + "'." + OS.EOL);
  }

  // `--compile`
  let compilationOutput;
  if (options.c || options.compile) {
    compilationOutput = await WorkflowCompile.compile(config);
  }
  // save artifacts if compilation took place
  if (compilationOutput) {
    await WorkflowCompile.save(config, compilationOutput);
  }
  return await promisify(exec)(config.with({ file }));
};


/***/ }),

/***/ 63979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (selectedCommand, subCommand, options) {
  const commands = __webpack_require__(91559);
  const globalCommandOptions = __webpack_require__(67023);
  const TruffleError = __webpack_require__(73321);

  let commandHelp, commandDescription;

  const inputStrings = process.argv.slice(2);

  const chosenCommand = commands[selectedCommand].meta;

  if (subCommand) {
    if (!chosenCommand.subCommands || !chosenCommand.subCommands[subCommand]) {
      throw new TruffleError(
        `"truffle ${inputStrings.join(" ")}" is an invalid command`
      );
    }
    commandHelp = chosenCommand.subCommands[subCommand].help;
    commandDescription = chosenCommand.subCommands[subCommand].description;
  } else {
    commandHelp = chosenCommand.help;
    commandDescription = chosenCommand.description;
  }

  if (typeof commandHelp === "function") {
    commandHelp = await commandHelp(options);
  }

  const allowedGlobalOptions = commandHelp.allowedGlobalOptions
    .filter(tag => tag in globalCommandOptions)
    .map(tag => globalCommandOptions[tag]);
  const validOptionsUsage = allowedGlobalOptions
    .map(({ option }) => `[${option}]`)
    .join(" ");

  const commandHelpUsage = commandHelp.usage + " " + validOptionsUsage;

  console.log(`\n  Usage:        ${commandHelpUsage}`);
  console.log(`  Description:  ${commandDescription}`);

  if (commandHelp.options.length > 0) {
    const allValidOptions = [...commandHelp.options, ...allowedGlobalOptions];

    console.log(`  Options: `);
    for (const option of allValidOptions) {
      if (option.hidden) {
        continue;
      }

      console.log(`                ${option.option}`);
      console.log(`                    ${option.description}`);
    }
  }
  console.log("");
};


/***/ }),

/***/ 9546:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const displayCommandHelp = __webpack_require__(63979);
  const commands = __webpack_require__(91559);
  if (options._.length === 0) {
    await displayCommandHelp("help", options);
    return;
  }
  const selectedCommand = options._[0];
  const subCommand = options._[1];

  if (commands[selectedCommand]) {
    await displayCommandHelp(selectedCommand, subCommand, options);
    return;
  } else {
    console.log(`\n  Cannot find the given command '${selectedCommand}'`);
    console.log("  Please ensure your command is one of the following: ");
    Object.keys(commands)
      .sort()
      .forEach(command => console.log(`      ${command}`));
    console.log("");
    return;
  }
};


/***/ }),

/***/ 91559:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  build: __webpack_require__(23525),
  call: __webpack_require__(51788),
  compile: __webpack_require__(14033),
  config: __webpack_require__(74445),
  console: __webpack_require__(89923),
  create: __webpack_require__(42957),
  dashboard: __webpack_require__(59602),
  db: __webpack_require__(49797),
  debug: __webpack_require__(76463),
  deploy: __webpack_require__(8230),
  develop: __webpack_require__(55114),
  exec: __webpack_require__(41400),
  help: __webpack_require__(67340),
  init: __webpack_require__(29287),
  install: __webpack_require__(70447),
  migrate: __webpack_require__(1827),
  networks: __webpack_require__(99706),
  obtain: __webpack_require__(53017),
  opcode: __webpack_require__(48829),
  preserve: __webpack_require__(96112),
  publish: __webpack_require__(88023),
  run: __webpack_require__(90512),
  test: __webpack_require__(86067),
  unbox: __webpack_require__(72995),
  version: __webpack_require__(69037),
  watch: __webpack_require__(36563)
};


/***/ }),

/***/ 44062:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(71017);
const fse = __webpack_require__(55674);
const { promptOverwrites } = __webpack_require__(69751);

const copyFiles = async (destination, options) => {
  fse.ensureDirSync(destination);
  const { force, logger, events } = options;
  const sourcePath = path.join(__dirname, "initSource");
  const projectFiles = fse.readdirSync(sourcePath).filter(
    filename => !filename.endsWith(".eslintrc.json") //exclude .eslintrc.json
  );
  const destinationContents = fse.readdirSync(destination);

  const newContents = projectFiles.filter(
    filename => !destinationContents.includes(filename)
  );

  const contentCollisions = projectFiles.filter(filename =>
    destinationContents.includes(filename)
  );

  let shouldCopy;
  if (force) {
    shouldCopy = projectFiles;
  } else {
    const overwriteContents = await promptOverwrites(contentCollisions, logger);
    shouldCopy = [...newContents, ...overwriteContents];
  }

  await events.emit("init:copyingProjectFiles", {
    destinationPath: destination,
  });
  for (const file of shouldCopy) {
    fse.copySync(path.join(sourcePath, file), path.join(destination, file));
  }
};

module.exports = { copyFiles };


/***/ }),

/***/ 29287:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(97509),
  meta: __webpack_require__(83193)
};


/***/ }),

/***/ 69751:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fse = __webpack_require__(55674);
const inquirer = __webpack_require__(85346);

const promptOverwrites = async (contentCollisions, logger = console) => {
  const overwriteContents = [];

  for (const file of contentCollisions) {
    logger.log(`${file} already exists in this directory...`);
    const overwriting = [
      {
        type: "confirm",
        name: "overwrite",
        message: `Overwrite ${file}?`,
        default: false,
      },
    ];

    const { overwrite } = await inquirer.prompt(overwriting);
    if (overwrite) {
      fse.removeSync(file);
      overwriteContents.push(file);
    }
  }

  return overwriteContents;
};

module.exports = { promptOverwrites };


/***/ }),

/***/ 97509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { copyFiles } = __webpack_require__(44062);
  const fse = __webpack_require__(55674);
  const Config = __webpack_require__(20553);
  const config = Config.default();

  let destinationPath;
  if (options._ && options._.length > 0) {
    destinationPath = options._[0];
    fse.ensureDirSync(destinationPath);
  } else {
    destinationPath = config.working_directory;
  }

  const { events } = config;
  events.emit("init:start");

  try {
    await copyFiles(destinationPath, config);
    await events.emit("init:succeed");
  } catch (error) {
    await events.emit("init:fail", { error });
    throw error;
  }
  return;
};


/***/ }),

/***/ 70447:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(8515),
  meta: __webpack_require__(72545)
};


/***/ }),

/***/ 8515:
/***/ ((module) => {

module.exports = function () {
  const emoji = String.fromCodePoint(0x1f61e);
  console.log(
    "\n  " +
      emoji +
      " Oops! ethpm has moved on faster than truffle's integration. " +
      "\n     This feature has been broken for some time, so we've disabled it. " +
      "\n     Please refer to https://github.com/trufflesuite/truffle/discussions/5293 \n"
  );
};


/***/ }),

/***/ 99706:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(13018),
  meta: __webpack_require__(41873)
};


/***/ }),

/***/ 13018:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(20553);
  const Networks = __webpack_require__(78979);

  const config = Config.detect(options);

  if (options.clean) {
    return await Networks.clean(config);
  }
  return await Networks.display(config);
};


/***/ }),

/***/ 53017:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(34122),
  meta: __webpack_require__(19518)
};


/***/ }),

/***/ 34122:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const SUPPORTED_COMPILERS = ["--solc"];
  const Config = __webpack_require__(20553);
  const config = Config.default().with(options);

  config.events.emit("obtain:start");

  if (options.solc) {
    return await downloadAndCacheSolc({ config, options });
  }

  const message =
    `You have specified a compiler that is unsupported by ` +
    `Truffle.\nYou must specify one of the following ` +
    `compilers as well as a version as arguments: ` +
    `${SUPPORTED_COMPILERS.join(", ")}\nSee 'truffle help ` +
    `obtain' for more information and usage.`;
  throw new Error(message);
};

const downloadAndCacheSolc = async ({ config, options }) => {
  const { CompilerSupplier } = __webpack_require__(4273);
  const semver = __webpack_require__(81249);
  const { events } = config;

  const version = options.solc;
  if (!version || !semver.validRange(version)) {
    const message =
      `You must specify a valid solc version to download` +
      `You specified: "${version}".`;
    throw new Error(message);
  }

  try {
    const supplier = new CompilerSupplier({
      events,
      solcConfig: {
        ...config.compilers.solc,
        version
      }
    });
    const { solc } = await supplier.load();
    events.emit("obtain:succeed", {
      compiler: {
        version: solc.version(),
        name: "Solidity"
      }
    });
    return;
  } catch (error) {
    events.emit("obtain:fail");
    return;
  }
};


/***/ }),

/***/ 48829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(86295),
  meta: __webpack_require__(3697)
};


/***/ }),

/***/ 86295:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const Config = __webpack_require__(20553);
  const TruffleError = __webpack_require__(73321);
  const WorkflowCompile = (__webpack_require__(37017)["default"]);
  const CodeUtils = __webpack_require__(8135);
  const { Conversion, Compilations } = __webpack_require__(20102);

  if (options._.length === 0) {
    throw new TruffleError("Please specify a contract name.");
  }

  const config = Config.detect(options);
  await WorkflowCompile.compileAndSave(config);
  const contractName = options._[0];
  let Contract;
  try {
    Contract = config.resolver.require(contractName);
  } catch (e) {
    throw new TruffleError(
      'Cannot find compiled contract with name "' + contractName + '"'
    );
  }

  const bytecode = options.creation
    ? Contract.bytecode
    : Contract.deployedBytecode;
  const sourceMap = Compilations.Utils.simpleShimSourceMap(
    options.creation ? Contract.sourceMap : Contract.deployedSourceMap
  ); //the shim is in case of an old-style Vyper source map

  let numInstructions;
  if (sourceMap) {
    numInstructions = sourceMap.split(";").length;
  }

  const opcodes = CodeUtils.parseCode(bytecode, {
    maxInstructionCount: numInstructions,
    attemptStripMetadata: sourceMap === undefined
  });

  if (opcodes.length === 0) {
    console.log(
      "Contract has no bytecode. Please check to make sure it's not an `abstract contract` or an `interface`."
    );
    return;
  }

  const lastPCByteLength = Conversion.toBytes(
    opcodes[opcodes.length - 1].pc
  ).byteLength;

  opcodes.forEach(opcode => {
    console.log(
      Conversion.toHexString(opcode.pc, lastPCByteLength) + ":",
      opcode.name,
      opcode.pushData !== undefined && opcode.pushData !== "0x"
        ? opcode.pushData
        : "" //display just "PUSH0", not "PUSH0 0x"
    );
  });
};


/***/ }),

/***/ 96112:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(22954),
  meta: __webpack_require__(75861)
};


/***/ }),

/***/ 88023:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(22986),
  meta: __webpack_require__(39662)
};


/***/ }),

/***/ 22986:
/***/ ((module) => {

module.exports = function () {
  const emoji = String.fromCodePoint(0x1f61e);
  console.log(
    "\n  " +
      emoji +
      " Oops! ethpm has moved on faster than truffle's integration. " +
      "\n     This feature has been broken for some time, so we've disabled it. " +
      "\n     Please refer to https://github.com/trufflesuite/truffle/discussions/5293 \n"
  );
};


/***/ }),

/***/ 43736:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TruffleError = __webpack_require__(73321);

const checkPluginConfig = ({ plugins }) => {
  if (!plugins) {
    throw new TruffleError(
      "\nError: No plugins detected in the configuration file.\n"
    );
  }

  if (!Array.isArray(plugins) || plugins.length === 0) {
    throw new TruffleError("\nError: Plugins configured incorrectly.\n");
  }
};

module.exports = {
  checkPluginConfig
};


/***/ }),

/***/ 14864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async options => {
  const Run = __webpack_require__(77928);
  const { promisify } = __webpack_require__(73837);
  const Config = __webpack_require__(20553);
  const { checkPluginConfig } = __webpack_require__(43736);
  const config = Config.detect(options);

  if (options._.length === 0) {
    const { displayCommandHelp } = __webpack_require__(67340);
    await displayCommandHelp("run");
    return;
  }

  const customCommand = options._[0];

  checkPluginConfig(config);

  return await promisify(Run.run.bind(Run))(customCommand, config);
};


/***/ }),

/***/ 77928:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { Plugins } = __webpack_require__(42113);
const TruffleError = __webpack_require__(73321);

const Run = {
  // executes command or throws user helpful error
  run(customCommand, config, done) {
    const [foundPlugin] = Plugins.findPluginsForCommand(config, customCommand);

    if (!foundPlugin) {
      throw new TruffleError(
        `\nError: "${customCommand}" command not supported by any currently configured plugins. Please make sure:
   plugins are correctly configured in truffle-config.js
   the plugin supporting the command you want to use is installed\n`
      );
    }

    // Will throw an error if loading fails, indicating misconfiguration
    const runCommand = foundPlugin.loadCommand(customCommand);

    const commandResult = runCommand(config, done);
    if (commandResult && typeof commandResult.then === "function") {
      commandResult.then(() => done()).catch(err => done(err));
    }
  }
};

module.exports = Run;


/***/ }),

/***/ 86067:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(46394),
  meta: __webpack_require__(43059)
};


/***/ }),

/***/ 72995:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(91283),
  meta: __webpack_require__(74292)
};


/***/ }),

/***/ 91283:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const normalizeDestination = (destination, workingDirectory) => {
  if (!destination) {
    return workingDirectory;
  }
  const path = __webpack_require__(71017);
  if (path.isAbsolute(destination)) return destination;
  return path.join(workingDirectory, destination);
};

module.exports = async options => {
  const Config = __webpack_require__(20553);
  const { default: Box } = __webpack_require__(21579);
  const fse = __webpack_require__(55674);

  const config = Config.default().with({ logger: console });
  // we merge in the options so that options passed on the command line
  // (for example --quiet) make it to the EventManager
  config.merge(options);

  let [url, destination] = options._;

  const normalizedDestination = normalizeDestination(
    destination,
    config.working_directory
  );

  fse.ensureDirSync(normalizedDestination);

  const unboxOptions = Object.assign({}, options, { logger: config.logger });

  config.events.emit("unbox:start");

  const boxConfig = await Box.unbox(
    url,
    normalizedDestination,
    unboxOptions,
    config
  );
  await config.events.emit("unbox:succeed", { boxConfig });
};


/***/ }),

/***/ 69037:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(87365),
  meta: __webpack_require__(74770)
};


/***/ }),

/***/ 87365:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = async function (options) {
  const { detectConfigOrDefault } = __webpack_require__(54708);
  const version = __webpack_require__(64146);
  const { logger } = options;

  const config = detectConfigOrDefault(options);

  version.logAll(logger, config);
  return;
};


/***/ }),

/***/ 36563:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  run: __webpack_require__(15088),
  meta: __webpack_require__(47766)
};


/***/ }),

/***/ 15088:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(83196);
const commandExistsSync = (__webpack_require__(5497).sync);

module.exports = async function (options) {
  const OS = __webpack_require__(22037);
  const deprecationMessage = colors.yellow(
    `> The watch command is planned ` +
      `for deprecation in version 6 of Truffle.${OS.EOL}` +
      `> See https://github.com/trufflesuite/truffle/issues/3227 for more ` +
      `information.`
  );
  console.log(deprecationMessage);
  const Config = __webpack_require__(20553);
  const sane = __webpack_require__(52817);
  const path = __webpack_require__(71017);

  const config = Config.detect(options);

  const watchOptions = {
    ignored: [
      "build/**/**",
      /[/\\]\./ // Ignore files prefixed with .
    ]
  };
  // Certain large codebases have trouble with the watch command.
  // Installing watchman resolves some of these issues.
  if (commandExistsSync("watchman")) {
    watchOptions.watchman = true;
  } else {
    config.logger.log(
      "If you have trouble using watch, try installing watchman."
    );
  }

  const watchCallback = filePath => {
    const displayPath = path.join(
      "./",
      filePath.replace(config.working_directory, "")
    );
    config.logger.log(colors.cyan(">> File " + displayPath + " changed."));

    build(config);
  };

  const watcher = sane(config.working_directory, watchOptions);
  watcher.on("change", watchCallback);
  watcher.on("add", watchCallback);
  watcher.on("delete", watchCallback);

  config.logger.log(colors.green("Watching for a change in project files..."));
  return new Promise(() => {});
};

const build = config => {
  const Build = __webpack_require__(23525);

  config.logger.log("Rebuilding...");

  Build.build(config, function (error) {
    printSummary(config, error);
  });
};

const printSummary = (config, error) => {
  if (error) {
    const TruffleError = __webpack_require__(73321);
    if (error instanceof TruffleError) {
      console.log(error.message);
    } else {
      // Bubble up all other unexpected errors.
      console.log(error.stack || error.toString());
    }
  } else {
    config.logger.log(
      colors.green("Completed without errors on " + new Date().toString())
    );
  }
};


/***/ }),

/***/ 68303:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const repl = __webpack_require__(38102);
const provision = __webpack_require__(7702);
const {
  Web3Shim,
  createInterfaceAdapter
} = __webpack_require__(36339);
const contract = __webpack_require__(78883);
const os = __webpack_require__(22037);
const vm = __webpack_require__(26144);
const expect = __webpack_require__(14096);
const TruffleError = __webpack_require__(73321);
const fse = __webpack_require__(55674);
const path = __webpack_require__(71017);
const EventEmitter = __webpack_require__(82361);
const { spawn } = __webpack_require__(32081);
const Require = __webpack_require__(35422);
const debug = __webpack_require__(15158)("console");
const { parseQuotesAndEscapes } = __webpack_require__(34763);
const {
  excludedTruffleConsoleCommands,
  validTruffleConsoleCommands
} = __webpack_require__(91874);

// Create an expression that returns a string when evaluated
// by the REPL
const makeIIFE = str => `(() => "${str}")()`;

const processInput = input => {
  const words = input.trim().split(/\s+/);

  // empty input
  if (words.length === 0) return input;

  // maybe truffle command
  if (words[0].toLowerCase() === "truffle") {
    const cmd = words[1];

    if (cmd === undefined) {
      return makeIIFE(
        ` : 'Missing truffle command. Please include a valid truffle command.`
      );
    }

    const normalizedCommand = cmd.toLowerCase();
    const isExcludedInREPL =
      excludedTruffleConsoleCommands.includes(normalizedCommand);

    if (isExcludedInREPL) {
      return makeIIFE(
        ` : '${words[0]} ${cmd}' is not allowed in Console environment.`
      );
    }

    if (!validTruffleConsoleCommands.includes(normalizedCommand)) {
      return makeIIFE(
        ` : '${words[0]} ${cmd}' is not a valid truffle command.`
      );
    }

    return words.slice(1).join(" ");
  }

  // an expression
  return input.trim();
};

class Console extends EventEmitter {
  constructor(options) {
    super();
    EventEmitter.call(this);

    expect.options(options, [
      "working_directory",
      "contracts_directory",
      "contracts_build_directory",
      "migrations_directory",
      "networks",
      "network",
      "network_id",
      "provider",
      "resolver",
      "build_directory"
    ]);

    this.options = options;

    this.repl = null;
    // we need to keep track of name conflicts that occur between contracts and
    // repl context objects so as not to overwrite them - this is to prevent
    // overwriting Node native objects like Buffer, number, etc.
    this.replGlobals = new Set();
    this.knownReplNameConflicts = new Set();
    this.newReplNameConflicts = new Set();

    this.interfaceAdapter = createInterfaceAdapter({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
    this.web3 = new Web3Shim({
      provider: options.provider,
      networkType: options.networks[options.network].type
    });
  }

  recordNameConflicts(abstractions) {
    for (const abstraction of abstractions) {
      const name = abstraction.contract_name;
      if (
        !this.knownReplNameConflicts.has(name) &&
        this.replGlobals.has(name)
      ) {
        this.newReplNameConflicts.add(name);
        this.knownReplNameConflicts.add(name);
      }
    }
  }

  async start() {
    try {
      // start the repl with an empty prompt and show a proper one when
      // the repl has set up its context and is ready to accept input
      this.repl = repl.start({
        prompt: "",
        eval: this.interpret.bind(this)
      });

      // Get and set Truffle and User Globals
      const truffleAndUserGlobals = await this.calculateTruffleAndUserGlobals();
      Object.entries(truffleAndUserGlobals).forEach(([key, value]) => {
        this.repl.context[key] = value;
      });

      // record name conflicts to avoid clobbering globals with contracts
      this.replGlobals = new Set(
        Object.getOwnPropertyNames(this.repl.context.global)
      );

      // repl is ready - set and display prompt
      this.repl.setPrompt("truffle(" + this.options.network + ")> ");

      // hydrate the environment with the user's contracts
      this.provision();

      // provision first before displaying prompt so that if
      // there is a warning the user will end up at the prompt
      this.repl.displayPrompt();

      this.repl.on("exit", () => {
        process.exit();
      });

      // ensure that `await`-ing this method never resolves. (we want to keep
      // the console open until it exits on its own)
      return new Promise(() => {});
    } catch (error) {
      this.options.logger.log(
        "Unexpected error setting up the environment or provisioning " +
          "contracts while instantiating the console."
      );
      this.options.logger.log(error.stack || error.message || error);
    }
  }

  getUserDefinedGlobals({ accounts, interfaceAdapter, web3 }) {
    // exit if feature should be disabled
    if (this.options["require-none"]) return;

    // exit if no hydrate options are set
    if (
      (!this.options.console || !this.options.console.require) &&
      !this.options.require &&
      !this.options.r
    )
      return;

    const addToContext = (context, userData, namespace) => {
      for (const key in userData) {
        if (namespace) {
          if (typeof context[namespace] === "undefined") {
            context[namespace] = {};
          }
          context[namespace][key] = userData[key];
        } else {
          context[key] = userData[key];
        }
      }
    };
    const errorMessage =
      "You must specify the console.require property as " +
      "either a string or an array. If you specify an array, its members " +
      "must be paths or objects containing at least a `path` property.";

    const requireValue =
      this.options.r || this.options.require || this.options.console.require;

    // Require allows us to inject Truffle variables into the script's scope
    const requireOptions = {
      context: {
        accounts,
        interfaceAdapter,
        web3
      }
    };
    const userGlobals = {};
    if (typeof requireValue === "string") {
      requireOptions.file = requireValue;
      addToContext(userGlobals, Require.file(requireOptions));
    } else if (Array.isArray(requireValue)) {
      this.options.console.require.forEach(item => {
        if (typeof item === "string") {
          requireOptions.file = item;
          addToContext(userGlobals, Require.file(requireOptions));
        } else if (typeof item === "object" && item.path) {
          requireOptions.file = item.path;
          addToContext(userGlobals, Require.file(requireOptions), item.as);
        } else {
          throw new Error(errorMessage);
        }
      });
    } else {
      throw new Error(errorMessage);
    }
    return userGlobals;
  }

  async calculateTruffleAndUserGlobals() {
    let accounts;
    try {
      accounts = await this.interfaceAdapter.getAccounts();
    } catch {
      // don't prevent Truffle from working if user doesn't provide some way
      // to sign transactions (e.g. no reason to disallow debugging)
      accounts = [];
    }

    const userGlobals = this.getUserDefinedGlobals({
      web3: this.web3,
      interfaceAdapter: this.interfaceAdapter,
      accounts
    });

    const truffleGlobals = {
      web3: this.web3,
      interfaceAdapter: this.interfaceAdapter,
      accounts,
      artifacts: this.options.resolver
    };

    // we insert user variables first so as to not clobber Truffle's
    return {
      ...userGlobals,
      ...truffleGlobals
    };
  }

  provision() {
    let files = [];
    let jsonBlobs = [];
    try {
      files = fse.readdirSync(this.options.contracts_build_directory);
    } catch (error) {
      // Error reading the build directory? Must mean it doesn't exist or we don't have access to it.
      // Couldn't provision the contracts if we wanted. It's possible we're hiding very rare FS
      // errors, but that's better than showing the user error messages that will be "build folder
      // doesn't exist" 99.9% of the time.
    }

    files.forEach(file => {
      // filter out non artifacts
      if (!file.endsWith(".json")) return;

      try {
        const body = fse.readFileSync(
          path.join(this.options.contracts_build_directory, file),
          "utf8"
        );
        const json = JSON.parse(body);
        // Artifacts may not contain metadata. For example, early Solidity versions as well as
        // Vyper contracts do not include metadata. Just push them to json blobs.
        if (json.metadata === undefined) {
          jsonBlobs.push(json);
        } else {
          // filter out Truffle's console.log. We don't want users to interact with in the REPL.
          // user contracts named console.log will be imported, and a warning will be issued.
          const metadata = JSON.parse(json.metadata);
          const sources = Object.keys(metadata.sources);
          if (
            sources.length > 1 ||
            (sources.length === 1 &&
              !sources.some(source => {
                return (
                  source === "truffle/console.sol" ||
                  source === "truffle/Console.sol"
                );
              }))
          ) {
            jsonBlobs.push(json);
          }
        }
      } catch (error) {
        throw new Error(`Error parsing or reading ${file}: ${error.message}`);
      }
    });

    const abstractions = jsonBlobs.map(json => {
      const abstraction = contract(json);
      provision(abstraction, this.options);
      return abstraction;
    });

    this.recordNameConflicts(abstractions);

    this.resetContractsInConsoleContext(abstractions);
    return abstractions;
  }

  resetContractsInConsoleContext(abstractions) {
    abstractions = abstractions || [];

    const contextVars = {};

    abstractions.forEach(abstraction => {
      const name = abstraction.contract_name;
      // don't overwrite Node's native objects - only load contracts
      // into the repl context when no conflict exists
      if (!this.knownReplNameConflicts.has(name)) {
        contextVars[name] = abstraction;
      }
    });

    if (this.newReplNameConflicts.size > 0) {
      const contractNames = [...this.newReplNameConflicts.keys()];
      this.newReplNameConflicts.clear();
      console.log(
        `\n > Warning: One or more of your contract(s) has a name conflict ` +
          `with something in the current repl context and was not loaded by ` +
          `default. \n > You can use 'artifacts.require("<artifactName>")' ` +
          `to obtain a reference to your contract(s). \n > Truffle recommends ` +
          `that you rename your contract to avoid problems. \n > The following ` +
          `name conflicts exist: ${contractNames.join(", ")}.\n`
      );
    }

    // make sure the repl gets the new contracts in its context
    Object.keys(contextVars || {}).forEach(key => {
      this.repl.context[key] = contextVars[key];
    });
  }

  async runSpawn(inputStrings, options) {
    let childPath;
    /* eslint-disable no-undef */
    if (true) {
      childPath = path.join(__dirname, "consoleChild.bundled.js");
    } else {}

    const spawnOptions = { stdio: "pipe" };
    const settings = ["config", "network", "url"]
      .filter(setting => options[setting])
      .map(setting => `--${setting} ${options[setting]}`)
      .join(" ");

    const spawnInput = `${settings} -- ${inputStrings}`;

    const spawnedProcess = spawn(
      "node",
      ["--no-deprecation", childPath, spawnInput],
      spawnOptions
    );

    // Theoretically stderr can contain multiple errors.
    // So let's just print it instead of throwing through
    // the error handling mechanism. Bad call? Who knows...
    // better be safe and buffer stderr so that it doesn't
    // interrupt stdout, and present it as a complete
    // string at the end of the spawned process.
    let bufferedError = "";
    spawnedProcess.stderr.on("data", data => {
      bufferedError += data.toString();
    });

    spawnedProcess.stdout.on("data", data => {
      // convert buffer to string
      data = data.toString();
      // workaround: remove extra newline in `truffle develop` console
      // truffle test, for some reason, appends a newline to the data
      // it emits here.
      if (data.endsWith(os.EOL)) data = data.slice(0, -os.EOL.length);
      console.log(data);
    });

    return new Promise((resolve, reject) => {
      spawnedProcess.on("close", code => {
        // dump bufferedError
        debug(bufferedError);

        if (!code) {
          // re-provision to ensure any changes are available in the repl
          this.provision();

          //display prompt when child repl process is finished
          this.repl.displayPrompt();
          return void resolve();
        }
        reject(code);
      });
    });
  }

  async interpret(input, context, filename, callback) {
    const processedInput = processInput(input);
    if (validTruffleConsoleCommands.includes(processedInput.split(/\s+/)[0])) {
      try {
        parseQuotesAndEscapes(processedInput); //we're just doing this to see
        //if it errors. unfortunately we need to throw out the result and recompute
        //it afterward (but the input string is probably short so it's OK).
        await this.runSpawn(processedInput, this.options);
      } catch (error) {
        // Perform error handling ourselves.
        if (error instanceof TruffleError) {
          console.log(error.message);
        } else {
          // Bubble up all other unexpected errors.
          console.log(error.stack || error.toString());
        }
        return callback();
      }

      // Reprovision after each command as it may change contracts.
      try {
        this.provision();
        return callback();
      } catch (error) {
        // Don't pass abstractions to the callback if they're there or else
        // they'll get printed in the repl.
        return callback(error);
      }
    }

    // Much of the following code is from here, though spruced up:
    // https://github.com/nfcampos/await-outside

    /*
    - allow whitespace before everything else
    - optionally capture `var| let |const <varname> = `
        - varname only matches if it starts with a-Z or _ or $
        and if contains only those chars or numbers
        - this is overly restrictive but is easier to maintain
        - capture `await <anything that follows it>`
          */
    let includesAwait =
      /^\s*((?:(?:var|const|let)\s+)?[a-zA-Z_$][0-9a-zA-Z_$]*\s*=\s*)?(\(?\s*await[\s\S]*)/;

    const match = processedInput.match(includesAwait);
    let source = processedInput;
    let assignment = null;

    // If our code includes an await, add special processing to ensure it's evaluated properly.
    if (match) {
      let assign = match[1];

      const expression =
        match[2] && match[2].endsWith(";")
          ? // strip off trailing ";" to prevent the expression below from erroring
            match[2].slice(0, -1)
          : match[2];

      const RESULT = "__await_outside_result";

      // Wrap the await inside an async function.
      // Strange indentation keeps column offset correct in stack traces
      source = `(async function() { try {${
        assign ? `global.${RESULT} =` : "return"
      } (
          ${expression.trim()}
  ); } catch(e) {global.ERROR = e; throw e; } }())`;

      assignment = assign
        ? `${assign.trim()} global.${RESULT}; void delete global.${RESULT};`
        : null;

      //finally, if the assignment did not use var, const, or let, make sure to
      //return the result afterward
      if (assign) {
        const bareAssignmentMatch = assign.match(
          /^\s*([a-zA-Z_$][0-9a-zA-Z_$]*)\s*=\s*/
        );
        if (bareAssignmentMatch) {
          const varName = bareAssignmentMatch[1];
          assignment += varName;
        }
      }
    }

    const runScript = script => {
      const options = {
        displayErrors: false,
        breakOnSigint: true,
        filename: filename
      };

      vm.createContext(context);
      return script.runInContext(context, options);
    };

    let script;
    try {
      const options = { lineOffset: -1 };
      script = vm.createScript(source, options);
    } catch (error) {
      // If syntax error, or similar, bail.
      return callback(error);
    }

    // Ensure our script returns a promise whether we're using an
    // async function or not. If our script is an async function,
    // this will ensure the console waits until that await is finished.
    Promise.resolve(runScript(script))
      .then(value => {
        // If there's an assignment to run, run that.
        if (assignment) return runScript(vm.createScript(assignment));
        return value;
      })
      .then(value => {
        // All good? Return the value (e.g., eval'd script or assignment)
        callback(null, value);
      })
      .catch(callback);
  }
}

module.exports = {
  Console
};


/***/ }),

/***/ 9941:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { CLIDebugger } = __webpack_require__(458);

module.exports = {
  CLIDebugger
};


/***/ }),

/***/ 42863:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const colors = __webpack_require__(83196);
const TruffleError = __webpack_require__(73321);

class BuildError extends TruffleError {
  constructor(message) {
    message =
      "Error building:\n\n" +
      message +
      "\n\n" +
      colors.red("Build failed. See above.");
    super(message);
  }
}

module.exports = BuildError;


/***/ }),

/***/ 48937:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var TruffleError = __webpack_require__(73321);

class ConfigurationError extends TruffleError {
  constructor(message) {
    super(message);
  }
}

module.exports = ConfigurationError;


/***/ }),

/***/ 932:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = function (options) {
  const Config = __webpack_require__(20553);
  const TruffleError = __webpack_require__(73321);
  const mergeConfigNetwork = __webpack_require__(22173);

  let config;
  try {
    config = Config.detect(options);
    config = mergeConfigNetwork(config, options);
  } catch (error) {
    if (error instanceof TruffleError && options.url) {
      config = Config.default();
      config = mergeConfigNetwork(config, options);
      // in case config file is not detected (exception thrown) AND url is provided in the options,
      // We use default config and set compileNone to true. Since there are is no config files and url is provided,
      // It is assumed that truffle debug/console is being used for analysis and debugging and that there is nothing to compile.
      // E.g. analysing/debugging a single transaction of an external project
      config.compileNone = true;
      config.configFileSkipped = true;
    } else {
      throw error;
    }
  }

  return config;
};


/***/ }),

/***/ 22173:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { URL } = __webpack_require__(57310);

module.exports = function (config, options) {
  if (options.url) {
    const url = new URL(options.url);
    config.networks[url.host] = {
      url: options.url,
      network_id: "*"
    };
    config.network = url.host;
  }
  config.merge(options);
  return config;
};


/***/ }),

/***/ 25603:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @module mnemonic;
 * @requires module:@truffle/config
 * @requires module:seedrandom
 * @requires module:ethereum-cryptography
 * @requires module:@truffle/hdwallet
 * @requires module:crypto
 */

const Config = __webpack_require__(20553);
const defaultUserConfig = Config.getUserConfig();
const {
  entropyToMnemonic,
  mnemonicToSeedSync
} = __webpack_require__(89211);
const { wordlist } = __webpack_require__(48732);
const crypto = __webpack_require__(6113);
const {
  createAccountGeneratorFromSeedAndPath,
  uncompressedPublicKeyToAddress
} = __webpack_require__(75262);

const mnemonic = {
  /**
   * gets user-level mnemonic from user config, and if missing generates a new mnemonic
   * @returns {String} mnemonic
   */
  getOrGenerateMnemonic: function () {
    let mnemonic;
    const userMnemonicExists = defaultUserConfig.get("mnemonic");
    if (!userMnemonicExists) {
      mnemonic = entropyToMnemonic(crypto.randomBytes(16), wordlist);
      defaultUserConfig.set({ mnemonic: mnemonic });
    } else {
      mnemonic = userMnemonicExists;
    }

    return mnemonic;
  },

  /**
   * gets accounts object using mnemonic
   * @param {String}
   * @returns {Object} mnemonicObject
   */
  getAccountsInfo: function (numAddresses) {
    let mnemonic = this.getOrGenerateMnemonic();
    let accounts = [];
    let privateKeys = [];

    let walletHdpath = "m/44'/60'/0'/0".split("/");
    let hdwallet = createAccountGeneratorFromSeedAndPath(
      Buffer.from(mnemonicToSeedSync(mnemonic)),
      walletHdpath
    );
    let addressIndex = 0;

    for (let i = addressIndex; i < addressIndex + numAddresses; i++) {
      let wallet = hdwallet(i);
      let addr = `0x${Buffer.from(
        uncompressedPublicKeyToAddress(wallet.publicKey)
      ).toString("hex")}`;
      let privKey = wallet.privateKey.toString("hex");
      accounts.push(addr);
      privateKeys.push(privKey);
    }

    return {
      mnemonic,
      accounts,
      privateKeys
    };
  }
};

module.exports = mnemonic;


/***/ }),

/***/ 78979:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(57147);
const path = __webpack_require__(71017);
const OS = __webpack_require__(22037);
const BlockchainUtils = __webpack_require__(86317);
const Provider = __webpack_require__(509);
const { createInterfaceAdapter } = __webpack_require__(36339);

const Networks = {
  deployed: async function(options) {
    let files;
    try {
      // Only read JSON files in directory
      files = fs
        .readdirSync(options.contracts_build_directory)
        .filter(fn => fn.endsWith(".json"));
    } catch (error) {
      // We can't read the directory. Act like we found nothing.
      files = [];
    }

    const binaries = files.map(file => {
      const filePath = path.join(options.contracts_build_directory, file);
      const fileContents = fs.readFileSync(filePath, "utf8");
      return JSON.parse(fileContents);
    });

    const idsToNames = {};
    const networks = {};

    for (let networkName in options.networks) {
      const network = options.networks[networkName];
      const networkId = network.network_id;

      if (networkId == null) return;

      idsToNames[networkId] = networkName;
      networks[networkName] = {};
    }

    for (let json of binaries) {
      for (let networkId in json.networks) {
        const networkName = idsToNames[networkId] || networkId;

        if (networks[networkName] == null) networks[networkName] = {};

        const address = json.networks[networkId].address;

        if (address == null) return;

        networks[networkName][json.contractName] = address;
      }
    }
    return networks;
  },

  display: async function(config) {
    const networks = await this.deployed(config);
    const { networkNames, starNetworks } = Object.keys(networks)
      .sort()
      .reduce(
        (acc, networkName) => {
          if (
            config.networks[networkName] &&
            config.networks[networkName].network_id === "*"
          ) {
            acc.starNetworks.push(networkName);
          } else {
            acc.networkNames.push(networkName);
          }
          return acc;
        },
        { networkNames: [], starNetworks: [] }
      );

    const unknownNetworks = networkNames.filter(networkName => {
      const configuredNetworks = Object.keys(config.networks);
      let found = false;
      for (let i = 0; i < configuredNetworks.length; i++) {
        const configuredNetworkName = configuredNetworks[i];
        if (networkName === configuredNetworkName) {
          found = true;
          break;
        }
      }

      return !found;
    });

    // Only display this warning if:
    //
    //   At least one network is configured with the wildcard ('*') network id
    //   There's a least one network deployed to
    //   And one of those networks deployed to is unknown (i.e., unconfigured).
    if (
      starNetworks.length > 0 &&
      networkNames.length > 0 &&
      unknownNetworks.length > 0
    ) {
      config.logger.log(
        OS.EOL +
          "The following networks are configured to match any network id ('*'):" +
          OS.EOL
      );

      starNetworks.forEach(networkName => {
        config.logger.log("    " + networkName);
      });

      config.logger.log(
        OS.EOL +
          "Closely inspect the deployed networks below, and use `truffle networks --clean` to remove any networks that don't match your configuration. You should not use the wildcard configuration ('*') for staging and production networks for which you intend to deploy your application."
      );
    }

    networkNames.forEach(networkName => {
      config.logger.log("");

      let output = Object.keys(networks[networkName])
        .sort()
        .map(contract_name => {
          const address = networks[networkName][contract_name];
          return contract_name + ": " + address;
        });

      if (output.length === 0) output = ["No contracts deployed."];

      let message = "Network: ";

      const is_id = config.networks[networkName] == null;

      if (is_id) {
        message += "UNKNOWN (id: " + networkName + ")";
      } else {
        message +=
          networkName +
          " (id: " +
          config.networks[networkName].network_id +
          ")";
      }

      config.logger.log(message);
      config.logger.log("  " + output.join("\n  "));
    });

    if (networkNames.length === 0) {
      config.logger.log(
        OS.EOL + "Contracts have not been deployed to any network."
      );
    }
    config.logger.log("");
  },

  clean: async function(config) {
    // Only read JSON files in directory
    let files = fs
      .readdirSync(config.contracts_build_directory)
      .filter(fn => fn.endsWith(".json"));
    const configuredNetworks = Object.keys(config.networks);
    const results = [];

    files.forEach(file => {
      const filePath = path.join(config.contracts_build_directory, file);
      const fileContents = fs.readFileSync(filePath, "utf8");
      const body = JSON.parse(fileContents);

      for (let installedNetworkId of Object.keys(body.networks)) {
        let found = false;
        for (let i = 0; i < configuredNetworks.length; i++) {
          const configuredNetwork = configuredNetworks[i];

          // If an installed network id matches a configured id, then we can ignore this one.
          let parsedNetworkId;
          try {
            // Account for an integer or string in the config
            parsedNetworkId = parseInt(installedNetworkId);
          } catch (_error) {
            // If it can't be parsed into an int like * then don't worry about it
          }
          if (
            installedNetworkId ===
              config.networks[configuredNetwork].network_id ||
            parsedNetworkId === config.networks[configuredNetwork].network_id
          ) {
            found = true;
            break;
          }
        }
        // If we didn't find a suitable configuration, delete this network.
        if (found === false) delete body.networks[installedNetworkId];
      }
      // Our work is done here. Save the file.
      fs.writeFileSync(filePath, JSON.stringify(body, null, 2), "utf8");
      results.push(body);
    });

    // TODO: Display what's removed?
    return results;
  },

  // Try to connect to every named network except for "test" and "development"
  asURIs: async function(options, networks) {
    const result = {
      uris: {},
      failed: []
    };

    for (const networkName of networks) {
      const provider = Provider.create(options.networks[networkName]);
      try {
        const uri = await BlockchainUtils.asURI(provider);
        result.uris[networkName] = uri;
      } catch (error) {
        result.failed.push(networkName);
      }
    }

    return result;
  },

  matchesNetwork: async function(network_id, network_options) {
    const provider = Provider.create(network_options);

    const first = network_id + "";
    const second = network_options.network_id + "";

    if (first === second) return true;

    const isFirstANumber = isNaN(parseInt(network_id)) === false;
    const isSecondANumber =
      isNaN(parseInt(network_options.network_id)) === false;

    // If both network ids are numbers, then they don't match, and we should quit.
    if (isFirstANumber && isSecondANumber) return false;

    const interfaceAdapter = createInterfaceAdapter({
      provider,
      networkType: network_options.type
    });

    const currentNetworkID = await interfaceAdapter.getNetworkId();
    if (first === currentNetworkID) return true;
    if (isFirstANumber === false)
      await BlockchainUtils.matches(first, provider);
    else {
      // Nothing else to compare.
      return false;
    }
  }
};

module.exports = Networks;


/***/ }),

/***/ 21579:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.normalizeSourcePath = void 0;
const utils_1 = __importDefault(__webpack_require__(26086));
const tmp_1 = __importDefault(__webpack_require__(36276));
const path_1 = __importDefault(__webpack_require__(71017));
const config_1 = __importDefault(__webpack_require__(20553));
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const inquirer_1 = __importDefault(__webpack_require__(96062));
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("unbox");
const defaultPath = "git@github.com:trufflesuite/truffle-init-default";
/*
 * accepts a number of different url and org/repo formats and returns the
 * format required by https://www.npmjs.com/package/download-git-repo for remote URLs
 * or absolute path to local folder if the source is local folder
 *
 * supported input formats are as follows:
 *   - org/repo[#branch]
 *   - https://github.com(/|:)<org>/<repo>[.git][#branch]
 *   - git@github.com:<org>/<repo>[#branch]
 *   - path to local folder (absolute, relative or ~/home)
 */
const normalizeSourcePath = (url = defaultPath) => {
    // Process filepath resolution
    //
    if (url.startsWith(".") || url.startsWith("/") || url.startsWith("~")) {
        debug({ in: url, out: path_1.default.normalize(url) });
        return path_1.default.resolve(path_1.default.normalize(url));
    }
    // preprocess to reduce regex complexity
    // `https` is not case sensitiv, unlike `git`
    url = url.replace(/^https/i, "https");
    // branch should not end with slash
    const invalidBranch = /\/$/;
    // process https? or git prefixed input
    //
    if (/^(https?|git)/i.test(url)) {
        // This regular expression uses named capture groups to parse input. The
        // format is (?<the-name>the-regex)
        //
        // \w, the word meta character is a member of [A-Za-z0-9_]. all letters,
        // digits and the underscore. Note \w has to be \\w to escape the backslash
        // in a string literal.
        //
        const protocolRex = new RegExp([
            // match either `htps://` or `git@`
            "(?<protocol>(https://|git@))",
            // service is 1 or many (word, dot or dash)
            "(?<service>[\\w.-]+)",
            // match either `/` or `:`
            "(/|:)",
            // org is 1 or many (word, dot or dash)
            "(?<org>[\\w.-]+)",
            "/",
            // repo is 1 or many (word, dot or dash)
            "(?<repo>[\\w.-]+)",
            // branch is 1 or many (word, dot or dash) and can be optional
            "(?<branch>#[\\w./-]+)?",
            // the input string must be consumed fully at this point to match
            "$"
        ].join(""));
        const match = url.match(protocolRex);
        if (match) {
            const { groups } = match;
            const branch = groups["branch"] || "";
            if (invalidBranch.test(branch)) {
                debug({
                    in: url,
                    error: "InvalidFormat (protocol)",
                    hint: "branch is malformed"
                });
                throw new Error("Box specified with invalid format (git/https)");
            }
            const repo = groups["repo"].replace(/\.git$/i, "");
            const result = `https://${groups["service"]}:${groups["org"]}/${repo}${branch}`;
            debug({ in: url, out: result });
            return result;
        }
        debug({
            in: url,
            error: "InvalidFormat (protocol)",
            hint: "did not match protocol"
        });
        throw new Error("Box specified with invalid format (git/https)");
    }
    // default case: process [org/] + repo + [ #branch/name/with/slashes ]
    //
    const orgRepoBranchRex = new RegExp([
        // start match at beginning
        "^",
        // org is 1 or many (word, dot or dash) followed by a slash. org can be
        // optional
        "(?<org>[\\w.-]+/)?",
        // repo is 1 or many (word, dot or dash)
        "(?<repo>[\\w.-]+)",
        // optional branch (undefined if unmatched)
        "(?<branch>#[\\w./-]+)?",
        "$"
    ].join(""));
    const match = url.match(orgRepoBranchRex);
    if (match) {
        const { groups } = match;
        // `truffle-box` is the default org
        const org = groups["org"] || "truffle-box/";
        const branch = groups["branch"] || "";
        if (invalidBranch.test(branch)) {
            debug({
                in: url,
                error: "InvalidFormat (orgRepoBranch)",
                hint: "branch is malformed"
            });
            throw new Error("Box specified with invalid format");
        }
        let repo = groups["repo"];
        // Official Truffle boxes should have a `-box` suffix
        if (org.toLowerCase().startsWith("truffle-box")) {
            repo = repo.endsWith("-box") ? repo : `${repo}-box`;
        }
        const result = `https://github.com:${org}${repo}${branch}`;
        debug({ in: url, out: result });
        return result;
    }
    // No match, it's an error!
    debug({ in: url, error: "InvalidFormat", hint: "matched nothing" });
    throw new Error("Box specified in invalid format");
};
exports.normalizeSourcePath = normalizeSourcePath;
const parseSandboxOptions = (options) => {
    if (typeof options === "string") {
        // back compatibility for when `options` used to be `name`
        return {
            name: options,
            unsafeCleanup: false,
            setGracefulCleanup: false,
            logger: console,
            force: false
        };
    }
    else if (typeof options === "object") {
        return {
            name: options.name || "default",
            unsafeCleanup: options.unsafeCleanup || false,
            setGracefulCleanup: options.setGracefulCleanup || false,
            logger: options.logger || console,
            force: options.force || false
        };
    }
};
const Box = {
    unbox: (url, destination, options = {}, config) => __awaiter(void 0, void 0, void 0, function* () {
        const { events } = config;
        let tempDirCleanup;
        const unpackBoxOptions = {
            logger: options.logger,
            force: options.force
        };
        try {
            const normalizedSourcePath = (0, exports.normalizeSourcePath)(url);
            yield Box.checkDir(options, destination);
            const tempDir = utils_1.default.setUpTempDirectory(events);
            const tempDirPath = tempDir.path;
            tempDirCleanup = tempDir.cleanupCallback;
            yield utils_1.default.downloadBox(normalizedSourcePath, tempDirPath, events);
            const boxConfig = yield utils_1.default.readBoxConfig(tempDirPath);
            yield utils_1.default.unpackBox(tempDirPath, destination, boxConfig, unpackBoxOptions);
            events.emit("unbox:cleaningTempFiles:start");
            tempDirCleanup();
            events.emit("unbox:cleaningTempFiles:succeed");
            utils_1.default.setUpBox(boxConfig, destination, events);
            return boxConfig;
        }
        catch (error) {
            if (tempDirCleanup)
                tempDirCleanup();
            events.emit("unbox:fail");
            throw error;
        }
    }),
    checkDir: (options = {}, destination) => __awaiter(void 0, void 0, void 0, function* () {
        let logger = options.logger || console;
        if (!options.force) {
            const unboxDir = fs_extra_1.default.readdirSync(destination);
            if (unboxDir.length) {
                logger.log(`This directory is non-empty...`);
                const prompt = [
                    {
                        type: "confirm",
                        name: "proceed",
                        message: `Proceed anyway?`,
                        default: true
                    }
                ];
                const answer = yield inquirer_1.default.prompt(prompt);
                if (!answer.proceed) {
                    logger.log("Unbox cancelled");
                    process.exit();
                }
            }
        }
    }),
    // options.unsafeCleanup
    //   Recursively removes the created temporary directory, even when it's not empty. default is false
    // options.setGracefulCleanup
    //   Cleanup temporary files even when an uncaught exception occurs
    sandbox: (options) => __awaiter(void 0, void 0, void 0, function* () {
        const { name, unsafeCleanup, setGracefulCleanup, logger, force } = parseSandboxOptions(options);
        const boxPath = name.replace(/^default(?=#|$)/, defaultPath);
        //ordinarily, this line will have no effect.  however, if the name is "default",
        //possibly with a branch specification, this replaces it appropriately
        //(this is necessary in order to keep using trufflesuite/truffle-init-default
        //instead of truffle-box/etc)
        if (setGracefulCleanup)
            tmp_1.default.setGracefulCleanup();
        let config = new config_1.default();
        const tmpDir = tmp_1.default.dirSync({ unsafeCleanup });
        const unboxOptions = { logger, force };
        yield Box.unbox(boxPath, tmpDir.name, unboxOptions, config);
        return config_1.default.load(path_1.default.join(tmpDir.name, "truffle-config.js"), {});
    })
};
exports["default"] = Box;
//# sourceMappingURL=box.js.map

/***/ }),

/***/ 77220:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(55674));
function setDefaults(config = {}) {
    const hooks = config.hooks || {};
    return {
        ignore: config.ignore || [],
        commands: config.commands || {
            compile: "truffle compile",
            migrate: "truffle migrate",
            test: "truffle test"
        },
        hooks: {
            "post-unpack": hooks["post-unpack"] || ""
        }
    };
}
function read(path) {
    return fs_extra_1.default
        .readFile(path)
        .catch(() => "{}")
        .then(JSON.parse)
        .then(setDefaults);
}
module.exports = {
    read,
    setDefaults
};
//# sourceMappingURL=config.js.map

/***/ }),

/***/ 26086:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const unbox_1 = __importDefault(__webpack_require__(91104));
const fs_1 = __importDefault(__webpack_require__(57147));
const config_1 = __importDefault(__webpack_require__(77220));
const tmp_1 = __importDefault(__webpack_require__(36276));
const path_1 = __importDefault(__webpack_require__(71017));
module.exports = {
    downloadBox: (source, destination, events) => __awaiter(void 0, void 0, void 0, function* () {
        events.emit("unbox:downloadingBox:start");
        yield unbox_1.default.verifySourcePath(source);
        yield unbox_1.default.fetchRepository(source, destination);
        events.emit("unbox:downloadingBox:succeed");
    }),
    readBoxConfig: (destination) => __awaiter(void 0, void 0, void 0, function* () {
        const possibleConfigs = [
            path_1.default.join(destination, "truffle-box.json"),
            path_1.default.join(destination, "truffle-init.json")
        ];
        const configPath = possibleConfigs.reduce((path, alt) => path || (fs_1.default.existsSync(alt) && alt), undefined);
        return yield config_1.default.read(configPath);
    }),
    setUpTempDirectory: (events) => {
        events.emit("unbox:preparingToDownload:start");
        const options = {
            unsafeCleanup: true
        };
        const tmpDir = tmp_1.default.dirSync(options);
        events.emit("unbox:preparingToDownload:succeed");
        return {
            path: path_1.default.join(tmpDir.name, "box"),
            cleanupCallback: tmpDir.removeCallback
        };
    },
    unpackBox: (tempDir, destination, boxConfig, unpackBoxOptions) => __awaiter(void 0, void 0, void 0, function* () {
        unbox_1.default.prepareToCopyFiles(tempDir, boxConfig);
        yield unbox_1.default.copyTempIntoDestination(tempDir, destination, unpackBoxOptions);
    }),
    setUpBox: (boxConfig, destination, events) => {
        events.emit("unbox:settingUpBox:start");
        unbox_1.default.installBoxDependencies(boxConfig, destination);
        events.emit("unbox:settingUpBox:succeed");
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 91104:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const path_1 = __importDefault(__webpack_require__(71017));
const download_git_repo_1 = __importDefault(__webpack_require__(20448));
const axios_1 = __importDefault(__webpack_require__(43306));
const vcsurl_1 = __importDefault(__webpack_require__(9627));
const url_1 = __webpack_require__(57310);
const child_process_1 = __webpack_require__(32081);
const inquirer_1 = __importDefault(__webpack_require__(96062));
const util_1 = __webpack_require__(73837);
const ignore_1 = __importDefault(__webpack_require__(15151));
function verifyLocalPath(localPath) {
    const configPath = path_1.default.join(localPath, "truffle-box.json");
    fs_extra_1.default.access(configPath).catch(_e => {
        throw new Error(`Truffle Box at path ${localPath} doesn't exist.`);
    });
}
function verifyVCSURL(url) {
    return __awaiter(this, void 0, void 0, function* () {
        // Next let's see if the expected repository exists. If it doesn't, ghdownload
        // will fail spectacularly in a way we can't catch, so we have to do it ourselves.
        const configURL = (0, url_1.parse)(`${(0, vcsurl_1.default)(url)
            .replace("github.com", "raw.githubusercontent.com")
            .replace(/#.*/, "")}/master/truffle-box.json`);
        const repoUrl = `https://${configURL.host}${configURL.path}`;
        try {
            yield axios_1.default.head(repoUrl, { maxRedirects: 50 });
        }
        catch (error) {
            if (error.response && error.response.status === 404) {
                throw new Error(`Truffle Box at URL ${url} doesn't exist. If you believe this is an error, please contact Truffle support.`);
            }
            else {
                const prefix = `Error connecting to ${repoUrl}. Please check your internet connection and try again.`;
                error.message = `${prefix}\n\n${error.message || ""}`;
                throw error;
            }
        }
    });
}
function verifySourcePath(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            return verifyLocalPath(sourcePath);
        }
        return verifyVCSURL(sourcePath);
    });
}
function gitIgnoreFilter(sourcePath) {
    return __awaiter(this, void 0, void 0, function* () {
        const ignoreFilter = (0, ignore_1.default)();
        try {
            const gitIgnore = yield fs_extra_1.default.readFile(path_1.default.join(sourcePath, ".gitignore"), "utf8");
            ignoreFilter.add(gitIgnore.split(/\r?\n/).map(p => p.replace(/\/$/, "")));
        }
        catch (err) { }
        return ignoreFilter;
    });
}
function fetchRepository(sourcePath, dir) {
    return __awaiter(this, void 0, void 0, function* () {
        if (sourcePath.startsWith("/")) {
            const filter = yield gitIgnoreFilter(sourcePath);
            return fs_extra_1.default.copy(sourcePath, dir, {
                filter: file => sourcePath === file || !filter.ignores(path_1.default.relative(sourcePath, file))
            });
        }
        return (0, util_1.promisify)(download_git_repo_1.default)(sourcePath, dir);
    });
}
function prepareToCopyFiles(tempDir, { ignore }) {
    const needingRemoval = ignore;
    // remove box config file
    needingRemoval.push("truffle-box.json");
    needingRemoval.push("truffle-init.json");
    needingRemoval
        .map((fileName) => path_1.default.join(tempDir, fileName))
        .forEach((filePath) => fs_extra_1.default.removeSync(filePath));
}
function promptOverwrites(contentCollisions, logger = console) {
    return __awaiter(this, void 0, void 0, function* () {
        const overwriteContents = [];
        for (const file of contentCollisions) {
            logger.log(`${file} already exists in this directory...`);
            const overwriting = [
                {
                    type: "confirm",
                    name: "overwrite",
                    message: `Overwrite ${file}?`,
                    default: false
                }
            ];
            const { overwrite } = yield inquirer_1.default.prompt(overwriting);
            if (overwrite) {
                fs_extra_1.default.removeSync(file);
                overwriteContents.push(file);
            }
        }
        return overwriteContents;
    });
}
function copyTempIntoDestination(tmpDir, destination, options) {
    return __awaiter(this, void 0, void 0, function* () {
        fs_extra_1.default.ensureDirSync(destination);
        const { force, logger } = options;
        const boxContents = fs_extra_1.default.readdirSync(tmpDir);
        const destinationContents = fs_extra_1.default.readdirSync(destination);
        const newContents = boxContents.filter(filename => !destinationContents.includes(filename));
        const contentCollisions = boxContents.filter(filename => destinationContents.includes(filename));
        let shouldCopy;
        if (force) {
            shouldCopy = boxContents;
        }
        else {
            const overwriteContents = yield promptOverwrites(contentCollisions, logger);
            shouldCopy = [...newContents, ...overwriteContents];
        }
        for (const file of shouldCopy) {
            fs_extra_1.default.copySync(`${tmpDir}/${file}`, `${destination}/${file}`);
        }
    });
}
function installBoxDependencies({ hooks }, destination) {
    const postUnpack = hooks["post-unpack"];
    if (postUnpack.length === 0)
        return;
    (0, child_process_1.execSync)(postUnpack, { cwd: destination });
}
module.exports = {
    copyTempIntoDestination,
    fetchRepository,
    installBoxDependencies,
    prepareToCopyFiles,
    verifySourcePath,
    verifyVCSURL
};
//# sourceMappingURL=unbox.js.map

/***/ }),

/***/ 74269:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("compile-vyper");
const path = __webpack_require__(71017);
const exec = (__webpack_require__(32081).exec);
const fs = __webpack_require__(57147);
const colors = __webpack_require__(83196);
const minimatch = __webpack_require__(91171);
const semver = __webpack_require__(81249);

const findContracts = __webpack_require__(23542);
const Config = __webpack_require__(20553);
const { Profiler } = __webpack_require__(76273);
const { requiredSources } = __webpack_require__(53377);
const { Compilations } = __webpack_require__(29833);

const { compileJson } = __webpack_require__(13919);

const VYPER_PATTERN_STRICT = "**/*.{vy,v.py,vyper.py}"; //no JSON

// Check that vyper is available, return its version
function checkVyper() {
  return new Promise((resolve, reject) => {
    exec("vyper-json --version", function (err, stdout, _stderr) {
      if (err) {
        //vyper-json not available, check vyper
        exec("vyper --version", function (err, stdout, stderr) {
          if (err) {
            //error: neither vyper nor vyper-json available
            return reject(`${colors.red("Error executing vyper:")}\n${stderr}`);
          }
          const version = normalizeVersion(stdout.trim());
          if (
            semver.satisfies(version, ">=0.2.5", {
              loose: true,
              includePrerelase: true
            })
          ) {
            //if version is >=0.2.5, we can still use JSON via
            //vyper --standard-json
            resolve({
              version,
              json: true,
              jsonCommand: "vyper --standard-json"
            });
          } else {
            //otherwise, we're stuck using vyper w/o JSON
            resolve({ version, json: false });
          }
        });
      } else {
        //no error: vyper-json is available
        const version = normalizeVersion(stdout.trim());
        resolve({ version, json: true, jsonCommand: "vyper-json" });
      }
    });
  });
}

//HACK: alters prerelease versions so semver can understand them
function normalizeVersion(version) {
  return version.replace(/^(\d+\.\d+\.\d+)b(\d+)/, "$1-beta.$2");
}

// Execute vyper for single source file
function execVyper(options, sourcePath, version, callback) {
  const formats = ["abi", "bytecode", "bytecode_runtime"];
  debug("version: %s", version);
  if (
    semver.satisfies(version, ">=0.1.0-beta.7", {
      loose: true,
      includePrerelase: true
    })
  ) {
    //Vyper chokes on unknown formats, so only include this for
    //ones that support it (they were introduced in 0.1.0b7)
    formats.push("source_map");
  }
  let evmVersionOption = "";
  if (
    options.compilers.vyper.settings &&
    options.compilers.vyper.settings.evmVersion
  ) {
    const evmVersion = options.compilers.vyper.settings.evmVersion;
    if (evmVersion.includes("'")) {
      throw new Error("Invalid EVM version");
    }
    evmVersionOption = `--evm-version '${evmVersion}'`;
  }
  if (options.contracts_directory.includes("'")) {
    throw new Error("Contracts directory contains apostrophe");
  }
  const command = `vyper -f ${formats.join(
    ","
  )} ${evmVersionOption} ${sourcePath} -p '${options.contracts_directory}'`;

  exec(command, { maxBuffer: 600 * 1024 }, function (err, stdout, stderr) {
    if (err)
      return callback(
        `${stderr}\n${colors.red(
          `Compilation of ${sourcePath} failed. See above.`
        )}`
      );

    var outputs = stdout.split(/\r?\n/);

    debug("formats: %O", formats);
    debug("outputs: %O", outputs);

    const compiledContract = outputs.reduce((contract, output, index) => {
      return Object.assign(contract, { [formats[index]]: output });
    }, {});

    callback(null, compiledContract);
  });
}

/**
 *
 * read source contents from sourcePath
 */
function readSource(sourcePath) {
  const sourceBuffer = fs.readFileSync(sourcePath);
  return sourceBuffer.toString();
}

/**
 * aggregate source information based on compiled output;
 * this can include sources that are not contracts
 */

//note: this takes paths, rather than full source objects like compileJson!
async function compileNoJson({ paths: sources, options, version }) {
  const compiler = { name: "vyper", version };
  const promises = [];
  const properSources = sources.filter(source => !source.endsWith(".json")); //filter out JSON interfaces
  const targets = options.compilationTargets
    ? properSources.filter(sourcePath =>
        options.compilationTargets.includes(sourcePath)
      )
    : properSources;
  targets.forEach(sourcePath => {
    promises.push(
      new Promise((resolve, reject) => {
        execVyper(
          options,
          sourcePath,
          version,
          function (error, compiledContract) {
            if (error) return reject(error);

            debug("compiledContract: %O", compiledContract);

            // remove first extension from filename
            const extension = path.extname(sourcePath);
            const basename = path.basename(sourcePath, extension);

            // if extension is .py, remove second extension from filename
            const contractName =
              extension !== ".py"
                ? basename
                : path.basename(basename, path.extname(basename));

            const sourceContents = readSource(sourcePath);
            const deployedSourceMap = compiledContract.source_map //there is no constructor source map
              ? JSON.parse(compiledContract.source_map)
              : undefined;

            const contractDefinition = {
              contractName: contractName,
              sourcePath: sourcePath,
              source: sourceContents,
              abi: JSON.parse(compiledContract.abi),
              bytecode: {
                bytes: compiledContract.bytecode.slice(2), //remove "0x" prefix
                linkReferences: [] //no libraries in Vyper
              },
              deployedBytecode: {
                bytes: compiledContract.bytecode_runtime.slice(2), //remove "0x" prefix
                linkReferences: [] //no libraries in Vyper
              },
              deployedSourceMap,
              compiler
            };

            const compilation = {
              sources: [
                {
                  sourcePath,
                  contents: sourceContents,
                  language: "Vyper"
                }
              ],
              contracts: [contractDefinition],
              compiler,
              sourceIndexes: [sourcePath]
            };

            resolve(compilation);
          }
        );
      })
    );
  });
  const compilations = await Promise.all(promises);

  return Compilations.promoteCompileResult({ compilations });
}

const Compile = {
  // Check that vyper is available then forward to internal compile function
  async sources({ sources = {}, options }) {
    options = Config.default().merge(options);
    const paths = Object.keys(sources);
    const vyperFiles = paths.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );

    // no vyper files found, no need to check vyper
    // (note that JSON-only will not activate vyper)
    if (vyperFiles.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    Compile.display(vyperFiles, options);
    const { version, json: useJson, jsonCommand } = await checkVyper();
    if (!useJson) {
      //it might be possible to handle this case by writing the sources
      //to a temporary directory (and possibly using some sort of remapping--
      //a manual one I mean, Vyper doesn't have remappings),
      //but for now I'll just have it throw for simplicity
      throw new Error("Compiling literal Vyper sources requires vyper-json");
    }

    return compileJson({ sources, options, version, command: jsonCommand });
  },

  async sourcesWithDependencies({ paths = [], options }) {
    options = Config.default().merge(options);
    debug("paths: %O", paths);
    const vyperFilesStrict = paths.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );
    debug("vyperFilesStrict: %O", vyperFilesStrict);

    // no vyper targets found, no need to check Vyper
    if (vyperFilesStrict.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    const { allSources, compilationTargets } = await requiredSources(
      options.with({
        paths: vyperFilesStrict,
        base_path: options.contracts_directory,
        compiler: {
          name: "vyper"
          //HACK: we leave version empty because we haven't determined
          //it at this point and we don't want to pay the cost of doing
          //so, and nothing in the resolver sources currently uses
          //precise vyper version
        }
      })
    );

    debug("allSources: %O", allSources);
    debug("compilationTargets: %O", compilationTargets);
    const vyperTargets = compilationTargets.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );

    // no vyper targets found, no need to activate Vyper
    if (vyperTargets.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    //having gotten the sources from the resolver, we invoke compileJson
    //ourselves, rather than going through Compile.sources()
    Compile.display(compilationTargets, options);

    const { version, json: useJson, jsonCommand } = await checkVyper();

    if (useJson) {
      return compileJson({
        sources: allSources,
        options: options.with({
          compilationTargets
        }),
        version,
        command: jsonCommand
      });
    } else {
      return await compileNoJson({
        paths: Object.keys(allSources),
        options: options.with({
          compilationTargets
        }),
        version
      });
    }
  },

  // contracts_directory: String. Directory where contract files can be found.
  // quiet: Boolean. Suppress output. Defaults to false.
  // strict: Boolean. Return compiler warnings as errors. Defaults to false.
  async all(options) {
    options = Config.default().merge(options);
    const files = await findContracts(options.contracts_directory);

    const vyperFilesStrict = files.filter(path =>
      minimatch(path, VYPER_PATTERN_STRICT, { dot: true })
    );
    // no vyper targets found, no need to check Vyper
    if (vyperFilesStrict.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }

    return await Compile.sourcesWithDependencies({
      paths: files,
      options
    });
  },

  // contracts_directory: String. Directory where contract files can be found.
  // all: Boolean. Compile all sources found. Defaults to true. If false, will compare sources against built files
  //      in the build directory to see what needs to be compiled.
  // quiet: Boolean. Suppress output. Defaults to false.
  // strict: Boolean. Return compiler warnings as errors. Defaults to false.
  async necessary(options) {
    options = Config.default().merge(options);

    const profiler = await new Profiler({});
    const updated = await profiler.updated(options);
    if (updated.length === 0) {
      return Compilations.emptyWorkflowCompileResult();
    }
    return await Compile.sourcesWithDependencies({
      paths: updated,
      options
    });
  },

  async display(paths, options) {
    if (options.quiet !== true) {
      if (!Array.isArray(paths)) {
        paths = Object.keys(paths);
      }

      const sourceFileNames = paths.sort().map(contract => {
        if (path.isAbsolute(contract)) {
          return `.${path.sep}${path.relative(
            options.working_directory,
            contract
          )}`;
        }

        return contract;
      });
      options.events.emit("compile:sourcesToCompile", { sourceFileNames });
    }
  }
};

module.exports = {
  Compile
};


/***/ }),

/***/ 87359:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("compile-vyper:parser");
const OS = __webpack_require__(22037);

function parseImports(body) {
  // WARNING: We're going to do this crudely with regexes!!
  //
  // Vyper has a rigid enough syntax that I think this is workable.
  //
  // We can't use the Solidity approach here of analyzing error messages
  // because the Vyper compiler will only provide an error for the *first*
  // failing import, not all of them.

  // (before we do all that, though, we'll try parsing as JSON
  // and return no imports if it parses, in case this gets passed
  // a JSON file!)
  try {
    JSON.parse(body);
    debug("was JSON, no imports");
    return []; //if we reach this point it was a JSON file
  } catch (_) {
    //it was Vyper, proceed onward
  }

  const stripWhitespace = str => str.replace(/\s/g, ""); //remove even internal whitespace

  //HACK: this isn't actually a correct way of handling line
  //extensions and comments... but it should be good enough
  //for our purposes!  I can't think of any cases that this
  //gets wrong *in a way that we care about*

  return (
    body
      .replace(/(#.*)\\\r?\n/g, "$1") //remove backslashes from end of comments
      // (this is the most-incorrect step; it will detect a "comment" even if
      // the # is used in a string literal.  but this shouldn't screw up imports,
      // so...)
      .replace(/\\\r?\n/g, " ") //process line extensions;
      //for convenience we use \r?\n instead of OS.EOL
      //(we don't care that this screws up string literals)
      .split(OS.EOL) //split body into lines
      .map(line => {
        //extract imports!
        const importRegex = /^import\b(.*?)\bas\b/;
        const fromImportRegex = /^from\b(.*?)\bimport\b(.*?)($|\bas\b)/;
        let matches;
        if ((matches = line.match(importRegex))) {
          const [_, path] = matches;
          return stripWhitespace(path);
        } else if ((matches = line.match(fromImportRegex))) {
          const [_, basePath, endPath] = matches;
          debug("basePath: %s; endPath: %s", basePath, endPath);
          const strippedBasePath = stripWhitespace(basePath);
          if (strippedBasePath === "vyper.interfaces") {
            //built-in import; we should not attempt to resolve it
            return null;
          }
          const strippedEndPath = stripWhitespace(endPath);
          return strippedBasePath.endsWith(".")
            ? `${strippedBasePath}${strippedEndPath}` //don't add extra "." for "from . import", etc
            : `${strippedBasePath}.${strippedEndPath}`;
          //on the endPath because
        } else {
          return null;
        }
      })
      .filter(moduleName => moduleName !== null)
  );
}

module.exports = {
  parseImports
};


/***/ }),

/***/ 53377:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("compile-vyper:profiler");
const { Profiler } = __webpack_require__(76273);
const { Resolver } = __webpack_require__(48511);
const { parseImports } = __webpack_require__(87359);

// Returns the minimal set of sources to pass to vyper-json as compilations targets,
// as well as the complete set of sources so vyper-json can resolve the comp targets' imports.
async function requiredSources(options) {
  const resolver = new Resolver(options);

  debug("resolver.sources.length: %d", resolver.sources.length);

  // generate profiler
  const profiler = new Profiler({
    parseImports,
    shouldIncludePath
  });

  // invoke profiler
  debug("invoking profiler");
  return await profiler.requiredSources(options.with({ resolver }));
}

function shouldIncludePath(path) {
  return path.match(/\.(vy|json|v\.py|vyper\.py)$/) !== null;
}

module.exports = {
  requiredSources
};


/***/ }),

/***/ 13919:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("compile-vyper:vyper-json");
const execSync = (__webpack_require__(32081).execSync);
const path = __webpack_require__(71017);
const semver = __webpack_require__(81249);
const Common = __webpack_require__(29833);
const partition = __webpack_require__(43174);

//NOTE: this file has a fair bit of copypaste-with-modifications
//from compile-solidity/run.js, so be warned...
//(some has since been factored into compile-common, but not all)

function compileJson({ sources: rawSources, options, version, command }) {
  const compiler = { name: "vyper", version };

  //in order to better support absolute Vyper imports, we pretend that
  //the contracts directory is the root directory.  note this means that
  //if an imported source from somewhere other than FS uses an absolute
  //import to refer to its own project root, it won't work.  But, oh well.
  const { sources, targets, originalSourcePaths } =
    Common.Sources.collectSources(
      rawSources,
      options.compilationTargets,
      options.contracts_directory
    );

  //Vyper complains if we give it a source that is not also a target,
  //*unless* we give it as an interface.  So we have to split that out.
  //(JSON files also must always be interfaces)
  const [properSourcePaths, interfacePaths] = partition(
    Object.keys(sources),
    targets.length > 0
      ? sourcePath =>
          !sourcePath.endsWith(".json") && targets.includes(sourcePath)
      : sourcePath => !sourcePath.endsWith(".json")
  );

  const properSources = Object.assign(
    {},
    ...properSourcePaths.map(sourcePath => ({
      [sourcePath]: sources[sourcePath]
    }))
  );

  const interfaces = Object.assign(
    {},
    ...interfacePaths.map(sourcePath => ({
      [sourcePath]: sources[sourcePath]
    }))
  );

  // construct compiler input
  const compilerInput = prepareCompilerInput({
    sources: properSources,
    interfaces,
    settings: options.compilers.vyper.settings || {},
    version
  });

  // perform compilation
  const rawCompilerOutput = invokeCompiler({
    compilerInput,
    command
  });
  debug("rawCompilerOutput: %O", rawCompilerOutput);

  // handle warnings as errors if options.strict
  // log if not options.quiet
  const { warnings, errors } = detectErrors({
    compilerOutput: rawCompilerOutput,
    options
  });
  if (warnings.length > 0) {
    options.events.emit("compile:warnings", { warnings });
  }

  if (errors.length > 0) {
    if (!options.quiet) {
      options.logger.log("");
    }

    throw new Common.Errors.CompileError(errors);
  }

  const compilerOutput = correctPaths(rawCompilerOutput);

  const outputSources = processAllSources({
    sources,
    compilerOutput,
    originalSourcePaths
  });
  const sourceIndexes = outputSources.map(source => source.sourcePath);
  const compilation = {
    sourceIndexes,
    contracts: processContracts({
      sources,
      compilerOutput,
      version,
      originalSourcePaths
    }),
    sources: outputSources,
    compiler
  };

  return Common.Compilations.promoteCompileResult({
    compilations: [compilation]
  });
}

function invokeCompiler({ compilerInput, command }) {
  const inputString = JSON.stringify(compilerInput);
  const outputString = execVyperJson(inputString, command);
  return JSON.parse(outputString);
}

function execVyperJson(inputString, command) {
  return execSync(command, {
    input: inputString,
    maxBuffer: 1024 * 1024 * 10 //I guess?? copied from compile-solidity
  });
}

function prepareCompilerInput({ sources, settings, interfaces, version }) {
  const outputSelection = prepareOutputSelection({ version });
  return {
    language: "Vyper",
    sources: prepareSources({ sources }),
    interfaces: prepareInterfaces({ interfaces }),
    settings: {
      ...settings,
      outputSelection
    },
    //older versions of vyper require outputSelection *outside* of settings.
    //we'll put it in both places for compatibility.
    outputSelection
  };
}

function prepareSources({ sources }) {
  return Object.entries(sources)
    .map(([sourcePath, content]) => ({ [sourcePath]: { content } }))
    .reduce((a, b) => Object.assign({}, a, b), {});
}

function prepareInterfaces({ interfaces }) {
  return Object.entries(interfaces)
    .map(([sourcePath, content]) =>
      sourcePath.endsWith(".json") //for JSON we need the ABI *object*, not JSON!
        ? { [sourcePath]: { abi: JSON.parse(content) } }
        : { [sourcePath]: { content } }
    )
    .reduce((a, b) => Object.assign({}, a, b), {});
}

function prepareOutputSelection({ version }) {
  //Vyper uses a simpler output selection format
  //than solc does; it also supports solc's format,
  //but I've gone with the simpler version here
  let defaultSelectors = [
    "abi",
    "ast",
    "evm.bytecode.object",
    //we have to omit sourceMap here, as annoyingly,
    //Vyper errors if you give it a not-yet-supported output selection...
    "evm.deployedBytecode.object",
    "evm.deployedBytecode.sourceMap"
  ];
  if (
    semver.satisfies(version, ">=0.1.0-beta.17", {
      loose: true,
      includePrerelase: true
    })
  ) {
    //again, due to Vyper erroring if you ask for output it doesn't know about,
    //we have to only add these to the output if we're on a sufficiently recent
    //version
    const additionalSelectors = ["userdoc", "devdoc"];
    defaultSelectors = defaultSelectors.concat(additionalSelectors);
  }

  //because we've already filtered down the sources to match the targets,
  //we can just say that the targets are everything
  return {
    "*": defaultSelectors
  };
}

//this also is copy-pasted, but minus some complications
function detectErrors({ compilerOutput: { errors: outputErrors }, options }) {
  outputErrors = outputErrors || [];
  const rawErrors = options.strict
    ? outputErrors
    : outputErrors.filter(({ severity }) => severity !== "warning");

  const rawWarnings = options.strict
    ? [] // none of those in strict mode
    : outputErrors.filter(({ severity }) => severity === "warning");

  // extract messages
  // NOTE: sufficiently old Vyper versions don't have formattedMessage, so we use message
  // instead in those cases
  let errors = rawErrors
    .map(({ formattedMessage, message }) => formattedMessage || message)
    .join();
  const warnings = rawWarnings.map(
    ({ formattedMessage, message }) => formattedMessage || message
  );

  return { warnings, errors };
}

//warning: copypaste
function processAllSources({ sources, compilerOutput, originalSourcePaths }) {
  if (!compilerOutput.sources) return [];
  let outputSources = [];
  for (const [sourcePath, { id, ast }] of Object.entries(
    compilerOutput.sources
  )) {
    outputSources[id] = {
      sourcePath: originalSourcePaths[sourcePath],
      contents: sources[sourcePath],
      ast,
      language: "Vyper"
    };
  }
  return outputSources;
}

function processContracts({
  compilerOutput,
  sources,
  version,
  originalSourcePaths
}) {
  if (!compilerOutput.contracts) return [];
  return (
    Object.entries(compilerOutput.contracts)
      // map to [[{ source, contractName, contract }]]
      .map(([sourcePath, sourceContracts]) =>
        Object.entries(sourceContracts).map(([contractName, contract]) => ({
          // if extension is .py, remove second extension from contract name (HACK)
          contractName:
            path.extname(sourcePath) !== ".py"
              ? contractName
              : path.basename(contractName, path.extname(contractName)),
          contract,
          source: {
            ast: compilerOutput.sources[sourcePath].ast,
            contents: sources[sourcePath],
            sourcePath
          }
        }))
      )
      // and flatten
      .reduce((a, b) => [...a, ...b], [])

      // All source will have a key, but only the compiled source will have
      // the evm output.
      .filter(({ contract: { evm } }) => Object.keys(evm).length > 0)

      // convert to output format
      .map(
        ({
          contractName,
          contract: {
            evm: {
              bytecode: { object: bytecode },
              deployedBytecode: {
                sourceMap: deployedSourceMap,
                object: deployedBytecode
              }
            },
            abi,
            devdoc,
            userdoc
          },
          source: { ast, sourcePath: transformedSourcePath, contents: source }
        }) => ({
          contractName,
          abi,
          devdoc,
          userdoc,
          sourcePath: originalSourcePaths[transformedSourcePath],
          source,
          deployedSourceMap,
          ast,
          bytecode: {
            bytes: bytecode.slice(2), //Vyper uses a "0x" prefix
            linkReferences: [] //no libraries in Vyper
          },
          deployedBytecode: {
            bytes: deployedBytecode.slice(2), //Vyper uses a "0x" prefix
            linkReferences: [] //no libraries in Vyper
          },
          compiler: {
            name: "vyper",
            version
          }
        })
      )
  );
}

function correctPaths(compilerOutput) {
  return {
    compiler: compilerOutput.compiler,
    errors: compilerOutput.errors,
    sources: fixKeys(compilerOutput.sources),
    contracts: fixKeys(compilerOutput.contracts)
  };
}

function fixKeys(pathKeyedObject) {
  return Object.assign(
    {},
    ...Object.entries(pathKeyedObject).map(([key, value]) => ({
      [fixPath(key)]: value
    }))
  );
}

function fixPath(path) {
  if (path[0] === "/") {
    return path;
  } else {
    return "/" + path;
  }
}

module.exports = {
  compileJson,
  execVyperJson
};


/***/ }),

/***/ 76775:
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = 76775;
module.exports = webpackEmptyContext;

/***/ }),

/***/ 96524:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardMessageBus = void 0;
const events_1 = __webpack_require__(82361);
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const utils_1 = __webpack_require__(44794);
const util_1 = __webpack_require__(73837);
class DashboardMessageBus extends events_1.EventEmitter {
    constructor(publishPort, subscribePort, host = "localhost") {
        super();
        this.publishPort = publishPort;
        this.subscribePort = subscribePort;
        this.host = host;
        this.publishers = [];
        this.subscribers = [];
        this.unfulfilledRequests = new Map([]);
        this.resetReadyState();
    }
    /**
     * Start the DashboardMessageBus
     * @dev This starts separate websocket servers for subscribers/publishers
     */
    start() {
        return __awaiter(this, void 0, void 0, function* () {
            this.subscribeServer = yield (0, utils_1.startWebSocketServer)({
                host: this.host,
                port: this.subscribePort
            });
            this.subscribeServer.on("connection", (newSubscriber) => {
                newSubscriber.once("close", () => {
                    this.removeSubscriber(newSubscriber);
                });
                // Require the subscriber to send a message *first* before being added
                newSubscriber.once("message", () => this.addSubscriber(newSubscriber));
            });
            this.publishServer = yield (0, utils_1.startWebSocketServer)({
                host: this.host,
                port: this.publishPort
            });
            this.publishServer.on("connection", (newPublisher) => {
                newPublisher.once("close", () => {
                    this.removePublisher(newPublisher);
                });
                this.addPublisher(newPublisher);
            });
        });
    }
    /**
     * A promise that resolves when the message bus is ready to process requests
     * (i.e. having any subscribers).
     */
    get ready() {
        return this.readyPromise;
    }
    /**
     * Close both websocket servers
     * @dev Emits a "terminate" event
     */
    terminate() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, util_1.promisify)(this.publishServer.close.bind(this.publishServer))();
            yield (0, util_1.promisify)(this.subscribeServer.close.bind(this.subscribeServer))();
            this.emit("terminate");
        });
    }
    /**
     * Process a message `data` coming from `publisher` by sending it to `subscribers`
     * and return the first received response to the `publisher`
     */
    processRequest(publisher, data, subscribers) {
        return __awaiter(this, void 0, void 0, function* () {
            // convert to string for uniformity since WebSocket.Data can take other forms
            if (typeof data !== "string") {
                data = data.toString();
            }
            yield this.ready;
            this.unfulfilledRequests.set(data, { publisher, data });
            const message = (0, dashboard_message_bus_common_1.base64ToJson)(data);
            try {
                this.logToPublishers(`Sending message to ${subscribers.length} subscribers`, "requests");
                this.logToPublishers(message, "requests");
                const response = yield (0, utils_1.broadcastAndAwaitFirst)(subscribers, message);
                this.logToPublishers(`Sending response for message ${message.id}`, "responses");
                this.logToPublishers(response, "responses");
                const encodedResponse = (0, dashboard_message_bus_common_1.jsonToBase64)(response);
                publisher.send(encodedResponse);
                this.unfulfilledRequests.delete(data);
                this.invalidateMessage(message.id);
            }
            catch (error) {
                this.logToPublishers(`An error occurred while processing message ${message.id}`, "errors");
                this.logToPublishers(error, "errors");
            }
        });
    }
    invalidateMessage(id) {
        const invalidationMessage = (0, dashboard_message_bus_common_1.createMessage)("invalidate", id);
        (0, utils_1.broadcastAndDisregard)(this.subscribers, invalidationMessage);
    }
    logToPublishers(logMessage, namespace) {
        this.logTo(logMessage, this.publishers, namespace);
    }
    logToSubscribers(logMessage, namespace) {
        this.logTo(logMessage, this.subscribers, namespace);
    }
    logToAll(logMessage, namespace) {
        this.logToPublishers(logMessage, namespace);
        this.logToSubscribers(logMessage, namespace);
    }
    logTo(logMessage, receivers, namespace) {
        const payload = {
            namespace: "dashboard-message-bus",
            message: logMessage
        };
        if (namespace) {
            payload.namespace += `:${namespace}`;
        }
        const message = (0, dashboard_message_bus_common_1.createMessage)("log", payload);
        (0, utils_1.broadcastAndDisregard)(receivers, message);
    }
    /**
     * Add a publisher so it can be used to send requests to
     * @dev Also sends all backlogged (unfulfilled) requests upon connection
     */
    addSubscriber(newSubscriber) {
        this.unfulfilledRequests.forEach(({ publisher, data }) => this.processRequest(publisher, data, [newSubscriber]));
        this.logToPublishers("Subscriber connected", "connections");
        this.subscribers.push(newSubscriber);
        if (this.subscribers.length == 1) {
            this.resolveReadyPromise();
        }
    }
    /**
     * Remove a subscriber
     * @dev Will cause the server to terminate if this was the last connection
     */
    removeSubscriber(subscriberToRemove) {
        this.logToPublishers("Subscriber disconnected", "connections");
        this.subscribers = this.subscribers.filter(subscriber => subscriber !== subscriberToRemove);
        if (this.subscribers.length === 0) {
            this.resetReadyState();
        }
        this.terminateIfNoConnections();
    }
    /**
     * Add a publisher and set up message listeners to process their requests
     */
    addPublisher(newPublisher) {
        this.logToPublishers("Publisher connected", "connections");
        newPublisher.on("message", (data) => {
            this.processRequest(newPublisher, data, this.subscribers);
        });
        this.publishers.push(newPublisher);
    }
    /**
     * Remove a publisher and their corresponding requests
     * @dev Will cause the server to terminate if this was the last connection
     */
    removePublisher(publisherToRemove) {
        this.logToPublishers("Publisher disconnected", "connections");
        this.publishers = this.publishers.filter(publisher => publisher !== publisherToRemove);
        this.clearRequestsForPublisher(publisherToRemove);
        this.terminateIfNoConnections();
    }
    terminateIfNoConnections() {
        if (this.publishers.length === 0 && this.subscribers.length === 0) {
            this.terminate();
        }
    }
    clearRequestsForPublisher(publisher) {
        this.unfulfilledRequests.forEach(({ publisher: requestPublisher }, key) => {
            if (requestPublisher === publisher) {
                this.unfulfilledRequests.delete(key);
            }
        });
    }
    resetReadyState() {
        this.readyPromise = new Promise((resolve => {
            this.resolveReadyPromise = resolve;
        }).bind(this));
    }
}
exports.DashboardMessageBus = DashboardMessageBus;
//# sourceMappingURL=DashboardMessageBus.js.map

/***/ }),

/***/ 37108:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(96524), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 44794:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.sendAndAwait = exports.broadcastAndAwaitFirst = exports.broadcastAndDisregard = exports.startWebSocketServer = void 0;
const isomorphic_ws_1 = __importDefault(__webpack_require__(47030));
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const promise_any_1 = __importDefault(__webpack_require__(25795));
promise_any_1.default.shim();
/**
 * Starts a websocket server and waits for it to be opened
 * @dev If you need to attach event listeners *before* the server connection opens,
 * do not use this function since it resolves *after* the connection is opened
 */
const startWebSocketServer = (options) => {
    return new Promise(resolve => {
        const server = new isomorphic_ws_1.default.Server(options, () => {
            resolve(server);
        });
    });
};
exports.startWebSocketServer = startWebSocketServer;
/**
 * Broadcast a message to multiple websocket connections and disregard them
 */
const broadcastAndDisregard = (sockets, message) => {
    const encodedMessage = (0, dashboard_message_bus_common_1.jsonToBase64)(message);
    sockets.forEach(socket => {
        socket.send(encodedMessage);
    });
};
exports.broadcastAndDisregard = broadcastAndDisregard;
/**
 * Broadcast a message to multuple websocket connections and return the first response
 */
const broadcastAndAwaitFirst = (sockets, message) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = sockets.map(socket => (0, exports.sendAndAwait)(socket, message));
    const result = yield Promise.any(promises);
    return result;
});
exports.broadcastAndAwaitFirst = broadcastAndAwaitFirst;
/**
 * Send a message to a websocket connection and await a matching response
 * @dev Responses are matched by looking at received messages that match the ID of the sent message
 */
const sendAndAwait = (socket, message) => {
    return new Promise((resolve, reject) => {
        socket.addEventListener("message", (event) => {
            if (typeof event.data !== "string") {
                event.data = event.data.toString();
            }
            const response = (0, dashboard_message_bus_common_1.base64ToJson)(event.data);
            if (response.id !== message.id)
                return;
            resolve(response);
        });
        // TODO: Need to check that the error corresponds to the sent message?
        socket.addEventListener("error", (event) => {
            reject(event.error);
        });
        socket.addEventListener("close", (event) => {
            reject(new Error(`Socket connection closed with code '${event.code}' and reason '${event.reason}'`));
        });
        const encodedMessage = (0, dashboard_message_bus_common_1.jsonToBase64)(message);
        socket.send(encodedMessage);
    });
};
exports.sendAndAwait = sendAndAwait;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 66205:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardServer = void 0;
const express_1 = __importDefault(__webpack_require__(99268));
const path_1 = __importDefault(__webpack_require__(71017));
const get_port_1 = __importDefault(__webpack_require__(15959));
const open_1 = __importDefault(__webpack_require__(78318));
const uuid_1 = __webpack_require__(88882);
const fetch_and_compile_1 = __webpack_require__(5523);
const object_hash_1 = __webpack_require__(49807);
const config_1 = __importDefault(__webpack_require__(20553));
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const dashboard_message_bus_1 = __webpack_require__(37108);
const dashboard_message_bus_client_1 = __webpack_require__(19602);
const cors_1 = __importDefault(__webpack_require__(17846));
const debug_1 = __importDefault(__webpack_require__(15158));
class DashboardServer {
    get subscribePort() {
        var _a;
        return (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.subscribePort;
    }
    get publishPort() {
        var _a;
        return (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.subscribePort;
    }
    constructor(options) {
        var _a, _b, _c, _d;
        this.host = (_a = options.host) !== null && _a !== void 0 ? _a : "localhost";
        this.port = options.port;
        this.configPublishPort = options.publishPort;
        this.configSubscribePort = options.subscribePort;
        this.rpc = (_b = options.rpc) !== null && _b !== void 0 ? _b : true;
        this.verbose = (_c = options.verbose) !== null && _c !== void 0 ? _c : false;
        this.autoOpen = (_d = options.autoOpen) !== null && _d !== void 0 ? _d : true;
        this.frontendPath = path_1.default.join(__dirname, "dashboard-frontend");
        this.boundTerminateListener = () => this.stop();
    }
    start() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if ((_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.listening) {
                return;
            }
            this.messageBus = yield this.startMessageBus();
            this.expressApp = (0, express_1.default)();
            this.expressApp.use((0, cors_1.default)());
            this.expressApp.use(express_1.default.json());
            this.expressApp.get("/ports", this.getPorts.bind(this));
            if (this.rpc) {
                yield this.connectToMessageBus();
                this.expressApp.post("/rpc", this.postRpc.bind(this));
            }
            this.expressApp.get("/fetch-and-compile", (req, res) => __awaiter(this, void 0, void 0, function* () {
                const { address, networkId, etherscanApiKey } = req.query;
                let config;
                try {
                    config = config_1.default.detect();
                    // we'll ignore errors as we only get the config for the api key
                }
                catch (_b) { }
                // a key provided in the browser takes precedence over on in the config
                let etherscanKey;
                if (etherscanApiKey) {
                    etherscanKey = etherscanApiKey;
                }
                else if (config && config.etherscan !== undefined) {
                    etherscanKey = config.etherscan.apiKey;
                }
                config = config_1.default.default().merge({
                    networks: {
                        custom: { network_id: networkId }
                    },
                    network: "custom",
                    etherscan: {
                        apiKey: etherscanKey
                    }
                });
                let result;
                try {
                    result = (yield (0, fetch_and_compile_1.fetchAndCompile)(address, config)).compileResult;
                }
                catch (error) {
                    if (!error.message.includes("No verified sources")) {
                        throw error;
                    }
                }
                if (result) {
                    // we calculate hashes on the server because it is at times too
                    // resource intensive for the browser and causes it to crash
                    const hashes = result.compilations.map((compilation) => {
                        return (0, object_hash_1.sha1)(compilation);
                    });
                    res.json({
                        hashes,
                        compilations: result.compilations
                    });
                }
                else {
                    res.json({ compilations: [] });
                }
            }));
            this.expressApp.get("/analytics", (_req, res) => {
                const userConfig = config_1.default.getUserConfig();
                res.json({
                    enableAnalytics: userConfig.get("enableAnalytics"),
                    analyticsSet: userConfig.get("analyticsSet"),
                    analyticsMessageDateTime: userConfig.get("analyticsMessageDateTime")
                });
            });
            this.expressApp.put("/analytics", (req, _res) => {
                const { value } = req.body;
                const userConfig = config_1.default.getUserConfig();
                const uid = userConfig.get("uniqueId");
                if (!uid)
                    userConfig.set("uniqueId", (0, uuid_1.v4)());
                userConfig.set({
                    enableAnalytics: !!value,
                    analyticsSet: true,
                    analyticsMessageDateTime: Date.now()
                });
            });
            this.expressApp.use(express_1.default.static(this.frontendPath));
            this.expressApp.get("*", (_req, res) => {
                res.sendFile("index.html", { root: this.frontendPath });
            });
            yield new Promise(resolve => {
                this.httpServer = this.expressApp.listen(this.port, this.host, () => {
                    if (this.autoOpen) {
                        const host = this.host === "0.0.0.0" ? "localhost" : this.host;
                        (0, open_1.default)(`http://${host}:${this.port}`);
                    }
                    resolve();
                });
            });
        });
    }
    stop() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            (_a = this.messageBus) === null || _a === void 0 ? void 0 : _a.off("terminate", this.boundTerminateListener);
            yield Promise.all([
                (_b = this.client) === null || _b === void 0 ? void 0 : _b.close(),
                (_c = this.messageBus) === null || _c === void 0 ? void 0 : _c.terminate(),
                new Promise(resolve => {
                    var _a;
                    (_a = this.httpServer) === null || _a === void 0 ? void 0 : _a.close(() => resolve());
                })
            ]);
            delete this.client;
        });
    }
    getPorts(req, res) {
        if (!this.messageBus) {
            throw new Error("Message bus has not been started yet");
        }
        res.json({
            dashboardPort: this.port,
            subscribePort: this.messageBus.subscribePort,
            publishPort: this.messageBus.publishPort
        });
    }
    postRpc(req, res, next) {
        if (!this.client) {
            throw new Error("Not connected to message bus");
        }
        this.client
            .publish({ type: dashboard_message_bus_common_1.dashboardProviderMessageType, payload: req.body })
            .then(lifecycle => lifecycle.response)
            .then(response => res.json(response === null || response === void 0 ? void 0 : response.payload))
            .catch(next);
    }
    startMessageBus() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const subscribePort = (_a = this.configSubscribePort) !== null && _a !== void 0 ? _a : (yield (0, get_port_1.default)({ host: this.host }));
            const publishPort = (_b = this.configPublishPort) !== null && _b !== void 0 ? _b : (yield (0, get_port_1.default)({ host: this.host }));
            const messageBus = new dashboard_message_bus_1.DashboardMessageBus(publishPort, subscribePort, this.host);
            yield messageBus.start();
            messageBus.on("terminate", this.boundTerminateListener);
            return messageBus;
        });
    }
    connectToMessageBus() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.messageBus) {
                throw new Error("Message bus has not been started yet");
            }
            if (this.client) {
                return;
            }
            this.client = new dashboard_message_bus_client_1.DashboardMessageBusClient({
                host: this.host,
                subscribePort: this.messageBus.subscribePort,
                publishPort: this.messageBus.publishPort
            });
            yield this.client.ready();
            // the promise returned by `setupVerboseLogging` never resolves, so don't
            // bother awaiting it.
            this.setupVerboseLogging();
        });
    }
    setupVerboseLogging() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.verbose && this.client) {
                this.client
                    .subscribe({ type: dashboard_message_bus_common_1.logMessageType })
                    .on("message", lifecycle => {
                    if (lifecycle && lifecycle.message.type === "log") {
                        const logMessage = lifecycle.message;
                        const debug = (0, debug_1.default)(logMessage.payload.namespace);
                        debug.enabled = true;
                        debug(logMessage.payload.message);
                    }
                });
            }
        });
    }
}
exports.DashboardServer = DashboardServer;
//# sourceMappingURL=DashboardServer.js.map

/***/ }),

/***/ 97722:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(66205), exports);
__exportStar(__webpack_require__(32550), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 32550:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.startDashboardInBackground = void 0;
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const child_process_1 = __webpack_require__(32081);
const path_1 = __importDefault(__webpack_require__(71017));
const startDashboardInBackground = (options) => {
    const dashboardPath = path_1.default.join(__dirname, "..", "bin", "start-dashboard");
    const optionsBase64 = (0, dashboard_message_bus_common_1.jsonToBase64)(options);
    const child = (0, child_process_1.spawn)("node", [dashboardPath, optionsBase64], {
        detached: true,
        stdio: "ignore"
    });
    return child;
};
exports.startDashboardInBackground = startDashboardInBackground;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 96412:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const debug = __webpack_require__(15158)("external-compile");
const { exec, execSync } = __webpack_require__(32081);
const resolve = (__webpack_require__(71017).resolve);
const { promisify } = __webpack_require__(73837);
const glob = promisify(__webpack_require__(12884));
const fs = __webpack_require__(57147);
const expect = __webpack_require__(14096);
const Schema = __webpack_require__(67078);
const web3Utils = __webpack_require__(18269);
const { Shims, Compilations } = __webpack_require__(29833);
const Config = __webpack_require__(20553);

const DEFAULT_ABI = [
  {
    payable: true,
    stateMutability: "payable",
    type: "fallback"
  }
];

/**
 * buffer a line of data, yielding each full line
 *
 * returned generator alternates between two states:
 * 1. reset
 * 2. read/write
 *
 * usage:
 *
 *   let gen = bufferLines();
 *
 *   // first reset
 *   gen.next(); // reset
 *
 *   // pass string data with zero or more new lines
 *   // or pass `null` to signal EOF
 *   let { value, done } = gen.next(data);
 *
 *   // if done, value possibly contains string value with unterminated output
 *   // otherwise, value contains any/all complete lines
 */
function* bufferLines() {
  let buffer = [];

  while (true) {
    // read input string or null as eof
    const input = yield;

    // eof returns buffer
    if (input == null) {
      const unterminated = buffer.join("");

      return unterminated ? [`${unterminated}%`] : [];
    }

    // split lines
    // last element is always partial line
    const data = input.split("\n");

    // add first element to buffer
    let [first] = data.slice(0);
    buffer.push(first);

    if (data.length > 1) {
      // split off partial line to save as new buffer
      const [last] = data.slice(-1);
      const [...middle] = data.slice(1, -1);

      // use buffer as first element (now complete line)
      // and yield all complete lines
      const lines = [buffer.join(""), ...middle];
      yield lines;

      // reset buffer
      buffer = [last];
    } else {
      // nothing to see yet
      yield [];
    }
  }
}

/**
 * run a command, forwarding data to arbitrary logger.
 * invokes callback when process exits, error on nonzero exit code.
 */
const runCommand = promisify(function (command, options, callback) {
  const { cwd, logger, input } = options;
  const child = exec(command, { cwd, input });

  // wrap buffer generator for easy use
  const buffer = func => {
    const gen = bufferLines();

    return data => {
      gen.next();

      let { value: lines } = gen.next(data);
      for (let line of lines) {
        func(line);
      }
    };
  };

  const log = buffer(logger.log);
  const warn = buffer(logger.warn || logger.log);

  child.stdout.on("data", data => log(data.toString()));
  child.stderr.on("data", data => warn(data.toString()));

  child.on("close", function (code) {
    // close streams to flush unterminated lines
    log(null);
    warn(null);

    // If the command didn't exit properly, show the output and throw.
    if (code !== 0) {
      var err = new Error("Unknown exit code: " + code);
      return callback(err);
    }

    callback();
  });
});

/**
 * identify and process contents as one of:
 * 1. JSON literal
 * 2. Hex string
 * 3. Raw binary data
 */
function decodeContents(contents) {
  // JSON
  try {
    return JSON.parse(contents);
  } catch (e) {
    /* no-op */
  }

  // hex string
  if (contents.toString().startsWith("0x")) {
    return contents.toString();
  }

  // raw binary
  return web3Utils.bytesToHex(contents);
}

async function processTargets(targets, cwd, logger) {
  const contracts = [];
  for (let target of targets) {
    let targetContracts = await processTarget(target, cwd, logger);
    for (let contract of Object.values(targetContracts)) {
      contracts.push(Schema.validate(contract));
    }
  }

  return contracts;
}

async function processTarget(target, cwd, logger) {
  const usesPath = target.path != undefined;
  const usesCommand = target.command != undefined;
  const usesStdin = target.stdin || target.stdin == undefined; // default true
  const usesProperties = target.properties || target.fileProperties;

  if (usesProperties && usesPath) {
    throw new Error(
      "External compilation target cannot define both properties and path"
    );
  }

  if (usesProperties && usesCommand) {
    throw new Error(
      "External compilation target cannot define both properties and command"
    );
  }

  if (usesCommand && !usesPath) {
    // just run command
    const output = execSync(target.command, { cwd });
    const contract = JSON.parse(output);
    return { [contract.contractName]: contract };
  }

  if (usesPath && !glob.hasMagic(target.path)) {
    // individual file
    const filename = resolve(cwd, target.path);
    let input, command, execOptions;
    if (usesStdin) {
      input = fs.readFileSync(filename).toString();
      command = target.command;
      execOptions = { cwd, input };
    } else {
      command = `${target.command} ${filename}`;
      execOptions = { cwd };
    }

    const output = usesCommand ? execSync(command, execOptions) : input;

    const contract = JSON.parse(output);
    return { [contract.contractName]: contract };
  }

  if (usesPath && glob.hasMagic(target.path)) {
    // glob expression, recurse after expansion
    let paths = await glob(target.path, { cwd, follow: true });
    // copy target properties, overriding path with expanded form
    let targets = paths.map(path => Object.assign({}, target, { path }));
    return await processTargets(targets, cwd, logger);
  }

  if (usesProperties) {
    // contract properties listed individually
    const contract = Object.assign({}, target.properties || {});

    for (let [key, path] of Object.entries(target.fileProperties || {})) {
      const contents = fs.readFileSync(resolve(cwd, path));
      const value = decodeContents(contents);

      contract[key] = value;
    }

    if (!contract.contractName) {
      throw new Error("External compilation target must specify contractName");
    }

    if (!contract.abi) {
      contract.abi = DEFAULT_ABI;
    }

    if (!contract.bytecode && logger) {
      logger.log(
        "Warning: contract " +
          contract.contractName +
          " does not specify bytecode. You won't be able to deploy it."
      );
    }

    return { [contract.contractName]: contract };
  }
}

const Compile = {
  async all(options) {
    return await Compile.sources({
      // currently you cannot specify sources here
      sources: undefined,
      options
    });
  },

  async necessary(options) {
    return await Compile.sources({
      // currently you cannot specify sources here
      sources: undefined,
      options
    });
  },

  // compile-common defines object argument to include `sources`, but this is
  // unused as the user is responsible for dealing with compiling their sources
  async sources({ options }) {
    options = Config.default().merge(options);
    if (options.logger == null) {
      options.logger = console;
    }

    expect.options(options, ["compilers"]);
    expect.options(options.compilers, ["external"]);
    expect.options(options.compilers.external, ["command", "targets"]);

    const { command, targets } = options.compilers.external;
    const cwd =
      options.compilers.external.workingDirectory ||
      options.compilers.external.working_directory || // just in case
      options.working_directory;
    const logger = options.logger;

    debug("running compile command: %s", command);
    await runCommand(command, { cwd, logger });

    const contracts = await processTargets(targets, cwd, logger);
    const compilations = [
      {
        contracts: contracts.map(Shims.LegacyToNew.forContract),
        // sourceIndexes is empty because we have no way of
        // knowing for certain the source paths for the contracts
        sourceIndexes: [],
        // since we don't know the sourcePaths, we can't really provide
        // the source info reliably
        sources: [],
        compiler: {
          name: "external",
          version: undefined
        }
      }
    ];
    return Compilations.promoteCompileResult({ compilations });
  },

  async sourcesWithDependencies({ options }) {
    return await Compile.sources({ options });
  }
};

module.exports = {
  Compile,
  DEFAULT_ABI,
  processTarget
};


/***/ }),

/***/ 32007:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncompatibleHardhatBuildInfoFormatError = exports.prepareCompilations = exports.prepareConfig = exports.IncompatibleHardhatVersionError = exports.NotHardhatError = exports.expectHardhat = void 0;
const fs_1 = __webpack_require__(57147);
const semver_1 = __importDefault(__webpack_require__(81249));
const constants_1 = __webpack_require__(65716);
const Compilation = __importStar(__webpack_require__(20897));
const Config = __importStar(__webpack_require__(35783));
const ask_hardhat_1 = __webpack_require__(21700);
/**
 * Checks for the existence of a Hardhat project configuration and asserts
 * that the local installed version of Hardhat matches this package's
 * supported version range.
 *
 * @param options to control process environment (e.g. working directory)
 * @return Promise<void> when expectation holds
 * @throws NotHardhatError when not in a Hardhat project directory
 * @throws IncompatibleHardhatError if Hardhat has unsupported version
 */
const expectHardhat = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const isHardhat = yield (0, ask_hardhat_1.checkHardhat)(options);
    if (!isHardhat) {
        throw new NotHardhatError();
    }
    const hardhatVersion = yield (0, ask_hardhat_1.askHardhatVersion)(options);
    if (!semver_1.default.satisfies(hardhatVersion, constants_1.supportedHardhatVersionRange)) {
        throw new IncompatibleHardhatVersionError(hardhatVersion);
    }
});
exports.expectHardhat = expectHardhat;
/**
 * Thrown when no Hardhat project is found
 */
class NotHardhatError extends Error {
    constructor() {
        super("Current working directory is not part of a Hardhat project");
    }
}
exports.NotHardhatError = NotHardhatError;
/**
 * Thrown when Hardhat was detected but with an incompatible version
 */
class IncompatibleHardhatVersionError extends Error {
    constructor(detectedVersion) {
        super(`Expected Hardhat version compatible with ${constants_1.supportedHardhatVersionRange}, got: ${detectedVersion}`);
    }
}
exports.IncompatibleHardhatVersionError = IncompatibleHardhatVersionError;
/**
 * Constructs a @truffle/config object based on the Hardhat config.
 *
 * WARNING: except for fields documented here, the values present on the
 * returned @truffle/config object MUST be regarded as unsafe to use.
 *
 * The returned `config` is defined to contain the following:
 *
 *   - `config.networks` with configurations for all Hardhat-configured
 *     networks, provided:
 *       - The configured network is not the built-in `hardhat` network
 *       - The configured network defines a `url` property
 *
 *     Note: this function ignores all properties other than `url`,
 *     including any information that can be used for computing
 *     cryptographic signatures. THIS FUNCTION DOES NOT READ PRIVATE KEYS.
 *
 * Suffice to say:
 *
 * THIS FUNCTION'S BEHAVIOR IS EXPERIMENTAL AND SHOULD ONLY BE USED IN
 * SPECIFICALLY KNOWN-SUPPORTED USE CASES (like reading for configured
 * network urls)
 *
 * @param options to control process environment (e.g. working directory)
 * @return Promise<TruffleConfig>
 *
 * @dev This function shells out to `npx hardhat console` to ask the Hardhat
 *      runtime environment for the Hardhat config info that Truffle needs.
 */
const prepareConfig = (options) => __awaiter(void 0, void 0, void 0, function* () {
    // define a function to grab only the networks and fields we need.
    //
    // this duplicates the transformation behavior in src/config.ts for safe
    // measure, since these two components may differ in requirements in the
    // future.
    const extractNetworks = (hre) => ({
        networks: Object.entries(hre.config.networks)
            .filter((pair) => pair[0] !== "hardhat" && "url" in pair[1])
            .map(([networkName, { url }]) => ({
            [networkName]: { url }
        }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {})
    });
    const hardhatConfig = (yield (0, ask_hardhat_1.askHardhatConsole)(
    // stringify the function hooray
    `(${extractNetworks.toString()})(hre)`, options));
    return Config.fromHardhatConfig(hardhatConfig);
});
exports.prepareConfig = prepareConfig;
/**
 * Constructs an array of @truffle/compile-common `Compilation` objects
 * corresponding one-to-one with Hardhat's persisted results of each solc
 * compilation.
 *
 * WARNING: this function only supports Hardhat projects written entirely
 * in solc-compatible languages (Solidity, Yul). Behavior of this function
 * for Hardhat projects using other languages is undefined.
 *
 * @param options to control process environment (e.g. working directory)
 * @return Promise<Compilation[]> from @truffle/compile-common
 *
 * @dev This function shells out to `npx hardhat console` to ask the Hardhat
 *      runtime environment for the location of the project build info
 *      files
 */
const prepareCompilations = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const compilations = [];
    const buildInfoPaths = (yield (0, ask_hardhat_1.askHardhatConsole)(`artifacts.getBuildInfoPaths()`, options));
    for (const buildInfoPath of buildInfoPaths) {
        const buildInfo = JSON.parse((yield fs_1.promises.readFile(buildInfoPath)).toString());
        const { _format } = buildInfo;
        if (!constants_1.supportedHardhatBuildInfoFormats.has(_format)) {
            throw new IncompatibleHardhatBuildInfoFormatError(_format);
        }
        const compilation = Compilation.fromBuildInfo(buildInfo);
        compilations.push(compilation);
    }
    return compilations;
});
exports.prepareCompilations = prepareCompilations;
/**
 * Thrown when the build-info format detected has an incompatible version
 */
class IncompatibleHardhatBuildInfoFormatError extends Error {
    constructor(detectedFormat) {
        super(`Expected build-info to be one of ["${[
            ...constants_1.supportedHardhatBuildInfoFormats
        ].join('", "')}"], got: "${detectedFormat}"`);
    }
}
exports.IncompatibleHardhatBuildInfoFormatError = IncompatibleHardhatBuildInfoFormatError;
//# sourceMappingURL=api.js.map

/***/ }),

/***/ 21700:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.askHardhatConsole = exports.askHardhatVersion = exports.checkHardhat = void 0;
const child_process_1 = __webpack_require__(32081);
const find_up_1 = __importDefault(__webpack_require__(29859));
const constants_1 = __webpack_require__(65716);
const options_1 = __webpack_require__(88504);
/**
 * Returns a Promise to a boolean that is true if and only if
 * the detected or specified environment is part of a Hardhat project.
 *
 * (i.e., if the working directory or any of its parents has a Hardhat config)
 */
const checkHardhat = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { workingDirectory } = (0, options_1.withDefaultEnvironmentOptions)(options);
    // search recursively up for a hardhat config
    const hardhatConfigPath = yield (0, find_up_1.default)(constants_1.validHardhatConfigFilenames, {
        cwd: workingDirectory
    });
    return !!hardhatConfigPath;
});
exports.checkHardhat = checkHardhat;
/**
 * Reads version information via `npx hardhat --version`
 */
const askHardhatVersion = (options) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((accept, reject) => {
        const { workingDirectory } = (0, options_1.withDefaultEnvironmentOptions)(options);
        const hardhat = (0, child_process_1.spawn)(`npx`, ["hardhat", "--version"], {
            stdio: ["pipe", "pipe", "inherit"],
            cwd: workingDirectory,
            shell: true
        });
        let output = "";
        hardhat.stdout.on("data", data => {
            output = `${output}${data}`;
        });
        hardhat.once("close", code => {
            if (code !== 0) {
                return reject(new Error(`Hardhat exited with non-zero code ${code}`));
            }
            return accept(output);
        });
    });
});
exports.askHardhatVersion = askHardhatVersion;
const askHardhatConsole = (expression, _a = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var { raw = false } = _a, options = __rest(_a, ["raw"]);
    return new Promise((accept, reject) => {
        const { workingDirectory } = (0, options_1.withDefaultEnvironmentOptions)(options);
        // Latin-1 Supplemental block control codes
        const sos = String.fromCodePoint(0x0098); // start of string
        const st = String.fromCodePoint(0x009c); // string terminator
        const prefix = `${sos}truffle-start${st}`;
        const suffix = `${sos}truffle-end${st}`;
        // note the hardhat console instance is spawned with --no-compile which causes it to skip the initial (default) compilation step
        const hardhat = (0, child_process_1.spawn)(`npx`, ["hardhat", "console", "--no-compile"], {
            stdio: ["pipe", "pipe", "inherit"],
            cwd: workingDirectory,
            shell: true
        });
        // we'll capture the stdout
        let output = "";
        hardhat.stdout.on("data", data => {
            output = `${output}${data}`;
        });
        // setup close event before writing to stdin because we're sending eof
        hardhat.once("close", code => {
            if (code !== 0) {
                return reject(new Error(`Hardhat exited with non-zero code ${code}`));
            }
            const data = output.slice(output.indexOf(prefix) + prefix.length, output.indexOf(suffix));
            if (raw) {
                return accept(data);
            }
            try {
                const result = JSON.parse(data);
                return accept(result);
            }
            catch (error) {
                return reject(error);
            }
        });
        // write to stdin to ask for requested data. this does a few things:
        // - wrap the expression into something that resolves as a Promise.
        //   this ensures that we can handle raw synchronous expressions as well
        //   as Promise-returning expressions.
        // - write the resolved value to the console, using the prefix/suffix
        //   sentinels to ensure Truffle knows what stdout comes from this process,
        //   vs. whatever stdout Hardhat may produce on its own.
        // - unless `raw` is turned on, stringify the resolved value as JSON.
        hardhat.stdin.write(`
      Promise.resolve(${expression})
        .then(${raw
            ? `(resolved) => console.log(
                \`${prefix}$\{resolved}${suffix}\`
              )`
            : `(resolved) => console.log(
                \`${prefix}$\{JSON.stringify(resolved)}${suffix}\`
              )`})
    `);
        hardhat.stdin.end();
    });
});
exports.askHardhatConsole = askHardhatConsole;
//# sourceMappingURL=ask-hardhat.js.map

/***/ }),

/***/ 20897:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromBuildInfo = void 0;
const CompileSolidity = __importStar(__webpack_require__(4273));
const fromBuildInfo = (buildInfo) => {
    const sourceIndexes = SourceIndexes.fromBuildInfo(buildInfo);
    return {
        sourceIndexes,
        sources: Sources.fromBuildInfo(buildInfo, sourceIndexes),
        contracts: Contracts.fromBuildInfo(buildInfo),
        compiler: {
            name: "solc",
            version: buildInfo.solcLongVersion
        }
    };
};
exports.fromBuildInfo = fromBuildInfo;
var SourceIndexes;
(function (SourceIndexes) {
    SourceIndexes.fromBuildInfo = (buildInfo) => {
        const sourceIndexes = [];
        for (const { index, sourcePath } of Object.entries(buildInfo.output.sources).map(([sourcePath, source]) => ({ index: source.id, sourcePath }))) {
            sourceIndexes[index] = sourcePath;
        }
        return sourceIndexes;
    };
})(SourceIndexes || (SourceIndexes = {}));
var Sources;
(function (Sources) {
    Sources.fromBuildInfo = (buildInfo, sourceIndexes) => sourceIndexes.map(sourcePath => {
        const inputSource = buildInfo.input.sources[sourcePath];
        const outputSource = buildInfo.output.sources[sourcePath];
        return {
            sourcePath,
            contents: inputSource.content,
            ast: outputSource.ast,
            language: buildInfo.input.language
        };
    });
})(Sources || (Sources = {}));
var Contracts;
(function (Contracts) {
    Contracts.fromBuildInfo = (buildInfo) => {
        const contracts = [];
        for (const [sourcePath, sourceContracts] of Object.entries(buildInfo.output.contracts)) {
            for (const [contractName, compilerOutputContract] of Object.entries(sourceContracts)) {
                const contract = {
                    contractName,
                    sourcePath,
                    source: buildInfo.input.sources[sourcePath].content,
                    sourceMap: compilerOutputContract.evm.bytecode.sourceMap,
                    deployedSourceMap: compilerOutputContract.evm.deployedBytecode.sourceMap,
                    legacyAST: undefined,
                    ast: buildInfo.output.sources[sourcePath].ast,
                    abi: compilerOutputContract.abi,
                    metadata: compilerOutputContract.metadata,
                    bytecode: CompileSolidity.Shims.zeroLinkReferences({
                        bytes: compilerOutputContract.evm.bytecode.object,
                        linkReferences: CompileSolidity.Shims.formatLinkReferences(compilerOutputContract.evm.bytecode.linkReferences)
                    }),
                    deployedBytecode: CompileSolidity.Shims.zeroLinkReferences({
                        bytes: compilerOutputContract.evm.deployedBytecode.object,
                        linkReferences: CompileSolidity.Shims.formatLinkReferences(compilerOutputContract.evm.deployedBytecode.linkReferences)
                    }),
                    compiler: {
                        name: "solc",
                        version: buildInfo.solcLongVersion
                    },
                    devdoc: undefined,
                    userdoc: undefined,
                    immutableReferences: compilerOutputContract.evm.deployedBytecode.immutableReferences,
                    generatedSources: compilerOutputContract.evm.bytecode
                        .generatedSources,
                    deployedGeneratedSources: compilerOutputContract.evm.deployedBytecode.generatedSources
                };
                contracts.push(contract);
            }
        }
        return contracts;
    };
})(Contracts || (Contracts = {}));
//# sourceMappingURL=compilation.js.map

/***/ }),

/***/ 35783:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.fromHardhatConfig = void 0;
const config_1 = __importDefault(__webpack_require__(20553));
const fromHardhatConfig = (hardhatConfig) => {
    return config_1.default.default().merge({
        networks: Networks.fromHardhatConfig(hardhatConfig)
    });
};
exports.fromHardhatConfig = fromHardhatConfig;
var Networks;
(function (Networks) {
    Networks.fromHardhatConfig = (hardhatConfig) => Object.entries(hardhatConfig.networks)
        .flatMap(([networkName, networkConfig]) => {
        // exclude hardhat network as not supported
        if (networkName === "hardhat") {
            return [];
        }
        // only accept netowrks that specify `url`
        if (!networkConfig || !("url" in networkConfig)) {
            return [];
        }
        const { url } = networkConfig;
        return [
            {
                [networkName]: {
                    url,
                    network_id: "*"
                }
            }
        ];
    })
        .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {});
})(Networks || (Networks = {}));
//# sourceMappingURL=config.js.map

/***/ }),

/***/ 65716:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.supportedHardhatBuildInfoFormats = exports.supportedHardhatVersionRange = exports.validHardhatConfigFilenames = void 0;
exports.validHardhatConfigFilenames = [
    "hardhat.config.js",
    "hardhat.config.ts"
];
exports.supportedHardhatVersionRange = "^2.10.1";
exports.supportedHardhatBuildInfoFormats = new Set([
    "hh-sol-build-info-1"
]);
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ 36052:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.prepareCompilations = exports.prepareConfig = exports.IncompatibleHardhatBuildInfoFormatError = exports.IncompatibleHardhatVersionError = exports.NotHardhatError = exports.expectHardhat = void 0;
var api_1 = __webpack_require__(32007);
Object.defineProperty(exports, "expectHardhat", ({ enumerable: true, get: function () { return api_1.expectHardhat; } }));
Object.defineProperty(exports, "NotHardhatError", ({ enumerable: true, get: function () { return api_1.NotHardhatError; } }));
Object.defineProperty(exports, "IncompatibleHardhatVersionError", ({ enumerable: true, get: function () { return api_1.IncompatibleHardhatVersionError; } }));
Object.defineProperty(exports, "IncompatibleHardhatBuildInfoFormatError", ({ enumerable: true, get: function () { return api_1.IncompatibleHardhatBuildInfoFormatError; } }));
Object.defineProperty(exports, "prepareConfig", ({ enumerable: true, get: function () { return api_1.prepareConfig; } }));
Object.defineProperty(exports, "prepareCompilations", ({ enumerable: true, get: function () { return api_1.prepareCompilations; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 88504:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.withDefaultEnvironmentOptions = void 0;
const withDefaultEnvironmentOptions = ({ workingDirectory = process.cwd() } = {}) => ({
    workingDirectory
});
exports.withDefaultEnvironmentOptions = withDefaultEnvironmentOptions;
//# sourceMappingURL=options.js.map

/***/ }),

/***/ 75262:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.uncompressedPublicKeyToAddress = exports.createAccountGeneratorFromSeedAndPath = void 0;
const keccak_1 = __webpack_require__(95901);
const crypto_1 = __webpack_require__(6113);
const secp256k1_1 = __importDefault(__webpack_require__(7972));
const HARDENED_OFFSET = 0x80000000;
const MASTER_SECRET = Buffer.from("Bitcoin seed", "utf8");
function createAccountGeneratorFromSeedAndPath(seedBuffer, hdPath) {
    const parent = createAccountFromSeed(seedBuffer);
    const path = deriveFromPath(hdPath, parent);
    return (index) => {
        return deriveFromIndex(index, path);
    };
}
exports.createAccountGeneratorFromSeedAndPath = createAccountGeneratorFromSeedAndPath;
const uncompressedPublicKeyToAddress = (uncompressedPublicKey) => {
    const address = Buffer.from(secp256k1_1.default.publicKeyConvert(uncompressedPublicKey, false));
    // first byte is discarded
    const hash = (0, keccak_1.keccak256)(address.slice(1));
    return hash.slice(-20); // address is the last 20
};
exports.uncompressedPublicKeyToAddress = uncompressedPublicKeyToAddress;
function createAccountFromSeed(seedBuffer) {
    const I = (0, crypto_1.createHmac)("sha512", MASTER_SECRET).update(seedBuffer).digest();
    const privateKey = I.slice(0, 32);
    const chainCode = I.slice(32);
    const publicKey = makePublicKey(privateKey);
    return {
        privateKey,
        chainCode,
        publicKey
    };
}
function deriveFromPath(fullPath, child) {
    fullPath.forEach(function (c, i) {
        if (i === 0) {
            if (!/^[mM]{1}/.test(c)) {
                throw new Error('Path must start with "m" or "M"');
            }
            return;
        }
        const hardened = c.length > 1 && c[c.length - 1] === "'";
        let childIndex = parseInt(c, 10);
        if (childIndex >= HARDENED_OFFSET)
            throw new Error("Invalid index");
        if (hardened)
            childIndex += HARDENED_OFFSET;
        child = deriveChild(childIndex, hardened, child.privateKey, child.publicKey, child.chainCode);
    });
    return child;
}
function deriveFromIndex(index, child) {
    if (index >= HARDENED_OFFSET)
        throw new Error("Invalid index");
    return deriveChild(index, false, child.privateKey, child.publicKey, child.chainCode);
}
function makePublicKey(privateKey) {
    return secp256k1_1.default.publicKeyCreate(privateKey);
}
/**
 * A buffer of size 4 that can be reused as long as all changes are consumed
 * within the same event loop.
 */
const SHARED_BUFFER_4 = Buffer.allocUnsafe(4);
function deriveChild(index, isHardened, privateKey, publicKey, chainCode) {
    const indexBuffer = SHARED_BUFFER_4;
    indexBuffer.writeUInt32BE(index, 0);
    let data;
    const privateKeyLength = privateKey.length;
    if (isHardened) {
        // Hardened child
        // privateKeyLength + 1 (BUFFER_ZERO.length) + 4 (indexBuffer.length)
        const dataLength = privateKeyLength + 1 + 4;
        data = Buffer.concat([Buffer.allocUnsafe(1).fill(0), privateKey, indexBuffer], dataLength);
    }
    else {
        // Normal child
        data = Buffer.concat([publicKey, indexBuffer], publicKey.length + 4);
    }
    const I = (0, crypto_1.createHmac)("sha512", chainCode).update(data).digest();
    const IL = I.slice(0, 32);
    try {
        const privK = Buffer.allocUnsafe(privateKeyLength);
        privateKey.copy(privK, 0, 0, privateKeyLength);
        const newPrivK = secp256k1_1.default.privateKeyTweakAdd(privK, IL);
        return {
            privateKey: Buffer.from(newPrivK),
            publicKey: makePublicKey(newPrivK),
            chainCode: I.slice(32)
        };
    }
    catch (_a) {
        return deriveChild(index + 1, isHardened, privateKey, publicKey, chainCode);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 37017:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("workflow-compile");
const fs_extra_1 = __importDefault(__webpack_require__(55674));
const utils_1 = __webpack_require__(80404);
const compile_common_1 = __webpack_require__(29833);
const db_loader_1 = __webpack_require__(70972);
const SUPPORTED_COMPILERS = {
    solc: (__webpack_require__(4273).Compile),
    vyper: (__webpack_require__(74269).Compile),
    external: (__webpack_require__(96412).Compile)
};
function compile(config) {
    return __awaiter(this, void 0, void 0, function* () {
        // determine compiler(s) to use
        const compilers = config.compiler
            ? config.compiler === "none"
                ? []
                : [config.compiler]
            : Object.keys(config.compilers);
        // invoke compilers
        const rawCompilations = yield Promise.all(compilers.map((name) => __awaiter(this, void 0, void 0, function* () {
            const Compile = SUPPORTED_COMPILERS[name];
            if (!Compile)
                throw new Error("Unsupported compiler: " + name);
            if (config.all === true || config.compileAll === true) {
                return yield Compile.all(config);
            }
            else if (Array.isArray(config.paths) && config.paths.length > 0) {
                // compile only user specified sources
                return yield Compile.sourcesWithDependencies({
                    options: config,
                    paths: config.paths
                });
            }
            else {
                return yield Compile.necessary(config);
            }
        })));
        // collect results - rawCompilations is CompilerResult[]
        // flatten the array and remove compilations without results
        const compilations = rawCompilations.reduce((a, compilerResult) => {
            compilerResult.compilations.forEach((compilation) => {
                if (compilation.contracts.length > 0) {
                    a = a.concat(compilation);
                }
            });
            return a;
        }, []);
        // collect together contracts as well as compilations
        const contracts = rawCompilations.flatMap(compilerResult => compilerResult.contracts);
        // return WorkflowCompileResult
        return { contracts, compilations };
    });
}
exports["default"] = {
    compile(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = (0, utils_1.prepareConfig)(options);
            if (config.events)
                config.events.emit("compile:start");
            const { contracts, compilations } = yield compile(config);
            const compilers = compilations
                .reduce((a, compilation) => {
                return a.concat(compilation.compiler);
            }, [])
                .filter(compiler => compiler);
            if (contracts.length === 0 && config.events) {
                if (config.compileNone || config["compile-none"]) {
                    config.events.emit("compile:skipped");
                }
                else {
                    config.events.emit("compile:nothingToCompile");
                }
            }
            const result = { contracts, compilations };
            if (config.events) {
                yield config.events.emit("compile:succeed", {
                    contractsBuildDirectory: config.contracts_build_directory,
                    compilers,
                    result
                });
            }
            return result;
        });
    },
    compileAndSave(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { contracts, compilations } = yield this.compile(options);
            return yield this.save(options, { contracts, compilations });
        });
    },
    save(options, { contracts, compilations }) {
        return __awaiter(this, void 0, void 0, function* () {
            const config = (0, utils_1.prepareConfig)(options);
            yield fs_extra_1.default.ensureDir(config.contracts_build_directory);
            if (options.db && options.db.enabled === true && contracts.length > 0) {
                // currently if Truffle Db fails to load, getTruffleDb returns `null`
                const Db = (0, db_loader_1.getTruffleDb)();
                if (Db) {
                    debug("saving to @truffle/db");
                    const db = Db.connect(config.db);
                    const project = yield Db.Project.initialize({
                        db,
                        project: {
                            directory: config.working_directory
                        }
                    });
                    ({ contracts, compilations } = yield project.loadCompile({
                        result: { contracts, compilations }
                    }));
                }
            }
            const artifacts = contracts.map(compile_common_1.Shims.NewToLegacy.forContract);
            yield config.artifactor.saveAll(artifacts);
            return { contracts, compilations };
        });
    },
    assignNames(options, { contracts }) {
        return __awaiter(this, void 0, void 0, function* () {
            // currently if Truffle Db fails to load, getTruffleDb returns `null`
            const Db = (0, db_loader_1.getTruffleDb)();
            const config = (0, utils_1.prepareConfig)(options);
            if (!Db || !config.db || !config.db.enabled || contracts.length === 0) {
                return;
            }
            const db = Db.connect(config.db);
            const project = yield Db.Project.initialize({
                db,
                project: {
                    directory: config.working_directory
                }
            });
            yield project.assignNames({
                assignments: {
                    contracts: contracts.map(({ db: { contract } }) => contract)
                }
            });
        });
    }
};
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 80404:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.multiPromisify = exports.prepareConfig = void 0;
const config_1 = __importDefault(__webpack_require__(20553));
const expect = __importStar(__webpack_require__(14096));
const resolver_1 = __webpack_require__(48511);
const artifactor_1 = __importDefault(__webpack_require__(29463));
function prepareConfig(options) {
    expect.options(options, ["contracts_build_directory"]);
    expect.one(options, ["contracts_directory", "files"]);
    // Use a config object to ensure we get the default sources.
    const config = config_1.default.default().merge(options);
    config.compilersInfo = {};
    if (!config.resolver)
        config.resolver = new resolver_1.Resolver(config);
    if (!config.artifactor) {
        config.artifactor = new artifactor_1.default(config.contracts_build_directory);
    }
    return config;
}
exports.prepareConfig = prepareConfig;
function multiPromisify(func) {
    return (...args) => new Promise((accept, reject) => {
        const callback = (err, ...results) => {
            if (err)
                reject(err);
            accept(results);
        };
        func(...args, callback);
    });
}
exports.multiPromisify = multiPromisify;
//# sourceMappingURL=utils.js.map

/***/ })

};
;
//# sourceMappingURL=6031.bundled.js.map