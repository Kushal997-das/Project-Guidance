#!/usr/bin/env node

exports.id = 553;
exports.ids = [553];
exports.modules = {

/***/ 69203:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configProps = exports.getInitialConfig = void 0;
const path = __importStar(__webpack_require__(71017));
const provider_1 = __importDefault(__webpack_require__(509));
const getInitialConfig = ({ truffleDirectory, workingDirectory, network }) => {
    const truffle_directory = truffleDirectory || path.resolve(path.join(__dirname, "../"));
    const working_directory = workingDirectory || process.cwd();
    return {
        truffle_directory,
        working_directory,
        network,
        networks: {
            dashboard: {
                network_id: "*",
                networkCheckTimeout: 120000,
                url: "http://localhost:24012/rpc",
                skipDryRun: true
            }
        },
        verboseRpc: false,
        solidityLog: {
            displayPrefix: "",
            preventConsoleLogMigration: false
        },
        debugGlobal: "debug",
        gas: null,
        gasPrice: null,
        maxFeePerGas: null,
        maxPriorityFeePerGas: null,
        type: undefined,
        from: null,
        confirmations: 0,
        timeoutBlocks: 0,
        production: false,
        skipDryRun: false,
        build: null,
        resolver: null,
        artifactor: null,
        quiet: false,
        dashboard: {
            host: "localhost",
            port: 24012,
            autoOpen: true,
            verbose: false
        },
        ens: {
            enabled: false,
            registryAddress: undefined
        },
        mocha: {
            bail: false,
            grep: null
        },
        compilers: {
            solc: {
                settings: {
                    //Note: The default solc version is *not* set here!
                    //It's set in compilerSupplier/index.js in compile-solidity
                    optimizer: {
                        enabled: false,
                        runs: 200
                    },
                    remappings: []
                }
            },
            vyper: {
                settings: {}
            }
        },
        console: {
            require: null
        },
        logger: console
    };
};
exports.getInitialConfig = getInitialConfig;
const configProps = ({ configObject }) => {
    const resolveDirectory = (value) => path.resolve(configObject.working_directory, value);
    return {
        // These are already set.
        truffle_directory() { },
        working_directory() { },
        network() { },
        networks() { },
        verboseRpc() { },
        solidityLog() { },
        build() { },
        resolver() { },
        artifactor() { },
        dashboard() { },
        logger() { },
        compilers() { },
        ens() { },
        console() { },
        mocha() { },
        quiet() { },
        debugGlobal() { },
        build_directory: {
            default: () => path.join(configObject.working_directory, "build"),
            transform: resolveDirectory
        },
        contracts_directory: {
            default: () => path.join(configObject.working_directory, "contracts"),
            transform: resolveDirectory
        },
        contracts_build_directory: {
            default: () => path.join(configObject.build_directory, "contracts"),
            transform: resolveDirectory
        },
        migrations_directory: {
            default: () => path.join(configObject.working_directory, "migrations"),
            transform: resolveDirectory
        },
        migrations_file_extension_regexp() {
            return /^\.(js|ts|es6?)$/;
        },
        test_directory: {
            default: () => path.join(configObject.working_directory, "test"),
            transform: resolveDirectory
        },
        test_file_extension_regexp() {
            return /.*\.(js|ts|es|es6|jsx|sol)$/;
        },
        example_project_directory: {
            default: () => path.join(configObject.truffle_directory, "example"),
            transform: resolveDirectory
        },
        network_id: {
            get() {
                try {
                    return configObject.network_config.network_id;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Do not set config.network_id. Instead, set config.networks and then config.networks[<network name>].network_id");
            }
        },
        network_config: {
            get() {
                const network = configObject.network;
                if (network === null || network === undefined) {
                    throw new Error("Network not set. Cannot determine network to use.");
                }
                let config = configObject.networks[network];
                if (config === null || config === undefined) {
                    config = {};
                }
                if (network === "dashboard") {
                    const { host: configuredHost, port } = configObject.dashboard;
                    const host = configuredHost === "0.0.0.0" ? "localhost" : configuredHost;
                    const userOverrides = config;
                    config = Object.assign(Object.assign({ network_id: "*", networkCheckTimeout: 120000 }, userOverrides), { url: `http://${host}:${port}/rpc`, skipDryRun: true });
                }
                return config;
            },
            set() {
                throw new Error("Don't set config.network_config. Instead, set config.networks with the desired values.");
            }
        },
        from: {
            get() {
                try {
                    return configObject.network_config.from;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Don't set config.from directly. Instead, set config.networks and then config.networks[<network name>].from");
            }
        },
        gas: {
            get() {
                try {
                    return configObject.network_config.gas;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Don't set config.gas directly. Instead, set config.networks and then config.networks[<network name>].gas");
            }
        },
        gasPrice: {
            get() {
                try {
                    return configObject.network_config.gasPrice;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Don't set config.gasPrice directly. Instead, set config.networks and then config.networks[<network name>].gasPrice");
            }
        },
        maxFeePerGas: {
            get() {
                try {
                    return configObject.network_config.maxFeePerGas;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Don't set config.maxFeePerGas directly. Instead, set config.networks and then config.networks[<network name>].maxFeePerGas");
            }
        },
        maxPriorityFeePerGas: {
            get() {
                try {
                    return configObject.network_config.maxPriorityFeePerGas;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Don't set config.maxPriorityFeePerGas directly. Instead, set config.networks and then config.networks[<network name>].maxPriorityFeePerGas");
            }
        },
        type: {
            get() {
                try {
                    return configObject.network_config.type;
                }
                catch (e) {
                    return null;
                }
            },
            set() {
                throw new Error("Don't set config.type directly. Instead, set config.networks and then config.networks[<network name>].type");
            }
        },
        provider: {
            get() {
                if (!configObject.network) {
                    return null;
                }
                const options = configObject.network_config;
                options.verboseRpc = configObject.verboseRpc;
                options.events = configObject.events;
                return provider_1.default.create(options);
            },
            set() {
                throw new Error("Don't set config.provider directly. Instead, set config.networks and then set config.networks[<network name>].provider");
            }
        },
        confirmations: {
            get() {
                try {
                    return configObject.network_config.confirmations;
                }
                catch (e) {
                    return 0;
                }
            },
            set() {
                throw new Error("Don't set config.confirmations directly. Instead, set config.networks and then config.networks[<network name>].confirmations");
            }
        },
        production: {
            get() {
                try {
                    return configObject.network_config.production;
                }
                catch (e) {
                    return false;
                }
            },
            set() {
                throw new Error("Don't set config.production directly. Instead, set config.networks and then config.networks[<network name>].production");
            }
        },
        timeoutBlocks: {
            get() {
                try {
                    return configObject.network_config.timeoutBlocks;
                }
                catch (e) {
                    return 0;
                }
            },
            set() {
                throw new Error("Don't set config.timeoutBlocks directly. Instead, set config.networks and then config.networks[<network name>].timeoutBlocks");
            }
        },
        ensRegistry: {
            get() {
                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v;
                let networkConfig;
                try {
                    networkConfig = configObject.network_config;
                }
                catch (_w) {
                    //if this throws, then there's no network config, whatever
                }
                //prefer specific over generic.  if there are two specific and they conflict,
                //or two generic and they conflict (w/o specific to shadow), throw error.
                //note: we treat null as a legitimate value here.
                let address;
                if ((networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.registry) !== undefined &&
                    ((_a = networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.ens) === null || _a === void 0 ? void 0 : _a.registry) !== undefined) {
                    throw new Error("<network_config>.registry and <network_config>.ens.registry both defined");
                }
                let specificAddressInsideRegistry = ((_c = (_b = networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.ens) === null || _b === void 0 ? void 0 : _b.registry) === null || _c === void 0 ? void 0 : _c.address) !== undefined
                    ? (_e = (_d = networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.ens) === null || _d === void 0 ? void 0 : _d.registry) === null || _e === void 0 ? void 0 : _e.address
                    : (_f = networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.registry) === null || _f === void 0 ? void 0 : _f.address;
                if (specificAddressInsideRegistry !== undefined ||
                    (networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.registryAddress) !== undefined) {
                    if (specificAddressInsideRegistry !== undefined &&
                        (networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.registryAddress) !== undefined) {
                        if (specificAddressInsideRegistry === (networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.registryAddress)) {
                            //if both are defined and they're equal, use either one
                            address = specificAddressInsideRegistry;
                        }
                        else {
                            //if both are defined but they're unequal, throw an error
                            throw new Error("Conflicting values for registry address found in network config");
                        }
                    }
                    else {
                        //if only one is defined, use that one
                        address =
                            specificAddressInsideRegistry !== undefined
                                ? specificAddressInsideRegistry
                                : networkConfig === null || networkConfig === void 0 ? void 0 : networkConfig.registryAddress;
                    }
                }
                else if (((_h = (_g = configObject.ens) === null || _g === void 0 ? void 0 : _g.registry) === null || _h === void 0 ? void 0 : _h.address) !== undefined ||
                    ((_j = configObject.ens) === null || _j === void 0 ? void 0 : _j.registryAddress) !== undefined) {
                    if (((_l = (_k = configObject.ens) === null || _k === void 0 ? void 0 : _k.registry) === null || _l === void 0 ? void 0 : _l.address) !== undefined &&
                        ((_m = configObject.ens) === null || _m === void 0 ? void 0 : _m.registryAddress) !== undefined) {
                        if (((_p = (_o = configObject.ens) === null || _o === void 0 ? void 0 : _o.registry) === null || _p === void 0 ? void 0 : _p.address) ===
                            ((_q = configObject.ens) === null || _q === void 0 ? void 0 : _q.registryAddress)) {
                            //if both are defined and they're equal, use either one
                            address = (_s = (_r = configObject.ens) === null || _r === void 0 ? void 0 : _r.registry) === null || _s === void 0 ? void 0 : _s.address;
                        }
                        else {
                            //if both are defined but they're unequal, throw an error
                            throw new Error("Conflicting values for registry address found in project ens config");
                        }
                    }
                    else {
                        //if only one is defined, use that one
                        address =
                            ((_u = (_t = configObject.ens) === null || _t === void 0 ? void 0 : _t.registry) === null || _u === void 0 ? void 0 : _u.address) ||
                                ((_v = configObject.ens) === null || _v === void 0 ? void 0 : _v.registryAddress);
                    }
                }
                //otherwise, address is just undefined
                return { address };
            },
            set() {
                throw new Error("Don't set config.ensRegistry directly. Instead, set config.networks[<network name>].registry, or config.networks[<network name>].registryAddress, or config.ens.registry, or config.ens.registryAddress.");
            }
        }
    };
};
exports.configProps = configProps;
//# sourceMappingURL=configDefaults.js.map

/***/ }),

/***/ 20553:
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = __importDefault(__webpack_require__(71017));
const merge_1 = __importDefault(__webpack_require__(82492));
const find_up_1 = __importDefault(__webpack_require__(16948));
const conf_1 = __importDefault(__webpack_require__(19658));
const error_1 = __importDefault(__webpack_require__(73321));
const original_require_1 = __importDefault(__webpack_require__(44516));
const configDefaults_1 = __webpack_require__(69203);
const events_1 = __webpack_require__(38279);
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)("config");
const DEFAULT_CONFIG_FILENAME = "truffle-config.js";
const BACKUP_CONFIG_FILENAME = "truffle.js"; // old config filename
class TruffleConfig {
    constructor(truffleDirectory, workingDirectory, network) {
        this._deepCopy = ["compilers", "mocha", "dashboard", "networks"];
        this._values = (0, configDefaults_1.getInitialConfig)({
            truffleDirectory,
            workingDirectory,
            network
        });
        this.events = new events_1.EventManager(this);
        const props = (0, configDefaults_1.configProps)({ configObject: this });
        Object.entries(props).forEach(([propName, descriptor]) => this.addProp(propName, descriptor));
    }
    addProp(propertyName, descriptor) {
        // possible property descriptors
        //
        // supports `default` and `transform` in addition to `get` and `set`
        //
        // default: specify function to retrieve default value (used by get)
        // transform: specify function to transform value when (used by set)
        const self = this;
        Object.defineProperty(this, propertyName, {
            get: descriptor.get ||
                function () {
                    // value is specified
                    if (propertyName in self._values) {
                        return self._values[propertyName];
                    }
                    // default getter is specified
                    if (descriptor.default) {
                        return descriptor.default();
                    }
                    // descriptor is a function
                    return descriptor();
                },
            set: descriptor.set ||
                function (value) {
                    self._values[propertyName] = descriptor.transform
                        ? descriptor.transform(value)
                        : value;
                },
            configurable: true,
            enumerable: true
        });
    }
    normalize(obj) {
        const clone = {};
        Object.keys(obj).forEach(key => {
            try {
                clone[key] = obj[key];
            }
            catch (e) {
                // Do nothing with values that throw.
            }
        });
        return clone;
    }
    with(obj) {
        //Normalized, or shallow clowning only copies an object's own enumerable
        //properties ignoring properties up the prototype chain
        const current = this.normalize(this);
        const normalized = this.normalize(obj);
        const newConfig = Object.assign(Object.create(TruffleConfig.prototype), current, normalized);
        this.events.updateSubscriberOptions(newConfig);
        return newConfig;
    }
    merge(obj) {
        const clone = this.normalize(obj);
        // Only set keys for values that don't throw.
        const propertyNames = Object.keys(obj);
        propertyNames.forEach(key => {
            try {
                if (typeof clone[key] === "object" && this._deepCopy.includes(key)) {
                    this[key] = (0, merge_1.default)(this[key], clone[key]);
                }
                else {
                    debug("setting key -- %o -- to -- %o", key, clone[key]);
                    this[key] = clone[key];
                }
            }
            catch (e) {
                // ignore
            }
        });
        this.events.updateSubscriberOptions(this);
        return this;
    }
    static default() {
        return new TruffleConfig();
    }
    static search(options = {}, filename) {
        const searchOptions = {
            cwd: options.working_directory || options.workingDirectory
        };
        if (!filename) {
            const isWin = process.platform === "win32";
            const defaultConfig = find_up_1.default.sync(DEFAULT_CONFIG_FILENAME, searchOptions);
            const backupConfig = find_up_1.default.sync(BACKUP_CONFIG_FILENAME, searchOptions);
            if (defaultConfig && backupConfig) {
                console.warn(`Warning: Both ${DEFAULT_CONFIG_FILENAME} and ${BACKUP_CONFIG_FILENAME} were found. Using ${DEFAULT_CONFIG_FILENAME}.`);
                return defaultConfig;
            }
            else if (backupConfig && !defaultConfig) {
                if (isWin)
                    console.warn(`Warning: Please rename ${BACKUP_CONFIG_FILENAME} to ${DEFAULT_CONFIG_FILENAME} to ensure Windows compatibility.`);
                return backupConfig;
            }
            else {
                return defaultConfig;
            }
        }
        return find_up_1.default.sync(filename, searchOptions);
    }
    static detect(options = {}, filename) {
        debug("callling Config.detect with filename -- %o", filename);
        let configFile;
        const configPath = options.config;
        if (configPath) {
            configFile = path_1.default.isAbsolute(configPath)
                ? configPath
                : path_1.default.resolve(configPath);
        }
        else {
            configFile = TruffleConfig.search(options, filename);
        }
        if (!configFile) {
            throw new error_1.default("Could not find suitable configuration file.");
        }
        return TruffleConfig.load(configFile, options);
    }
    static load(file, options = {}) {
        debug("calling Config.load with file -- %o", file);
        const workingDirectory = options.config
            ? process.cwd()
            : path_1.default.dirname(path_1.default.resolve(file));
        const config = new TruffleConfig(undefined, workingDirectory, undefined);
        const staticConfig = (0, original_require_1.default)(file);
        debug("the static config is -- %o", staticConfig);
        config.merge(staticConfig);
        config.merge(options);
        // When loading a user's config, ensure their subscribers are initialized
        config.events.updateSubscriberOptions(config);
        config.events.initializeUserSubscribers(config);
        return config;
    }
    static getUserConfig() {
        return new conf_1.default({ projectName: "truffle" });
    }
    static getTruffleDataDirectory() {
        const conf = TruffleConfig.getUserConfig();
        return path_1.default.dirname(conf.path);
    }
}
module.exports = TruffleConfig;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 96053:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardMessageBusClient = void 0;
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const connection_1 = __webpack_require__(83806);
const delay_1 = __importDefault(__webpack_require__(65780));
const debug_1 = __importDefault(__webpack_require__(15158));
const lifecycle_1 = __webpack_require__(47993);
const promise_tracker_1 = __webpack_require__(16164);
const debug = (0, debug_1.default)(`dashboard-message-bus-client:client`);
class DashboardMessageBusClient {
    get options() {
        return Object.assign({}, this._options);
    }
    constructor(options) {
        this._subscriptions = [];
        this._options = Object.assign({ host: "localhost", port: 24012, maxRetries: 1, retryDelayMsec: 100 }, (options !== null && options !== void 0 ? options : {}));
        const { host, port, publishPort, subscribePort } = this._options;
        this._publishConnection = new connection_1.DashboardMessageBusConnection({
            host,
            port,
            publishPort,
            connectionType: "publish"
        });
        this._subscribeConnection = new connection_1.DashboardMessageBusConnection({
            host,
            port,
            subscribePort,
            connectionType: "subscribe"
        });
        this._subscribeConnection.on("message", this._messageHandler.bind(this));
    }
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._withRetriesAsync(() => __awaiter(this, void 0, void 0, function* () {
                Promise.all([
                    this._publishConnection.connect(),
                    this._subscribeConnection.connect()
                ]);
            }));
        });
    }
    publish(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, payload } = options;
            let message = (0, dashboard_message_bus_common_1.createMessage)(type, payload);
            try {
                yield this.ready();
                const lifecycle = new lifecycle_1.PublishMessageLifecycle({
                    message,
                    connection: this._publishConnection
                });
                return yield this._withRetriesAsync((() => __awaiter(this, void 0, void 0, function* () {
                    debug("publisher sending message %o", message);
                    yield this._publishConnection.send(message);
                    return lifecycle;
                })).bind(this));
            }
            catch (err) {
                debug("sending message %o failed due to error %s", message, err);
                throw err;
            }
        });
    }
    subscribe(options) {
        const subscription = new lifecycle_1.DashboardMessageBusSubscription(options);
        this._subscriptions.push(subscription);
        return subscription;
    }
    close(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                yield this.waitForOutstandingPromises();
            }
            this._subscriptions.map(sub => sub._end());
            this._subscriptions = [];
            yield Promise.all([
                this._subscribeConnection.close(),
                this._publishConnection.close()
            ]);
        });
    }
    waitForOutstandingPromises() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, promise_tracker_1.waitForOutstandingPromises)({ target: this });
            return;
        });
    }
    _messageHandler(message) {
        this._subscriptions.map(sub => sub._evaluateMessage({ message, connection: this._subscribeConnection }));
    }
    _withRetriesAsync(f) {
        return __awaiter(this, void 0, void 0, function* () {
            const { maxRetries, retryDelayMsec } = this._options;
            for (let tryCount = 0; tryCount <= maxRetries; tryCount++) {
                try {
                    const result = f.call(this);
                    if (result.then) {
                        // ensure any promise rejections are handled here so we count them as
                        // failures to retry
                        return yield result;
                    }
                    else {
                        return result;
                    }
                }
                catch (err) {
                    if (tryCount < maxRetries) {
                        debug("Attempt failed, %s of %s attempts remaining, delaying %s msec before retrying.", maxRetries - tryCount, maxRetries + 1, retryDelayMsec);
                        yield (0, delay_1.default)(retryDelayMsec);
                        debug("Retrying failed operation now");
                    }
                    else {
                        debug("Operation failed after %s attempts", tryCount);
                        throw err;
                    }
                }
            }
        });
    }
}
exports.DashboardMessageBusClient = DashboardMessageBusClient;
//# sourceMappingURL=client.js.map

/***/ }),

/***/ 83806:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashboardMessageBusConnection = void 0;
const isomorphic_ws_1 = __importDefault(__webpack_require__(47030));
// must polyfill AbortController to use axios >=0.20.0, <=0.27.2 on node <= v14.x
__webpack_require__(26426);
const axios_1 = __importDefault(__webpack_require__(43306));
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const debug_1 = __importDefault(__webpack_require__(15158));
const errors_1 = __webpack_require__(25338);
const tiny_typed_emitter_1 = __webpack_require__(12527);
const promise_tracker_1 = __webpack_require__(16164);
const delay_1 = __importDefault(__webpack_require__(65780));
const debug = (0, debug_1.default)("dashboard-message-bus-client:connection");
const debugMessage = (0, debug_1.default)("dashboard-message-bus-client:message");
class DashboardMessageBusConnection extends tiny_typed_emitter_1.TypedEmitter {
    constructor({ host, port, publishPort, subscribePort, connectionType: socketType }) {
        super();
        this._host = host;
        this._port = port;
        this._publishPort = publishPort;
        this._subscribePort = subscribePort;
        this._connectionType = socketType;
    }
    get isConnected() {
        return this._socket && this._socket.readyState === isomorphic_ws_1.default.OPEN;
    }
    get isConnecting() {
        return this._socket && this._socket.readyState === isomorphic_ws_1.default.CONNECTING;
    }
    get isClosing() {
        return this._socket && this._socket.readyState === isomorphic_ws_1.default.CLOSING;
    }
    connect() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._socket) {
                switch (this._socket.readyState) {
                    case isomorphic_ws_1.default.CONNECTING:
                        debug("connect: %s already attempting to connect (readyState switch)", this._connectionType);
                        yield (0, delay_1.default)(10);
                        return this.connect();
                    case isomorphic_ws_1.default.OPEN:
                        // we're already connected, just return
                        debug("connect: %s already connected", this._connectionType);
                        return;
                    case isomorphic_ws_1.default.CLOSING:
                    case isomorphic_ws_1.default.CLOSED:
                        debug("connect: %s was previously connected but has been closed", this._connectionType);
                        // already closed or on our way there, so we'll just recreate it in a
                        // moment
                        delete this._socket;
                }
            }
            try {
                if (this._connecting) {
                    debug("connect: %s already attempting to connect (_connecting flag)", this._connectionType);
                    yield (0, delay_1.default)(10);
                    return this.connect();
                }
                this._connecting = true;
                const port = yield this._getMessageBusPort();
                const url = `ws://${this._host}:${port}`;
                debug("connect: %s is attempting to connect to %s", this._connectionType, url);
                this._socket = new isomorphic_ws_1.default(url);
                (_a = this._socket) === null || _a === void 0 ? void 0 : _a.addEventListener("message", ((event) => {
                    if (typeof event.data !== "string") {
                        event.data = event.data.toString();
                    }
                    const message = (0, dashboard_message_bus_common_1.base64ToJson)(event.data);
                    debugMessage("%s connection received message %o", this._connectionType, message);
                    this.emit("message", message);
                }).bind(this));
                // connecting
                // we now have a socket that's in the process of opening, so return a
                // promise that resolves when it opens, or fails to open
                const connectPromise = this._createEventWrapperPromise((resolve, reject) => {
                    return {
                        open: () => {
                            var _a, _b;
                            debug("connect: %s connection succeeded to url %s", this._connectionType, (_a = this._socket) === null || _a === void 0 ? void 0 : _a.url);
                            if (this._connectionType === "subscribe") {
                                (_b = this._socket) === null || _b === void 0 ? void 0 : _b.send("ready");
                            }
                            resolve();
                            this._connecting = false;
                        },
                        error: (event) => {
                            var _a;
                            debug("connect: %s connection to url %s failed due to error %s", this._connectionType, (_a = this._socket) === null || _a === void 0 ? void 0 : _a.url, event.error);
                            reject(new errors_1.MessageBusConnectionError({
                                message: event.error.message,
                                cause: event.error
                            }));
                            this._connecting = false;
                        },
                        close: (event) => {
                            var _a;
                            debug("connect: %s connection to url %s closed before successfully connecting due to code %s and reason %s", this._connectionType, (_a = this._socket) === null || _a === void 0 ? void 0 : _a.url, event.code, event.reason);
                            reject(new errors_1.MessageBusConnectionError({
                                message: `Socket connection closed with code '${event.code}' and reason '${event.reason}'`
                            }));
                            this._connecting = false;
                        }
                    };
                });
                let timedout = false;
                yield Promise.race([
                    connectPromise,
                    () => __awaiter(this, void 0, void 0, function* () {
                        yield (0, delay_1.default)(350);
                        timedout = true;
                    })
                ]);
                if (timedout) {
                    debug("connect: %s connection to url %s timed out", this._connectionType, url);
                }
            }
            catch (_b) {
                this._connecting = false;
            }
        });
    }
    send(dataOrMessage) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const encodedMessage = typeof dataOrMessage === "string"
                ? dataOrMessage
                : (0, dashboard_message_bus_common_1.jsonToBase64)(dataOrMessage);
            yield this.connect();
            debug("send: %s connection sending %o", this._connectionType, (0, dashboard_message_bus_common_1.base64ToJson)(encodedMessage));
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.send(encodedMessage);
        });
    }
    close() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._socket) {
                return;
            }
            if (this._socket.readyState <= isomorphic_ws_1.default.CLOSING) {
                const promise = this._createEventWrapperPromise((resolve, reject) => {
                    return {
                        error: (event) => {
                            reject(event.error);
                        },
                        close: () => {
                            debug("%s connection closed", this._connectionType);
                            resolve();
                        }
                    };
                });
                this._socket.close();
                return promise;
            }
        });
    }
    _getMessageBusPort() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._connectionType === "subscribe" && this._subscribePort) {
                return this._subscribePort;
            }
            if (this._connectionType === "publish" && this._publishPort) {
                return this._publishPort;
            }
            // otherwise, fetch it from the server
            try {
                debug("_getMessageBusPort: %s connection attempting to fetch ports", this._connectionType);
                const { data } = yield axios_1.default.get(`http://${this._host}:${this._port}/ports`, {
                    timeout: 350
                });
                const port = this._connectionType === "subscribe"
                    ? data.subscribePort
                    : data.publishPort;
                debug("_getMessageBusPort: %s connection will use port %s", this._connectionType, port);
                return port;
            }
            catch (err) {
                debug("_getMessageBusPort: failed fetching ports for %s connection due to error %s", this._connectionType, err);
                throw err;
            }
        });
    }
    _createEventWrapperPromise(handlerFactory) {
        return new Promise(((resolve, reject) => {
            this._registerEventHandlers(handlerFactory.call(this, resolve, reject));
        }).bind(this));
    }
    _registerEventHandlers(handlers) {
        var _a;
        let wrappedHandlers = {};
        for (const eventType in handlers) {
            wrappedHandlers[eventType] = ((...args) => {
                handlers[eventType].call(this, ...args);
                this._cleanUpEventHandlers(wrappedHandlers);
            }).bind(this);
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.addEventListener(eventType, wrappedHandlers[eventType]);
        }
    }
    _cleanUpEventHandlers(handlers) {
        var _a;
        for (const eventType in handlers) {
            (_a = this._socket) === null || _a === void 0 ? void 0 : _a.removeEventListener(eventType, handlers[eventType]);
        }
    }
}
__decorate([
    promise_tracker_1.tracked
], DashboardMessageBusConnection.prototype, "send", null);
exports.DashboardMessageBusConnection = DashboardMessageBusConnection;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 25338:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageBusConnectionError = exports.AlreadyRespondedError = void 0;
class AlreadyRespondedError extends Error {
    constructor({ serviceBusMessage }) {
        super(`A response has already been sent for message id ${serviceBusMessage.id} of type "${serviceBusMessage.type}".`);
    }
}
exports.AlreadyRespondedError = AlreadyRespondedError;
class MessageBusConnectionError extends Error {
    constructor({ message, cause }) {
        super(message);
        this.cause = cause;
    }
    toString() {
        return this.cause
            ? `${super.toString()}\ncaused by: ${this.cause.toString()}`
            : super.toString();
    }
}
exports.MessageBusConnectionError = MessageBusConnectionError;
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ 19602:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(96053), exports);
__exportStar(__webpack_require__(82118), exports);
__exportStar(__webpack_require__(47993), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 47993:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(35933), exports);
__exportStar(__webpack_require__(71033), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 35933:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublishMessageLifecycle = void 0;
const dashboard_message_bus_common_1 = __webpack_require__(75756);
const debug_1 = __importDefault(__webpack_require__(15158));
const debug = (0, debug_1.default)(`dashboard-message-bus-client:publish`);
class PublishMessageLifecycle {
    constructor({ message, connection }) {
        this._responseReceived = false;
        this._invalidated = false;
        this._abandoned = false;
        this.message = message;
        this._connection = connection;
        this._messageHandler = this._messageHandler.bind(this);
        this.response = new Promise(resolve => {
            this._responsePromiseResolve = resolve;
        });
        connection.on("message", this._messageHandler);
    }
    /**
     * Notify other potential subscribers of this message that it has been
     * invalidated, and they therefore should not respond.
     */
    invalidate() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._abandoned || this._invalidated || this._responseReceived) {
                return;
            }
            this._invalidated = true;
            this._connection.off("message", this._messageHandler);
            /*
             * Resolving the response promise with `null` is the best of the bad options
             * when a message is invalidated
             *
             * Other options included rejecting with an error, and simply letting the
             * promise go unresolved.
             *
             * Letting the promise go unresolved is worst option, as it prevents the
             * `finally` block/handler from ever running.
             *
             * Rejecting with an error is maybe okay, but there's nothing to prompt the
             * consumer of this library to know that they'll need to catch this error or
             * else they'll encounter terminations due to unresolved promises.
             *
             * Returning null means that authors writing TS code against this library
             * will at least have some indicator that the message invalidation mechanism
             * exists, and they may need to write code to handle it.
             *
             */
            this._responsePromiseResolve(null);
            yield this._connection.send((0, dashboard_message_bus_common_1.createMessage)(dashboard_message_bus_common_1.invalidateMessageType, this.message.id));
        });
    }
    /**
     * Stop waiting for the response to this message, but don't invalidate it,
     * either.
     */
    abandon() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._abandoned || this._invalidated || this._responseReceived) {
                return;
            }
            this._abandoned = true;
            this._connection.off("message", this._messageHandler);
            /*
             * Resolving the response promise with `null` is the best of the bad options
             * when a message is invalidated
             *
             * Other options included rejecting with an error, and simply letting the
             * promise go unresolved.
             *
             * Letting the promise go unresolved is worst option, as it prevents the
             * `finally` block/handler from ever running.
             *
             * Rejecting with an error is maybe okay, but there's nothing to prompt the
             * consumer of this library to know that they'll need to catch this error or
             * else they'll encounter terminations due to unresolved promises.
             *
             * Returning null means that authors writing TS code against this library
             * will at least have some indicator that the message invalidation mechanism
             * exists, and they may need to write code to handle it.
             *
             */
            this._responsePromiseResolve(null);
        });
    }
    _messageHandler(response) {
        if (response.id === this.message.id) {
            this._responseReceived = true;
            this._connection.off("message", this._messageHandler);
            debug("Received response %o for message %s of type '%s'", response, this.message.id, this.message.type);
            return this._responsePromiseResolve(response);
        }
        if (invalidatesMessage({ response, message: this.message })) {
            this._invalidated = true;
            this._connection.off("message", this._messageHandler);
            debug("Message id %s of type '%s' was invalidated.", this.message.id, this.message.type);
            return this._responsePromiseResolve(null);
        }
    }
}
exports.PublishMessageLifecycle = PublishMessageLifecycle;
function invalidatesMessage({ response, message }) {
    if (response.type !== dashboard_message_bus_common_1.invalidateMessageType &&
        message.type !== dashboard_message_bus_common_1.invalidateMessageType) {
        return false;
    }
    return response.payload === message.id;
}
//# sourceMappingURL=publish.js.map

/***/ }),

/***/ 71033:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReceivedMessageLifecycle = exports.DashboardMessageBusSubscription = void 0;
const errors_1 = __webpack_require__(25338);
const debug_1 = __importDefault(__webpack_require__(15158));
const tiny_typed_emitter_1 = __webpack_require__(12527);
const debug = (0, debug_1.default)(`dashboard-message-bus-client:subscribe`);
class DashboardMessageBusSubscription extends tiny_typed_emitter_1.TypedEmitter {
    constructor({ id, type }) {
        super();
        this._ended = false;
        this._predicate = (message) => (id === undefined || message.id === id) &&
            (type === undefined || message.type === type);
    }
    _evaluateMessage({ message, connection }) {
        if (this._predicate(message)) {
            const messageLifecycle = new ReceivedMessageLifecycle({
                message,
                connection
            });
            this.emit("message", messageLifecycle);
        }
    }
    _end() {
        this._ended = true;
        this.emit("end");
        this.removeAllListeners();
    }
}
exports.DashboardMessageBusSubscription = DashboardMessageBusSubscription;
class ReceivedMessageLifecycle {
    constructor({ message, connection }) {
        this._responded = false;
        this.message = message;
        this._connection = connection;
    }
    respond({ payload }) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._responded) {
                throw new errors_1.AlreadyRespondedError({ serviceBusMessage: this.message });
            }
            this._responded = true;
            const response = { id: this.message.id, payload };
            debug("Responding to message %s of type '%s' with %o", this.message.id, this.message.type, response);
            yield this._connection.send(response);
        });
    }
}
exports.ReceivedMessageLifecycle = ReceivedMessageLifecycle;
//# sourceMappingURL=subscribe.js.map

/***/ }),

/***/ 26426:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
// must polyfill AbortController to use axios >=0.20.0, <=0.27.2 on node <= v14.x
const node_abort_controller_1 = __webpack_require__(53357);
if (typeof global.AbortController === "undefined") {
    global.AbortController = node_abort_controller_1.AbortController;
    global.AbortSignal = node_abort_controller_1.AbortSignal;
}
//# sourceMappingURL=polyfill.js.map

/***/ }),

/***/ 82118:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=types.js.map

/***/ }),

/***/ 75756:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(16212), exports);
__exportStar(__webpack_require__(88863), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 16212:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.isInvalidateMessage = exports.isDebugMessage = exports.isLogMessage = exports.isDashboardProviderMessage = exports.isCliEventMessage = exports.invalidateMessageType = exports.debugMessageType = exports.logMessageType = exports.dashboardProviderMessageType = exports.cliEventMessageType = void 0;
exports.cliEventMessageType = "cli-event";
exports.dashboardProviderMessageType = "provider";
exports.logMessageType = "log";
exports.debugMessageType = "debug";
exports.invalidateMessageType = "invalidate";
const isCliEventMessage = (message) => {
    return message.type === exports.cliEventMessageType;
};
exports.isCliEventMessage = isCliEventMessage;
const isDashboardProviderMessage = (message) => {
    return message.type === exports.dashboardProviderMessageType;
};
exports.isDashboardProviderMessage = isDashboardProviderMessage;
const isLogMessage = (message) => {
    return message.type === exports.logMessageType;
};
exports.isLogMessage = isLogMessage;
const isDebugMessage = (message) => {
    return message.type === exports.debugMessageType;
};
exports.isDebugMessage = isDebugMessage;
const isInvalidateMessage = (message) => {
    return message.type === exports.invalidateMessageType;
};
exports.isInvalidateMessage = isInvalidateMessage;
//# sourceMappingURL=messages.js.map

/***/ }),

/***/ 88863:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createMessage = exports.base64ToJson = exports.jsonToBase64 = void 0;
const buffer_1 = __webpack_require__(14300);
/**
 * Convert any JS object or value to a base64 representation of it
 */
const jsonToBase64 = (json) => {
    const stringifiedJson = JSON.stringify(json);
    const buffer = buffer_1.Buffer.from(stringifiedJson);
    const base64 = buffer.toString("base64");
    return base64;
};
exports.jsonToBase64 = jsonToBase64;
/**
 * Convert the base64 representation of a JS object or value to its JS representation
 * @dev This is the reverse of `jsonToBase64` and is not expected to work with other base64 formats
 */
const base64ToJson = (base64) => {
    const buffer = buffer_1.Buffer.from(base64, "base64");
    const stringifiedJson = buffer.toString("utf8");
    const json = JSON.parse(stringifiedJson);
    return json;
};
exports.base64ToJson = base64ToJson;
const createMessage = (type, payload) => {
    const id = Math.random();
    return { id, type, payload };
};
exports.createMessage = createMessage;
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ 73321:
/***/ ((module) => {

"use strict";

class TruffleError extends Error {
    constructor(message) {
        super(message);
        this.name = this.constructor.name;
        this.stack = "";
    }
}
module.exports = TruffleError;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 23518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const SubscriberAggregator = __webpack_require__(42626);
const Emittery = __webpack_require__(91371);
const defaultSubscribers = __webpack_require__(25829);

class EventManager {
  constructor(config) {
    this.emitter = new Emittery();
    this.subscriberAggregators = [];

    this.initializationOptions = {
      config,
      emitter: this.emitter
    };
    this.initializeDefaultSubscribers(this.initializationOptions);
  }

  emit(event, data) {
    return this.emitter.emit(event, data);
  }

  initializeDefaultSubscribers(initializationOptions) {
    const aggregatorOptions = {
      ...initializationOptions,
      subscribers: defaultSubscribers
    };
    this.subscriberAggregators.push(
      new SubscriberAggregator(aggregatorOptions)
    );
  }

  initializeUserSubscribers(initializationOptions) {
    const { subscribers } = initializationOptions;
    if (subscribers && Object.keys(subscribers).length > 0) {
      const aggregatorOptions = Object.assign({}, initializationOptions, {
        emitter: this.emitter
      });
      this.subscriberAggregators.push(
        new SubscriberAggregator(aggregatorOptions)
      );
    }
  }

  updateSubscriberOptions(newOptions) {
    this.subscriberAggregators.forEach(aggregator => {
      aggregator.updateSubscriberOptions(newOptions);
    });
  }
}

module.exports = EventManager;


/***/ }),

/***/ 50676:
/***/ ((module) => {

const validateOptions = options => {
  const { handlers, initialization } = options;

  if (initialization !== undefined && typeof initialization !== "function") {
    const message =
      `The initialization property specified in your ` +
      `reporter config must be a function. The current value is ` +
      `${initialization}.`;
    throw new Error(message);
  }

  if (typeof handlers !== "object" || Object.keys(handlers).length === 0) {
    const message =
      `You must provide a handlers property in your reporter ` +
      `config. Please ensure that the handlers property ` +
      ` exists and is in the following form:\n ` +
      `  handlers: {\n` +
      `    <handlerName1>: [\n` +
      `       handler1,\n` +
      `       handler2,\n` +
      `       ...\n` +
      `     ],\n` +
      `     <handlerName2>: [\n` +
      `       ...\n` +
      `Currently the handlers property is ${handlers}.`;
    throw new Error(message);
  }
};

// match single or double `*` as long as it isn't preceded by an odd number of
// backslashes. Note: this doesn't handle cases like `***`, as the first two
// stars get matched and the third gets escaped.
const globMatchRegEx = /(?:[^\\]|[^\\](?:\\\\)+)(\*\*|\*)/g;
// list of all characters that should be escaped for use in a regular
// expression
const reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
const convertHandlerNameToRegex = name => {
  let match;
  let start = 0;
  let str = "";
  // making a regular expression match the cases where there is a backlash at
  // the start of the string makes it much harder to read, instead, just pad
  // the start:
  name = " " + name;
  // build our final string one match at a time
  while ((match = globMatchRegEx.exec(name)) !== null) {
    const star = match[1];
    const starRegex = star === "*" ? "[^:]+" : "(?:[^:]+(?::[^:]+)*)?";
    const matchLength = match[0].length;
    const end = match.index + matchLength - star.length;
    const unmatched = name.substring(start, end);
    // escape unsafe characters
    const cleanString = unmatched.replace(reRegExpChar, "\\$&");
    start += match.index + matchLength;
    str += cleanString + starRegex;
  }
  str += name.slice(start).replace(reRegExpChar, "\\$&");
  return new RegExp(`^${str.slice(1)}$`, "i");
};

const createLookupTable = handlerNames => {
  return handlerNames.reduce((lookupTable, handlerName) => {
    const regex = convertHandlerNameToRegex(handlerName);
    lookupTable[handlerName] = regex;
    return lookupTable;
  }, {});
};

const sortHandlers = handlers => {
  const globbedHandlers = {};
  const nonGlobbedHandlers = {};
  for (let handlerName in handlers) {
    if (globMatchRegEx.test(handlerName)) {
      globbedHandlers[handlerName] = handlers[handlerName];
    } else {
      nonGlobbedHandlers[handlerName] = handlers[handlerName];
    }
  }
  return { nonGlobbedHandlers, globbedHandlers };
};

module.exports = {
  createLookupTable,
  sortHandlers,
  validateOptions
};


/***/ }),

/***/ 13764:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const helpers = __webpack_require__(50676);
const { createLookupTable, sortHandlers, validateOptions } = helpers;

class Subscriber {
  constructor({ emitter, options, config }) {
    validateOptions(options);
    const { initialization, handlers } = options;

    this.emitter = emitter;
    // Object for storing unsubscribe methods for non-globbed listeners
    this.unsubscribeListeners = {};
    this.quiet = config.quiet;
    this.config = config;
    if (config.logger) this.logger = config.logger;
    if (initialization) initialization.bind(this)(config);

    const { globbedHandlers, nonGlobbedHandlers } = sortHandlers(handlers);

    if (nonGlobbedHandlers) this.setUpListeners(nonGlobbedHandlers);

    if (globbedHandlers) {
      this.globbedHandlers = globbedHandlers;
      this.setUpGlobbedListeners(globbedHandlers);
    }
  }

  handleEvent(eventName, data) {
    let promises = [];
    for (let handlerName in this.globbedHandlerLookupTable) {
      if (this.globbedHandlerLookupTable[handlerName].test(eventName)) {
        this.globbedHandlers[handlerName].forEach(handler => {
          promises.push(handler.bind(this)(data, eventName));
        });
      }
    }
    return Promise.all(promises);
  }

  removeListener(name) {
    if (this.unsubscribeListeners.hasOwnProperty(name)) {
      this.unsubscribeListeners[name]();
    }
    if (this.globbedHandlerLookupTable[name]) {
      delete this.globbedHandlerLookupTable[name];
    }
  }

  setUpGlobbedListeners(handlers) {
    const handlerNames = Object.keys(handlers);
    this.globbedHandlerLookupTable = createLookupTable(handlerNames);
    this.emitter.onAny(this.handleEvent.bind(this));
  }

  setUpListeners(handlers) {
    for (let handlerName in handlers) {
      handlers[handlerName].forEach(handler => {
        this.unsubscribeListeners[handlerName] = this.emitter.on(
          handlerName,
          handler.bind(this)
        );
      });
    }
  }

  updateOptions(config) {
    this.config = config;
    if (config.quiet) this.quiet = true;
    if (config.logger) this.logger = config.logger;
  }
}

module.exports = Subscriber;


/***/ }),

/***/ 42626:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Subscriber = __webpack_require__(13764);

class SubscriberAggregator {
  constructor(initializationOptions) {
    this.subscribers = [];
    this.initializeSubscribers(initializationOptions);
  }

  initializeSubscribers(initializationOptions) {
    let { emitter, subscribers, config } = initializationOptions;
    for (let name in subscribers) {
      this.subscribers.push(
        new Subscriber({
          config,
          options: subscribers[name],
          emitter
        })
      );
    }
  }

  updateSubscriberOptions(config) {
    this.subscribers.forEach(subscriber => {
      subscriber.updateOptions(config);
    });
  }
}

module.exports = SubscriberAggregator;


/***/ }),

/***/ 79373:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);

module.exports = {
  initialization: function () {
    this.logger = console;
  },
  handlers: {
    "compile:start": [
      function () {
        if (this.quiet) return;
        this.logger.log(OS.EOL + `Compiling your contracts...`);
        this.logger.log(`===========================`);
      }
    ],
    "compile:succeed": [
      function ({ contractsBuildDirectory, compilers }) {
        if (this.quiet) return;
        if (compilers.length > 0) {
          this.logger.log(`> Artifacts written to ${contractsBuildDirectory}`);
          this.logger.log(`> Compiled successfully using:`);

          const versionReports = new Set();

          const maxLength = compilers
            .map(({ name }) => name.length)
            .reduce((max, length) => (length > max ? length : max), 0);

          for (const compiler of compilers) {
            const padding = " ".repeat(maxLength - compiler.name.length);
            const versionReport = `   - ${compiler.name}:${padding} ${compiler.version}`;

            if (!versionReports.has(versionReport)) {
              this.logger.log(versionReport);
              versionReports.add(versionReport);
            }
          }
        }
      }
    ],
    "compile:sourcesToCompile": [
      function ({ sourceFileNames }) {
        if (this.quiet) return;
        if (!sourceFileNames) return;
        sourceFileNames.forEach(sourceFileName =>
          this.logger.log("> Compiling " + sourceFileName)
        );
      }
    ],
    "compile:warnings": [
      function ({ warnings }) {
        if (this.quiet) return;
        this.logger.log("> Compilation warnings encountered:");
        this.logger.log(`${OS.EOL}    ${warnings.join()}`);
      }
    ],
    "compile:infos": [
      function ({ infos }) {
        if (this.quiet) return;
        this.logger.log("> Compilation notices encountered:");
        this.logger.log(`${OS.EOL}    ${infos.join()}`);
      }
    ],
    "compile:nothingToCompile": [
      function () {
        if (this.quiet) return;
        this.logger.log(
          `> Everything is up to date, there is nothing to compile.`
        );
      }
    ],
    "compile:skipped": [
      function () {
        if (this.quiet) return;
        this.logger.log(
          `> Compilation skipped because --compile-none option was passed.`
        );
      }
    ],
    "compile:downloadDockerImage:start": [
      function () {
        if (this.quiet) return;
        this.logger.log("Attempting to download the Docker image.");
      }
    ],
    "compile:downloadDockerImage:succeed": [
      function () {
        if (this.quiet) return;
        this.logger.log("Download successful!");
      }
    ],
    "compile:downloadDockerImage:fail": [
      function ({ error }) {
        if (this.quiet) return;
        this.logger.log(
          `There was a problem downloading the Docker image. \n${error}.`
        );
      }
    ]
  }
};


/***/ }),

/***/ 75321:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Spinner = (__webpack_require__(92189).Spinner);
const {
  DashboardMessageBusClient
} = __webpack_require__(19602);

module.exports = {
  initialization: function (config) {
    const dashboardConfig = config.dashboard || {
      host: "localhost",
      port: 24012
    };

    this.messageBusClient = new DashboardMessageBusClient(dashboardConfig);

    this._logger = {
      log: ((...args) => {
        if (config.quiet) {
          return;
        }

        (this.logger || config.logger || console).log(...args);
      }).bind(this)
    };
    this.pendingTransactions = [];
  },
  handlers: {
    "compile:start": [
      async function () {
        if (!isDashboardNetwork(this.config)) return;

        try {
          const publishLifecycle = await this.messageBusClient.publish({
            type: "debug",
            payload: {
              message: "compile:start"
            }
          });
          publishLifecycle.abandon();
        } catch (err) {
          // best effort only, dashboard might not even be alive
        }
      }
    ],
    "compile:succeed": [
      async function ({ result }) {
        try {
          const publishLifecycle = await this.messageBusClient.publish({
            type: "cli-event",
            payload: {
              label: "workflow-compile-result",
              data: result
            }
          });
          publishLifecycle.abandon();
        } catch (err) {}
      }
    ],
    "rpc:request": [
      function (event) {
        if (!isDashboardNetwork(this.config)) return;

        const { payload } = event;
        if (payload.method === "eth_sendTransaction") {
          this.pendingTransactions[payload.id] = payload;

          this.spinner = new Spinner("events:subscribers:dashboard", {
            text: `Waiting for transaction signature. Please check your wallet for a transaction approval message.`
          });
        }
      }
    ],
    "rpc:result": [
      function (event) {
        if (!isDashboardNetwork(this.config)) return;

        let { error } = event;
        const { payload, result } = event;

        if (payload.method === "eth_sendTransaction") {
          error = error || result.error;
          if (error) {
            const errMessage = `Transaction submission failed with error ${error.code}: '${error.message}'`;
            this.spinner.fail(errMessage);
          } else {
            this.spinner.remove();
          }

          delete this.pendingTransactions[payload.id];
        }
      }
    ]
  }
};

function isDashboardNetwork(config) {
  return config.network === "dashboard";
}


/***/ }),

/***/ 25829:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  compile: __webpack_require__(79373),
  dashboard: __webpack_require__(75321),
  test: __webpack_require__(50363),
  init: __webpack_require__(50525),
  migrate: __webpack_require__(49812),
  obtain: __webpack_require__(13843),
  unbox: __webpack_require__(82084)
};


/***/ }),

/***/ 50525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const OS = __webpack_require__(22037);

module.exports = {
  initialization: function () {
    this.logger = console;
  },
  handlers: {
    "init:start": [
      function () {
        this.logger.log(`${OS.EOL}Starting init...`);
        this.logger.log(`================`);
      }
    ],
    "init:copyingProjectFiles": [
      function ({ destinationPath }) {
        this.logger.log(
          `${OS.EOL}> Copying project files to ${destinationPath}`
        );
      }
    ],
    "init:succeed": [
      function () {
        this.logger.log(`${OS.EOL}Init successful, sweet!${OS.EOL}`);
        this.logger.log(`Try our scaffold commands to get started:`);
        this.logger.log(
          "  $ truffle create contract YourContractName # scaffold a contract"
        );
        this.logger.log(
          "  $ truffle create test YourTestName         # scaffold a test"
        );
        this.logger.log(`${OS.EOL}http://trufflesuite.com/docs${OS.EOL}`);
      }
    ],
    "init:fail": [
      function ({ error }) {
        this.logger.log(`${OS.EOL}Something went wrong while copying files!`);
        this.logger.log(`${error}${OS.EOL}`);
      }
    ]
  }
};


/***/ }),

/***/ 6471:
/***/ ((module) => {

/**
 *  A module that formats output for the Migrations reporter.
 */
class Messages {
  constructor(reporter) {
    this.reporter = reporter;
  }

  // ----------------------------------- Utilities -------------------------------------------------

  underline(msg) {
    return typeof msg === "number"
      ? `   ${"-".repeat(msg)}`
      : `\n   ${msg}\n   ${"-".repeat(msg.length)}`;
  }

  doubleline(msg) {
    const ul = "=".repeat(msg.length);
    return `\n${msg}\n${ul}`;
  }

  // Emoji alternative
  onMissing() {
    return "**";
  }

  migrationStatus(msg) {
    return `MIGRATION_STATUS:${JSON.stringify(msg)}`;
  }

  decAndHex(num) {
    return `${Number(num).toString(10)} (0x${Number(num).toString(16)})`;
  }

  // ----------------------------------  Errors ----------------------------------------------------

  errors(kind, data) {
    const prefix = " *** Deployment Failed ***\n\n";

    const kinds = {
      migrateErr: () =>
        `\nExiting: Review successful transactions manually by checking the transaction hashes ` +
        `above on Etherscan.\n`,

      noLibName: () => `${prefix}Cannot link a library with no name.\n`,

      noLibAddress: () =>
        `${prefix}"${data.contract.contractName}" has no address. Has it been deployed?\n`,

      noBytecode: () =>
        `${prefix}"${data.contract.contractName}" ` +
        `is an abstract contract or an interface and cannot be deployed.\n` +
        `   * Import abstractions into the '.sol' file that uses them instead of deploying them separately.\n` +
        `   * Contracts that inherit an abstraction must implement all its method signatures exactly.\n` +
        `   * A contract that only implements part of an inherited abstraction is also considered abstract.\n`,

      noBatches: () =>
        `Support for batch deployments (array syntax) is deprecated. ` +
        `Please deploy each contract individually.`,

      intWithGas: () =>
        `${prefix}"${data.contract.contractName}" ran out of gas ` +
        `(using a value you set in your network config or deployment parameters.)\n` +
        `   * Block limit:  ${this.decAndHex(data.blockLimit)}\n` +
        `   * Gas sent:     ${this.decAndHex(data.gas)}\n`,

      intNoGas: () =>
        `${prefix}"${data.contract.contractName}" ran out of gas ` +
        `(using Truffle's estimate.)\n` +
        `   * Block limit:  ${this.decAndHex(data.blockLimit)}\n` +
        `   * Gas sent:     ${this.decAndHex(data.estimate)}\n` +
        `   * Try:\n` +
        `      + Setting a higher gas estimate multiplier for this contract\n` +
        `      + Using the solc optimizer settings in 'truffle-config.js'\n` +
        `      + Making your contract smaller\n` +
        `      + Making your contract constructor more efficient\n` +
        `      + Setting a higher network block limit if you are on a\n` +
        `        private network or test client (like ganache).\n`,

      oogNoGas: () =>
        `${prefix}"${data.contract.contractName}" ran out of gas. Something in the constructor ` +
        `(ex: infinite loop) caused gas estimation to fail. Try:\n` +
        `   * Making your contract constructor more efficient\n` +
        `   * Setting the gas manually in your config or as a deployment parameter\n` +
        `   * Using the solc optimizer settings in 'truffle-config.js'\n` +
        `   * Setting a higher network block limit if you are on a\n` +
        `     private network or test client (like ganache).\n`,

      rvtReason: () =>
        `${prefix}"${data.contract.contractName}" hit a require or revert statement ` +
        `with the following reason given:\n` +
        `   * ${data.reason}\n`,

      rvtNoReason: () =>
        `${prefix}"${data.contract.contractName}" hit a require or revert statement ` +
        `somewhere in its constructor. Try:\n` +
        `   * Verifying that your constructor params satisfy all require conditions.\n` +
        `   * Adding reason strings to your require statements.\n`,

      asrtNoReason: () =>
        `${prefix}"${data.contract.contractName}" hit an invalid opcode while deploying. Try:\n` +
        `   * Verifying that your constructor params satisfy all assert conditions.\n` +
        `   * Verifying your constructor code doesn't access an array out of bounds.\n` +
        `   * Adding reason strings to your assert statements.\n`,

      noMoney: () =>
        `${prefix}"${data.contract.contractName}" could not deploy due to insufficient funds\n` +
        `   * Account:  ${data.from}\n` +
        `   * Balance:  ${data.balance} wei\n` +
        `   * Message:  ${data.error.message}\n` +
        `   * Try:\n` +
        `      + Using an adequately funded account\n` +
        `      + If you are using a local Geth node, verify that your node is synced.\n`,

      blockWithGas: () =>
        `${prefix}"${data.contract.contractName}" exceeded the block limit ` +
        `(with a gas value you set).\n` +
        `   * Block limit:  ${this.decAndHex(data.blockLimit)}\n` +
        `   * Gas sent:     ${this.decAndHex(data.gas)}\n` +
        `   * Try:\n` +
        `      + Sending less gas.\n` +
        `      + Setting a higher network block limit if you are on a\n` +
        `        private network or test client (like ganache).\n`,

      blockNoGas: () =>
        `${prefix}"${data.contract.contractName}" exceeded the block limit ` +
        `(using Truffle's estimate).\n` +
        `   * Block limit: ${this.decAndHex(data.blockLimit)}\n` +
        `   * Report this error in the Truffle issues on Github. It should not happen.\n` +
        `   * Try: setting gas manually in 'truffle-config.js' or as parameter to 'deployer.deploy'\n`,

      nonce: () =>
        `${prefix}"${data.contract.contractName}" received: ${data.error.message}.\n` +
        `   * This error is common when Infura is under heavy network load.\n` +
        `   * Try: setting the 'confirmations' key in your network config\n` +
        `          to wait for several block confirmations between each deployment.\n`,

      geth: () =>
        `${prefix}"${data.contract.contractName}" received a generic error from Geth that\n` +
        `can be caused by hitting revert in a contract constructor or running out of gas.\n` +
        `   * ${data.estimateError.message}.\n` +
        `   * Try: + using the '--dry-run' option to reproduce this failure with clearer errors.\n` +
        `          + verifying that your gas is adequate for this deployment.\n`,

      default: () =>
        `${prefix}"${data.contract.contractName}" -- ${data.error.message}.\n`
    };

    return kinds[kind]();
  }

  // ----------------------------------  Steps ----------------------------------------------------

  steps(kind, data) {
    const self = this;
    const reporter = self.reporter;
    const valueUnit = data.valueUnit || "ETH";

    const kinds = {
      // Deployments
      deploying: () => {
        let output = "";

        if (reporter.subscriber.config.describeJson) {
          output +=
            self.migrationStatus({
              status: "deploying",
              data: {
                contractName: data.contract.contractName
              }
            }) + "\n";
        }

        output += self.underline(`Deploying '${data.contract.contractName}'`);

        return output;
      },

      replacing: () => {
        let output = "";

        if (reporter.subscriber.config.describeJson) {
          output +=
            self.migrationStatus({
              status: "replacing",
              data: {
                contractName: data.contract.contractName,
                priorAddress: data.contract.address
              }
            }) + "\n";
        }

        output += self.underline(`Replacing '${data.contract.contractName}'`);

        return output;
      },

      reusing: () => {
        let output = "";

        if (reporter.subscriber.config.describeJson) {
          output +=
            self.migrationStatus({
              status: "reusing",
              data: {
                contractName: data.contract.contractName,
                address: data.contract.address
              }
            }) + "\n";
        }

        output +=
          self.underline(`Re-using deployed '${data.contract.contractName}'`) +
          "\n" +
          `   > ${"contract address:".padEnd(20)} ${data.contract.address}\n`;

        return output;
      },

      deployed: () => {
        let stopText;
        if (reporter.blockSpinner) {
          reporter.blockSpinner.remove();
          stopText = `   > ${reporter.currentBlockWait}`;
        }

        let output = "";

        if (!reporter.subscriber.config.dryRun) {
          output += `   > ${"contract address:".padEnd(20)} ${
            data.receipt.contractAddress
          }\n`;
        }

        output += `   > ${"block number:".padEnd(20)} ${
          data.receipt.blockNumber
        }\n`;

        output += `   > ${"block timestamp:".padEnd(20)} ${data.timestamp}\n`;

        output +=
          `   > ${"account:".padEnd(20)} ${data.from}\n` +
          `   > ${"balance:".padEnd(20)} ${data.balance}\n` +
          `   > ${"gas used:".padEnd(20)} ${self.decAndHex(data.gas)}\n` +
          `   > ${"gas price:".padEnd(20)} ${data.gasPrice} ${data.gasUnit}\n` +
          `   > ${"value sent:".padEnd(20)} ${data.value} ${valueUnit}\n` +
          `   > ${"total cost:".padEnd(20)} ${data.cost} ${valueUnit}\n`;

        if (
          reporter.subscriber.config.confirmations !== undefined &&
          reporter.subscriber.config.confirmations !== 0
        )
          output += self.underline(
            `Pausing for ${reporter.subscriber.config.confirmations} confirmations...\n`
          );

        if (reporter.subscriber.config.describeJson) {
          output += self.migrationStatus({
            status: "deployed",
            data: Object.assign({}, data, {
              contract: {
                contractName: data.contract.contractName,
                address: data.receipt.contractAddress
              },
              instance: undefined,
              receipt: {
                transactionHash: data.receipt.transactionHash,
                gasUsed: data.receipt.gasUsed
              }
            })
          });
        }

        return stopText ? stopText + "\n" + output : output;
      },

      // Transactions
      endTransaction: () => {
        if (reporter.blockSpinner) {
          reporter.blockSpinner.remove();
        }
        return `   > ${data.message}`;
      },

      // Libraries
      linking: () => {
        let output =
          self.underline(`Linking`) +
          `\n   * Contract: ${data.contractName} <--> Library: ${data.libraryName} `;

        if (!reporter.subscriber.config.dryRun) {
          output += `(at address: ${data.libraryAddress})`;
        }

        return output;
      },

      // PromiEvents
      hash: () =>
        `   > ${"transaction hash:".padEnd(20)} ` + data.transactionHash,

      receipt: () => `   > ${"gas usage:".padEnd(20)} ` + data.gas,

      confirmation: () =>
        `   > ${"confirmation number:".padEnd(20)} ` +
        `${data.num} (block: ${data.block})`,

      // Migrator
      preAllMigrations: () => {
        let output = "";

        if (reporter.subscriber.config.describeJson) {
          const migrations = data.migrations.map(migration =>
            migration.serializeable()
          );
          output += self.migrationStatus({
            status: "preAllMigrations",
            data: Object.assign({}, data, {
              migrations
            })
          });
        }

        return output;
      },

      postAllMigrations: () => {
        let output = "";

        if (reporter.subscriber.config.describeJson) {
          output += self.migrationStatus({
            status: "postAllMigrations",
            data
          });
        }

        return output;
      },

      // Migrations
      preMigrate: () => {
        let output = "";
        if (reporter.subscriber.config.describeJson) {
          output +=
            self.migrationStatus({
              status: "preMigrate",
              data
            }) + "\n";
        }

        output += self.doubleline(`${data.file}`);
        return output;
      },

      saving: () => `\n   * Saving migration`,

      firstMigrate: () => {
        let output = ``;
        reporter.subscriber.config.dryRun
          ? (output +=
              self.doubleline(`Migrations dry-run (simulation)`) + "\n")
          : (output += self.doubleline(`Starting migrations...`) + "\n");

        output +=
          `> Network name:    '${data.network}'\n` +
          `> Network id:      ${data.networkId}\n` +
          `> Block gas limit: ${self.decAndHex(data.blockLimit)}\n`;
        return output;
      },

      postMigrate: () => {
        let output = "";
        let deployments =
          self.reporter.summary[self.reporter.currentFileIndex].deployments;

        if (!self.reporter.subscriber.config.dryRun && deployments.length) {
          output += `   > Saving artifacts\n`;
        }

        output +=
          self.underline(37) +
          "\n" +
          `   > ${"Total cost:".padEnd(15)} ${data.cost.padStart(
            15
          )} ${valueUnit}\n`;

        if (self.reporter.subscriber.config.describeJson) {
          output +=
            "\n" +
            self.migrationStatus({
              status: "postMigrate",
              data
            }) +
            "\n";
        }

        return output;
      },

      lastMigrate: () => {
        let output = "";

        output +=
          self.doubleline("Summary") +
          "\n" +
          `> ${"Total deployments:".padEnd(20)} ${data.totalDeployments}\n` +
          `> ${"Final cost:".padEnd(20)} ${data.finalCost} ${valueUnit}\n`;

        if (self.reporter.subscriber.config.describeJson) {
          output +=
            "\n" +
            self.migrationStatus({
              status: "lastMigrate",
              data: {
                totalDeployments: data.totalDeployments,
                finalCost: data.finalCost
              }
            }) +
            "\n";
        }

        return output;
      },

      // Batch
      many: () => self.underline(`Deploying Batch`),

      listMany: () => `   * ${data.contractName}`
    };

    return kinds[kind]();
  }
}

module.exports = Messages;


/***/ }),

/***/ 20605:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("reporters:migrations:reporter"); // eslint-disable-line no-unused-vars
const web3Utils = __webpack_require__(18269);
const Spinner = (__webpack_require__(92189).Spinner);

const Messages = __webpack_require__(6471);

/**
 *  Reporter consumed by a migrations sequence which iteself consumes a series of Migration and
 *  Deployer instances that emit both async `Emittery` events and conventional EventEmitter
 *  events (from Web3PromiEvent). This reporter is designed to track the execution of
 *  several migrations files in sequence and is analagous to the Mocha reporter in that:
 *
 *  test:: deployment
 *  suite:: deployer.start to deployer.finish
 *  test file:: migrations file
 *
 */
class Reporter {
  constructor({ subscriber }) {
    this.currentGasTotal = new web3Utils.BN(0);
    this.currentCostTotal = new web3Utils.BN(0);
    this.finalCostTotal = new web3Utils.BN(0);
    this.deployments = 0;
    this.separator = "\n";
    this.summary = [];
    this.currentFileIndex = -1;
    this.currentBlockWait = "";
    this.subscriber = subscriber;

    this.messages = new Messages(this);
  }

  // ------------------------------------  Utilities -----------------------------------------------

  /**
   * Retrieves gas usage totals per migrations file / totals since the reporter
   * started running. Calling this method resets the gas counters for migrations totals
   */
  getTotals(interfaceAdapter) {
    const gas = this.currentGasTotal.toString(10);
    const cost = interfaceAdapter.displayCost(this.currentCostTotal);
    this.finalCostTotal = this.finalCostTotal.add(this.currentCostTotal);

    this.currentGasTotal = new web3Utils.BN(0);
    this.currentCostTotal = new web3Utils.BN(0);

    return {
      gas,
      cost,
      finalCost: interfaceAdapter.displayCost(this.finalCostTotal),
      deployments: this.deployments.toString()
    };
  }

  /**
   * Error dispatcher. Parses the error returned from web3 and outputs a more verbose error after
   * doing what it can to evaluate the failure context from data passed to it.
   * @param  {Object} data info collected during deployment attempt
   */
  async processDeploymentError(data) {
    const error = data.estimateError || data.error;

    data.reason = data.error ? data.error.reason : null;

    const errors = {
      ETH: error.message.includes("funds"),
      OOG: error.message.includes("out of gas"),
      INT:
        error.message.includes("base fee") ||
        error.message.includes("intrinsic"),
      RVT: error.message.includes("revert"),
      BLK: error.message.includes("block gas limit"),
      NCE: error.message.includes("nonce"),
      INV: error.message.includes("invalid opcode"),
      GTH: error.message.includes("always failing transaction")
    };

    let type = Object.keys(errors).find(key => errors[key]);

    switch (type) {
      // `Intrinsic gas too low`
      case "INT":
        return data.gas
          ? this.messages.errors("intWithGas", data)
          : this.messages.errors("intNoGas", data);

      // `Out of gas`
      case "OOG":
        return data.gas && !(data.gas === data.blockLimit)
          ? this.messages.errors("intWithGas", data)
          : this.messages.errors("oogNoGas", data);

      // `Revert`
      case "RVT":
        return data.reason
          ? this.messages.errors("rvtReason", data)
          : this.messages.errors("rvtNoReason", data);

      // `Invalid opcode`
      case "INV":
        return data.reason
          ? this.messages.errors("asrtReason", data)
          : this.messages.errors("asrtNoReason", data);

      // `Exceeds block limit`
      case "BLK":
        return data.gas
          ? this.messages.errors("blockWithGas", data)
          : this.messages.errors("blockNoGas", data);

      // `Insufficient funds`
      case "ETH":
        const balance = await data.contract.interfaceAdapter.getBalance(
          data.from
        );
        data.balance = balance.toString();
        return this.messages.errors("noMoney", data);

      // `Invalid nonce`
      case "NCE":
        return this.messages.errors("nonce", data);

      // Generic geth error
      case "GTH":
        return this.messages.errors("geth", data);

      default:
        return this.messages.errors("default", data);
    }
  }

  // -------------------------  Migration File Handlers --------------------------------------------

  /**
   * Run when a migrations file is loaded, before deployments begin
   * @param  {Object} data
   */
  async preMigrate(data) {
    let message;
    if (data.isFirst) {
      message = this.messages.steps("firstMigrate", data);
    }

    this.summary.push({
      file: data.file,
      number: data.number,
      deployments: []
    });

    this.currentFileIndex++;

    const messagePart2 = this.messages.steps("preMigrate", data);
    if (message && messagePart2) {
      return message + "\n" + messagePart2;
    } else if (message) {
      return message;
    }
    return messagePart2;
  }

  /**
   * Run after a migrations file has completed and the migration has been saved.
   * @param  {Object} data
   */
  async postMigrate(data) {
    const totals = this.getTotals(data.interfaceAdapter);
    this.summary[this.currentFileIndex].totalCost = totals.cost;

    let messageData = {
      number: this.summary[this.currentFileIndex].number,
      cost: totals.cost,
      valueUnit: this.valueUnit
    };
    let message = this.messages.steps("postMigrate", messageData);

    if (data.isLast) {
      messageData.totalDeployments = totals.deployments;
      messageData.finalCost = totals.finalCost;

      this.summary.totalDeployments = messageData.totalDeployments;
      this.summary.finalCost = messageData.finalCost;

      message += this.messages.steps("lastMigrate", messageData);
    }
    return message;
  }

  // ----------------------------  Deployment Handlers --------------------------------------------

  /**
   * Runs after pre-flight estimate has executed, before the sendTx is attempted
   * @param  {Object} data
   */
  async preDeploy(data) {
    let message;
    data.deployed
      ? (message = this.messages.steps("replacing", data))
      : (message = this.messages.steps("deploying", data));

    return message;
  }

  /**
   * Run at intervals after the sendTx has executed, before the deployment resolves
   * @param  {Object} data
   */
  async block(data) {
    this.currentBlockWait =
      `Blocks: ${data.blocksWaited}`.padEnd(21) +
      `Seconds: ${data.secondsWaited}`;

    if (this.blockSpinner) {
      this.blockSpinner.text = this.currentBlockWait;
    }
  }

  /**
   * Run after a deployment instance has resolved. This handler collects deployment cost
   * data and stores it a `summary` map so that it can later be replayed in an interactive
   * preview (e.g. dry-run --> real). Also passes this data to the messaging utility for
   * output formatting.
   * @param  {Object} data
   */
  async postDeploy(data) {
    let message;
    if (data.deployed) {
      const txCostReport =
        await data.contract.interfaceAdapter.getTransactionCostReport(
          data.receipt
        );

      // if it returns null, try again!
      if (!txCostReport) {
        return this.postDeploy(data);
      }

      data = {
        ...data,
        ...txCostReport,
        cost: data.contract.interfaceAdapter.displayCost(txCostReport.cost)
      };

      this.valueUnit = data.valueUnit;
      this.currentGasTotal = this.currentGasTotal.add(txCostReport.gas);
      this.currentCostTotal = this.currentCostTotal.add(txCostReport.cost);
      this.currentAddress = this.from;
      this.deployments++;

      if (this.summary[this.currentFileIndex]) {
        this.summary[this.currentFileIndex].deployments.push(data);
      }

      message = this.messages.steps("deployed", data);
    } else {
      message = this.messages.steps("reusing", data);
    }

    return message;
  }

  /**
   * Runs on deployment error. Forwards err to the error parser/dispatcher after shutting down
   * any `pending` UI.any `pending` UI.
   * @param  {Object}  data  event args
   * @return {Promise}       resolves string error message
   */
  async deployFailed(data) {
    if (this.blockSpinner) {
      this.blockSpinner.fail();
    }

    if (this.transactionSpinner) {
      this.transactionSpinner.fail();
    }
    return await this.processDeploymentError(data);
  }

  // --------------------------  Transaction Handlers  ------------------------------------------

  /**
   * Run on `startTransaction` event. This is fired by migrations on save
   * but could also be fired within a migrations script by a user.
   * @param  {Object} data
   */
  async startTransaction(data) {
    const message = data.message || "Starting unknown transaction...";
    this.transactionSpinner = new Spinner(
      "events:subscribers:migrate:reporter:transactions",
      {
        text: message,
        indent: 3,
        prefixColor: "red"
      }
    );
  }

  /**
   * Run after a start transaction
   * @param  {Object} data
   */
  async endTransaction(data) {
    data.message = data.message || "Ending unknown transaction....";
    const message = this.messages.steps("endTransaction", data);
    this.transactionSpinner.remove();
    return message;
  }

  // ----------------------------  Library Event Handlers ------------------------------------------
  linking(data) {
    return this.messages.steps("linking", data);
  }

  // ----------------------------  PromiEvent Handlers --------------------------------------------

  /**
   * For misc error reporting that requires no context specific UI mgmt
   * @param  {Object} data
   */
  async error(data) {
    return this.messages.errors(data.type, data);
  }

  /**
   * Fired on Web3Promievent 'transactionHash' event. Begins running a UI
   * a block / time counter.
   * @param  {Object} data
   */
  async txHash(data) {
    if (this.subscriber.config.dryRun) {
      return;
    }

    let message = this.messages.steps("hash", data);
    this.subscriber.logger.log(message);

    this.currentBlockWait = `Blocks: 0`.padEnd(21) + `Seconds: 0`;

    this.blockSpinner = new Spinner("events:subscribers:migrate:reporter", {
      text: this.currentBlockWait,
      indent: 3,
      prefixColor: "red"
    });
  }

  /**
   * Fired on Web3Promievent 'confirmation' event.
   * @param  {Object} data
   */
  async confirmation(data) {
    return this.messages.steps("confirmation", data);
  }
}

module.exports = Reporter;


/***/ }),

/***/ 49812:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Reporter = __webpack_require__(20605);

module.exports = {
  initialization: function (config) {
    this.logger = config.logger || console;
    this.config = config;
    this.reporter = new Reporter({
      subscriber: this
    });
  },
  handlers: {
    "migrate:dryRun:notAccepted": [
      async function () {
        if (this.config.quiet) return;
        this.logger.log("\n> Exiting without migrating...\n\n");
      }
    ],
    "migrate:runMigrations:start": [
      async function ({ dryRun, migrations }) {
        if (this.config.quiet) return;
        const message = this.reporter.messages.steps("preAllMigrations", {
          migrations,
          dryRun
        });
        this.logger.log(message);
      }
    ],
    "migrate:runMigrations:finish": [
      async function ({ dryRun, error }) {
        if (this.config.quiet) return;
        const message = this.reporter.messages.steps("postAllMigrations", {
          dryRun,
          error
        });
        this.logger.log(message);
      }
    ],

    "migrate:settingCompletedMigrations:start": [
      async function (data) {
        if (this.config.quiet) return;

        await this.reporter.startTransaction(data);
      }
    ],
    "migrate:settingCompletedMigrations:succeed": [
      async function (data) {
        if (this.config.quiet) return;
        const message = await this.reporter.endTransaction(data);
        this.logger.log(message);
      }
    ],

    "migrate:migration:start": [
      async function (data) {
        if (this.config.quiet) return;
        const message = await this.reporter.preMigrate(data);
        this.logger.log(message);
      }
    ],
    "migrate:migration:succeed": [
      async function (eventArgs) {
        if (this.config.quiet) return;
        const message = await this.reporter.postMigrate(eventArgs);
        this.logger.log(message);
      }
    ],
    "migrate:migration:error": [
      async function (errorData) {
        if (this.config.quiet) return;
        const message = await this.reporter.error(errorData);
        this.logger.log(message);
      }
    ],

    "deployment:error": [
      async function (data) {
        const message = await this.reporter.error(data);
        if (!this.config.quiet) {
          this.logger.error(message);
        }
        return message; //we want to return the message no matter what for use in errors
      }
    ],
    "deployment:failed": [
      async function (data) {
        const message = await this.reporter.deployFailed(data);
        if (!this.config.quiet) {
          this.logger.log(message);
        }
        return message; //we want to return the message no matter what for use in errors
      }
    ],
    "deployment:start": [
      async function (data) {
        if (this.config.quiet) return;
        const message = await this.reporter.preDeploy(data);
        this.logger.log(message);
      }
    ],
    "deployment:succeed": [
      async function (data) {
        if (this.config.quiet) return;
        const message = await this.reporter.postDeploy(data);
        this.logger.log(message);
      }
    ],

    "deployment:block": [
      async function (data) {
        if (this.config.quiet) return;
        await this.reporter.block(data);
      }
    ],
    "deployment:confirmation": [
      async function (data) {
        if (this.config.quiet) return;
        const message = await this.reporter.confirmation(data);
        this.logger.log(message);
      }
    ],
    "deployment:txHash": [
      async function (data) {
        if (this.config.quiet) return;
        await this.reporter.txHash(data);
      }
    ],
    "deployment:linking": [
      async function (data) {
        if (this.config.quiet) return;
        const message = await this.reporter.linking(data);
        this.logger.log(message);
      }
    ],
    "deployment:newContract": [
      function ({ contract }) {
        if (this.config.quiet) return;
        this.logger.log("Creating new instance of " + contract.contractName);
      }
    ]
  }
};


/***/ }),

/***/ 13843:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Spinner = (__webpack_require__(92189).Spinner);
const OS = __webpack_require__(22037);

module.exports = {
  initialization: function () {
    this.logger = console;
  },
  handlers: {
    "obtain:start": [
      function () {
        if (this.quiet) {
          return;
        }
        this.logger.log(`${OS.EOL}Starting obtain...`);
        this.logger.log(`==================${OS.EOL}`);
      }
    ],
    "obtain:succeed": [
      function ({ compiler }) {
        if (this.quiet) {
          return;
        }
        const { name, version } = compiler;
        this.logger.log(
          `    > successfully downloaded and cached version ${version} ` +
            `of the ${name} compiler.${OS.EOL}`
        );
      }
    ],
    "obtain:fail": [
      function () {
        if (this.quiet) {
          return;
        }

        this.spinner.fail();
        this.logger.log("Unbox failed!");
      }
    ],

    "downloadCompiler:start": [
      function ({ attemptNumber }) {
        if (this.quiet) {
          return;
        }
        this.downloadSpinner = new Spinner(
          "events:subscribers:obtain:download",
          {
            text: `Downloading compiler. Attempt #${attemptNumber}.`,
            prefixColor: "red"
          }
        );
      }
    ],
    "downloadCompiler:succeed": [
      function () {
        if (this.quiet) {
          return;
        }
        this.downloadSpinner.succeed();
      }
    ],
    "downloadCompiler:fail": [
      function () {
        if (this.quiet) {
          return;
        }
        this.downloadSpinner.fail();
      }
    ],
    "fetchSolcList:start": [
      function ({ attemptNumber }) {
        if (this.quiet) {
          return;
        }
        this.fetchSpinner = new Spinner("events:subscribers:obtain:fetch", {
          text: `Fetching solc version list from solc-bin. Attempt #${attemptNumber}`,
          prefixColor: "yellow"
        });
      }
    ],
    "fetchSolcList:succeed": [
      function () {
        if (this.quiet) {
          return;
        }
        this.fetchSpinner.succeed();
      }
    ],
    "fetchSolcList:fail": [
      function () {
        if (this.quiet) {
          return;
        }
        this.fetchSpinner.fail();
      }
    ]
  }
};


/***/ }),

/***/ 50363:
/***/ ((module) => {

module.exports = {
  initialization: function () {
    this.logger = console;
  },
  handlers: {
    "test:migration:skipped": [
      function () {
        if (this.quiet) return;
        this.logger.log(
          `> Migration skipped because --migrate-none option was passed.`
        );
      }
    ]
  }
};


/***/ }),

/***/ 82084:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Spinner = (__webpack_require__(92189).Spinner);
const OS = __webpack_require__(22037);

const formatCommands = commands => {
  const names = Object.keys(commands);
  const maxLength = Math.max.apply(
    null,
    names.map(name => name.length)
  );

  return names.map(name => {
    const spacing = Array(maxLength - name.length + 1).join(" ");
    return `  ${name}: ${spacing}${commands[name]}`;
  });
};

module.exports = {
  initialization: function () {
    this.logger = console;
    this.spinners = {};
  },
  handlers: {
    "unbox:start": [
      function () {
        if (this.quiet) {
          return;
        }
        this.logger.log(`${OS.EOL}Starting unbox...`);
        this.logger.log(`=================${OS.EOL}`);
      }
    ],
    "unbox:preparingToDownload:start": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.prepareDownloadSpinner = new Spinner(
          "events:subscribers:unbox:download-prepare",
          "Preparing to download box"
        );
      }
    ],
    "unbox:preparingToDownload:succeed": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.prepareDownloadSpinner.succeed();
      }
    ],
    "unbox:downloadingBox:start": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.downloadSpinner = new Spinner(
          "events:subscribers:unbox:download",
          "Downloading"
        );
      }
    ],
    "unbox:downloadingBox:succeed": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.downloadSpinner.succeed();
      }
    ],
    "unbox:cleaningTempFiles:start": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.cleanUpSpinner = new Spinner(
          "events:subscribers:unbox:cleanup",
          "Cleaning up temporary files"
        );
      }
    ],
    "unbox:cleaningTempFiles:succeed": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.cleanUpSpinner.succeed();
      }
    ],
    "unbox:settingUpBox:start": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.unboxHandlerSpinner = new Spinner(
          "events:subscribers:unbox:handler",
          "Setting up box"
        );
      }
    ],
    "unbox:settingUpBox:succeed": [
      function () {
        if (this.quiet) {
          return;
        }
        this.spinners.unboxHandlerSpinner.succeed();
      }
    ],
    "unbox:succeed": [
      function ({ boxConfig }) {
        if (this.quiet) {
          return;
        }
        this.logger.log(`${OS.EOL}Unbox successful, sweet!${OS.EOL}`);

        const commandMessages = formatCommands(boxConfig.commands);
        if (commandMessages.length > 0) {
          this.logger.log("Commands:" + OS.EOL);
        }

        commandMessages.forEach(message => this.logger.log(message));
        this.logger.log("");

        if (boxConfig.epilogue) {
          this.logger.log(boxConfig.epilogue.replace("\n", OS.EOL));
        }
      }
    ],
    "unbox:fail": [
      function () {
        if (this.quiet) {
          return;
        }
        Object.values(this.spinners).map(spinner => {
          if (spinner.isSpinning) {
            spinner.fail();
          }
        });
        this.logger.log("Unbox failed!");
      }
    ]
  }
};


/***/ }),

/***/ 38279:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = {
  Subscriber: __webpack_require__(13764),
  EventManager: __webpack_require__(23518),
  SubscriberAggregator: __webpack_require__(42626)
};


/***/ }),

/***/ 50159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createInterfaceAdapter = void 0;
const web3_1 = __webpack_require__(65714);
const getNetworkTypeClass = (networkType = "ethereum") => {
    const supportedEvmNetworks = ["ethereum", "fabric-evm", "quorum"];
    if (supportedEvmNetworks.includes(networkType))
        return "evm-like";
    return networkType;
};
const createInterfaceAdapter = (options) => {
    const { networkType } = options;
    switch (getNetworkTypeClass(networkType)) {
        case "evm-like": {
            const { provider } = options;
            return new web3_1.Web3InterfaceAdapter({
                networkType: networkType,
                provider: provider
            });
        }
        default:
            throw Error(`Sorry, "${networkType}" is not supported at this time.`);
    }
};
exports.createInterfaceAdapter = createInterfaceAdapter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 65714:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Web3InterfaceAdapter = void 0;
const bn_js_1 = __importDefault(__webpack_require__(13550));
const shim_1 = __webpack_require__(69554);
class Web3InterfaceAdapter {
    constructor({ provider, networkType } = {}) {
        this.web3 = new shim_1.Web3Shim({ provider, networkType });
    }
    getNetworkId() {
        return this.web3.eth.net.getId();
    }
    getBlock(block) {
        return this.web3.eth.getBlock(block);
    }
    getTransaction(tx) {
        return this.web3.eth.getTransaction(tx);
    }
    getTransactionReceipt(tx) {
        return this.web3.eth.getTransactionReceipt(tx);
    }
    getBalance(address) {
        return this.web3.eth.getBalance(address);
    }
    getCode(address) {
        return this.web3.eth.getCode(address);
    }
    getAccounts() {
        return this.web3.eth.getAccounts();
    }
    estimateGas(transactionConfig, stacktrace = false) {
        return __awaiter(this, void 0, void 0, function* () {
            // web3 does not error gracefully when gas estimation fails due to a revert,
            // so in cases where we want to get past this (debugging/stacktracing), we must
            // catch the error and return null instead
            if (stacktrace === true) {
                try {
                    const gasEstimate = yield this.web3.eth.estimateGas(transactionConfig);
                    return gasEstimate;
                }
                catch (_a) {
                    return null;
                }
            }
            else {
                return this.web3.eth.estimateGas(transactionConfig);
            }
        });
    }
    getBlockNumber() {
        return this.web3.eth.getBlockNumber();
    }
    getTransactionCostReport(receipt) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.getTransaction(receipt.transactionHash);
            const block = yield this.getBlock(receipt.blockNumber);
            if (!block)
                return null;
            const balance = yield this.getBalance(tx.from);
            const gasPrice = new bn_js_1.default(tx.gasPrice);
            const gas = new bn_js_1.default(receipt.gasUsed);
            const value = new bn_js_1.default(tx.value);
            const cost = gasPrice.mul(gas).add(value);
            const timestamp = typeof block.timestamp === "string"
                ? parseInt(block.timestamp)
                : block.timestamp;
            return {
                timestamp,
                from: tx.from,
                balance: shim_1.Web3Shim.utils.fromWei(balance, "ether"),
                gasUnit: "gwei",
                gasPrice: shim_1.Web3Shim.utils.fromWei(gasPrice, "gwei"),
                gas,
                valueUnit: "ETH",
                value: shim_1.Web3Shim.utils.fromWei(value, "ether"),
                cost
            };
        });
    }
    displayCost(value) {
        return shim_1.Web3Shim.utils.fromWei(value, "ether");
    }
}
exports.Web3InterfaceAdapter = Web3InterfaceAdapter;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 36339:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createInterfaceAdapter = exports.Web3Shim = void 0;
var shim_1 = __webpack_require__(69554);
Object.defineProperty(exports, "Web3Shim", ({ enumerable: true, get: function () { return shim_1.Web3Shim; } }));
var adapter_1 = __webpack_require__(50159);
Object.defineProperty(exports, "createInterfaceAdapter", ({ enumerable: true, get: function () { return adapter_1.createInterfaceAdapter; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 69554:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Web3Shim = void 0;
const web3_1 = __importDefault(__webpack_require__(3283));
const ethereum_1 = __webpack_require__(73183);
const quorum_1 = __webpack_require__(52763);
const fabric_evm_1 = __webpack_require__(44043);
const web3js_1 = __webpack_require__(47241);
const initInterface = (web3Shim) => __awaiter(void 0, void 0, void 0, function* () {
    const networkTypes = new Map(Object.entries({
        "web3js": web3js_1.Web3JsDefinition,
        "ethereum": ethereum_1.EthereumDefinition,
        "quorum": quorum_1.QuorumDefinition,
        "fabric-evm": fabric_evm_1.FabricEvmDefinition
    }));
    networkTypes.get(web3Shim.networkType).initNetworkType(web3Shim);
});
// March 14, 2019 - Mike Seese:
// This shim was intended to be temporary (see the above comment)
// with the idea of a more robust implementation. That implementation
// would essentially take this shim and include it under the
// ethereum/apis/web3 (or something like that) structure.
// I chose to extend/inherit web3 here to keep scope minimal for
// getting web3 to behave with Quorum and AxCore (future/concurrent PR).
// I wanted to do as little changing to the original Truffle codebase, and
// for it to still expect a web3 instance. Otherwise, the scope of these
// quick support work would be high. The "Web3Shim" is a shim for only
// web3.js, and it was not intended to serve as the general purpose
// truffle <=> all DLTs adapter. We have other commitments currently that
// should drive the development of the correct architecture of
// `@truffle/interface-adapter`that should use this work in a more
// sane and organized manner.
class Web3Shim extends web3_1.default {
    constructor(options) {
        super();
        if (options) {
            this.networkType = options.networkType || "ethereum";
            if (options.provider) {
                this.setProvider(options.provider);
            }
        }
        else {
            this.networkType = "ethereum";
        }
        initInterface(this);
    }
    setNetworkType(networkType) {
        this.networkType = networkType;
        initInterface(this);
    }
}
exports.Web3Shim = Web3Shim;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 73183:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EthereumDefinition = void 0;
const bn_js_1 = __importDefault(__webpack_require__(13550));
exports.EthereumDefinition = {
    initNetworkType(web3) {
        return __awaiter(this, void 0, void 0, function* () {
            // truffle has started expecting gas used/limit to be
            // hex strings to support bignumbers for other ledgers
            overrides.getBlock(web3);
            overrides.getTransaction(web3);
            overrides.getTransactionReceipt(web3);
        });
    }
};
const overrides = {
    // The ts-ignores are ignoring the checks that are
    // saying that web3.eth.getBlock is a function and doesn't
    // have a `method` property, which it does
    getBlock: (web3) => {
        // @ts-ignore
        const _oldFormatter = web3.eth.getBlock.method.outputFormatter;
        // @ts-ignore
        web3.eth.getBlock.method.outputFormatter = (block) => {
            // @ts-ignore
            let result = _oldFormatter.call(web3.eth.getBlock.method, block);
            // Perhaps there is a better method of doing this,
            // but the raw hexstrings work for the time being
            result.gasLimit = "0x" + new bn_js_1.default(result.gasLimit).toString(16);
            result.gasUsed = "0x" + new bn_js_1.default(result.gasUsed).toString(16);
            return result;
        };
    },
    getTransaction: (web3) => {
        const _oldTransactionFormatter = 
        // @ts-ignore
        web3.eth.getTransaction.method.outputFormatter;
        // @ts-ignore
        web3.eth.getTransaction.method.outputFormatter = (tx) => {
            let result = _oldTransactionFormatter.call(
            // @ts-ignore
            web3.eth.getTransaction.method, tx);
            // Perhaps there is a better method of doing this,
            // but the raw hexstrings work for the time being
            result.gas = "0x" + new bn_js_1.default(result.gas).toString(16);
            return result;
        };
    },
    getTransactionReceipt: (web3) => {
        const _oldTransactionReceiptFormatter = 
        // @ts-ignore
        web3.eth.getTransactionReceipt.method.outputFormatter;
        // @ts-ignore
        web3.eth.getTransactionReceipt.method.outputFormatter = (receipt) => {
            let result = _oldTransactionReceiptFormatter.call(
            // @ts-ignore
            web3.eth.getTransactionReceipt.method, receipt);
            // Perhaps there is a better method of doing this,
            // but the raw hexstrings work for the time being
            result.gasUsed = "0x" + new bn_js_1.default(result.gasUsed).toString(16);
            return result;
        };
    }
};
//# sourceMappingURL=ethereum.js.map

/***/ }),

/***/ 44043:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FabricEvmDefinition = void 0;
exports.FabricEvmDefinition = {
    initNetworkType(web3) {
        return __awaiter(this, void 0, void 0, function* () {
            // web3 expects getId to return a hexString convertible to a number
            // for fabric-evm we ignore the hexToNumber output formatter
            overrides.getId(web3);
        });
    }
};
const overrides = {
    // The ts-ignores are ignoring the checks that are
    // saying that web3.eth.net.getId is a function and doesn't
    // have a `method` property, which it does
    getId: (web3) => {
        // @ts-ignore
        const _oldGetIdFormatter = web3.eth.net.getId.method.outputFormatter;
        // @ts-ignore
        web3.eth.net.getId.method.outputFormatter = (networkId) => {
            // chaincode-fabric-evm currently returns a "fabric-evm" string
            // instead of a hex networkID. Instead of trying to decode the hexToNumber,
            // let's just accept `fabric-evm` as a valid networkID for now.
            return networkId;
        };
    }
};
//# sourceMappingURL=fabric-evm.js.map

/***/ }),

/***/ 52763:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QuorumDefinition = void 0;
const bn_js_1 = __importDefault(__webpack_require__(13550));
const abi_coder_1 = __webpack_require__(79531);
exports.QuorumDefinition = {
    initNetworkType(web3) {
        return __awaiter(this, void 0, void 0, function* () {
            // duck punch some of web3's output formatters
            overrides.getBlock(web3);
            overrides.getTransaction(web3);
            overrides.getTransactionReceipt(web3);
            overrides.decodeParameters(web3);
        });
    }
};
const overrides = {
    // The ts-ignores are ignoring the checks that are
    // saying that web3.eth.getBlock is a function and doesn't
    // have a `method` property, which it does
    getBlock: (web3) => {
        // @ts-ignore
        const _oldBlockFormatter = web3.eth.getBlock.method.outputFormatter;
        // @ts-ignore
        web3.eth.getBlock.method.outputFormatter = (block) => {
            const _oldTimestamp = block.timestamp;
            const _oldGasLimit = block.gasLimit;
            const _oldGasUsed = block.gasUsed;
            // Quorum uses nanoseconds instead of seconds in timestamp
            let timestamp = new bn_js_1.default(block.timestamp.slice(2), 16);
            timestamp = timestamp.div(new bn_js_1.default(10).pow(new bn_js_1.default(9)));
            block.timestamp = "0x" + timestamp.toString(16);
            // Since we're overwriting the gasLimit/Used later,
            // it doesn't matter what it is before the call
            // The same applies to the timestamp, but I reduced
            // the precision since there was an accurate representation
            // We do this because Quorum can have large block/transaction
            // gas limits
            block.gasLimit = "0x0";
            block.gasUsed = "0x0";
            // @ts-ignore
            let result = _oldBlockFormatter.call(web3.eth.getBlock.method, block);
            // Perhaps there is a better method of doing this,
            // but the raw hexstrings work for the time being
            result.timestamp = _oldTimestamp;
            result.gasLimit = _oldGasLimit;
            result.gasUsed = _oldGasUsed;
            return result;
        };
    },
    getTransaction: (web3) => {
        const _oldTransactionFormatter = 
        // @ts-ignore
        web3.eth.getTransaction.method.outputFormatter;
        // @ts-ignore
        web3.eth.getTransaction.method.outputFormatter = (tx) => {
            const _oldGas = tx.gas;
            tx.gas = "0x0";
            let result = _oldTransactionFormatter.call(
            // @ts-ignore
            web3.eth.getTransaction.method, tx);
            // Perhaps there is a better method of doing this,
            // but the raw hexstrings work for the time being
            result.gas = _oldGas;
            return result;
        };
    },
    getTransactionReceipt: (web3) => {
        const _oldTransactionReceiptFormatter = 
        // @ts-ignore
        web3.eth.getTransactionReceipt.method.outputFormatter;
        // @ts-ignore
        web3.eth.getTransactionReceipt.method.outputFormatter = (receipt) => {
            const _oldGasUsed = receipt.gasUsed;
            receipt.gasUsed = "0x0";
            let result = _oldTransactionReceiptFormatter.call(
            // @ts-ignore
            web3.eth.getTransactionReceipt.method, receipt);
            // Perhaps there is a better method of doing this,
            // but the raw hexstrings work for the time being
            result.gasUsed = _oldGasUsed;
            return result;
        };
    },
    // The primary difference between this decodeParameters function and web3's
    // is that the 'Out of Gas?' zero/null bytes guard has been removed and any
    // falsy bytes are interpreted as a zero value.
    decodeParameters: (web3) => {
        const _oldDecodeParameters = web3.eth.abi.decodeParameters;
        const ethersAbiCoder = new abi_coder_1.AbiCoder((type, value) => {
            if (type.match(/^u?int/) &&
                !Array.isArray(value) &&
                (typeof value !== "object" || value.constructor.name !== "BN")) {
                return value.toString();
            }
            return value;
        });
        // result method
        function Result() { }
        web3.eth.abi.decodeParameters = (outputs, bytes) => {
            // if bytes is falsy, we'll pass 64 '0' bits to the ethers.js decoder.
            // the decoder will decode the 64 '0' bits as a 0 value.
            if (!bytes)
                bytes = "0".repeat(64);
            const res = ethersAbiCoder.decode(
            //@ts-ignore 'mapTypes' not existing on type 'ABI'
            web3.eth.abi.mapTypes(outputs), `0x${bytes.replace(/0x/i, "")}`);
            //@ts-ignore complaint regarding Result method
            const returnValue = new Result();
            returnValue.__length__ = 0;
            outputs.forEach((output, i) => {
                let decodedValue = res[returnValue.__length__];
                decodedValue = decodedValue === "0x" ? null : decodedValue;
                returnValue[i] = decodedValue;
                // @ts-ignore object not having name key
                if (typeof output === "object" && output.name) {
                    // @ts-ignore object not having name key
                    returnValue[output.name] = decodedValue;
                }
                returnValue.__length__++;
            });
            return returnValue;
        };
    }
};
//# sourceMappingURL=quorum.js.map

/***/ }),

/***/ 47241:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Web3JsDefinition = void 0;
// We simply return plain ol' Web3.js
exports.Web3JsDefinition = {
    initNetworkType(web3) {
        return __awaiter(this, void 0, void 0, function* () { });
    }
};
//# sourceMappingURL=web3js.js.map

/***/ }),

/***/ 16164:
/***/ (function(__unused_webpack_module, exports) {

"use strict";

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getOutstandingPromises = exports.waitForOutstandingPromises = exports.tracked = void 0;
const _outstandingPromiseInstanceMap = new WeakMap();
const _outstandingPromiseMap = new Map();
function tracked(target, key, descriptor) {
    if (typeof descriptor.value !== "function" || !target.constructor) {
        throw new Error("The 'tracked' decorator can only be applied to methods.");
    }
    const impl = descriptor.value;
    // wrapper function that keeps a list of outstanding promises for each
    // instance of DashboardMessageBusClient
    function newImpl(...args) {
        const returnValue = impl.apply(this, args);
        // only track async functions
        if ((returnValue === null || returnValue === void 0 ? void 0 : returnValue.then) && typeof returnValue.then === "function") {
            const trackedTask = returnValue.finally(() => {
                _cleanUpTrackedTask(this, trackedTask);
            });
            _trackTask(this, trackedTask);
            return trackedTask;
        }
        return returnValue;
    }
    return Object.assign(Object.assign({}, descriptor), { value: newImpl });
}
exports.tracked = tracked;
function waitForOutstandingPromises(options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { target } = options || {};
        let { catchHandler } = options || {};
        const iterable = (target
            ? (_a = _outstandingPromiseInstanceMap.get(target)) === null || _a === void 0 ? void 0 : _a.values()
            : _outstandingPromiseMap.keys()) || [];
        catchHandler = catchHandler || (() => { });
        yield Promise.all(Array.from(iterable, p => p.catch(catchHandler)));
    });
}
exports.waitForOutstandingPromises = waitForOutstandingPromises;
function _trackTask(target, trackedTask) {
    if (!_outstandingPromiseInstanceMap.has(target)) {
        _outstandingPromiseInstanceMap.set(target, new Set());
    }
    _outstandingPromiseInstanceMap.get(target).add(trackedTask);
    _outstandingPromiseMap.set(trackedTask, true);
}
function _cleanUpTrackedTask(target, trackedTask) {
    _outstandingPromiseMap.delete(trackedTask);
    const promises = _outstandingPromiseInstanceMap.get(target);
    promises === null || promises === void 0 ? void 0 : promises.delete(trackedTask);
    if ((promises === null || promises === void 0 ? void 0 : promises.size) === 0) {
        _outstandingPromiseInstanceMap.delete(target);
    }
}
function getOutstandingPromises(options) {
    var _a;
    const { target } = options;
    const iterable = (target
        ? (_a = _outstandingPromiseInstanceMap.get(target)) === null || _a === void 0 ? void 0 : _a.values()
        : _outstandingPromiseMap.keys()) || [];
    return Array.from(iterable);
}
exports.getOutstandingPromises = getOutstandingPromises;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 64723:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const TruffleError = __webpack_require__(73321);

// HACK: string comparison seems to be only way to identify being unable to
// connect to RPC node.
const NOT_CONNECTED_MESSAGE = 'Invalid JSON RPC response: ""';

class ProviderError extends TruffleError {
  constructor(message, options) {
    if (message === NOT_CONNECTED_MESSAGE) {
      message = buildMessage(options);
    }
    super(message);

    // important fields from RPC error responses, should be retained
    // see: https://www.jsonrpc.org/specification#error_object
    if (options && options.underlyingError && options.underlyingError.code !== undefined) {
      this.code = options.underlyingError.code;
    }

    if (options && options.underlyingError && options.underlyingError.data) {
      this.data = options.underlyingError.data;
    }
  }
}

const buildMessage = options => {
  const { host, port, network_id } = options;
  let message;
  if (host) {
    message =
      "\nCould not connect to your Ethereum client with the following parameters:\n" +
      `    - host       > ${host}\n` +
      `    - port       > ${port}\n` +
      `    - network_id > ${network_id}\n`;
  } else {
    message = "\nCould not connect to your Ethereum client.\n";
  }

  message +=
    "Please check that your Ethereum client:\n" +
    "    - is running\n" +
    '    - is accepting RPC connections (i.e., "--rpc" or "--http" option is used in geth)\n' +
    "    - is accessible over the network\n" +
    "    - is properly configured in your Truffle configuration file (truffle-config.js)\n";
  return message;
};

module.exports = ProviderError;


/***/ }),

/***/ 509:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("provider");
const Web3 = __webpack_require__(3283);
const { createInterfaceAdapter } = __webpack_require__(36339);
const wrapper = __webpack_require__(2623);
const DEFAULT_NETWORK_CHECK_TIMEOUT = 5000;

module.exports = {
  wrap: function (provider, options) {
    return wrapper.wrap(provider, options);
  },

  create: function (options) {
    const provider = this.getProvider(options);
    return this.wrap(provider, options);
  },

  getProvider: function (options) {
    let provider;
    if (options.provider && typeof options.provider === "function") {
      provider = options.provider();
    } else if (options.provider) {
      provider = options.provider;
    } else if (options.websockets || /^wss?:\/\//.test(options.url)) {
      provider = new Web3.providers.WebsocketProvider(
        options.url || "ws://" + options.host + ":" + options.port
      );
    } else {
      provider = new Web3.providers.HttpProvider(
        options.url || `http://${options.host}:${options.port}`,
        { keepAlive: false }
      );
    }
    return provider;
  },

  testConnection: function (options) {
    let networkCheckTimeout, networkType;
    const { networks, network } = options;
    if (networks && networks[network]) {
      networkCheckTimeout =
        networks[network].networkCheckTimeout || DEFAULT_NETWORK_CHECK_TIMEOUT;
      networkType = networks[network].type;
    } else {
      networkCheckTimeout = DEFAULT_NETWORK_CHECK_TIMEOUT;
    }
    const provider = this.getProvider(options);
    const { host } = provider;
    const interfaceAdapter = createInterfaceAdapter({ provider, networkType });
    return new Promise((resolve, reject) => {
      const noResponseFromNetworkCall = setTimeout(() => {
        let errorMessage =
          "There was a timeout while attempting to connect to the network at " +
          host +
          ".\n       Check to see that your provider is valid." +
          "\n       If you have a slow internet connection, try configuring a longer " +
          "timeout in your Truffle config. Use the " +
          "networks[networkName].networkCheckTimeout property to do this.";

        if (network === "dashboard") {
          errorMessage +=
            "\n       Also make sure that your Truffle Dashboard browser " +
            "tab is open and connected to MetaMask.";
        }

        throw new Error(errorMessage);
      }, networkCheckTimeout);

      let networkCheckDelay = 1;
      (function networkCheck() {
        setTimeout(async () => {
          try {
            await interfaceAdapter.getBlockNumber();
            clearTimeout(noResponseFromNetworkCall);
            clearTimeout(networkCheck);
            return resolve(true);
          } catch (error) {
            console.log(
              "> Something went wrong while attempting to connect to the " +
                "network at " +
                host +
                ". Check your network configuration."
            );
            clearTimeout(noResponseFromNetworkCall);
            clearTimeout(networkCheck);
            return reject(error);
          }
          networkCheckDelay *= 2;
          networkCheck();
        }, networkCheckDelay);
      })();
    });
  }
};


/***/ }),

/***/ 2623:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const debug = __webpack_require__(15158)("provider:wrapper"); // eslint-disable-line no-unused-vars
const ProviderError = __webpack_require__(64723);

function make1193ProviderRequest(provider) {
  /*
  NOTE: If truffle switches to use WebSockets instead of HTTP requests in the future
        then we will need to keep separate requestId counters for .request and .send
        methods to avoid collision while generating requestIds on parallel requests.
  */
  let requestId = 0;
  const modifiedRequest = async function ({ method, params }) {
    return await new Promise((accept, reject) => {
      provider.send(
        {
          jsonrpc: "2.0",
          id: ++requestId,
          method,
          params
        },
        (error, response) => {
          if (error) {
            return reject(error);
          }
          if (response.error) {
            const error = new Error(response.error.message);
            error.code = response.error.code;
            if (response.error.data) {
              error.data = response.error.data;
            }
            return reject(error);
          }
          const { result: res } = response;
          accept(res);
        }
      );
    });
  };
  return modifiedRequest.bind(provider);
}

module.exports = {
  /*
   * Web3.js Transport Wrapper
   *
   * Wraps an underlying web3 provider's RPC transport methods (send/sendAsync)
   * for Truffle-specific purposes, mainly for logging / request verbosity.
   */
  wrap: function (provider, options) {
    /* wrapping should be idempotent */
    if (provider._alreadyWrapped) return provider;

    /* setup options defaults */
    options = options || {};
    // custom logger
    options.logger = options.logger || console;
    // to see what web3 is sending and receiving.
    options.verbose = options.verbose || options.verboseRpc || false;

    /* create wrapper functions for before/after send/sendAsync */
    const preHook = this.preHook(options);
    const postHook = this.postHook(options);

    const originalSend = provider.send.bind(provider);

    /* overwrite method */
    provider.send = this.send(originalSend, preHook, postHook);
    // overwrite sendAsync only when sendAsync is used.
    if (provider.sendAsync) {
      const originalSendAsync = provider.sendAsync.bind(provider);
      provider.sendAsync = this.send(originalSendAsync, preHook, postHook);
    }

    // EIP-1193 provider wrapping
    if (provider.request === undefined && provider.send !== undefined) {
      provider.request = make1193ProviderRequest(provider);
    }

    /* mark as wrapped */
    provider._alreadyWrapped = true;

    return provider;
  },

  /*
   * Transport Hook Generators
   *
   * Used to wrap underlying web3.js behavior before/after sending request
   * payloads to the RPC.
   *
   * Transport hooks may be used to perform additional operations before/after
   * sending, and/or to modify request/response data.
   *
   * Each generator accepts an `options` argument and uses it to construct
   * and return a function.
   *
   * Returned functions accept relevant arguments and return potentially new
   * versions of those arguments (for payload/result/error overrides)
   */

  // before send/sendAsync
  preHook: function (options) {
    return function (payload) {
      if (options.verbose) {
        // for request payload debugging
        options.logger.log(
          "   > " + JSON.stringify(payload, null, 2).split("\n").join("\n   > ")
        );
      }

      if (options.events) {
        options.events.emit("rpc:request", { payload });
      }
      return payload;
    };
  },

  // after send/sendAsync
  postHook: function (options) {
    return function (payload, error, result) {
      // web3 websocket providers return false and web3 http providers
      // return null when no error has occurred...kind of obnoxious
      if (error) {
        error = new ProviderError(error.message, {
          ...options,
          underlyingError: error
        });
      }

      if (result && options.verbose) {
        options.logger.log(
          " <   " + JSON.stringify(result, null, 2).split("\n").join("\n <   ")
        );
      }

      if (options.events) {
        options.events.emit(
          "rpc:result",
          error ? { payload, error } : { payload, result }
        );
      }

      return [payload, error, result];
    };
  },

  /*
   * Transport Method Generators
   *
   * Generate wrapped versions of `send`/`sendAsync`, given original method and
   * transport hooks.
   *
   * Pre-condition: originals are bound correctly (`send.bind(provider)`)
   *
   * Return the wrapped function matching the original function's signature.
   */
  send: function (originalSend, preHook, postHook) {
    return function (payload, callback) {
      payload = preHook(payload);

      originalSend(payload, function (error, result) {
        const modified = postHook(payload, error, result);
        payload = modified[0];
        error = modified[1];
        result = modified[2];

        callback(error, result);
      });
    };
  }
};


/***/ }),

/***/ 92189:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.dots = exports.dashes = void 0;
var spinnies_1 = __webpack_require__(35701);
Object.defineProperty(exports, "dashes", ({ enumerable: true, get: function () { return spinnies_1.dashes; } }));
Object.defineProperty(exports, "dots", ({ enumerable: true, get: function () { return spinnies_1.dots; } }));
__exportStar(__webpack_require__(19560), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ 19560:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Spinner = void 0;
const spinnies_1 = __importDefault(__webpack_require__(35701));
const spinnies = new spinnies_1.default();
class Spinner {
    constructor(name, optionsOrText) {
        this.name = name;
        const options = typeof optionsOrText === "string"
            ? { text: optionsOrText }
            : optionsOrText;
        if (options.text === undefined) {
            throw new Error("Spinner text cannot be undefined");
        }
        spinnies.add(this.name, options);
    }
    /**
     * Stops all spinners
     * @param status the terminal state of the spinners that have been stopped (one of "stopped", "succeed", or "fail").
     */
    static stopAll(status) {
        spinnies.stopAll(status);
    }
    /**
     * @returns false if all spinners have succeeded, failed or have been stopped
     */
    static hasActiveSpinners() {
        return spinnies.hasActiveSpinners();
    }
    /**
     * Removes this spinner from display. After this method is called, other modifications to this spinner object have no effect.
     */
    remove() {
        if (!spinnies.pick(this.name)) {
            return;
        }
        spinnies.remove(this.name);
    }
    stop(textOrOptions) {
        if (!spinnies.pick(this.name)) {
            return;
        }
        spinnies.stop(this.name, textOrOptions);
    }
    succeed(textOrOptions) {
        if (!spinnies.pick(this.name)) {
            return;
        }
        spinnies.succeed(this.name, textOrOptions);
    }
    fail(textOrOptions) {
        if (!spinnies.pick(this.name)) {
            return;
        }
        spinnies.fail(this.name, textOrOptions);
    }
    warn(textOrOptions) {
        if (!spinnies.pick(this.name)) {
            return;
        }
        spinnies.warn(this.name, textOrOptions);
    }
    /**
     * @returns string the spinner prefix used on success
     */
    static get succeedPrefix() {
        return spinnies.options.succeedPrefix;
    }
    /**
     * Updates the spinner success decoration. Updates apply to all spinning
     * spinners, and do not apply to spinners that have already stopped.
     */
    static set succeedPrefix(value) {
        spinnies.options.succeedPrefix = value;
    }
    /**
     * @returns string the spinner prefix used on failure
     */
    static get failPrefix() {
        return spinnies.options.failPrefix;
    }
    /**
     * Updates the spinner fail decoration. Updates apply to all spinning
     * spinners, and do not apply to spinners that have already stopped.
     */
    static set failPrefix(value) {
        spinnies.options.failPrefix = value;
    }
    /**
     * @returns string the text currently displayed by this spinner, without the
     * spinner decoration
     */
    get text() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.text;
    }
    /**
     * Updates the text displayed by this spinner
     */
    set text(value) {
        this._mutateOptions("text", value);
    }
    /**
     * @returns the indent level of this spinner, expressed as a number of spaces
     */
    get indent() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.indent;
    }
    /**
     * Sets the indent level of this spinner, expressed as a number of spaces
     */
    set indent(value) {
        this._mutateOptions("indent", value);
    }
    /**
     * @returns string the `chalk` color of this spinner's text
     */
    get textColor() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.textColor;
    }
    /**
     * updates the `chalk` color of this spinner's text
     */
    set textColor(value) {
        this._mutateOptions("textColor", value);
    }
    /**
     * @returns string the `chalk` color of this spinner decoration
     */
    get prefixColor() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.prefixColor;
    }
    /**
     * updates the `chalk` color of this spinner's decoration
     */
    set prefixColor(value) {
        this._mutateOptions("prefixColor", value);
    }
    /**
     * @returns string the prefix used when this spinner is stopped
     */
    get stoppedPrefix() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.stoppedPrefix;
    }
    /**
     * updates the prefix used when this spinner is stopped
     */
    set stoppedPrefix(value) {
        this._mutateOptions("stoppedPrefix", value);
    }
    /**
     * @returns string the prefix used on success
     */
    get succeedPrefix() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.succeedPrefix;
    }
    /**
     * updates the prefix used on success
     */
    set succeedPrefix(value) {
        this._mutateOptions("succeedPrefix", value);
    }
    /**
     * @returns string the prefix used on failure
     */
    get failPrefix() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.failPrefix;
    }
    /**
     * updates the prefix used on failure
     */
    set failPrefix(value) {
        this._mutateOptions("failPrefix", value);
    }
    /**
     * @returns string the prefix used on warn
     */
    get warnPrefix() {
        var _a;
        return (_a = spinnies.pick(this.name)) === null || _a === void 0 ? void 0 : _a.warnPrefix;
    }
    /**
     * updates the prefix used on warn
     */
    set warnPrefix(value) {
        this._mutateOptions("warnPrefix", value);
    }
    /**
     * @returns boolean `true` when the spinner is active and spinning, otherwise
     * `false`
     */
    get isSpinning() {
        const options = spinnies.pick(this.name);
        if (!options) {
            return false;
        }
        return options.status === "spinning";
    }
    _mutateOptions(key, value) {
        const options = spinnies.pick(this.name);
        if (!options) {
            return;
        }
        options[key] = value;
        spinnies.update(this.name, options);
    }
}
exports.Spinner = Spinner;
//# sourceMappingURL=spinner.js.map

/***/ })

};
;
//# sourceMappingURL=553.bundled.js.map