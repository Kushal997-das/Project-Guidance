"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DashboardMessageBusClient = void 0;
const dashboard_message_bus_common_1 = require("@truffle/dashboard-message-bus-common");
const connection_1 = require("./connection");
const delay_1 = __importDefault(require("delay"));
const debug_1 = __importDefault(require("debug"));
const lifecycle_1 = require("./lifecycle");
const promise_tracker_1 = require("@truffle/promise-tracker");
const debug = (0, debug_1.default)(`dashboard-message-bus-client:client`);
class DashboardMessageBusClient {
    get options() {
        return Object.assign({}, this._options);
    }
    constructor(options) {
        this._subscriptions = [];
        this._options = Object.assign({ host: "localhost", port: 24012, maxRetries: 1, retryDelayMsec: 100 }, (options !== null && options !== void 0 ? options : {}));
        const { host, port, publishPort, subscribePort } = this._options;
        this._publishConnection = new connection_1.DashboardMessageBusConnection({
            host,
            port,
            publishPort,
            connectionType: "publish"
        });
        this._subscribeConnection = new connection_1.DashboardMessageBusConnection({
            host,
            port,
            subscribePort,
            connectionType: "subscribe"
        });
        this._subscribeConnection.on("message", this._messageHandler.bind(this));
    }
    ready() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._withRetriesAsync(() => __awaiter(this, void 0, void 0, function* () {
                Promise.all([
                    this._publishConnection.connect(),
                    this._subscribeConnection.connect()
                ]);
            }));
        });
    }
    publish(options) {
        return __awaiter(this, void 0, void 0, function* () {
            const { type, payload } = options;
            let message = (0, dashboard_message_bus_common_1.createMessage)(type, payload);
            try {
                yield this.ready();
                const lifecycle = new lifecycle_1.PublishMessageLifecycle({
                    message,
                    connection: this._publishConnection
                });
                return yield this._withRetriesAsync((() => __awaiter(this, void 0, void 0, function* () {
                    debug("publisher sending message %o", message);
                    yield this._publishConnection.send(message);
                    return lifecycle;
                })).bind(this));
            }
            catch (err) {
                debug("sending message %o failed due to error %s", message, err);
                throw err;
            }
        });
    }
    subscribe(options) {
        const subscription = new lifecycle_1.DashboardMessageBusSubscription(options);
        this._subscriptions.push(subscription);
        return subscription;
    }
    close(force = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!force) {
                yield this.waitForOutstandingPromises();
            }
            this._subscriptions.map(sub => sub._end());
            this._subscriptions = [];
            yield Promise.all([
                this._subscribeConnection.close(),
                this._publishConnection.close()
            ]);
        });
    }
    waitForOutstandingPromises() {
        return __awaiter(this, void 0, void 0, function* () {
            yield (0, promise_tracker_1.waitForOutstandingPromises)({ target: this });
            return;
        });
    }
    _messageHandler(message) {
        this._subscriptions.map(sub => sub._evaluateMessage({ message, connection: this._subscribeConnection }));
    }
    _withRetriesAsync(f) {
        return __awaiter(this, void 0, void 0, function* () {
            const { maxRetries, retryDelayMsec } = this._options;
            for (let tryCount = 0; tryCount <= maxRetries; tryCount++) {
                try {
                    const result = f.call(this);
                    if (result.then) {
                        // ensure any promise rejections are handled here so we count them as
                        // failures to retry
                        return yield result;
                    }
                    else {
                        return result;
                    }
                }
                catch (err) {
                    if (tryCount < maxRetries) {
                        debug("Attempt failed, %s of %s attempts remaining, delaying %s msec before retrying.", maxRetries - tryCount, maxRetries + 1, retryDelayMsec);
                        yield (0, delay_1.default)(retryDelayMsec);
                        debug("Retrying failed operation now");
                    }
                    else {
                        debug("Operation failed after %s attempts", tryCount);
                        throw err;
                    }
                }
            }
        });
    }
}
exports.DashboardMessageBusClient = DashboardMessageBusClient;
//# sourceMappingURL=client.js.map