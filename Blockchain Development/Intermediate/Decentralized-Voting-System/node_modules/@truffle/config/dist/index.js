"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const path_1 = __importDefault(require("path"));
const merge_1 = __importDefault(require("lodash/merge"));
const find_up_1 = __importDefault(require("find-up"));
const conf_1 = __importDefault(require("conf"));
const error_1 = __importDefault(require("@truffle/error"));
const original_require_1 = __importDefault(require("original-require"));
const configDefaults_1 = require("./configDefaults");
const events_1 = require("@truffle/events");
const debug_1 = __importDefault(require("debug"));
const debug = (0, debug_1.default)("config");
const DEFAULT_CONFIG_FILENAME = "truffle-config.js";
const BACKUP_CONFIG_FILENAME = "truffle.js"; // old config filename
class TruffleConfig {
    constructor(truffleDirectory, workingDirectory, network) {
        this._deepCopy = ["compilers", "mocha", "dashboard", "networks"];
        this._values = (0, configDefaults_1.getInitialConfig)({
            truffleDirectory,
            workingDirectory,
            network
        });
        this.events = new events_1.EventManager(this);
        const props = (0, configDefaults_1.configProps)({ configObject: this });
        Object.entries(props).forEach(([propName, descriptor]) => this.addProp(propName, descriptor));
    }
    addProp(propertyName, descriptor) {
        // possible property descriptors
        //
        // supports `default` and `transform` in addition to `get` and `set`
        //
        // default: specify function to retrieve default value (used by get)
        // transform: specify function to transform value when (used by set)
        const self = this;
        Object.defineProperty(this, propertyName, {
            get: descriptor.get ||
                function () {
                    // value is specified
                    if (propertyName in self._values) {
                        return self._values[propertyName];
                    }
                    // default getter is specified
                    if (descriptor.default) {
                        return descriptor.default();
                    }
                    // descriptor is a function
                    return descriptor();
                },
            set: descriptor.set ||
                function (value) {
                    self._values[propertyName] = descriptor.transform
                        ? descriptor.transform(value)
                        : value;
                },
            configurable: true,
            enumerable: true
        });
    }
    normalize(obj) {
        const clone = {};
        Object.keys(obj).forEach(key => {
            try {
                clone[key] = obj[key];
            }
            catch (e) {
                // Do nothing with values that throw.
            }
        });
        return clone;
    }
    with(obj) {
        //Normalized, or shallow clowning only copies an object's own enumerable
        //properties ignoring properties up the prototype chain
        const current = this.normalize(this);
        const normalized = this.normalize(obj);
        const newConfig = Object.assign(Object.create(TruffleConfig.prototype), current, normalized);
        this.events.updateSubscriberOptions(newConfig);
        return newConfig;
    }
    merge(obj) {
        const clone = this.normalize(obj);
        // Only set keys for values that don't throw.
        const propertyNames = Object.keys(obj);
        propertyNames.forEach(key => {
            try {
                if (typeof clone[key] === "object" && this._deepCopy.includes(key)) {
                    this[key] = (0, merge_1.default)(this[key], clone[key]);
                }
                else {
                    debug("setting key -- %o -- to -- %o", key, clone[key]);
                    this[key] = clone[key];
                }
            }
            catch (e) {
                // ignore
            }
        });
        this.events.updateSubscriberOptions(this);
        return this;
    }
    static default() {
        return new TruffleConfig();
    }
    static search(options = {}, filename) {
        const searchOptions = {
            cwd: options.working_directory || options.workingDirectory
        };
        if (!filename) {
            const isWin = process.platform === "win32";
            const defaultConfig = find_up_1.default.sync(DEFAULT_CONFIG_FILENAME, searchOptions);
            const backupConfig = find_up_1.default.sync(BACKUP_CONFIG_FILENAME, searchOptions);
            if (defaultConfig && backupConfig) {
                console.warn(`Warning: Both ${DEFAULT_CONFIG_FILENAME} and ${BACKUP_CONFIG_FILENAME} were found. Using ${DEFAULT_CONFIG_FILENAME}.`);
                return defaultConfig;
            }
            else if (backupConfig && !defaultConfig) {
                if (isWin)
                    console.warn(`Warning: Please rename ${BACKUP_CONFIG_FILENAME} to ${DEFAULT_CONFIG_FILENAME} to ensure Windows compatibility.`);
                return backupConfig;
            }
            else {
                return defaultConfig;
            }
        }
        return find_up_1.default.sync(filename, searchOptions);
    }
    static detect(options = {}, filename) {
        debug("callling Config.detect with filename -- %o", filename);
        let configFile;
        const configPath = options.config;
        if (configPath) {
            configFile = path_1.default.isAbsolute(configPath)
                ? configPath
                : path_1.default.resolve(configPath);
        }
        else {
            configFile = TruffleConfig.search(options, filename);
        }
        if (!configFile) {
            throw new error_1.default("Could not find suitable configuration file.");
        }
        return TruffleConfig.load(configFile, options);
    }
    static load(file, options = {}) {
        debug("calling Config.load with file -- %o", file);
        const workingDirectory = options.config
            ? process.cwd()
            : path_1.default.dirname(path_1.default.resolve(file));
        const config = new TruffleConfig(undefined, workingDirectory, undefined);
        const staticConfig = (0, original_require_1.default)(file);
        debug("the static config is -- %o", staticConfig);
        config.merge(staticConfig);
        config.merge(options);
        // When loading a user's config, ensure their subscribers are initialized
        config.events.updateSubscriberOptions(config);
        config.events.initializeUserSubscribers(config);
        return config;
    }
    static getUserConfig() {
        return new conf_1.default({ projectName: "truffle" });
    }
    static getTruffleDataDirectory() {
        const conf = TruffleConfig.getUserConfig();
        return path_1.default.dirname(conf.path);
    }
}
module.exports = TruffleConfig;
//# sourceMappingURL=index.js.map