import type { _ } from "hkts/src";
import type { ContractObject, NetworkObject } from "@truffle/contract-schema/spec";
import type { IdObject } from "../../resources";
import type { Process } from "../../process";
import * as Base from "../batch";
export type Config = {
    network?: {};
    artifact?: {};
    requires?: {};
    produces: {} | undefined;
    entry: any;
    result: any;
};
export type Network<C extends Config> = C["network"] & {
    networkId: string;
};
export type Requires<C extends Config> = "requires" extends keyof C ? C["requires"] : {};
export type Produces<C extends Config> = C["produces"];
export type Entry<C extends Config> = C["entry"];
export type Result<C extends Config> = C["result"];
export type ArtifactNetwork<C extends Config> = NetworkObject & Requires<C>;
export type Artifact<C extends Config> = ContractObject & C["artifact"] & {
    db: {
        contract: IdObject<"contracts">;
        callBytecode: IdObject<"bytecodes">;
        createBytecode: IdObject<"bytecodes">;
    };
    networks?: {
        [networkId: string]: ArtifactNetwork<C>;
    };
};
export type Input<C extends Config> = ArtifactNetwork<C>;
export type Output<C extends Config> = Input<C> & Produces<C>;
export type Structure<C extends Config> = {
    network: Network<C>;
    artifacts: (ContractObject & Artifact<C> & {
        db: {
            contract: IdObject<"contracts">;
            callBytecode: IdObject<"bytecodes">;
            createBytecode: IdObject<"bytecodes">;
        };
        networks?: {
            [networkId: string]: _;
        };
    })[];
};
export type Breadcrumb<_C extends Config> = {
    artifactIndex: number;
};
export type Batch<C extends Config> = {
    structure: Structure<C>;
    breadcrumb: Breadcrumb<C>;
    input: Input<C>;
    output: Output<C>;
    entry: Entry<C>;
    result: Result<C>;
};
export type Options<C extends Config> = Omit<Base.Options<Batch<C>>, "iterate" | "find" | "initialize" | "merge">;
export declare const configure: <C extends Config>(options: Options<C>) => <I extends Input<C>, O extends Output<C>>(inputs: {
    network: import("hkts/src").$<Network<C>, [I]>;
    artifacts: import("hkts/src").$<ContractObject & C["artifact"] & {
        db: {
            contract: IdObject<"contracts">;
            callBytecode: IdObject<"bytecodes">;
            createBytecode: IdObject<"bytecodes">;
        };
        networks?: {
            [networkId: string]: ArtifactNetwork<C>;
        } | undefined;
    } & {
        db: {
            contract: IdObject<"contracts">;
            callBytecode: IdObject<"bytecodes">;
            createBytecode: IdObject<"bytecodes">;
        };
        networks?: {
            [networkId: string]: _<0>;
        } | undefined;
    }, [I]>[];
}) => Generator<import("../../meta/process/types").GraphQlRequest | import("../../meta/process/types").Web3Request, {
    network: import("hkts/src").$<Network<C>, [I & O]>;
    artifacts: import("hkts/src").$<ContractObject & C["artifact"] & {
        db: {
            contract: IdObject<"contracts">;
            callBytecode: IdObject<"bytecodes">;
            createBytecode: IdObject<"bytecodes">;
        };
        networks?: {
            [networkId: string]: ArtifactNetwork<C>;
        } | undefined;
    } & {
        db: {
            contract: IdObject<"contracts">;
            callBytecode: IdObject<"bytecodes">;
            createBytecode: IdObject<"bytecodes">;
        };
        networks?: {
            [networkId: string]: _<0>;
        } | undefined;
    }, [I & O]>[];
}, any>;
