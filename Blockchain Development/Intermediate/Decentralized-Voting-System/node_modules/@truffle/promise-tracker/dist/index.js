"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOutstandingPromises = exports.waitForOutstandingPromises = exports.tracked = void 0;
const _outstandingPromiseInstanceMap = new WeakMap();
const _outstandingPromiseMap = new Map();
function tracked(target, key, descriptor) {
    if (typeof descriptor.value !== "function" || !target.constructor) {
        throw new Error("The 'tracked' decorator can only be applied to methods.");
    }
    const impl = descriptor.value;
    // wrapper function that keeps a list of outstanding promises for each
    // instance of DashboardMessageBusClient
    function newImpl(...args) {
        const returnValue = impl.apply(this, args);
        // only track async functions
        if ((returnValue === null || returnValue === void 0 ? void 0 : returnValue.then) && typeof returnValue.then === "function") {
            const trackedTask = returnValue.finally(() => {
                _cleanUpTrackedTask(this, trackedTask);
            });
            _trackTask(this, trackedTask);
            return trackedTask;
        }
        return returnValue;
    }
    return Object.assign(Object.assign({}, descriptor), { value: newImpl });
}
exports.tracked = tracked;
function waitForOutstandingPromises(options) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        const { target } = options || {};
        let { catchHandler } = options || {};
        const iterable = (target
            ? (_a = _outstandingPromiseInstanceMap.get(target)) === null || _a === void 0 ? void 0 : _a.values()
            : _outstandingPromiseMap.keys()) || [];
        catchHandler = catchHandler || (() => { });
        yield Promise.all(Array.from(iterable, p => p.catch(catchHandler)));
    });
}
exports.waitForOutstandingPromises = waitForOutstandingPromises;
function _trackTask(target, trackedTask) {
    if (!_outstandingPromiseInstanceMap.has(target)) {
        _outstandingPromiseInstanceMap.set(target, new Set());
    }
    _outstandingPromiseInstanceMap.get(target).add(trackedTask);
    _outstandingPromiseMap.set(trackedTask, true);
}
function _cleanUpTrackedTask(target, trackedTask) {
    _outstandingPromiseMap.delete(trackedTask);
    const promises = _outstandingPromiseInstanceMap.get(target);
    promises === null || promises === void 0 ? void 0 : promises.delete(trackedTask);
    if ((promises === null || promises === void 0 ? void 0 : promises.size) === 0) {
        _outstandingPromiseInstanceMap.delete(target);
    }
}
function getOutstandingPromises(options) {
    var _a;
    const { target } = options;
    const iterable = (target
        ? (_a = _outstandingPromiseInstanceMap.get(target)) === null || _a === void 0 ? void 0 : _a.values()
        : _outstandingPromiseMap.keys()) || [];
    return Array.from(iterable);
}
exports.getOutstandingPromises = getOutstandingPromises;
//# sourceMappingURL=index.js.map